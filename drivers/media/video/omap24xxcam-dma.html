<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › omap24xxcam-dma.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>omap24xxcam-dma.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/media/video/omap24xxcam-dma.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 MontaVista Software, Inc.</span>
<span class="cm"> * Copyright (C) 2004 Texas Instruments.</span>
<span class="cm"> * Copyright (C) 2007 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact: Sakari Ailus &lt;sakari.ailus@nokia.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on code from Andy Lowe &lt;source@mvista.com&gt; and</span>
<span class="cm"> *                    David Cohen &lt;david.cohen@indt.org.br&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>

<span class="cp">#include &quot;omap24xxcam.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * DMA hardware.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* Ack all interrupt on CSR and IRQSTATUS_L0 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_dmahw_ack_all</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">csr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">csr</span> <span class="o">=</span> <span class="n">omap24xxcam_reg_in</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CSR</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="cm">/* ack interrupt in CSR */</span>
		<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CSR</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">csr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_IRQSTATUS_L0</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Ack dmach on CSR and IRQSTATUS_L0 */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">omap24xxcam_dmahw_ack_ch</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dmach</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">csr</span><span class="p">;</span>

	<span class="n">csr</span> <span class="o">=</span> <span class="n">omap24xxcam_reg_in</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CSR</span><span class="p">(</span><span class="n">dmach</span><span class="p">));</span>
	<span class="cm">/* ack interrupt in CSR */</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CSR</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="n">csr</span><span class="p">);</span>
	<span class="cm">/* ack interrupt in IRQSTATUS */</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_IRQSTATUS_L0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">dmach</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">csr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_dmahw_running</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dmach</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">omap24xxcam_reg_in</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CCR</span><span class="p">(</span><span class="n">dmach</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">CAMDMA_CCR_ENABLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_dmahw_transfer_setup</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dmach</span><span class="p">,</span>
					     <span class="n">dma_addr_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CCR</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span>
			    <span class="n">CAMDMA_CCR_SEL_SRC_DST_SYNC</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_BS</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_DST_AMODE_POST_INC</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_SRC_AMODE_POST_INC</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_FS</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_WR_ACTIVE</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_RD_ACTIVE</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_SYNCHRO_CAMERA</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CLNK_CTRL</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CEN</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CFN</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CSDP</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span>
			    <span class="n">CAMDMA_CSDP_WRITE_MODE_POSTED</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CSDP_DST_BURST_EN_32</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CSDP_DST_PACKED</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CSDP_SRC_BURST_EN_32</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CSDP_SRC_PACKED</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CSDP_DATA_TYPE_8BITS</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CSSA</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CDSA</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CSEI</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CSFI</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="n">DMA_THRESHOLD</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CDEI</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CDFI</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CSR</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span>
			    <span class="n">CAMDMA_CSR_MISALIGNED_ERR</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CSR_SECURE_ERR</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CSR_TRANS_ERR</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CSR_BLOCK</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CSR_DROP</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CICR</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span>
			    <span class="n">CAMDMA_CICR_MISALIGNED_ERR_IE</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CICR_SECURE_ERR_IE</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CICR_TRANS_ERR_IE</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CICR_BLOCK_IE</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CICR_DROP_IE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_dmahw_transfer_start</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dmach</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CCR</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span>
			    <span class="n">CAMDMA_CCR_SEL_SRC_DST_SYNC</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_BS</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_DST_AMODE_POST_INC</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_SRC_AMODE_POST_INC</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_ENABLE</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_FS</span>
			    <span class="o">|</span> <span class="n">CAMDMA_CCR_SYNCHRO_CAMERA</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_dmahw_transfer_chain</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dmach</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">free_dmach</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prev_dmach</span><span class="p">,</span> <span class="n">ch</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmach</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">prev_dmach</span> <span class="o">=</span> <span class="n">NUM_CAMDMA_CHANNELS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">prev_dmach</span> <span class="o">=</span> <span class="n">dmach</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CLNK_CTRL</span><span class="p">(</span><span class="n">prev_dmach</span><span class="p">),</span>
			    <span class="n">CAMDMA_CLNK_CTRL_ENABLE_LNK</span> <span class="o">|</span> <span class="n">dmach</span><span class="p">);</span>
	<span class="cm">/* Did we chain the DMA transfer before the previous one</span>
<span class="cm">	 * finished?</span>
<span class="cm">	 */</span>
	<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">dmach</span> <span class="o">+</span> <span class="n">free_dmach</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">omap24xxcam_reg_in</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CCR</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>
		 <span class="o">&amp;</span> <span class="n">CAMDMA_CCR_ENABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="n">dmach</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The previous transfer has ended and this one</span>
<span class="cm">			 * hasn&#39;t started, so we must not have chained</span>
<span class="cm">			 * to the previous one in time.  We&#39;ll have to</span>
<span class="cm">			 * start it now.</span>
<span class="cm">			 */</span>
			<span class="n">omap24xxcam_dmahw_transfer_start</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">dmach</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Abort all chained DMA transfers. After all transfers have been</span>
<span class="cm"> * aborted and the DMA controller is idle, the completion routines for</span>
<span class="cm"> * any aborted transfers will be called in sequence. The DMA</span>
<span class="cm"> * controller may not be idle after this routine completes, because</span>
<span class="cm"> * the completion routines might start new transfers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_dmahw_abort_ch</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dmach</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* mask all interrupts from this channel */</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CICR</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* unlink this channel */</span>
	<span class="n">omap24xxcam_reg_merge</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CLNK_CTRL</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">CAMDMA_CLNK_CTRL_ENABLE_LNK</span><span class="p">);</span>
	<span class="cm">/* disable this channel */</span>
	<span class="n">omap24xxcam_reg_merge</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_CCR</span><span class="p">(</span><span class="n">dmach</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CAMDMA_CCR_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_dmahw_init</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_OCP_SYSCONFIG</span><span class="p">,</span>
			    <span class="n">CAMDMA_OCP_SYSCONFIG_MIDLEMODE_FSTANDBY</span>
			    <span class="o">|</span> <span class="n">CAMDMA_OCP_SYSCONFIG_SIDLEMODE_FIDLE</span>
			    <span class="o">|</span> <span class="n">CAMDMA_OCP_SYSCONFIG_AUTOIDLE</span><span class="p">);</span>

	<span class="n">omap24xxcam_reg_merge</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_GCR</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span>
			      <span class="n">CAMDMA_GCR_MAX_CHANNEL_FIFO_DEPTH</span><span class="p">);</span>

	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">CAMDMA_IRQENABLE_L0</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Individual DMA channel handling.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* Start a DMA transfer from the camera to memory.</span>
<span class="cm"> * Returns zero if the transfer was successfully started, or non-zero if all</span>
<span class="cm"> * DMA channels are already in use or starting is currently inhibited.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_dma_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_dma</span> <span class="o">*</span><span class="n">dma</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">start</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="n">dma_callback_t</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dmach</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span> <span class="o">||</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">dma_stop</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dmach</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">next_dmach</span><span class="p">;</span>

	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">ch_state</span><span class="p">[</span><span class="n">dmach</span><span class="p">].</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">ch_state</span><span class="p">[</span><span class="n">dmach</span><span class="p">].</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="n">omap24xxcam_dmahw_transfer_setup</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">dmach</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* We&#39;re ready to start the DMA transfer. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span> <span class="o">&lt;</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* A transfer is already in progress, so try to chain to it. */</span>
		<span class="n">omap24xxcam_dmahw_transfer_chain</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">dmach</span><span class="p">,</span>
						 <span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* No transfer is in progress, so we&#39;ll just start this one</span>
<span class="cm">		 * now.</span>
<span class="cm">		 */</span>
		<span class="n">omap24xxcam_dmahw_transfer_start</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">dmach</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">next_dmach</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">next_dmach</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span><span class="o">--</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Abort all chained DMA transfers. After all transfers have been</span>
<span class="cm"> * aborted and the DMA controller is idle, the completion routines for</span>
<span class="cm"> * any aborted transfers will be called in sequence. The DMA</span>
<span class="cm"> * controller may not be idle after this routine completes, because</span>
<span class="cm"> * the completion routines might start new transfers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_dma_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_dma</span> <span class="o">*</span><span class="n">dma</span><span class="p">,</span> <span class="n">u32</span> <span class="n">csr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dmach</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">free_dmach</span><span class="p">;</span>
	<span class="n">dma_callback_t</span> <span class="n">callback</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* stop any DMA transfers in progress */</span>
	<span class="n">dmach</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">next_dmach</span> <span class="o">+</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap24xxcam_dmahw_abort_ch</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">dmach</span><span class="p">);</span>
		<span class="n">dmach</span> <span class="o">=</span> <span class="p">(</span><span class="n">dmach</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We have to be careful here because the callback routine</span>
<span class="cm">	 * might start a new DMA transfer, and we only want to abort</span>
<span class="cm">	 * transfers that were started before this routine was called.</span>
<span class="cm">	 */</span>
	<span class="n">free_dmach</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span> <span class="o">&lt;</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">free_dmach</span> <span class="o">&lt;</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dmach</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">next_dmach</span> <span class="o">+</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span><span class="p">)</span>
			<span class="o">%</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span>
		<span class="n">callback</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">ch_state</span><span class="p">[</span><span class="n">dmach</span><span class="p">].</span><span class="n">callback</span><span class="p">;</span>
		<span class="n">arg</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">ch_state</span><span class="p">[</span><span class="n">dmach</span><span class="p">].</span><span class="n">arg</span><span class="p">;</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span><span class="o">++</span><span class="p">;</span>
		<span class="n">free_dmach</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* leave interrupts disabled during callback */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="n">csr</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Abort all chained DMA transfers. After all transfers have been</span>
<span class="cm"> * aborted and the DMA controller is idle, the completion routines for</span>
<span class="cm"> * any aborted transfers will be called in sequence. If the completion</span>
<span class="cm"> * routines attempt to start a new DMA transfer it will fail, so the</span>
<span class="cm"> * DMA controller will be idle after this routine completes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_dma_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_dma</span> <span class="o">*</span><span class="n">dma</span><span class="p">,</span> <span class="n">u32</span> <span class="n">csr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">dma_stop</span><span class="p">);</span>
	<span class="n">omap24xxcam_dma_abort</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">dma_stop</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Camera DMA interrupt service routine. */</span>
<span class="kt">void</span> <span class="nf">omap24xxcam_dma_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_dma</span> <span class="o">*</span><span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dmach</span><span class="p">;</span>
	<span class="n">dma_callback_t</span> <span class="n">callback</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csr</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">csr_error</span> <span class="o">=</span> <span class="n">CAMDMA_CSR_MISALIGNED_ERR</span>
		<span class="o">|</span> <span class="n">CAMDMA_CSR_SUPERVISOR_ERR</span> <span class="o">|</span> <span class="n">CAMDMA_CSR_SECURE_ERR</span>
		<span class="o">|</span> <span class="n">CAMDMA_CSR_TRANS_ERR</span> <span class="o">|</span> <span class="n">CAMDMA_CSR_DROP</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span> <span class="o">==</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* A camera DMA interrupt occurred while all channels</span>
<span class="cm">		 * are idle, so we&#39;ll acknowledge the interrupt in the</span>
<span class="cm">		 * IRQSTATUS register and exit.</span>
<span class="cm">		 */</span>
		<span class="n">omap24xxcam_dmahw_ack_all</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span> <span class="o">&lt;</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dmach</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">next_dmach</span> <span class="o">+</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span><span class="p">)</span>
			<span class="o">%</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">omap24xxcam_dmahw_running</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">dmach</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This buffer hasn&#39;t finished yet, so we&#39;re done. */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">csr</span> <span class="o">=</span> <span class="n">omap24xxcam_dmahw_ack_ch</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">dmach</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="n">csr_error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* A DMA error occurred, so stop all DMA</span>
<span class="cm">			 * transfers in progress.</span>
<span class="cm">			 */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">omap24xxcam_dma_stop</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">callback</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">ch_state</span><span class="p">[</span><span class="n">dmach</span><span class="p">].</span><span class="n">callback</span><span class="p">;</span>
			<span class="n">arg</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">ch_state</span><span class="p">[</span><span class="n">dmach</span><span class="p">].</span><span class="n">arg</span><span class="p">;</span>
			<span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="n">csr</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">omap24xxcam_sgdma_process</span><span class="p">(</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap24xxcam_sgdma</span><span class="p">,</span> <span class="n">dma</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">omap24xxcam_dma_hwinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_dma</span> <span class="o">*</span><span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">omap24xxcam_dmahw_init</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_dma_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_dma</span> <span class="o">*</span><span class="n">dma</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>

	<span class="cm">/* group all channels on DMA IRQ0 and unmask irq */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">free_dmach</span> <span class="o">=</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">next_dmach</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ch</span> <span class="o">&lt;</span> <span class="n">NUM_CAMDMA_CHANNELS</span><span class="p">;</span> <span class="n">ch</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">ch_state</span><span class="p">[</span><span class="n">ch</span><span class="p">].</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">ch_state</span><span class="p">[</span><span class="n">ch</span><span class="p">].</span><span class="n">arg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Scatter-gather DMA.</span>
<span class="cm"> *</span>
<span class="cm"> * High-level DMA construct for transferring whole picture frames to</span>
<span class="cm"> * memory that is discontinuous.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* DMA completion routine for the scatter-gather DMA fragments. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_sgdma_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_dma</span> <span class="o">*</span><span class="n">dma</span><span class="p">,</span> <span class="n">u32</span> <span class="n">csr</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_sgdma</span> <span class="o">*</span><span class="n">sgdma</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap24xxcam_sgdma</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sgslot</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgdma_state</span> <span class="o">*</span><span class="n">sg_state</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">csr_error</span> <span class="o">=</span> <span class="n">CAMDMA_CSR_MISALIGNED_ERR</span>
		<span class="o">|</span> <span class="n">CAMDMA_CSR_SUPERVISOR_ERR</span> <span class="o">|</span> <span class="n">CAMDMA_CSR_SECURE_ERR</span>
		<span class="o">|</span> <span class="n">CAMDMA_CSR_TRANS_ERR</span> <span class="o">|</span> <span class="n">CAMDMA_CSR_DROP</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* We got an interrupt, we can remove the timer */</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">reset_timer</span><span class="p">);</span>

	<span class="n">sg_state</span> <span class="o">=</span> <span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span> <span class="o">+</span> <span class="n">sgslot</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">queued_sglist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: sgdma completed when none queued!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">|=</span> <span class="n">csr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">queued_sglist</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Queue for this sglist is empty, so check to see if we&#39;re</span>
<span class="cm">		 * done.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">next_sglist</span> <span class="o">==</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="n">csr_error</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sgdma_callback_t</span> <span class="n">callback</span> <span class="o">=</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">;</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">sg_csr</span> <span class="o">=</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">csr</span><span class="p">;</span>
			<span class="cm">/* All done with this sglist */</span>
			<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">free_sgdma</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="n">sgdma</span><span class="p">,</span> <span class="n">sg_csr</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Start queued scatter-gather DMA transfers. */</span>
<span class="kt">void</span> <span class="nf">omap24xxcam_sgdma_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_sgdma</span> <span class="o">*</span><span class="n">sgdma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">queued_sgdma</span><span class="p">,</span> <span class="n">sgslot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgdma_state</span> <span class="o">*</span><span class="n">sg_state</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">csr_error</span> <span class="o">=</span> <span class="n">CAMDMA_CSR_MISALIGNED_ERR</span>
		<span class="o">|</span> <span class="n">CAMDMA_CSR_SUPERVISOR_ERR</span> <span class="o">|</span> <span class="n">CAMDMA_CSR_SECURE_ERR</span>
		<span class="o">|</span> <span class="n">CAMDMA_CSR_TRANS_ERR</span> <span class="o">|</span> <span class="n">CAMDMA_CSR_DROP</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">queued_sgdma</span> <span class="o">=</span> <span class="n">NUM_SG_DMA</span> <span class="o">-</span> <span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">free_sgdma</span><span class="p">;</span>
	<span class="n">sgslot</span> <span class="o">=</span> <span class="p">(</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">next_sgdma</span> <span class="o">+</span> <span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">free_sgdma</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_SG_DMA</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">queued_sgdma</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg_state</span> <span class="o">=</span> <span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span> <span class="o">+</span> <span class="n">sgslot</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">next_sglist</span> <span class="o">&lt;</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="p">(</span><span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="n">csr_error</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

			<span class="n">sglist</span> <span class="o">=</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">sglist</span> <span class="o">+</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">next_sglist</span><span class="p">;</span>
			<span class="cm">/* try to start the next DMA transfer */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">next_sglist</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 *  On the last sg, we handle the case where</span>
<span class="cm">				 *  cam-&gt;img.pix.sizeimage % PAGE_ALIGN != 0</span>
<span class="cm">				 */</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">bytes_read</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">omap24xxcam_dma_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
						  <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span>
						  <span class="n">len</span><span class="p">,</span>
						  <span class="n">omap24xxcam_sgdma_callback</span><span class="p">,</span>
						  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sgslot</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* DMA start failed */</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">;</span>
				<span class="cm">/* DMA start was successful */</span>
				<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">next_sglist</span><span class="o">++</span><span class="p">;</span>
				<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">bytes_read</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
				<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">queued_sglist</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/* We start the reset timer */</span>
				<span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
				<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">reset_timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">queued_sgdma</span><span class="o">--</span><span class="p">;</span>
		<span class="n">sgslot</span> <span class="o">=</span> <span class="p">(</span><span class="n">sgslot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_SG_DMA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue a scatter-gather DMA transfer from the camera to memory.</span>
<span class="cm"> * Returns zero if the transfer was successfully queued, or non-zero</span>
<span class="cm"> * if all of the scatter-gather slots are already in use.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap24xxcam_sgdma_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_sgdma</span> <span class="o">*</span><span class="n">sgdma</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sglen</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">sgdma_callback_t</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgdma_state</span> <span class="o">*</span><span class="n">sg_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sglen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">sglen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sglist</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">free_sgdma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sg_state</span> <span class="o">=</span> <span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span> <span class="o">+</span> <span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">next_sgdma</span><span class="p">;</span>

	<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">sglist</span> <span class="o">=</span> <span class="n">sglist</span><span class="p">;</span>
	<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">=</span> <span class="n">sglen</span><span class="p">;</span>
	<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">next_sglist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">bytes_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">queued_sglist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>
	<span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">next_sgdma</span> <span class="o">=</span> <span class="p">(</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">next_sgdma</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_SG_DMA</span><span class="p">;</span>
	<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">free_sgdma</span><span class="o">--</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">omap24xxcam_sgdma_process</span><span class="p">(</span><span class="n">sgdma</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Sync scatter-gather DMA by aborting any DMA transfers currently in progress.</span>
<span class="cm"> * Any queued scatter-gather DMA transactions that have not yet been started</span>
<span class="cm"> * will remain queued.  The DMA controller will be idle after this routine</span>
<span class="cm"> * completes.  When the scatter-gather queue is restarted, the next</span>
<span class="cm"> * scatter-gather DMA transfer will begin at the start of a new transaction.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap24xxcam_sgdma_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_sgdma</span> <span class="o">*</span><span class="n">sgdma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sgslot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgdma_state</span> <span class="o">*</span><span class="n">sg_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csr</span> <span class="o">=</span> <span class="n">CAMDMA_CSR_TRANS_ERR</span><span class="p">;</span>

	<span class="cm">/* stop any DMA transfers in progress */</span>
	<span class="n">omap24xxcam_dma_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">free_sgdma</span> <span class="o">&lt;</span> <span class="n">NUM_SG_DMA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sgslot</span> <span class="o">=</span> <span class="p">(</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">next_sgdma</span> <span class="o">+</span> <span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">free_sgdma</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_SG_DMA</span><span class="p">;</span>
		<span class="n">sg_state</span> <span class="o">=</span> <span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span> <span class="o">+</span> <span class="n">sgslot</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">next_sglist</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This DMA transfer was in progress, so abort it. */</span>
			<span class="n">sgdma_callback_t</span> <span class="n">callback</span> <span class="o">=</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">;</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">sg_state</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
			<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">free_sgdma</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* leave interrupts masked */</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="n">sgdma</span><span class="p">,</span> <span class="n">csr</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">omap24xxcam_sgdma_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_sgdma</span> <span class="o">*</span><span class="n">sgdma</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_callback</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">),</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reset_callback_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sg</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">free_sgdma</span> <span class="o">=</span> <span class="n">NUM_SG_DMA</span><span class="p">;</span>
	<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">next_sgdma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sg</span> <span class="o">&lt;</span> <span class="n">NUM_SG_DMA</span><span class="p">;</span> <span class="n">sg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span><span class="p">[</span><span class="n">sg</span><span class="p">].</span><span class="n">sglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span><span class="p">[</span><span class="n">sg</span><span class="p">].</span><span class="n">next_sglist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span><span class="p">[</span><span class="n">sg</span><span class="p">].</span><span class="n">bytes_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span><span class="p">[</span><span class="n">sg</span><span class="p">].</span><span class="n">queued_sglist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span><span class="p">[</span><span class="n">sg</span><span class="p">].</span><span class="n">csr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span><span class="p">[</span><span class="n">sg</span><span class="p">].</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">sg_state</span><span class="p">[</span><span class="n">sg</span><span class="p">].</span><span class="n">arg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">omap24xxcam_dma_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgdma</span><span class="o">-&gt;</span><span class="n">reset_timer</span><span class="p">,</span> <span class="n">reset_callback</span><span class="p">,</span> <span class="n">reset_callback_data</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
