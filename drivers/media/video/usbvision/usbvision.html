<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › usbvision › usbvision.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>usbvision.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * USBVISION.H</span>
<span class="cm"> *  usbvision header file</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1999-2005 Joerg Heckenbach &lt;joerg@heckenbach-aw.de&gt;</span>
<span class="cm"> *                         Dwaine Garden &lt;dwainegarden@rogers.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Report problems to v4l MailingList: linux-media@vger.kernel.org</span>
<span class="cm"> *</span>
<span class="cm"> * This module is part of usbvision driver project.</span>
<span class="cm"> * Updates to driver completed by Dwaine P. Garden</span>
<span class="cm"> * v4l2 conversion by Thierry Merle &lt;thierry.merle@free.fr&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>


<span class="cp">#ifndef __LINUX_USBVISION_H</span>
<span class="cp">#define __LINUX_USBVISION_H</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-device.h&gt;</span>
<span class="cp">#include &lt;media/tuner.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>

<span class="cp">#define USBVISION_DEBUG		</span><span class="cm">/* Turn on debug messages */</span><span class="cp"></span>

<span class="cp">#define USBVISION_PWR_REG		0x00</span>
	<span class="cp">#define USBVISION_SSPND_EN		(1 &lt;&lt; 1)</span>
	<span class="cp">#define USBVISION_RES2			(1 &lt;&lt; 2)</span>
	<span class="cp">#define USBVISION_PWR_VID		(1 &lt;&lt; 5)</span>
	<span class="cp">#define USBVISION_E2_EN			(1 &lt;&lt; 7)</span>
<span class="cp">#define USBVISION_CONFIG_REG		0x01</span>
<span class="cp">#define USBVISION_ADRS_REG		0x02</span>
<span class="cp">#define USBVISION_ALTER_REG		0x03</span>
<span class="cp">#define USBVISION_FORCE_ALTER_REG	0x04</span>
<span class="cp">#define USBVISION_STATUS_REG		0x05</span>
<span class="cp">#define USBVISION_IOPIN_REG		0x06</span>
	<span class="cp">#define USBVISION_IO_1			(1 &lt;&lt; 0)</span>
	<span class="cp">#define USBVISION_IO_2			(1 &lt;&lt; 1)</span>
	<span class="cp">#define USBVISION_AUDIO_IN		0</span>
	<span class="cp">#define USBVISION_AUDIO_TV		1</span>
	<span class="cp">#define USBVISION_AUDIO_RADIO		2</span>
	<span class="cp">#define USBVISION_AUDIO_MUTE		3</span>
<span class="cp">#define USBVISION_SER_MODE		0x07</span>
	<span class="cp">#define USBVISION_CLK_OUT		(1 &lt;&lt; 0)</span>
	<span class="cp">#define USBVISION_DAT_IO		(1 &lt;&lt; 1)</span>
	<span class="cp">#define USBVISION_SENS_OUT		(1 &lt;&lt; 2)</span>
	<span class="cp">#define USBVISION_SER_MODE_SOFT		(0 &lt;&lt; 4)</span>
	<span class="cp">#define USBVISION_SER_MODE_SIO		(1 &lt;&lt; 4)</span>
<span class="cp">#define USBVISION_SER_ADRS		0x08</span>
<span class="cp">#define USBVISION_SER_CONT		0x09</span>
<span class="cp">#define USBVISION_SER_DAT1		0x0A</span>
<span class="cp">#define USBVISION_SER_DAT2		0x0B</span>
<span class="cp">#define USBVISION_SER_DAT3		0x0C</span>
<span class="cp">#define USBVISION_SER_DAT4		0x0D</span>
<span class="cp">#define USBVISION_EE_DATA		0x0E</span>
<span class="cp">#define USBVISION_EE_LSBAD		0x0F</span>
<span class="cp">#define USBVISION_EE_CONT		0x10</span>
<span class="cp">#define USBVISION_DRM_CONT			0x12</span>
	<span class="cp">#define USBVISION_REF			(1 &lt;&lt; 0)</span>
	<span class="cp">#define USBVISION_RES_UR		(1 &lt;&lt; 2)</span>
	<span class="cp">#define USBVISION_RES_FDL		(1 &lt;&lt; 3)</span>
	<span class="cp">#define USBVISION_RES_VDW		(1 &lt;&lt; 4)</span>
<span class="cp">#define USBVISION_DRM_PRM1		0x13</span>
<span class="cp">#define USBVISION_DRM_PRM2		0x14</span>
<span class="cp">#define USBVISION_DRM_PRM3		0x15</span>
<span class="cp">#define USBVISION_DRM_PRM4		0x16</span>
<span class="cp">#define USBVISION_DRM_PRM5		0x17</span>
<span class="cp">#define USBVISION_DRM_PRM6		0x18</span>
<span class="cp">#define USBVISION_DRM_PRM7		0x19</span>
<span class="cp">#define USBVISION_DRM_PRM8		0x1A</span>
<span class="cp">#define USBVISION_VIN_REG1		0x1B</span>
	<span class="cp">#define USBVISION_8_422_SYNC		0x01</span>
	<span class="cp">#define USBVISION_16_422_SYNC		0x02</span>
	<span class="cp">#define USBVISION_VSNC_POL		(1 &lt;&lt; 3)</span>
	<span class="cp">#define USBVISION_HSNC_POL		(1 &lt;&lt; 4)</span>
	<span class="cp">#define USBVISION_FID_POL		(1 &lt;&lt; 5)</span>
	<span class="cp">#define USBVISION_HVALID_PO		(1 &lt;&lt; 6)</span>
	<span class="cp">#define USBVISION_VCLK_POL		(1 &lt;&lt; 7)</span>
<span class="cp">#define USBVISION_VIN_REG2		0x1C</span>
	<span class="cp">#define USBVISION_AUTO_FID		(1 &lt;&lt; 0)</span>
	<span class="cp">#define USBVISION_NONE_INTER		(1 &lt;&lt; 1)</span>
	<span class="cp">#define USBVISION_NOHVALID		(1 &lt;&lt; 2)</span>
	<span class="cp">#define USBVISION_UV_ID			(1 &lt;&lt; 3)</span>
	<span class="cp">#define USBVISION_FIX_2C		(1 &lt;&lt; 4)</span>
	<span class="cp">#define USBVISION_SEND_FID		(1 &lt;&lt; 5)</span>
	<span class="cp">#define USBVISION_KEEP_BLANK		(1 &lt;&lt; 7)</span>
<span class="cp">#define USBVISION_LXSIZE_I		0x1D</span>
<span class="cp">#define USBVISION_MXSIZE_I		0x1E</span>
<span class="cp">#define USBVISION_LYSIZE_I		0x1F</span>
<span class="cp">#define USBVISION_MYSIZE_I		0x20</span>
<span class="cp">#define USBVISION_LX_OFFST		0x21</span>
<span class="cp">#define USBVISION_MX_OFFST		0x22</span>
<span class="cp">#define USBVISION_LY_OFFST		0x23</span>
<span class="cp">#define USBVISION_MY_OFFST		0x24</span>
<span class="cp">#define USBVISION_FRM_RATE		0x25</span>
<span class="cp">#define USBVISION_LXSIZE_O		0x26</span>
<span class="cp">#define USBVISION_MXSIZE_O		0x27</span>
<span class="cp">#define USBVISION_LYSIZE_O		0x28</span>
<span class="cp">#define USBVISION_MYSIZE_O		0x29</span>
<span class="cp">#define USBVISION_FILT_CONT		0x2A</span>
<span class="cp">#define USBVISION_VO_MODE		0x2B</span>
<span class="cp">#define USBVISION_INTRA_CYC		0x2C</span>
<span class="cp">#define USBVISION_STRIP_SZ		0x2D</span>
<span class="cp">#define USBVISION_FORCE_INTRA		0x2E</span>
<span class="cp">#define USBVISION_FORCE_UP		0x2F</span>
<span class="cp">#define USBVISION_BUF_THR		0x30</span>
<span class="cp">#define USBVISION_DVI_YUV		0x31</span>
<span class="cp">#define USBVISION_AUDIO_CONT		0x32</span>
<span class="cp">#define USBVISION_AUD_PK_LEN		0x33</span>
<span class="cp">#define USBVISION_BLK_PK_LEN		0x34</span>
<span class="cp">#define USBVISION_PCM_THR1		0x38</span>
<span class="cp">#define USBVISION_PCM_THR2		0x39</span>
<span class="cp">#define USBVISION_DIST_THR_L		0x3A</span>
<span class="cp">#define USBVISION_DIST_THR_H		0x3B</span>
<span class="cp">#define USBVISION_MAX_DIST_L		0x3C</span>
<span class="cp">#define USBVISION_MAX_DIST_H		0x3D</span>
<span class="cp">#define USBVISION_OP_CODE		0x33</span>

<span class="cp">#define MAX_BYTES_PER_PIXEL		4</span>

<span class="cp">#define MIN_FRAME_WIDTH			64</span>
<span class="cp">#define MAX_USB_WIDTH			320  </span><span class="cm">/* 384 */</span><span class="cp"></span>
<span class="cp">#define MAX_FRAME_WIDTH			320  </span><span class="cm">/* 384 */</span><span class="cp">			</span><span class="cm">/* streching sometimes causes crashes*/</span><span class="cp"></span>

<span class="cp">#define MIN_FRAME_HEIGHT		48</span>
<span class="cp">#define MAX_USB_HEIGHT			240  </span><span class="cm">/* 288 */</span><span class="cp"></span>
<span class="cp">#define MAX_FRAME_HEIGHT		240  </span><span class="cm">/* 288 */</span><span class="cp">			</span><span class="cm">/* Streching sometimes causes crashes*/</span><span class="cp"></span>

<span class="cp">#define MAX_FRAME_SIZE			(MAX_FRAME_WIDTH * MAX_FRAME_HEIGHT * MAX_BYTES_PER_PIXEL)</span>
<span class="cp">#define USBVISION_CLIPMASK_SIZE		(MAX_FRAME_WIDTH * MAX_FRAME_HEIGHT / 8) </span><span class="cm">/* bytesize of clipmask */</span><span class="cp"></span>

<span class="cp">#define USBVISION_URB_FRAMES		32</span>

<span class="cp">#define USBVISION_NUM_HEADERMARKER	20</span>
<span class="cp">#define USBVISION_NUMFRAMES		3  </span><span class="cm">/* Maximum number of frames an application can get */</span><span class="cp"></span>
<span class="cp">#define USBVISION_NUMSBUF		2 </span><span class="cm">/* Dimensioning the USB S buffering */</span><span class="cp"></span>

<span class="cp">#define USBVISION_POWEROFF_TIME		(3 * HZ)		</span><span class="cm">/* 3 seconds */</span><span class="cp"></span>


<span class="cp">#define FRAMERATE_MIN	0</span>
<span class="cp">#define FRAMERATE_MAX	31</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">ISOC_MODE_YUV422</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
	<span class="n">ISOC_MODE_YUV420</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
	<span class="n">ISOC_MODE_COMPRESS</span> <span class="o">=</span> <span class="mh">0x60</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* This macro restricts an int variable to an inclusive range */</span>
<span class="cp">#define RESTRICT_TO_RANGE(v, mi, ma) \</span>
<span class="cp">	{ if ((v) &lt; (mi)) (v) = (mi); else if ((v) &gt; (ma)) (v) = (ma); }</span>

<span class="cm">/*</span>
<span class="cm"> * We use macros to do YUV -&gt; RGB conversion because this is</span>
<span class="cm"> * very important for speed and totally unimportant for size.</span>
<span class="cm"> *</span>
<span class="cm"> * YUV -&gt; RGB Conversion</span>
<span class="cm"> * ---------------------</span>
<span class="cm"> *</span>
<span class="cm"> * B = 1.164*(Y-16)		    + 2.018*(V-128)</span>
<span class="cm"> * G = 1.164*(Y-16) - 0.813*(U-128) - 0.391*(V-128)</span>
<span class="cm"> * R = 1.164*(Y-16) + 1.596*(U-128)</span>
<span class="cm"> *</span>
<span class="cm"> * If you fancy integer arithmetics (as you should), hear this:</span>
<span class="cm"> *</span>
<span class="cm"> * 65536*B = 76284*(Y-16)		  + 132252*(V-128)</span>
<span class="cm"> * 65536*G = 76284*(Y-16) -  53281*(U-128) -  25625*(V-128)</span>
<span class="cm"> * 65536*R = 76284*(Y-16) + 104595*(U-128)</span>
<span class="cm"> *</span>
<span class="cm"> * Make sure the output values are within [0..255] range.</span>
<span class="cm"> */</span>
<span class="cp">#define LIMIT_RGB(x) (((x) &lt; 0) ? 0 : (((x) &gt; 255) ? 255 : (x)))</span>
<span class="cp">#define YUV_TO_RGB_BY_THE_BOOK(my, mu, mv, mr, mg, mb) { \</span>
<span class="cp">	int mm_y, mm_yc, mm_u, mm_v, mm_r, mm_g, mm_b; \</span>
<span class="cp">	mm_y = (my) - 16; \</span>
<span class="cp">	mm_u = (mu) - 128; \</span>
<span class="cp">	mm_v = (mv) - 128; \</span>
<span class="cp">	mm_yc = mm_y * 76284; \</span>
<span class="cp">	mm_b = (mm_yc + 132252 * mm_v) &gt;&gt; 16; \</span>
<span class="cp">	mm_g = (mm_yc - 53281 * mm_u - 25625 * mm_v) &gt;&gt; 16; \</span>
<span class="cp">	mm_r = (mm_yc + 104595 * mm_u) &gt;&gt; 16; \</span>
<span class="cp">	mb = LIMIT_RGB(mm_b); \</span>
<span class="cp">	mg = LIMIT_RGB(mm_g); \</span>
<span class="cp">	mr = LIMIT_RGB(mm_r); \</span>
<span class="cp">}</span>

<span class="cm">/* Debugging aid */</span>
<span class="cp">#define USBVISION_SAY_AND_WAIT(what) { \</span>
<span class="cp">	wait_queue_head_t wq; \</span>
<span class="cp">	init_waitqueue_head(&amp;wq); \</span>
<span class="cp">	printk(KERN_INFO &quot;Say: %s\n&quot;, what); \</span>
<span class="cp">	interruptible_sleep_on_timeout(&amp;wq, HZ * 3); \</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * This macro checks if usbvision is still operational. The &#39;usbvision&#39;</span>
<span class="cm"> * pointer must be valid, usbvision-&gt;dev must be valid, we are not</span>
<span class="cm"> * removing the device and the device has not erred on us.</span>
<span class="cm"> */</span>
<span class="cp">#define USBVISION_IS_OPERATIONAL(udevice) (\</span>
<span class="cp">	(udevice != NULL) &amp;&amp; \</span>
<span class="cp">	((udevice)-&gt;dev != NULL) &amp;&amp; \</span>
<span class="cp">	((udevice)-&gt;last_error == 0) &amp;&amp; \</span>
<span class="cp">	(!(udevice)-&gt;remove_pending))</span>

<span class="cp">#define I2C_USB_ADAP_MAX	16</span>

<span class="cp">#define USBVISION_NORMS (V4L2_STD_PAL | V4L2_STD_NTSC | V4L2_STD_SECAM | V4L2_STD_PAL_M)</span>

<span class="cm">/* ----------------------------------------------------------------- */</span>
<span class="cm">/* usbvision video structures                                        */</span>
<span class="cm">/* ----------------------------------------------------------------- */</span>
<span class="k">enum</span> <span class="n">scan_state</span> <span class="p">{</span>
	<span class="n">scan_state_scanning</span><span class="p">,</span>	<span class="cm">/* Scanning for header */</span>
	<span class="n">scan_state_lines</span>	<span class="cm">/* Parsing lines */</span>
<span class="p">};</span>

<span class="cm">/* Completion states of the data parser */</span>
<span class="k">enum</span> <span class="n">parse_state</span> <span class="p">{</span>
	<span class="n">parse_state_continue</span><span class="p">,</span>	<span class="cm">/* Just parse next item */</span>
	<span class="n">parse_state_next_frame</span><span class="p">,</span>	<span class="cm">/* Frame done, send it to V4L */</span>
	<span class="n">parse_state_out</span><span class="p">,</span>	<span class="cm">/* Not enough data for frame */</span>
	<span class="n">parse_state_end_parse</span>	<span class="cm">/* End parsing */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">frame_state</span> <span class="p">{</span>
	<span class="n">frame_state_unused</span><span class="p">,</span>	<span class="cm">/* Unused (no MCAPTURE) */</span>
	<span class="n">frame_state_ready</span><span class="p">,</span>	<span class="cm">/* Ready to start grabbing */</span>
	<span class="n">frame_state_grabbing</span><span class="p">,</span>	<span class="cm">/* In the process of being grabbed into */</span>
	<span class="n">frame_state_done</span><span class="p">,</span>	<span class="cm">/* Finished grabbing, but not been synced yet */</span>
	<span class="n">frame_state_done_hold</span><span class="p">,</span>	<span class="cm">/* Are syncing or reading */</span>
	<span class="n">frame_state_error</span><span class="p">,</span>	<span class="cm">/* Something bad happened while processing */</span>
<span class="p">};</span>

<span class="cm">/* stream states */</span>
<span class="k">enum</span> <span class="n">stream_state</span> <span class="p">{</span>
	<span class="n">stream_off</span><span class="p">,</span>		<span class="cm">/* Driver streaming is completely OFF */</span>
	<span class="n">stream_idle</span><span class="p">,</span>		<span class="cm">/* Driver streaming is ready to be put ON by the application */</span>
	<span class="n">stream_interrupt</span><span class="p">,</span>	<span class="cm">/* Driver streaming must be interrupted */</span>
	<span class="n">stream_on</span><span class="p">,</span>		<span class="cm">/* Driver streaming is put ON by the application */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">isoc_state</span> <span class="p">{</span>
	<span class="n">isoc_state_in_frame</span><span class="p">,</span>	<span class="cm">/* Isoc packet is member of frame */</span>
	<span class="n">isoc_state_no_frame</span><span class="p">,</span>	<span class="cm">/* Isoc packet is not member of any frame */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">usb_device</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">usbvision_sbuf</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define USBVISION_MAGIC_1			0x55</span>
<span class="cp">#define USBVISION_MAGIC_2			0xAA</span>
<span class="cp">#define USBVISION_HEADER_LENGTH			0x0c</span>
<span class="cp">#define USBVISION_SAA7111_ADDR			0x48</span>
<span class="cp">#define USBVISION_SAA7113_ADDR			0x4a</span>
<span class="cp">#define USBVISION_IIC_LRACK			0x20</span>
<span class="cp">#define USBVISION_IIC_LRNACK			0x30</span>
<span class="cp">#define USBVISION_FRAME_FORMAT_PARAM_INTRA	(1&lt;&lt;7)</span>

<span class="k">struct</span> <span class="n">usbvision_v4l2_format_st</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">supported</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">bytes_per_pixel</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">format</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">desc</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define USBVISION_SUPPORTED_PALETTES ARRAY_SIZE(usbvision_v4l2_format)</span>

<span class="k">struct</span> <span class="n">usbvision_frame_header</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">magic_1</span><span class="p">;</span>				<span class="cm">/* 0 magic */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">magic_2</span><span class="p">;</span>				<span class="cm">/* 1  magic */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">header_length</span><span class="p">;</span>			<span class="cm">/* 2 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">frame_num</span><span class="p">;</span>			<span class="cm">/* 3 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">frame_phase</span><span class="p">;</span>			<span class="cm">/* 4 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">frame_latency</span><span class="p">;</span>			<span class="cm">/* 5 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data_format</span><span class="p">;</span>			<span class="cm">/* 6 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">format_param</span><span class="p">;</span>			<span class="cm">/* 7 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">frame_width_lo</span><span class="p">;</span>			<span class="cm">/* 8 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">frame_width_hi</span><span class="p">;</span>			<span class="cm">/* 9 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">frame_height_lo</span><span class="p">;</span>			<span class="cm">/* 10 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">frame_height_hi</span><span class="p">;</span>			<span class="cm">/* 11 */</span>
	<span class="n">__u16</span> <span class="n">frame_width</span><span class="p">;</span>				<span class="cm">/* 8 - 9 after endian correction*/</span>
	<span class="n">__u16</span> <span class="n">frame_height</span><span class="p">;</span>				<span class="cm">/* 10 - 11 after endian correction*/</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">usbvision_frame</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>					<span class="cm">/* Frame buffer */</span>
	<span class="k">struct</span> <span class="n">usbvision_frame_header</span> <span class="n">isoc_header</span><span class="p">;</span>	<span class="cm">/* Header from stream */</span>

	<span class="kt">int</span> <span class="n">width</span><span class="p">;</span>					<span class="cm">/* Width application is expecting */</span>
	<span class="kt">int</span> <span class="n">height</span><span class="p">;</span>					<span class="cm">/* Height */</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>					<span class="cm">/* Frame index */</span>
	<span class="kt">int</span> <span class="n">frmwidth</span><span class="p">;</span>					<span class="cm">/* Width the frame actually is */</span>
	<span class="kt">int</span> <span class="n">frmheight</span><span class="p">;</span>					<span class="cm">/* Height */</span>

	<span class="k">volatile</span> <span class="kt">int</span> <span class="n">grabstate</span><span class="p">;</span>				<span class="cm">/* State of grabbing */</span>
	<span class="kt">int</span> <span class="n">scanstate</span><span class="p">;</span>					<span class="cm">/* State of scanning */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">frame</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">curline</span><span class="p">;</span>					<span class="cm">/* Line of frame we&#39;re working on */</span>

	<span class="kt">long</span> <span class="n">scanlength</span><span class="p">;</span>				<span class="cm">/* uncompressed, raw data length of frame */</span>
	<span class="kt">long</span> <span class="n">bytes_read</span><span class="p">;</span>				<span class="cm">/* amount of scanlength that has been read from data */</span>
	<span class="k">struct</span> <span class="n">usbvision_v4l2_format_st</span> <span class="n">v4l2_format</span><span class="p">;</span>	<span class="cm">/* format the user needs*/</span>
	<span class="kt">int</span> <span class="n">v4l2_linesize</span><span class="p">;</span>				<span class="cm">/* bytes for one videoline*/</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">timestamp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sequence</span><span class="p">;</span>					<span class="cm">/* How many video frames we send to user */</span>
<span class="p">};</span>

<span class="cp">#define CODEC_SAA7113	7113</span>
<span class="cp">#define CODEC_SAA7111	7111</span>
<span class="cp">#define CODEC_WEBCAM	3000</span>
<span class="cp">#define BRIDGE_NT1003	1003</span>
<span class="cp">#define BRIDGE_NT1004	1004</span>
<span class="cp">#define BRIDGE_NT1005   1005</span>

<span class="k">struct</span> <span class="n">usbvision_device_data_st</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">video_norm</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model_string</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">interface</span><span class="p">;</span> <span class="cm">/* to handle special interface number like BELKIN and Hauppauge WinTV-USB II */</span>
	<span class="n">__u16</span> <span class="n">codec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">video_channels</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">audio_channels</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">radio</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vbi</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tuner</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vin_reg1_override</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Override default value with */</span>
	<span class="kt">unsigned</span> <span class="n">vin_reg2_override</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>   <span class="cm">/* vin_reg1, vin_reg2, etc. */</span>
	<span class="kt">unsigned</span> <span class="n">dvi_yuv_override</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">vin_reg1</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">vin_reg2</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">dvi_yuv</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">tuner_type</span><span class="p">;</span>
	<span class="n">__s16</span> <span class="n">x_offset</span><span class="p">;</span>
	<span class="n">__s16</span> <span class="n">y_offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Declared on usbvision-cards.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">usbvision_device_data_st</span> <span class="n">usbvision_device_data</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">usbvision_table</span><span class="p">[];</span>

<span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="n">v4l2_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>					<span class="cm">/* Video Device */</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">rdev</span><span class="p">;</span>					<span class="cm">/* Radio Device */</span>

	<span class="cm">/* i2c Declaration Section*/</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="n">i2c_adap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">registered_i2c</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">ctrl_urb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ctrl_urb_buffer</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ctrl_urb_busy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="n">ctrl_urb_setup</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">ctrl_urb_wq</span><span class="p">;</span>					<span class="cm">/* Processes waiting */</span>

	<span class="cm">/* configuration part */</span>
	<span class="kt">int</span> <span class="n">have_tuner</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tuner_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bridge_type</span><span class="p">;</span>						<span class="cm">/* NT1003, NT1004, NT1005 */</span>
	<span class="kt">int</span> <span class="n">radio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">video_inputs</span><span class="p">;</span>						<span class="cm">/* # of inputs */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">audio_mute</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">audio_channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">isoc_mode</span><span class="p">;</span>							<span class="cm">/* format of video data for the usb isoc-transfer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>						<span class="cm">/* Number of the device */</span>

	<span class="cm">/* Device structure */</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="cm">/* usb transfer */</span>
	<span class="kt">int</span> <span class="n">num_alt</span><span class="p">;</span>		<span class="cm">/* Number of alternative settings */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">alt_max_pkt_size</span><span class="p">;</span>	<span class="cm">/* array of max_packet_size */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">iface</span><span class="p">;</span>						<span class="cm">/* Video interface number */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">iface_alt</span><span class="p">;</span>					<span class="cm">/* Alt settings */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">vin_reg2_preset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">v4l2_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">power_off_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">power_off_work</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">power</span><span class="p">;</span>							<span class="cm">/* is the device powered on? */</span>
	<span class="kt">int</span> <span class="n">user</span><span class="p">;</span>							<span class="cm">/* user count for exclusive use */</span>
	<span class="kt">int</span> <span class="n">initialized</span><span class="p">;</span>						<span class="cm">/* Had we already sent init sequence? */</span>
	<span class="kt">int</span> <span class="n">dev_model</span><span class="p">;</span>							<span class="cm">/* What type of USBVISION device we got? */</span>
	<span class="k">enum</span> <span class="n">stream_state</span> <span class="n">streaming</span><span class="p">;</span>					<span class="cm">/* Are we streaming Isochronous? */</span>
	<span class="kt">int</span> <span class="n">last_error</span><span class="p">;</span>							<span class="cm">/* What calamity struck us? */</span>
	<span class="kt">int</span> <span class="n">curwidth</span><span class="p">;</span>							<span class="cm">/* width of the frame the device is currently set to*/</span>
	<span class="kt">int</span> <span class="n">curheight</span><span class="p">;</span>							<span class="cm">/* height of the frame the device is currently set to*/</span>
	<span class="kt">int</span> <span class="n">stretch_width</span><span class="p">;</span>						<span class="cm">/* stretch-factor for frame width (from usb to screen)*/</span>
	<span class="kt">int</span> <span class="n">stretch_height</span><span class="p">;</span>						<span class="cm">/* stretch-factor for frame height (from usb to screen)*/</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fbuf</span><span class="p">;</span>							<span class="cm">/* Videodev buffer area for mmap*/</span>
	<span class="kt">int</span> <span class="n">max_frame_size</span><span class="p">;</span>						<span class="cm">/* Bytes in one video frame */</span>
	<span class="kt">int</span> <span class="n">fbuf_size</span><span class="p">;</span>							<span class="cm">/* Videodev buffer size */</span>
	<span class="n">spinlock_t</span> <span class="n">queue_lock</span><span class="p">;</span>						<span class="cm">/* spinlock for protecting mods on inqueue and outqueue */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">inqueue</span><span class="p">,</span> <span class="n">outqueue</span><span class="p">;</span>                             <span class="cm">/* queued frame list and ready to dequeue frame list */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait_frame</span><span class="p">;</span>					<span class="cm">/* Processes waiting */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait_stream</span><span class="p">;</span>					<span class="cm">/* Processes waiting */</span>
	<span class="k">struct</span> <span class="n">usbvision_frame</span> <span class="o">*</span><span class="n">cur_frame</span><span class="p">;</span>				<span class="cm">/* pointer to current frame, set by usbvision_find_header */</span>
	<span class="k">struct</span> <span class="n">usbvision_frame</span> <span class="n">frame</span><span class="p">[</span><span class="n">USBVISION_NUMFRAMES</span><span class="p">];</span>		<span class="cm">/* frame buffer */</span>
	<span class="kt">int</span> <span class="n">num_frames</span><span class="p">;</span>							<span class="cm">/* number of frames allocated */</span>
	<span class="k">struct</span> <span class="n">usbvision_sbuf</span> <span class="n">sbuf</span><span class="p">[</span><span class="n">USBVISION_NUMSBUF</span><span class="p">];</span>			<span class="cm">/* S buffering */</span>
	<span class="k">volatile</span> <span class="kt">int</span> <span class="n">remove_pending</span><span class="p">;</span>					<span class="cm">/* If set then about to exit */</span>

	<span class="cm">/* Scratch space from the Isochronous Pipe.*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scratch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scratch_read_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scratch_write_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scratch_headermarker</span><span class="p">[</span><span class="n">USBVISION_NUM_HEADERMARKER</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">scratch_headermarker_read_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scratch_headermarker_write_ptr</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">isoc_state</span> <span class="n">isocstate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbvision_v4l2_format_st</span> <span class="n">palette</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">v4l2_capability</span> <span class="n">vcap</span><span class="p">;</span>					<span class="cm">/* Video capabilities */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctl_input</span><span class="p">;</span>						<span class="cm">/* selected input */</span>
	<span class="n">v4l2_std_id</span> <span class="n">tvnorm_id</span><span class="p">;</span>						<span class="cm">/* selected tv norm */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">video_endp</span><span class="p">;</span>					<span class="cm">/* 0x82 for USBVISION devices based */</span>

	<span class="cm">/* Decompression stuff: */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">intra_frame_buffer</span><span class="p">;</span>				<span class="cm">/* Buffer for reference frame */</span>
	<span class="kt">int</span> <span class="n">block_pos</span><span class="p">;</span>							<span class="cm">/* for test only */</span>
	<span class="kt">int</span> <span class="n">request_intra</span><span class="p">;</span>						<span class="cm">/* 0 = normal; 1 = intra frame is requested; */</span>
	<span class="kt">int</span> <span class="n">last_isoc_frame_num</span><span class="p">;</span>					<span class="cm">/* check for lost isoc frames */</span>
	<span class="kt">int</span> <span class="n">isoc_packet_size</span><span class="p">;</span>						<span class="cm">/* need to calculate used_bandwidth */</span>
	<span class="kt">int</span> <span class="n">used_bandwidth</span><span class="p">;</span>						<span class="cm">/* used bandwidth 0-100%, need to set compr_level */</span>
	<span class="kt">int</span> <span class="n">compr_level</span><span class="p">;</span>						<span class="cm">/* How strong (100) or weak (0) is compression */</span>
	<span class="kt">int</span> <span class="n">last_compr_level</span><span class="p">;</span>						<span class="cm">/* How strong (100) or weak (0) was compression */</span>
	<span class="kt">int</span> <span class="n">usb_bandwidth</span><span class="p">;</span>						<span class="cm">/* Mbit/s */</span>

	<span class="cm">/* Statistics that can be overlayed on the screen */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">isoc_urb_count</span><span class="p">;</span>			<span class="cm">/* How many URBs we received so far */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">urb_length</span><span class="p">;</span>			<span class="cm">/* Length of last URB */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">isoc_data_count</span><span class="p">;</span>			<span class="cm">/* How many bytes we received */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">header_count</span><span class="p">;</span>			<span class="cm">/* How many frame headers we found */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scratch_ovf_count</span><span class="p">;</span>		<span class="cm">/* How many times we overflowed scratch */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">isoc_skip_count</span><span class="p">;</span>			<span class="cm">/* How many empty ISO packets received */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">isoc_err_count</span><span class="p">;</span>			<span class="cm">/* How many bad ISO packets received */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">isoc_packet_count</span><span class="p">;</span>		<span class="cm">/* How many packets we totally got */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_in_irq</span><span class="p">;</span>			<span class="cm">/* How long do we need for interrupt */</span>
	<span class="kt">int</span> <span class="n">isoc_measure_bandwidth_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frame_num</span><span class="p">;</span>					<span class="cm">/* How many video frames we send to user */</span>
	<span class="kt">int</span> <span class="n">max_strip_len</span><span class="p">;</span>				<span class="cm">/* How big is the biggest strip */</span>
	<span class="kt">int</span> <span class="n">comprblock_pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">strip_len_errors</span><span class="p">;</span>				<span class="cm">/* How many times was block_pos greater than strip_len */</span>
	<span class="kt">int</span> <span class="n">strip_magic_errors</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">strip_line_number_errors</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">compr_block_types</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="nf">to_usbvision</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">v4l2_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_usbvision</span><span class="p">,</span> <span class="n">v4l2_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define call_all(usbvision, o, f, args...) \</span>
<span class="cp">	v4l2_device_call_all(&amp;usbvision-&gt;v4l2_dev, 0, o, f, ##args)</span>

<span class="cm">/* --------------------------------------------------------------- */</span>
<span class="cm">/* defined in usbvision-i2c.c                                      */</span>
<span class="cm">/* i2c-algo-usb declaration                                        */</span>
<span class="cm">/* --------------------------------------------------------------- */</span>

<span class="cm">/* ----------------------------------------------------------------------- */</span>
<span class="cm">/* usbvision specific I2C functions                                        */</span>
<span class="cm">/* ----------------------------------------------------------------------- */</span>
<span class="kt">int</span> <span class="n">usbvision_i2c_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_i2c_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>

<span class="cm">/* defined in usbvision-core.c                                      */</span>
<span class="kt">int</span> <span class="n">usbvision_read_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_write_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">usbvision_frames_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">,</span> <span class="kt">int</span> <span class="n">number_of_frames</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbvision_frames_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_scratch_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbvision_scratch_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_decompress_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbvision_decompress_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">usbvision_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">,</span> <span class="kt">int</span> <span class="n">format</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_init_isoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_restart_isoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbvision_stop_isoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_set_alternate</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">usbvision_set_audio</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">,</span> <span class="kt">int</span> <span class="n">audio_channel</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_audio_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">usbvision_begin_streaming</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbvision_empty_framequeues</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_stream_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">usbvision_muxsel</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_set_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_set_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">usbvision_init_power_off_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbvision_set_power_off_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbvision_reset_power_off_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_power_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbvision_power_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_usbvision</span> <span class="o">*</span><span class="n">usbvision</span><span class="p">);</span>

<span class="cp">#endif									</span><span class="cm">/* __LINUX_USBVISION_H */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Overrides for Emacs so that we follow Linus&#39;s tabbing style.</span>
<span class="cm"> * ---------------------------------------------------------------------------</span>
<span class="cm"> * Local variables:</span>
<span class="cm"> * c-basic-offset: 8</span>
<span class="cm"> * End:</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
