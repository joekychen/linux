<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › ivtv › ivtv-driver.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ivtv-driver.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    ivtv driver internal defines and structures</span>
<span class="cm">    Copyright (C) 2003-2004  Kevin Thayer &lt;nufan_wfk at yahoo.com&gt;</span>
<span class="cm">    Copyright (C) 2004  Chris Kennedy &lt;c@groovy.org&gt;</span>
<span class="cm">    Copyright (C) 2005-2007  Hans Verkuil &lt;hverkuil@xs4all.nl&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef IVTV_DRIVER_H</span>
<span class="cp">#define IVTV_DRIVER_H</span>

<span class="cm">/* Internal header for ivtv project:</span>
<span class="cm"> * Driver for the cx23415/6 chip.</span>
<span class="cm"> * Author: Kevin Thayer (nufan_wfk at yahoo.com)</span>
<span class="cm"> * License: GPL</span>
<span class="cm"> * http://www.ivtvdriver.org</span>
<span class="cm"> *</span>
<span class="cm"> * -----</span>
<span class="cm"> * MPG600/MPG160 support by  T.Adachi &lt;tadachi@tadachi-net.com&gt;</span>
<span class="cm"> *                      and Takeru KOMORIYA&lt;komoriya@paken.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * AVerMedia M179 GPIO info by Chris Pinkham &lt;cpinkham@bc2va.org&gt;</span>
<span class="cm"> *                using information provided by Jiun-Kuei Jung @ AVerMedia.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/i2c-algo-bit.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &lt;linux/dvb/video.h&gt;</span>
<span class="cp">#include &lt;linux/dvb/audio.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-common.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-ioctl.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-ctrls.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-device.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-fh.h&gt;</span>
<span class="cp">#include &lt;media/tuner.h&gt;</span>
<span class="cp">#include &lt;media/cx2341x.h&gt;</span>
<span class="cp">#include &lt;media/ir-kbd-i2c.h&gt;</span>

<span class="cp">#include &lt;linux/ivtv.h&gt;</span>

<span class="cm">/* Memory layout */</span>
<span class="cp">#define IVTV_ENCODER_OFFSET	0x00000000</span>
<span class="cp">#define IVTV_ENCODER_SIZE	0x00800000	</span><span class="cm">/* Total size is 0x01000000, but only first half is used */</span><span class="cp"></span>
<span class="cp">#define IVTV_DECODER_OFFSET	0x01000000</span>
<span class="cp">#define IVTV_DECODER_SIZE	0x00800000	</span><span class="cm">/* Total size is 0x01000000, but only first half is used */</span><span class="cp"></span>
<span class="cp">#define IVTV_REG_OFFSET 	0x02000000</span>
<span class="cp">#define IVTV_REG_SIZE		0x00010000</span>

<span class="cm">/* Maximum ivtv driver instances. Some people have a huge number of</span>
<span class="cm">   capture cards, so set this to a high value. */</span>
<span class="cp">#define IVTV_MAX_CARDS 32</span>

<span class="cp">#define IVTV_ENC_STREAM_TYPE_MPG  0</span>
<span class="cp">#define IVTV_ENC_STREAM_TYPE_YUV  1</span>
<span class="cp">#define IVTV_ENC_STREAM_TYPE_VBI  2</span>
<span class="cp">#define IVTV_ENC_STREAM_TYPE_PCM  3</span>
<span class="cp">#define IVTV_ENC_STREAM_TYPE_RAD  4</span>
<span class="cp">#define IVTV_DEC_STREAM_TYPE_MPG  5</span>
<span class="cp">#define IVTV_DEC_STREAM_TYPE_VBI  6</span>
<span class="cp">#define IVTV_DEC_STREAM_TYPE_VOUT 7</span>
<span class="cp">#define IVTV_DEC_STREAM_TYPE_YUV  8</span>
<span class="cp">#define IVTV_MAX_STREAMS	  9</span>

<span class="cp">#define IVTV_DMA_SG_OSD_ENT	(2883584/PAGE_SIZE)	</span><span class="cm">/* sg entities */</span><span class="cp"></span>

<span class="cm">/* DMA Registers */</span>
<span class="cp">#define IVTV_REG_DMAXFER 	(0x0000)</span>
<span class="cp">#define IVTV_REG_DMASTATUS 	(0x0004)</span>
<span class="cp">#define IVTV_REG_DECDMAADDR 	(0x0008)</span>
<span class="cp">#define IVTV_REG_ENCDMAADDR 	(0x000c)</span>
<span class="cp">#define IVTV_REG_DMACONTROL 	(0x0010)</span>
<span class="cp">#define IVTV_REG_IRQSTATUS 	(0x0040)</span>
<span class="cp">#define IVTV_REG_IRQMASK 	(0x0048)</span>

<span class="cm">/* Setup Registers */</span>
<span class="cp">#define IVTV_REG_ENC_SDRAM_REFRESH 	(0x07F8)</span>
<span class="cp">#define IVTV_REG_ENC_SDRAM_PRECHARGE 	(0x07FC)</span>
<span class="cp">#define IVTV_REG_DEC_SDRAM_REFRESH 	(0x08F8)</span>
<span class="cp">#define IVTV_REG_DEC_SDRAM_PRECHARGE 	(0x08FC)</span>
<span class="cp">#define IVTV_REG_VDM 			(0x2800)</span>
<span class="cp">#define IVTV_REG_AO 			(0x2D00)</span>
<span class="cp">#define IVTV_REG_BYTEFLUSH 		(0x2D24)</span>
<span class="cp">#define IVTV_REG_SPU 			(0x9050)</span>
<span class="cp">#define IVTV_REG_HW_BLOCKS 		(0x9054)</span>
<span class="cp">#define IVTV_REG_VPU 			(0x9058)</span>
<span class="cp">#define IVTV_REG_APU 			(0xA064)</span>

<span class="cm">/* Other registers */</span>
<span class="cp">#define IVTV_REG_DEC_LINE_FIELD		(0x28C0)</span>

<span class="cm">/* debugging */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ivtv_debug</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_VIDEO_ADV_DEBUG</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ivtv_fw_debug</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#define IVTV_DBGFLG_WARN    (1 &lt;&lt; 0)</span>
<span class="cp">#define IVTV_DBGFLG_INFO    (1 &lt;&lt; 1)</span>
<span class="cp">#define IVTV_DBGFLG_MB      (1 &lt;&lt; 2)</span>
<span class="cp">#define IVTV_DBGFLG_IOCTL   (1 &lt;&lt; 3)</span>
<span class="cp">#define IVTV_DBGFLG_FILE    (1 &lt;&lt; 4)</span>
<span class="cp">#define IVTV_DBGFLG_DMA     (1 &lt;&lt; 5)</span>
<span class="cp">#define IVTV_DBGFLG_IRQ     (1 &lt;&lt; 6)</span>
<span class="cp">#define IVTV_DBGFLG_DEC     (1 &lt;&lt; 7)</span>
<span class="cp">#define IVTV_DBGFLG_YUV     (1 &lt;&lt; 8)</span>
<span class="cp">#define IVTV_DBGFLG_I2C     (1 &lt;&lt; 9)</span>
<span class="cm">/* Flag to turn on high volume debugging */</span>
<span class="cp">#define IVTV_DBGFLG_HIGHVOL (1 &lt;&lt; 10)</span>

<span class="cp">#define IVTV_DEBUG(x, type, fmt, args...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		if ((x) &amp; ivtv_debug) \</span>
<span class="cp">			v4l2_info(&amp;itv-&gt;v4l2_dev, &quot; &quot; type &quot;: &quot; fmt , ##args);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define IVTV_DEBUG_WARN(fmt, args...)  IVTV_DEBUG(IVTV_DBGFLG_WARN,  &quot;warn&quot;,  fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_INFO(fmt, args...)  IVTV_DEBUG(IVTV_DBGFLG_INFO,  &quot;info&quot;,  fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_MB(fmt, args...)    IVTV_DEBUG(IVTV_DBGFLG_MB,    &quot;mb&quot;,    fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_DMA(fmt, args...)   IVTV_DEBUG(IVTV_DBGFLG_DMA,   &quot;dma&quot;,   fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_IOCTL(fmt, args...) IVTV_DEBUG(IVTV_DBGFLG_IOCTL, &quot;ioctl&quot;, fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_FILE(fmt, args...)  IVTV_DEBUG(IVTV_DBGFLG_FILE,  &quot;file&quot;,  fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_I2C(fmt, args...)   IVTV_DEBUG(IVTV_DBGFLG_I2C,   &quot;i2c&quot;,   fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_IRQ(fmt, args...)   IVTV_DEBUG(IVTV_DBGFLG_IRQ,   &quot;irq&quot;,   fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_DEC(fmt, args...)   IVTV_DEBUG(IVTV_DBGFLG_DEC,   &quot;dec&quot;,   fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_YUV(fmt, args...)   IVTV_DEBUG(IVTV_DBGFLG_YUV,   &quot;yuv&quot;,   fmt , ## args)</span>

<span class="cp">#define IVTV_DEBUG_HIGH_VOL(x, type, fmt, args...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		if (((x) &amp; ivtv_debug) &amp;&amp; (ivtv_debug &amp; IVTV_DBGFLG_HIGHVOL)) 	\</span>
<span class="cp">			v4l2_info(&amp;itv-&gt;v4l2_dev, &quot; &quot; type &quot;: &quot; fmt , ##args);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define IVTV_DEBUG_HI_WARN(fmt, args...)  IVTV_DEBUG_HIGH_VOL(IVTV_DBGFLG_WARN,  &quot;warn&quot;,  fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_HI_INFO(fmt, args...)  IVTV_DEBUG_HIGH_VOL(IVTV_DBGFLG_INFO,  &quot;info&quot;,  fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_HI_MB(fmt, args...)    IVTV_DEBUG_HIGH_VOL(IVTV_DBGFLG_MB,    &quot;mb&quot;,    fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_HI_DMA(fmt, args...)   IVTV_DEBUG_HIGH_VOL(IVTV_DBGFLG_DMA,   &quot;dma&quot;,   fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_HI_IOCTL(fmt, args...) IVTV_DEBUG_HIGH_VOL(IVTV_DBGFLG_IOCTL, &quot;ioctl&quot;, fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_HI_FILE(fmt, args...)  IVTV_DEBUG_HIGH_VOL(IVTV_DBGFLG_FILE,  &quot;file&quot;,  fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_HI_I2C(fmt, args...)   IVTV_DEBUG_HIGH_VOL(IVTV_DBGFLG_I2C,   &quot;i2c&quot;,   fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_HI_IRQ(fmt, args...)   IVTV_DEBUG_HIGH_VOL(IVTV_DBGFLG_IRQ,   &quot;irq&quot;,   fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_HI_DEC(fmt, args...)   IVTV_DEBUG_HIGH_VOL(IVTV_DBGFLG_DEC,   &quot;dec&quot;,   fmt , ## args)</span>
<span class="cp">#define IVTV_DEBUG_HI_YUV(fmt, args...)   IVTV_DEBUG_HIGH_VOL(IVTV_DBGFLG_YUV,   &quot;yuv&quot;,   fmt , ## args)</span>

<span class="cm">/* Standard kernel messages */</span>
<span class="cp">#define IVTV_ERR(fmt, args...)      v4l2_err(&amp;itv-&gt;v4l2_dev, fmt , ## args)</span>
<span class="cp">#define IVTV_WARN(fmt, args...)     v4l2_warn(&amp;itv-&gt;v4l2_dev, fmt , ## args)</span>
<span class="cp">#define IVTV_INFO(fmt, args...)     v4l2_info(&amp;itv-&gt;v4l2_dev, fmt , ## args)</span>

<span class="cm">/* output modes (cx23415 only) */</span>
<span class="cp">#define OUT_NONE        0</span>
<span class="cp">#define OUT_MPG         1</span>
<span class="cp">#define OUT_YUV         2</span>
<span class="cp">#define OUT_UDMA_YUV    3</span>
<span class="cp">#define OUT_PASSTHROUGH 4</span>

<span class="cp">#define IVTV_MAX_PGM_INDEX (400)</span>

<span class="cm">/* Default I2C SCL period in microseconds */</span>
<span class="cp">#define IVTV_DEFAULT_I2C_CLOCK_PERIOD	20</span>

<span class="k">struct</span> <span class="n">ivtv_options</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">kilobytes</span><span class="p">[</span><span class="n">IVTV_MAX_STREAMS</span><span class="p">];</span>        <span class="cm">/* size in kilobytes of each stream */</span>
	<span class="kt">int</span> <span class="n">cardtype</span><span class="p">;</span>				<span class="cm">/* force card type on load */</span>
	<span class="kt">int</span> <span class="n">tuner</span><span class="p">;</span>				<span class="cm">/* set tuner on load */</span>
	<span class="kt">int</span> <span class="n">radio</span><span class="p">;</span>				<span class="cm">/* enable/disable radio */</span>
	<span class="kt">int</span> <span class="n">newi2c</span><span class="p">;</span>				<span class="cm">/* new I2C algorithm */</span>
	<span class="kt">int</span> <span class="n">i2c_clock_period</span><span class="p">;</span>			<span class="cm">/* period of SCL for I2C bus */</span>
<span class="p">};</span>

<span class="cm">/* ivtv-specific mailbox template */</span>
<span class="k">struct</span> <span class="n">ivtv_mailbox</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">[</span><span class="n">CX2341X_MBOX_MAX_DATA</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ivtv_api_cache</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_jiffies</span><span class="p">;</span>		<span class="cm">/* when last command was issued */</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">[</span><span class="n">CX2341X_MBOX_MAX_DATA</span><span class="p">];</span>	<span class="cm">/* last sent api data */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ivtv_mailbox_data</span> <span class="p">{</span>
	<span class="k">volatile</span> <span class="k">struct</span> <span class="n">ivtv_mailbox</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="cm">/* Bits 0-2 are for the encoder mailboxes, 0-1 are for the decoder mailboxes.</span>
<span class="cm">	   If the bit is set, then the corresponding mailbox is in use by the driver. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">busy</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_mbox</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* per-buffer bit flags */</span>
<span class="cp">#define IVTV_F_B_NEED_BUF_SWAP  (1 &lt;&lt; 0)	</span><span class="cm">/* this buffer should be byte swapped */</span><span class="cp"></span>

<span class="cm">/* per-stream, s_flags */</span>
<span class="cp">#define IVTV_F_S_DMA_PENDING	0	</span><span class="cm">/* this stream has pending DMA */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_S_DMA_HAS_VBI	1       </span><span class="cm">/* the current DMA request also requests VBI data */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_S_NEEDS_DATA	2 	</span><span class="cm">/* this decoding stream needs more data */</span><span class="cp"></span>

<span class="cp">#define IVTV_F_S_CLAIMED 	3	</span><span class="cm">/* this stream is claimed */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_S_STREAMING      4	</span><span class="cm">/* the fw is decoding/encoding this stream */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_S_INTERNAL_USE	5	</span><span class="cm">/* this stream is used internally (sliced VBI processing) */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_S_PASSTHROUGH	6	</span><span class="cm">/* this stream is in passthrough mode */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_S_STREAMOFF	7	</span><span class="cm">/* signal end of stream EOS */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_S_APPL_IO        8	</span><span class="cm">/* this stream is used read/written by an application */</span><span class="cp"></span>

<span class="cp">#define IVTV_F_S_PIO_PENDING	9	</span><span class="cm">/* this stream has pending PIO */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_S_PIO_HAS_VBI	1       </span><span class="cm">/* the current PIO request also requests VBI data */</span><span class="cp"></span>

<span class="cm">/* per-ivtv, i_flags */</span>
<span class="cp">#define IVTV_F_I_DMA		   0 	</span><span class="cm">/* DMA in progress */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_UDMA		   1 	</span><span class="cm">/* UDMA in progress */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_UDMA_PENDING	   2 	</span><span class="cm">/* UDMA pending */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_SPEED_CHANGE	   3 	</span><span class="cm">/* a speed change is in progress */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_EOS		   4 	</span><span class="cm">/* end of encoder stream reached */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_RADIO_USER	   5 	</span><span class="cm">/* the radio tuner is selected */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_DIG_RST	   6 	</span><span class="cm">/* reset digitizer */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_DEC_YUV	   7 	</span><span class="cm">/* YUV instead of MPG is being decoded */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_UPDATE_CC	   9  	</span><span class="cm">/* CC should be updated */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_UPDATE_WSS	   10 	</span><span class="cm">/* WSS should be updated */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_UPDATE_VPS	   11 	</span><span class="cm">/* VPS should be updated */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_DECODING_YUV	   12 	</span><span class="cm">/* this stream is YUV frame decoding */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_ENC_PAUSED	   13 	</span><span class="cm">/* the encoder is paused */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_VALID_DEC_TIMINGS 14 	</span><span class="cm">/* last_dec_timing is valid */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_HAVE_WORK  	   15	</span><span class="cm">/* used in the interrupt handler: there is work to be done */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_WORK_HANDLER_VBI  16	</span><span class="cm">/* there is work to be done for VBI */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_WORK_HANDLER_YUV  17	</span><span class="cm">/* there is work to be done for YUV */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_WORK_HANDLER_PIO  18	</span><span class="cm">/* there is work to be done for PIO */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_PIO		   19	</span><span class="cm">/* PIO in progress */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_DEC_PAUSED	   20 	</span><span class="cm">/* the decoder is paused */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_INITED		   21 	</span><span class="cm">/* set after first open */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_FAILED		   22 	</span><span class="cm">/* set if first open failed */</span><span class="cp"></span>

<span class="cm">/* Event notifications */</span>
<span class="cp">#define IVTV_F_I_EV_DEC_STOPPED	   28	</span><span class="cm">/* decoder stopped event */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_EV_VSYNC	   29 	</span><span class="cm">/* VSYNC event */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_EV_VSYNC_FIELD    30 	</span><span class="cm">/* VSYNC event field (0 = first, 1 = second field) */</span><span class="cp"></span>
<span class="cp">#define IVTV_F_I_EV_VSYNC_ENABLED  31 	</span><span class="cm">/* VSYNC event enabled */</span><span class="cp"></span>

<span class="cm">/* Scatter-Gather array element, used in DMA transfers */</span>
<span class="k">struct</span> <span class="n">ivtv_sg_element</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">dst</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ivtv_sg_host_element</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ivtv_user_dma</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">map</span><span class="p">[</span><span class="n">IVTV_DMA_SG_OSD_ENT</span><span class="p">];</span>
	<span class="cm">/* Needed when dealing with highmem userspace buffers */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">bouncemap</span><span class="p">[</span><span class="n">IVTV_DMA_SG_OSD_ENT</span><span class="p">];</span>

	<span class="cm">/* Base Dev SG Array for cx23415/6 */</span>
	<span class="k">struct</span> <span class="n">ivtv_sg_element</span> <span class="n">SGarray</span><span class="p">[</span><span class="n">IVTV_DMA_SG_OSD_ENT</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">SG_handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">SG_length</span><span class="p">;</span>

	<span class="cm">/* SG List of Buffers */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">SGlist</span><span class="p">[</span><span class="n">IVTV_DMA_SG_OSD_ENT</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ivtv_dma_page_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ivtv_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">b_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">dma_xfer_cnt</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bytesused</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">readpos</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ivtv_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>          <span class="cm">/* the list of buffers in this queue */</span>
	<span class="n">u32</span> <span class="n">buffers</span><span class="p">;</span>                    <span class="cm">/* number of buffers in this queue */</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>                     <span class="cm">/* total number of bytes of available buffer space */</span>
	<span class="n">u32</span> <span class="n">bytesused</span><span class="p">;</span>                  <span class="cm">/* total number of bytes used in this queue */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ivtv</span><span class="p">;</span>				<span class="cm">/* forward reference */</span>

<span class="k">struct</span> <span class="n">ivtv_stream</span> <span class="p">{</span>
	<span class="cm">/* These first four fields are always set, even if the stream</span>
<span class="cm">	   is not actually created. */</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>	<span class="cm">/* NULL when stream not created */</span>
	<span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="n">itv</span><span class="p">;</span> 		<span class="cm">/* for ease of use */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* name of the stream */</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>			<span class="cm">/* stream type */</span>
	<span class="n">u32</span> <span class="n">caps</span><span class="p">;</span>			<span class="cm">/* V4L2 capabilities */</span>

	<span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>		<span class="cm">/* pointer to the streaming filehandle */</span>
	<span class="n">spinlock_t</span> <span class="n">qlock</span><span class="p">;</span> 		<span class="cm">/* locks access to the queues */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_flags</span><span class="p">;</span>		<span class="cm">/* status flags, see above */</span>
	<span class="kt">int</span> <span class="n">dma</span><span class="p">;</span>			<span class="cm">/* can be PCI_DMA_TODEVICE, PCI_DMA_FROMDEVICE or PCI_DMA_NONE */</span>
	<span class="n">u32</span> <span class="n">pending_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pending_backup</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pending_pts</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">dma_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma_backup</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dma_pts</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">subtype</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">waitq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma_last_offset</span><span class="p">;</span>

	<span class="cm">/* Buffer Stats */</span>
	<span class="n">u32</span> <span class="n">buffers</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">buffers_stolen</span><span class="p">;</span>

	<span class="cm">/* Buffer Queues */</span>
	<span class="k">struct</span> <span class="n">ivtv_queue</span> <span class="n">q_free</span><span class="p">;</span>	<span class="cm">/* free buffers */</span>
	<span class="k">struct</span> <span class="n">ivtv_queue</span> <span class="n">q_full</span><span class="p">;</span>	<span class="cm">/* full buffers */</span>
	<span class="k">struct</span> <span class="n">ivtv_queue</span> <span class="n">q_io</span><span class="p">;</span>		<span class="cm">/* waiting for I/O */</span>
	<span class="k">struct</span> <span class="n">ivtv_queue</span> <span class="n">q_dma</span><span class="p">;</span>	<span class="cm">/* waiting for DMA */</span>
	<span class="k">struct</span> <span class="n">ivtv_queue</span> <span class="n">q_predma</span><span class="p">;</span>	<span class="cm">/* waiting for DMA */</span>

	<span class="cm">/* DMA xfer counter, buffers belonging to the same DMA</span>
<span class="cm">	   xfer will have the same dma_xfer_cnt. */</span>
	<span class="n">u16</span> <span class="n">dma_xfer_cnt</span><span class="p">;</span>

	<span class="cm">/* Base Dev SG Array for cx23415/6 */</span>
	<span class="k">struct</span> <span class="n">ivtv_sg_host_element</span> <span class="o">*</span><span class="n">sg_pending</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ivtv_sg_host_element</span> <span class="o">*</span><span class="n">sg_processing</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ivtv_sg_element</span> <span class="o">*</span><span class="n">sg_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">sg_handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_pending_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_processing_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_processed</span><span class="p">;</span>

	<span class="cm">/* SG List of Buffers */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">SGlist</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ivtv_open_id</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="n">fh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>                       <span class="cm">/* stream type */</span>
	<span class="kt">int</span> <span class="n">yuv_frames</span><span class="p">;</span>                 <span class="cm">/* 1: started OUT_UDMA_YUV output mode */</span>
	<span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="n">itv</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ivtv_open_id</span> <span class="o">*</span><span class="nf">fh2id</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ivtv_open_id</span><span class="p">,</span> <span class="n">fh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">yuv_frame_info</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">update</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">src_x</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">src_y</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">src_w</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">src_h</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">dst_x</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">dst_y</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dst_w</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dst_h</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">pan_x</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">pan_y</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vis_w</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vis_h</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">interlaced_y</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">interlaced_uv</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">tru_x</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tru_w</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tru_h</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset_y</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">lace_mode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sync_field</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">delay</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">interlaced</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IVTV_YUV_MODE_INTERLACED	0x00</span>
<span class="cp">#define IVTV_YUV_MODE_PROGRESSIVE	0x01</span>
<span class="cp">#define IVTV_YUV_MODE_AUTO		0x02</span>
<span class="cp">#define IVTV_YUV_MODE_MASK		0x03</span>

<span class="cp">#define IVTV_YUV_SYNC_EVEN		0x00</span>
<span class="cp">#define IVTV_YUV_SYNC_ODD		0x04</span>
<span class="cp">#define IVTV_YUV_SYNC_MASK		0x04</span>

<span class="cp">#define IVTV_YUV_BUFFERS 8</span>

<span class="k">struct</span> <span class="n">yuv_playback_info</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg_2834</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2838</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_283c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2840</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2844</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2848</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2854</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_285c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2864</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">reg_2870</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2874</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2890</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2898</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_289c</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">reg_2918</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_291c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2920</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2924</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2928</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_292c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2930</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">reg_2934</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">reg_2938</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_293c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2940</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2944</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2948</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_294c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2950</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2954</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2958</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_295c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2960</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2964</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_2968</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_296c</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">reg_2970</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">v_filter_1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">v_filter_2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">h_filter</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">track_osd</span><span class="p">;</span> <span class="cm">/* Should yuv output track the OSD size &amp; position */</span>

	<span class="n">u32</span> <span class="n">osd_x_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">osd_y_offset</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">osd_x_pan</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">osd_y_pan</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">osd_vis_w</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">osd_vis_h</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">osd_full_w</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">osd_full_h</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">decode_height</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">lace_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lace_threshold</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lace_sync_field</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">next_dma_frame</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">next_fill_frame</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">yuv_forced_update</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">update_frame</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">fields_lapsed</span><span class="p">;</span>   <span class="cm">/* Counter used when delaying a frame */</span>

	<span class="k">struct</span> <span class="n">yuv_frame_info</span> <span class="n">new_frame_info</span><span class="p">[</span><span class="n">IVTV_YUV_BUFFERS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">yuv_frame_info</span> <span class="n">old_frame_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">yuv_frame_info</span> <span class="n">old_frame_info_args</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">blanking_ptr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">blanking_dmaptr</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">stream_size</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">draw_frame</span><span class="p">;</span> <span class="cm">/* PVR350 buffer to draw into */</span>
	<span class="n">u8</span> <span class="n">max_frames_buffered</span><span class="p">;</span> <span class="cm">/* Maximum number of frames to buffer */</span>

	<span class="k">struct</span> <span class="n">v4l2_rect</span> <span class="n">main_rect</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v4l2_src_w</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v4l2_src_h</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">running</span><span class="p">;</span> <span class="cm">/* Have any frames been displayed */</span>
<span class="p">};</span>

<span class="cp">#define IVTV_VBI_FRAMES 32</span>

<span class="cm">/* VBI data */</span>
<span class="k">struct</span> <span class="n">vbi_cc</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">odd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* two-byte payload of odd field */</span>
	<span class="n">u8</span> <span class="n">even</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* two-byte payload of even field */</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vbi_vps</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* five-byte VPS payload */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vbi_info</span> <span class="p">{</span>
	<span class="cm">/* VBI general data, does not change during streaming */</span>

	<span class="n">u32</span> <span class="n">raw_decoder_line_size</span><span class="p">;</span>              <span class="cm">/* raw VBI line size from digitizer */</span>
	<span class="n">u8</span> <span class="n">raw_decoder_sav_odd_field</span><span class="p">;</span>           <span class="cm">/* raw VBI Start Active Video digitizer code of odd field */</span>
	<span class="n">u8</span> <span class="n">raw_decoder_sav_even_field</span><span class="p">;</span>          <span class="cm">/* raw VBI Start Active Video digitizer code of even field */</span>
	<span class="n">u32</span> <span class="n">sliced_decoder_line_size</span><span class="p">;</span>           <span class="cm">/* sliced VBI line size from digitizer */</span>
	<span class="n">u8</span> <span class="n">sliced_decoder_sav_odd_field</span><span class="p">;</span>        <span class="cm">/* sliced VBI Start Active Video digitizer code of odd field */</span>
	<span class="n">u8</span> <span class="n">sliced_decoder_sav_even_field</span><span class="p">;</span>       <span class="cm">/* sliced VBI Start Active Video digitizer code of even field */</span>

	<span class="n">u32</span> <span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>				<span class="cm">/* start of first VBI line in the odd/even fields */</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>				<span class="cm">/* number of VBI lines per field */</span>
	<span class="n">u32</span> <span class="n">raw_size</span><span class="p">;</span>				<span class="cm">/* size of raw VBI line from the digitizer */</span>
	<span class="n">u32</span> <span class="n">sliced_size</span><span class="p">;</span>			<span class="cm">/* size of sliced VBI line from the digitizer */</span>

	<span class="n">u32</span> <span class="n">dec_start</span><span class="p">;</span>				<span class="cm">/* start in decoder memory of VBI re-insertion buffers */</span>
	<span class="n">u32</span> <span class="n">enc_start</span><span class="p">;</span>				<span class="cm">/* start in encoder memory of VBI capture buffers */</span>
	<span class="n">u32</span> <span class="n">enc_size</span><span class="p">;</span>				<span class="cm">/* size of VBI capture area */</span>
	<span class="kt">int</span> <span class="n">fpi</span><span class="p">;</span>				<span class="cm">/* number of VBI frames per interrupt */</span>

	<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="n">in</span><span class="p">;</span>			<span class="cm">/* current VBI capture format */</span>
	<span class="k">struct</span> <span class="n">v4l2_sliced_vbi_format</span> <span class="o">*</span><span class="n">sliced_in</span><span class="p">;</span> <span class="cm">/* convenience pointer to sliced struct in vbi.in union */</span>
	<span class="kt">int</span> <span class="n">insert_mpeg</span><span class="p">;</span>			<span class="cm">/* if non-zero, then embed VBI data in MPEG stream */</span>

	<span class="cm">/* Raw VBI compatibility hack */</span>

	<span class="n">u32</span> <span class="n">frame</span><span class="p">;</span> 				<span class="cm">/* frame counter hack needed for backwards compatibility</span>
<span class="cm">						   of old VBI software */</span>

	<span class="cm">/* Sliced VBI output data */</span>

	<span class="k">struct</span> <span class="n">vbi_cc</span> <span class="n">cc_payload</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>		<span class="cm">/* sliced VBI CC payload array: it is an array to</span>
<span class="cm">						   prevent dropping CC data if they couldn&#39;t be</span>
<span class="cm">						   processed fast enough */</span>
	<span class="kt">int</span> <span class="n">cc_payload_idx</span><span class="p">;</span>			<span class="cm">/* index in cc_payload */</span>
	<span class="n">u8</span> <span class="n">cc_missing_cnt</span><span class="p">;</span>			<span class="cm">/* counts number of frames without CC for passthrough mode */</span>
	<span class="kt">int</span> <span class="n">wss_payload</span><span class="p">;</span>			<span class="cm">/* sliced VBI WSS payload */</span>
	<span class="n">u8</span> <span class="n">wss_missing_cnt</span><span class="p">;</span>			<span class="cm">/* counts number of frames without WSS for passthrough mode */</span>
	<span class="k">struct</span> <span class="n">vbi_vps</span> <span class="n">vps_payload</span><span class="p">;</span>		<span class="cm">/* sliced VBI VPS payload */</span>

	<span class="cm">/* Sliced VBI capture data */</span>

	<span class="k">struct</span> <span class="n">v4l2_sliced_vbi_data</span> <span class="n">sliced_data</span><span class="p">[</span><span class="mi">36</span><span class="p">];</span>	<span class="cm">/* sliced VBI storage for VBI encoder stream */</span>
	<span class="k">struct</span> <span class="n">v4l2_sliced_vbi_data</span> <span class="n">sliced_dec_data</span><span class="p">[</span><span class="mi">36</span><span class="p">];</span><span class="cm">/* sliced VBI storage for VBI decoder stream */</span>

	<span class="cm">/* VBI Embedding data */</span>

	<span class="cm">/* Buffer for VBI data inserted into MPEG stream.</span>
<span class="cm">	   The first byte is a dummy byte that&#39;s never used.</span>
<span class="cm">	   The next 16 bytes contain the MPEG header for the VBI data,</span>
<span class="cm">	   the remainder is the actual VBI data.</span>
<span class="cm">	   The max size accepted by the MPEG VBI reinsertion turns out</span>
<span class="cm">	   to be 1552 bytes, which happens to be 4 + (1 + 42) * (2 * 18) bytes,</span>
<span class="cm">	   where 4 is a four byte header, 42 is the max sliced VBI payload, 1 is</span>
<span class="cm">	   a single line header byte and 2 * 18 is the number of VBI lines per frame.</span>

<span class="cm">	   However, it seems that the data must be 1K aligned, so we have to</span>
<span class="cm">	   pad the data until the 1 or 2 K boundary.</span>

<span class="cm">	   This pointer array will allocate 2049 bytes to store each VBI frame. */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">sliced_mpeg_data</span><span class="p">[</span><span class="n">IVTV_VBI_FRAMES</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">sliced_mpeg_size</span><span class="p">[</span><span class="n">IVTV_VBI_FRAMES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ivtv_buffer</span> <span class="n">sliced_mpeg_buf</span><span class="p">;</span>	<span class="cm">/* temporary buffer holding data from sliced_mpeg_data */</span>
	<span class="n">u32</span> <span class="n">inserted_frame</span><span class="p">;</span>			<span class="cm">/* index in sliced_mpeg_size of next sliced data</span>
<span class="cm">						   to be inserted in the MPEG stream */</span>
<span class="p">};</span>

<span class="cm">/* forward declaration of struct defined in ivtv-cards.h */</span>
<span class="k">struct</span> <span class="n">ivtv_card</span><span class="p">;</span>

<span class="cm">/* Struct to hold info about ivtv cards */</span>
<span class="k">struct</span> <span class="n">ivtv</span> <span class="p">{</span>
	<span class="cm">/* General fixed card data */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>		<span class="cm">/* PCI device */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ivtv_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>	<span class="cm">/* card information */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">card_name</span><span class="p">;</span>          <span class="cm">/* full name of the card */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ivtv_card_tuner_i2c</span> <span class="o">*</span><span class="n">card_i2c</span><span class="p">;</span> <span class="cm">/* i2c addresses to probe for tuner */</span>
	<span class="n">u8</span> <span class="n">has_cx23415</span><span class="p">;</span>			<span class="cm">/* 1 if it is a cx23415 based card, 0 for cx23416 */</span>
	<span class="n">u8</span> <span class="n">pvr150_workaround</span><span class="p">;</span>           <span class="cm">/* 1 if the cx25840 needs to workaround a PVR150 bug */</span>
	<span class="n">u8</span> <span class="n">nof_inputs</span><span class="p">;</span>			<span class="cm">/* number of video inputs */</span>
	<span class="n">u8</span> <span class="n">nof_audio_inputs</span><span class="p">;</span>		<span class="cm">/* number of audio inputs */</span>
	<span class="n">u32</span> <span class="n">v4l2_cap</span><span class="p">;</span>			<span class="cm">/* V4L2 capabilities of card */</span>
	<span class="n">u32</span> <span class="n">hw_flags</span><span class="p">;</span> 			<span class="cm">/* hardware description of the board */</span>
	<span class="n">v4l2_std_id</span> <span class="n">tuner_std</span><span class="p">;</span>		<span class="cm">/* the norm of the card&#39;s tuner (fixed) */</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd_video</span><span class="p">;</span>	<span class="cm">/* controlling video decoder subdev */</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd_audio</span><span class="p">;</span>	<span class="cm">/* controlling audio subdev */</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd_muxer</span><span class="p">;</span>	<span class="cm">/* controlling audio muxer subdev */</span>
	<span class="n">resource_size_t</span> <span class="n">base_addr</span><span class="p">;</span>      <span class="cm">/* PCI resource base address */</span>
	<span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">enc_mem</span><span class="p">;</span> <span class="cm">/* pointer to mapped encoder memory */</span>
	<span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">dec_mem</span><span class="p">;</span> <span class="cm">/* pointer to mapped decoder memory */</span>
	<span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg_mem</span><span class="p">;</span> <span class="cm">/* pointer to mapped registers */</span>
	<span class="k">struct</span> <span class="n">ivtv_options</span> <span class="n">options</span><span class="p">;</span> 	<span class="cm">/* user options */</span>

	<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="n">v4l2_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx2341x_handler</span> <span class="n">cxhdl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* PTS/Frame count control cluster */</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl_pts</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl_frame</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Audio Playback control cluster */</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl_audio_playback</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl_audio_multilingual_playback</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="n">hdl_gpio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="n">sd_gpio</span><span class="p">;</span>	<span class="cm">/* GPIO sub-device */</span>
	<span class="n">u16</span> <span class="n">instance</span><span class="p">;</span>

	<span class="cm">/* High-level state info */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i_flags</span><span class="p">;</span>          <span class="cm">/* global ivtv flags */</span>
	<span class="n">u8</span> <span class="n">is_50hz</span><span class="p">;</span>                     <span class="cm">/* 1 if the current capture standard is 50 Hz */</span>
	<span class="n">u8</span> <span class="n">is_60hz</span>                      <span class="cm">/* 1 if the current capture standard is 60 Hz */</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">is_out_50hz</span>                  <span class="cm">/* 1 if the current TV output standard is 50 Hz */</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">is_out_60hz</span>                  <span class="cm">/* 1 if the current TV output standard is 60 Hz */</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">output_mode</span><span class="p">;</span>                <span class="cm">/* decoder output mode: NONE, MPG, YUV, UDMA YUV, passthrough */</span>
	<span class="n">u32</span> <span class="n">audio_input</span><span class="p">;</span>                <span class="cm">/* current audio input */</span>
	<span class="n">u32</span> <span class="n">active_input</span><span class="p">;</span>               <span class="cm">/* current video input */</span>
	<span class="n">u32</span> <span class="n">active_output</span><span class="p">;</span>              <span class="cm">/* current video output */</span>
	<span class="n">v4l2_std_id</span> <span class="n">std</span><span class="p">;</span>                <span class="cm">/* current capture TV standard */</span>
	<span class="n">v4l2_std_id</span> <span class="n">std_out</span><span class="p">;</span>            <span class="cm">/* current TV output standard */</span>
	<span class="n">u8</span> <span class="n">audio_stereo_mode</span><span class="p">;</span>           <span class="cm">/* decoder setting how to handle stereo MPEG audio */</span>
	<span class="n">u8</span> <span class="n">audio_bilingual_mode</span><span class="p">;</span>        <span class="cm">/* decoder setting how to handle bilingual MPEG audio */</span>

	<span class="cm">/* Locking */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>                <span class="cm">/* lock access to this struct */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">serialize_lock</span><span class="p">;</span>    <span class="cm">/* mutex used to serialize open/close/start/stop/ioctl operations */</span>

	<span class="cm">/* Streams */</span>
	<span class="kt">int</span> <span class="n">stream_buf_size</span><span class="p">[</span><span class="n">IVTV_MAX_STREAMS</span><span class="p">];</span>          <span class="cm">/* stream buffer size */</span>
	<span class="k">struct</span> <span class="n">ivtv_stream</span> <span class="n">streams</span><span class="p">[</span><span class="n">IVTV_MAX_STREAMS</span><span class="p">];</span> 	<span class="cm">/* stream data */</span>
	<span class="n">atomic_t</span> <span class="n">capturing</span><span class="p">;</span>		<span class="cm">/* count number of active capture streams */</span>
	<span class="n">atomic_t</span> <span class="n">decoding</span><span class="p">;</span>		<span class="cm">/* count number of active decoding streams */</span>


	<span class="cm">/* Interrupts &amp; DMA */</span>
	<span class="n">u32</span> <span class="n">irqmask</span><span class="p">;</span>                    <span class="cm">/* active interrupts */</span>
	<span class="n">u32</span> <span class="n">irq_rr_idx</span><span class="p">;</span>                 <span class="cm">/* round-robin stream index */</span>
	<span class="k">struct</span> <span class="n">kthread_worker</span> <span class="n">irq_worker</span><span class="p">;</span>		<span class="cm">/* kthread worker for PIO/YUV/VBI actions */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">irq_worker_task</span><span class="p">;</span>		<span class="cm">/* task for irq_worker */</span>
	<span class="k">struct</span> <span class="n">kthread_work</span> <span class="n">irq_work</span><span class="p">;</span>	<span class="cm">/* kthread work entry */</span>
	<span class="n">spinlock_t</span> <span class="n">dma_reg_lock</span><span class="p">;</span>        <span class="cm">/* lock access to DMA engine registers */</span>
	<span class="kt">int</span> <span class="n">cur_dma_stream</span><span class="p">;</span>		<span class="cm">/* index of current stream doing DMA (-1 if none) */</span>
	<span class="kt">int</span> <span class="n">cur_pio_stream</span><span class="p">;</span>		<span class="cm">/* index of current stream doing PIO (-1 if none) */</span>
	<span class="n">u32</span> <span class="n">dma_data_req_offset</span><span class="p">;</span>        <span class="cm">/* store offset in decoder memory of current DMA request */</span>
	<span class="n">u32</span> <span class="n">dma_data_req_size</span><span class="p">;</span>          <span class="cm">/* store size of current DMA request */</span>
	<span class="kt">int</span> <span class="n">dma_retries</span><span class="p">;</span>                <span class="cm">/* current DMA retry attempt */</span>
	<span class="k">struct</span> <span class="n">ivtv_user_dma</span> <span class="n">udma</span><span class="p">;</span>      <span class="cm">/* user based DMA for OSD */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">dma_timer</span><span class="p">;</span>    <span class="cm">/* timer used to catch unfinished DMAs */</span>
	<span class="n">u32</span> <span class="n">last_vsync_field</span><span class="p">;</span>           <span class="cm">/* last seen vsync field */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">dma_waitq</span><span class="p">;</span>    <span class="cm">/* wake up when the current DMA is finished */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">eos_waitq</span><span class="p">;</span>    <span class="cm">/* wake up when EOS arrives */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">event_waitq</span><span class="p">;</span>  <span class="cm">/* wake up when the next decoder event arrives */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">vsync_waitq</span><span class="p">;</span>  <span class="cm">/* wake up when the next decoder vsync arrives */</span>


	<span class="cm">/* Mailbox */</span>
	<span class="k">struct</span> <span class="n">ivtv_mailbox_data</span> <span class="n">enc_mbox</span><span class="p">;</span>              <span class="cm">/* encoder mailboxes */</span>
	<span class="k">struct</span> <span class="n">ivtv_mailbox_data</span> <span class="n">dec_mbox</span><span class="p">;</span>              <span class="cm">/* decoder mailboxes */</span>
	<span class="k">struct</span> <span class="n">ivtv_api_cache</span> <span class="n">api_cache</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span> 		<span class="cm">/* cached API commands */</span>


	<span class="cm">/* I2C */</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="n">i2c_adap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_algo_bit_data</span> <span class="n">i2c_algo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="n">i2c_client</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i2c_state</span><span class="p">;</span>                  <span class="cm">/* i2c bit state */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">i2c_bus_lock</span><span class="p">;</span>      <span class="cm">/* lock i2c bus */</span>

	<span class="k">struct</span> <span class="n">IR_i2c_init_data</span> <span class="n">ir_i2c_init_data</span><span class="p">;</span>

	<span class="cm">/* Program Index information */</span>
	<span class="n">u32</span> <span class="n">pgm_info_offset</span><span class="p">;</span>            <span class="cm">/* start of pgm info in encoder memory */</span>
	<span class="n">u32</span> <span class="n">pgm_info_num</span><span class="p">;</span>               <span class="cm">/* number of elements in the pgm cyclic buffer in encoder memory */</span>
	<span class="n">u32</span> <span class="n">pgm_info_write_idx</span><span class="p">;</span>         <span class="cm">/* last index written by the card that was transferred to pgm_info[] */</span>
	<span class="n">u32</span> <span class="n">pgm_info_read_idx</span><span class="p">;</span>          <span class="cm">/* last index in pgm_info read by the application */</span>
	<span class="k">struct</span> <span class="n">v4l2_enc_idx_entry</span> <span class="n">pgm_info</span><span class="p">[</span><span class="n">IVTV_MAX_PGM_INDEX</span><span class="p">];</span> <span class="cm">/* filled from the pgm cyclic buffer on the card */</span>


	<span class="cm">/* Miscellaneous */</span>
	<span class="n">u32</span> <span class="n">open_id</span><span class="p">;</span>			<span class="cm">/* incremented each time an open occurs, is &gt;= 1 */</span>
	<span class="kt">int</span> <span class="n">search_pack_header</span><span class="p">;</span>         <span class="cm">/* 1 if ivtv_copy_buf_to_user() is scanning for a pack header (0xba) */</span>
	<span class="kt">int</span> <span class="n">speed</span><span class="p">;</span>                      <span class="cm">/* current playback speed setting */</span>
	<span class="n">u8</span> <span class="n">speed_mute_audio</span><span class="p">;</span>            <span class="cm">/* 1 if audio should be muted when fast forward */</span>
	<span class="n">u64</span> <span class="n">mpg_data_received</span><span class="p">;</span>          <span class="cm">/* number of bytes received from the MPEG stream */</span>
	<span class="n">u64</span> <span class="n">vbi_data_inserted</span><span class="p">;</span>          <span class="cm">/* number of VBI bytes inserted into the MPEG stream */</span>
	<span class="n">u32</span> <span class="n">last_dec_timing</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>         <span class="cm">/* cache last retrieved pts/scr/frame values */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dualwatch_jiffies</span><span class="p">;</span><span class="cm">/* jiffies value of the previous dualwatch check */</span>
	<span class="n">u32</span> <span class="n">dualwatch_stereo_mode</span><span class="p">;</span>      <span class="cm">/* current detected dualwatch stereo mode */</span>


	<span class="cm">/* VBI state info */</span>
	<span class="k">struct</span> <span class="n">vbi_info</span> <span class="n">vbi</span><span class="p">;</span>            <span class="cm">/* VBI-specific data */</span>


	<span class="cm">/* YUV playback */</span>
	<span class="k">struct</span> <span class="n">yuv_playback_info</span> <span class="n">yuv_info</span><span class="p">;</span>              <span class="cm">/* YUV playback data */</span>


	<span class="cm">/* OSD support */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">osd_video_pbase</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">osd_global_alpha_state</span><span class="p">;</span>     <span class="cm">/* 1 = global alpha is on */</span>
	<span class="kt">int</span> <span class="n">osd_local_alpha_state</span><span class="p">;</span>      <span class="cm">/* 1 = local alpha is on */</span>
	<span class="kt">int</span> <span class="n">osd_chroma_key_state</span><span class="p">;</span>       <span class="cm">/* 1 = chroma-keying is on */</span>
	<span class="n">u8</span>  <span class="n">osd_global_alpha</span><span class="p">;</span>           <span class="cm">/* current global alpha */</span>
	<span class="n">u32</span> <span class="n">osd_chroma_key</span><span class="p">;</span>             <span class="cm">/* current chroma key */</span>
	<span class="k">struct</span> <span class="n">v4l2_rect</span> <span class="n">osd_rect</span><span class="p">;</span>      <span class="cm">/* current OSD position and size */</span>
	<span class="k">struct</span> <span class="n">v4l2_rect</span> <span class="n">main_rect</span><span class="p">;</span>     <span class="cm">/* current Main window position and size */</span>
	<span class="k">struct</span> <span class="n">osd_info</span> <span class="o">*</span><span class="n">osd_info</span><span class="p">;</span>      <span class="cm">/* ivtvfb private OSD info */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ivtvfb_restore</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="n">itv</span><span class="p">);</span> <span class="cm">/* Used for a warm start */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="nf">to_ivtv</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">v4l2_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ivtv</span><span class="p">,</span> <span class="n">v4l2_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Globals */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ivtv_first_minor</span><span class="p">;</span>

<span class="cm">/*==============Prototypes==================*/</span>

<span class="cm">/* Hardware/IRQ */</span>
<span class="kt">void</span> <span class="n">ivtv_set_irq_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="n">itv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ivtv_clear_irq_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="n">itv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>

<span class="cm">/* try to set output mode, return current mode. */</span>
<span class="kt">int</span> <span class="n">ivtv_set_output_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="n">itv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>

<span class="cm">/* return current output stream based on current mode */</span>
<span class="k">struct</span> <span class="n">ivtv_stream</span> <span class="o">*</span><span class="n">ivtv_get_output_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="n">itv</span><span class="p">);</span>

<span class="cm">/* Return non-zero if a signal is pending */</span>
<span class="kt">int</span> <span class="n">ivtv_msleep_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">intr</span><span class="p">);</span>

<span class="cm">/* Wait on queue, returns -EINTR if interrupted */</span>
<span class="kt">int</span> <span class="n">ivtv_waitq</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">waitq</span><span class="p">);</span>

<span class="cm">/* Read Hauppauge eeprom */</span>
<span class="k">struct</span> <span class="n">tveeprom</span><span class="p">;</span> <span class="cm">/* forward reference */</span>
<span class="kt">void</span> <span class="n">ivtv_read_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="n">itv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tveeprom</span> <span class="o">*</span><span class="n">tv</span><span class="p">);</span>

<span class="cm">/* First-open initialization: load firmware, init cx25840, etc. */</span>
<span class="kt">int</span> <span class="n">ivtv_init_on_first_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="n">itv</span><span class="p">);</span>

<span class="cm">/* Test if the current VBI mode is raw (1) or sliced (0) */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ivtv_raw_vbi</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ivtv</span> <span class="o">*</span><span class="n">itv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">itv</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">in</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">V4L2_BUF_TYPE_VBI_CAPTURE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is a PCI post thing, where if the pci register is not read, then</span>
<span class="cm">   the write doesn&#39;t always take effect right away. By reading back the</span>
<span class="cm">   register any pending PCI writes will be performed (in order), and so</span>
<span class="cm">   you can be sure that the writes are guaranteed to be done.</span>

<span class="cm">   Rarely needed, only in some timing sensitive cases.</span>
<span class="cm">   Apparently if this is not done some motherboards seem</span>
<span class="cm">   to kill the firmware and get into the broken state until computer is</span>
<span class="cm">   rebooted. */</span>
<span class="cp">#define write_sync(val, reg) \</span>
<span class="cp">	do { writel(val, reg); readl(reg); } while (0)</span>

<span class="cp">#define read_reg(reg) readl(itv-&gt;reg_mem + (reg))</span>
<span class="cp">#define write_reg(val, reg) writel(val, itv-&gt;reg_mem + (reg))</span>
<span class="cp">#define write_reg_sync(val, reg) \</span>
<span class="cp">	do { write_reg(val, reg); read_reg(reg); } while (0)</span>

<span class="cp">#define read_enc(addr) readl(itv-&gt;enc_mem + (u32)(addr))</span>
<span class="cp">#define write_enc(val, addr) writel(val, itv-&gt;enc_mem + (u32)(addr))</span>
<span class="cp">#define write_enc_sync(val, addr) \</span>
<span class="cp">	do { write_enc(val, addr); read_enc(addr); } while (0)</span>

<span class="cp">#define read_dec(addr) readl(itv-&gt;dec_mem + (u32)(addr))</span>
<span class="cp">#define write_dec(val, addr) writel(val, itv-&gt;dec_mem + (u32)(addr))</span>
<span class="cp">#define write_dec_sync(val, addr) \</span>
<span class="cp">	do { write_dec(val, addr); read_dec(addr); } while (0)</span>

<span class="cm">/* Call the specified callback for all subdevs matching hw (if 0, then</span>
<span class="cm">   match them all). Ignore any errors. */</span>
<span class="cp">#define ivtv_call_hw(itv, hw, o, f, args...) 				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		struct v4l2_subdev *__sd;				\</span>
<span class="cp">		__v4l2_device_call_subdevs_p(&amp;(itv)-&gt;v4l2_dev, __sd,	\</span>
<span class="cp">			!(hw) || (__sd-&gt;grp_id &amp; (hw)), o, f , ##args);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define ivtv_call_all(itv, o, f, args...) ivtv_call_hw(itv, 0, o, f , ##args)</span>

<span class="cm">/* Call the specified callback for all subdevs matching hw (if 0, then</span>
<span class="cm">   match them all). If the callback returns an error other than 0 or</span>
<span class="cm">   -ENOIOCTLCMD, then return with that error code. */</span>
<span class="cp">#define ivtv_call_hw_err(itv, hw, o, f, args...)			\</span>
<span class="cp">({									\</span>
<span class="cp">	struct v4l2_subdev *__sd;					\</span>
<span class="cp">	__v4l2_device_call_subdevs_until_err_p(&amp;(itv)-&gt;v4l2_dev, __sd,	\</span>
<span class="cp">		!(hw) || (__sd-&gt;grp_id &amp; (hw)), o, f , ##args);		\</span>
<span class="cp">})</span>

<span class="cp">#define ivtv_call_all_err(itv, o, f, args...) ivtv_call_hw_err(itv, 0, o, f , ##args)</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
