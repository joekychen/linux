<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › videobuf2-core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>videobuf2-core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * videobuf2-core.c - V4L2 driver helper framework</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010 Samsung Electronics</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Pawel Osciak &lt;pawel@osciak.com&gt;</span>
<span class="cm"> *	   Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#include &lt;media/v4l2-dev.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-fh.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-event.h&gt;</span>
<span class="cp">#include &lt;media/videobuf2-core.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="cp">#define dprintk(level, fmt, arg...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (debug &gt;= level)					\</span>
<span class="cp">			printk(KERN_DEBUG &quot;vb2: &quot; fmt, ## arg);		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define call_memop(q, op, args...)					\</span>
<span class="cp">	(((q)-&gt;mem_ops-&gt;op) ?						\</span>
<span class="cp">		((q)-&gt;mem_ops-&gt;op(args)) : 0)</span>

<span class="cp">#define call_qop(q, op, args...)					\</span>
<span class="cp">	(((q)-&gt;ops-&gt;op) ? ((q)-&gt;ops-&gt;op(args)) : 0)</span>

<span class="cp">#define V4L2_BUFFER_STATE_FLAGS	(V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_QUEUED | \</span>
<span class="cp">				 V4L2_BUF_FLAG_DONE | V4L2_BUF_FLAG_ERROR | \</span>
<span class="cp">				 V4L2_BUF_FLAG_PREPARED)</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_buf_mem_alloc() - allocate video memory for the given buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_buf_mem_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mem_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">plane</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for all planes in this buffer */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mem_priv</span> <span class="o">=</span> <span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">alloc</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_ctx</span><span class="p">[</span><span class="n">plane</span><span class="p">],</span>
				      <span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">[</span><span class="n">plane</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">mem_priv</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>

		<span class="cm">/* Associate allocator private data with this plane */</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span> <span class="o">=</span> <span class="n">mem_priv</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">[</span><span class="n">plane</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">free:</span>
	<span class="cm">/* Free already allocated memory if one of the allocations failed */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">plane</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">put</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">);</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">mem_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_buf_mem_free() - free memory of the given buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vb2_buf_mem_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">put</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">);</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Freed plane %d of buffer %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_buf_userptr_put() - release userspace memory associated with</span>
<span class="cm"> * a USERPTR buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vb2_buf_userptr_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">)</span>
			<span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">put_userptr</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">);</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __setup_offsets() - setup unique offsets (&quot;cookies&quot;) for every plane in</span>
<span class="cm"> * every buffer on the queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__setup_offsets</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">plane</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">v4l2_plane</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">mem_offset</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vb</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">[</span><span class="n">plane</span><span class="p">];</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">mem_offset</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>

			<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Buffer %d, plane %d offset 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">buffer</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>

			<span class="n">off</span> <span class="o">+=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
			<span class="n">off</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">off</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_queue_alloc() - allocate videobuf buffer structures and (for MMAP type)</span>
<span class="cm"> * video buffer memory for all buffers/planes on the queue and initializes the</span>
<span class="cm"> * queue</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of buffers successfully allocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_queue_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_memory</span> <span class="n">memory</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_buffers</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_planes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Allocate videobuf buffer structures */</span>
		<span class="n">vb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">buf_struct_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Memory alloc for buffer struct failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Length stores number of planes for multiplanar buffers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_TYPE_IS_MULTIPLANAR</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">num_planes</span><span class="p">;</span>

		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VB2_BUF_STATE_DEQUEUED</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span> <span class="o">=</span> <span class="n">num_planes</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">memory</span><span class="p">;</span>

		<span class="cm">/* Allocate video buffer memory for the MMAP type */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_buf_mem_alloc</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Failed allocating memory for &quot;</span>
						<span class="s">&quot;buffer %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Call the driver-provided buffer initialization</span>
<span class="cm">			 * callback, if given. An error in initialization</span>
<span class="cm">			 * results in queue setup failure.</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">buf_init</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Buffer %d %p initialization&quot;</span>
					<span class="s">&quot; failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
				<span class="n">__vb2_buf_mem_free</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">]</span> <span class="o">=</span> <span class="n">vb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__setup_offsets</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Allocated %d buffers, %d plane(s) each</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">buffer</span><span class="p">,</span> <span class="n">num_planes</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_free_mem() - release all video buffer memory for a given queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vb2_free_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffers</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">-</span> <span class="n">buffers</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span>
	     <span class="o">++</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vb</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Free MMAP buffers or release USERPTR buffers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">)</span>
			<span class="n">__vb2_buf_mem_free</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__vb2_buf_userptr_put</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_queue_free() - free buffers at the end of the queue - video memory and</span>
<span class="cm"> * related information, if no buffers are left return the queue to an</span>
<span class="cm"> * uninitialized state. Might be called even if the queue has already been freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vb2_queue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffers</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>

	<span class="cm">/* Call driver-provided cleanup function for each buffer, if provided */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">buf_cleanup</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">-</span> <span class="n">buffers</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span>
		     <span class="o">++</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">])</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">buf_cleanup</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Release video buffer memory */</span>
	<span class="n">__vb2_free_mem</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">buffers</span><span class="p">);</span>

	<span class="cm">/* Free videobuf buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">-</span> <span class="n">buffers</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span>
	     <span class="o">++</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">]);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">-=</span> <span class="n">buffers</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __verify_planes_array() - verify that the planes array passed in struct</span>
<span class="cm"> * v4l2_buffer from userspace can be safely used</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__verify_planes_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Is memory for copying plane information present? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Multi-planar buffer passed but &quot;</span>
			   <span class="s">&quot;planes array not provided</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span> <span class="o">||</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">VIDEO_MAX_PLANES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Incorrect planes array length, &quot;</span>
			   <span class="s">&quot;expected %d, got %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __buffer_in_use() - return true if the buffer is in use and</span>
<span class="cm"> * the queue cannot be freed (by the means of REQBUFS(0)) call</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">__buffer_in_use</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">mem_priv</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If num_users() has not been provided, call_memop</span>
<span class="cm">		 * will return 0, apparently nobody cares about this</span>
<span class="cm">		 * case anyway. If num_users() returns more than 1,</span>
<span class="cm">		 * we are not the only user of the plane&#39;s memory.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem_priv</span> <span class="o">&amp;&amp;</span> <span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">num_users</span><span class="p">,</span> <span class="n">mem_priv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __buffers_in_use() - return true if any buffers on the queue are in use and</span>
<span class="cm"> * the queue cannot be freed (by the means of REQBUFS(0)) call</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">__buffers_in_use</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__buffer_in_use</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">]))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __fill_v4l2_buffer() - fill in a struct v4l2_buffer with information to be</span>
<span class="cm"> * returned to userspace</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__fill_v4l2_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Copy back data such as timestamp, flags, input, etc. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_buffer</span><span class="p">,</span> <span class="n">m</span><span class="p">));</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">input</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">input</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">reserved</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_TYPE_IS_MULTIPLANAR</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__verify_planes_array</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Fill in plane-related data if userspace provided an array</span>
<span class="cm">		 * for it. The memory and size is verified above.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">,</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_plane</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We use length and offset in v4l2_planes array even for</span>
<span class="cm">		 * single-planar buffers, but userspace does not.</span>
<span class="cm">		 */</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bytesused</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">)</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">mem_offset</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_USERPTR</span><span class="p">)</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear any buffer state related flags.</span>
<span class="cm">	 */</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">V4L2_BUFFER_STATE_FLAGS</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VB2_BUF_STATE_QUEUED</span>:
	<span class="k">case</span> <span class="n">VB2_BUF_STATE_ACTIVE</span>:
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">V4L2_BUF_FLAG_QUEUED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VB2_BUF_STATE_ERROR</span>:
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">V4L2_BUF_FLAG_ERROR</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">VB2_BUF_STATE_DONE</span>:
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">V4L2_BUF_FLAG_DONE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VB2_BUF_STATE_PREPARED</span>:
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">V4L2_BUF_FLAG_PREPARED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VB2_BUF_STATE_DEQUEUED</span>:
		<span class="cm">/* nothing */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__buffer_in_use</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">vb</span><span class="p">))</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">V4L2_BUF_FLAG_MAPPED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_querybuf() - query video buffer information</span>
<span class="cm"> * @q:		videobuf queue</span>
<span class="cm"> * @b:		buffer struct passed from userspace to vidioc_querybuf handler</span>
<span class="cm"> *		in driver</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called from vidioc_querybuf ioctl handler in driver.</span>
<span class="cm"> * This function will verify the passed v4l2_buffer structure and fill the</span>
<span class="cm"> * relevant information for the userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * The return values from this function are intended to be directly returned</span>
<span class="cm"> * from vidioc_querybuf handler in driver.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_querybuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;querybuf: wrong buffer type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;querybuf: buffer index out of range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">__fill_v4l2_buffer</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vb2_querybuf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __verify_userptr_ops() - verify that all memory operations required for</span>
<span class="cm"> * USERPTR queue type have been provided</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__verify_userptr_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">io_modes</span> <span class="o">&amp;</span> <span class="n">VB2_USERPTR</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="o">-&gt;</span><span class="n">get_userptr</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="o">-&gt;</span><span class="n">put_userptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __verify_mmap_ops() - verify that all memory operations required for</span>
<span class="cm"> * MMAP queue type have been provided</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__verify_mmap_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">io_modes</span> <span class="o">&amp;</span> <span class="n">VB2_MMAP</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="o">-&gt;</span><span class="n">put</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_reqbufs() - Initiate streaming</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @req:	struct passed from userspace to vidioc_reqbufs handler in driver</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called from vidioc_reqbufs ioctl handler of a driver.</span>
<span class="cm"> * This function:</span>
<span class="cm"> * 1) verifies streaming parameters passed from the userspace,</span>
<span class="cm"> * 2) sets up the queue,</span>
<span class="cm"> * 3) negotiates number of buffers and planes per buffer with the driver</span>
<span class="cm"> *    to be used during streaming,</span>
<span class="cm"> * 4) allocates internal buffer structures (struct vb2_buffer), according to</span>
<span class="cm"> *    the agreed parameters,</span>
<span class="cm"> * 5) for MMAP memory type, allocates actual video memory, using the</span>
<span class="cm"> *    memory handling/allocation routines provided during queue initialization</span>
<span class="cm"> *</span>
<span class="cm"> * If req-&gt;count is 0, all the memory will be freed instead.</span>
<span class="cm"> * If the queue has been allocated previously (by a previous vb2_reqbufs) call</span>
<span class="cm"> * and the queue is not busy, memory will be reallocated.</span>
<span class="cm"> *</span>
<span class="cm"> * The return values from this function are intended to be directly returned</span>
<span class="cm"> * from vidioc_reqbufs handler in driver.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_reqbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_requestbuffers</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_buffers</span><span class="p">,</span> <span class="n">allocated_buffers</span><span class="p">,</span> <span class="n">num_planes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;reqbufs: file io in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">V4L2_MEMORY_MMAP</span>
			<span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">V4L2_MEMORY_USERPTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;reqbufs: unsupported memory type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;reqbufs: requested type is incorrect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;reqbufs: streaming active</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure all the required memory ops for given memory type</span>
<span class="cm">	 * are available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_MMAP</span> <span class="o">&amp;&amp;</span> <span class="n">__verify_mmap_ops</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;reqbufs: MMAP for current setup unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_USERPTR</span> <span class="o">&amp;&amp;</span> <span class="n">__verify_userptr_ops</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;reqbufs: USERPTR for current setup unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We already have buffers allocated, so first check if they</span>
<span class="cm">		 * are not in use and can be freed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_MMAP</span> <span class="o">&amp;&amp;</span> <span class="n">__buffers_in_use</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;reqbufs: memory in use, cannot free</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">__vb2_queue_free</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * In case of REQBUFS(0) return immediately without calling</span>
<span class="cm">		 * driver&#39;s queue_setup() callback and allocating resources.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure the requested values and current defaults are sane.</span>
<span class="cm">	 */</span>
	<span class="n">num_buffers</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">VIDEO_MAX_FRAME</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_ctx</span><span class="p">));</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ask the driver how many buffers and planes per buffer it requires.</span>
<span class="cm">	 * Driver also sets the size and allocator context for each plane.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">queue_setup</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_buffers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_planes</span><span class="p">,</span>
		       <span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Finally, allocate buffers and video memory */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_queue_alloc</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">,</span> <span class="n">num_buffers</span><span class="p">,</span> <span class="n">num_planes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">allocated_buffers</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if driver can handle the allocated number of buffers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocated_buffers</span> <span class="o">&lt;</span> <span class="n">num_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_buffers</span> <span class="o">=</span> <span class="n">allocated_buffers</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">queue_setup</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_buffers</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">num_planes</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_ctx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">allocated_buffers</span> <span class="o">&lt;</span> <span class="n">num_buffers</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Either the driver has accepted a smaller number of buffers,</span>
<span class="cm">		 * or .queue_setup() returned an error</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">=</span> <span class="n">allocated_buffers</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__vb2_queue_free</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">allocated_buffers</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return the number of successfully allocated buffers</span>
<span class="cm">	 * to the userspace.</span>
<span class="cm">	 */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">allocated_buffers</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_reqbufs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_create_bufs() - Allocate buffers and any required auxiliary structs</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @create:	creation parameters, passed from userspace to vidioc_create_bufs</span>
<span class="cm"> *		handler in driver</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called from vidioc_create_bufs ioctl handler of a driver.</span>
<span class="cm"> * This function:</span>
<span class="cm"> * 1) verifies parameter sanity</span>
<span class="cm"> * 2) calls the .queue_setup() queue operation</span>
<span class="cm"> * 3) performs any necessary memory allocations</span>
<span class="cm"> *</span>
<span class="cm"> * The return values from this function are intended to be directly returned</span>
<span class="cm"> * from vidioc_create_bufs handler in driver.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_create_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_create_buffers</span> <span class="o">*</span><span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_planes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_buffers</span><span class="p">,</span> <span class="n">allocated_buffers</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): file io in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">create</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">V4L2_MEMORY_MMAP</span>
			<span class="o">&amp;&amp;</span> <span class="n">create</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">V4L2_MEMORY_USERPTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): unsupported memory type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">create</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): requested type is incorrect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure all the required memory ops for given memory type</span>
<span class="cm">	 * are available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">create</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_MMAP</span> <span class="o">&amp;&amp;</span> <span class="n">__verify_mmap_ops</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): MMAP for current setup unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">create</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_USERPTR</span> <span class="o">&amp;&amp;</span> <span class="n">__verify_userptr_ops</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): USERPTR for current setup unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">==</span> <span class="n">VIDEO_MAX_FRAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): maximum number of buffers already allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">create</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_ctx</span><span class="p">));</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">=</span> <span class="n">create</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">num_buffers</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">create</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">VIDEO_MAX_FRAME</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ask the driver, whether the requested number of buffers, planes per</span>
<span class="cm">	 * buffer and their sizes are acceptable</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">queue_setup</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">create</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_buffers</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">num_planes</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Finally, allocate buffers and video memory */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_queue_alloc</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">create</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">,</span> <span class="n">num_buffers</span><span class="p">,</span>
				<span class="n">num_planes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed with error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">allocated_buffers</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if driver can handle the so far allocated number of buffers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">num_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_buffers</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * q-&gt;num_buffers contains the total number of buffers, that the</span>
<span class="cm">		 * queue driver has set up</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">queue_setup</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">create</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_buffers</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">num_planes</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_ctx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">allocated_buffers</span> <span class="o">&lt;</span> <span class="n">num_buffers</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Either the driver has accepted a smaller number of buffers,</span>
<span class="cm">		 * or .queue_setup() returned an error</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">+=</span> <span class="n">allocated_buffers</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__vb2_queue_free</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">allocated_buffers</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return the number of successfully allocated buffers</span>
<span class="cm">	 * to the userspace.</span>
<span class="cm">	 */</span>
	<span class="n">create</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">allocated_buffers</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_create_bufs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_plane_vaddr() - Return a kernel virtual address of a given plane</span>
<span class="cm"> * @vb:		vb2_buffer to which the plane in question belongs to</span>
<span class="cm"> * @plane_no:	plane number for which the address is to be returned</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a kernel virtual address of a given plane if</span>
<span class="cm"> * such a mapping exist, NULL otherwise.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">vb2_plane_vaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plane_no</span> <span class="o">&gt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span> <span class="o">||</span> <span class="o">!</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane_no</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane_no</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_plane_vaddr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_plane_cookie() - Return allocator specific cookie for the given plane</span>
<span class="cm"> * @vb:		vb2_buffer to which the plane in question belongs to</span>
<span class="cm"> * @plane_no:	plane number for which the cookie is to be returned</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns an allocator specific cookie for a given plane if</span>
<span class="cm"> * available, NULL otherwise. The allocator should provide some simple static</span>
<span class="cm"> * inline function, which would convert this cookie to the allocator specific</span>
<span class="cm"> * type that can be used directly by the driver to access the buffer. This can</span>
<span class="cm"> * be for example physical address, pointer to scatter list or IOMMU mapping.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">vb2_plane_cookie</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plane_no</span> <span class="o">&gt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span> <span class="o">||</span> <span class="o">!</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane_no</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane_no</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_plane_cookie</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_buffer_done() - inform videobuf that an operation on a buffer is finished</span>
<span class="cm"> * @vb:		vb2_buffer returned from the driver</span>
<span class="cm"> * @state:	either VB2_BUF_STATE_DONE if the operation finished successfully</span>
<span class="cm"> *		or VB2_BUF_STATE_ERROR if the operation finished with an error</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called by the driver after a hardware operation on</span>
<span class="cm"> * a buffer is finished and the buffer may be returned to userspace. The driver</span>
<span class="cm"> * cannot use this buffer anymore until it is queued back to it by videobuf</span>
<span class="cm"> * by the means of buf_queue callback. Only buffers previously queued to the</span>
<span class="cm"> * driver by buf_queue can be passed to this function.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">vb2_buffer_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">enum</span> <span class="n">vb2_buffer_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">VB2_BUF_STATE_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">VB2_BUF_STATE_DONE</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">!=</span> <span class="n">VB2_BUF_STATE_ERROR</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Done processing on buffer %d, state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="cm">/* Add the buffer to the done buffers list */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">done_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_count</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Inform any processes that may be waiting for buffers */</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_wq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_buffer_done</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __fill_vb2_buffer() - fill a vb2_buffer with information provided in</span>
<span class="cm"> * a v4l2_buffer by the userspace</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__fill_vb2_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_plane</span> <span class="o">*</span><span class="n">v4l2_planes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_TYPE_IS_MULTIPLANAR</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Verify that the userspace gave us a valid array for</span>
<span class="cm">		 * plane information.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__verify_planes_array</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* Fill in driver-provided information for OUTPUT types */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_TYPE_IS_OUTPUT</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Will have to go up to b-&gt;length when API starts</span>
<span class="cm">			 * accepting variable number of planes.</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">bytesused</span> <span class="o">=</span>
					<span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">bytesused</span><span class="p">;</span>
				<span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">data_offset</span> <span class="o">=</span>
					<span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">data_offset</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_USERPTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span> <span class="o">=</span>
					<span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span><span class="p">;</span>
				<span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span>
					<span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Single-planar buffers do not use planes array,</span>
<span class="cm">		 * so fill in relevant v4l2_buffer struct fields instead.</span>
<span class="cm">		 * In videobuf we use our internal V4l2_planes struct for</span>
<span class="cm">		 * single-planar buffers as well, for simplicity.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_TYPE_IS_OUTPUT</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
			<span class="n">v4l2_planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bytesused</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bytesused</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_USERPTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v4l2_planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span><span class="p">;</span>
			<span class="n">v4l2_planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">;</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">input</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">;</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">V4L2_BUFFER_STATE_FLAGS</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __qbuf_userptr() - handle qbuf of a USERPTR buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__qbuf_userptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_plane</span> <span class="n">planes</span><span class="p">[</span><span class="n">VIDEO_MAX_PLANES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mem_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write</span> <span class="o">=</span> <span class="o">!</span><span class="n">V4L2_TYPE_IS_OUTPUT</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

	<span class="cm">/* Verify and copy relevant information provided by the userspace */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__fill_vb2_buffer</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">planes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Skip the plane if already verified */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span> <span class="o">&amp;&amp;</span>
		    <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span> <span class="o">==</span> <span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span>
		    <span class="o">&amp;&amp;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span> <span class="o">==</span> <span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;qbuf: userspace address for plane %d changed, &quot;</span>
				<span class="s">&quot;reacquiring memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">plane</span><span class="p">);</span>

		<span class="cm">/* Check if the provided plane buffer is large enough */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">plane_sizes</span><span class="p">[</span><span class="n">plane</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Release previously acquired memory if present */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">)</span>
			<span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">put_userptr</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">);</span>

		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Acquire each plane&#39;s memory */</span>
		<span class="n">mem_priv</span> <span class="o">=</span> <span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">get_userptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_ctx</span><span class="p">[</span><span class="n">plane</span><span class="p">],</span>
				      <span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span><span class="p">,</span>
				      <span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">mem_priv</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;qbuf: failed acquiring userspace &quot;</span>
						<span class="s">&quot;memory for plane %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">plane</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_priv</span> <span class="o">?</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mem_priv</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span> <span class="o">=</span> <span class="n">mem_priv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call driver-specific initialization on the newly acquired buffer,</span>
<span class="cm">	 * if provided.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">buf_init</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;qbuf: buffer initialization failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that everything is in order, copy relevant information</span>
<span class="cm">	 * provided by userspace.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">]</span> <span class="o">=</span> <span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="cm">/* In case of errors, release planes that were already acquired */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">)</span>
			<span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">put_userptr</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">);</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">userptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __qbuf_mmap() - handle qbuf of an MMAP buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__qbuf_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__fill_vb2_buffer</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __enqueue_in_driver() - enqueue a vb2_buffer in driver for processing</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__enqueue_in_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>

	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VB2_BUF_STATE_ACTIVE</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_count</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">buf_queue</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__buf_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">V4L2_MEMORY_MMAP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__qbuf_mmap</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">V4L2_MEMORY_USERPTR</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__qbuf_userptr</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Invalid queue type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">buf_prepare</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;qbuf: buffer preparation failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VB2_BUF_STATE_PREPARED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_prepare_buf() - Pass ownership of a buffer from userspace to the kernel</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @b:		buffer structure passed from userspace to vidioc_prepare_buf</span>
<span class="cm"> *		handler in driver</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called from vidioc_prepare_buf ioctl handler of a driver.</span>
<span class="cm"> * This function:</span>
<span class="cm"> * 1) verifies the passed buffer,</span>
<span class="cm"> * 2) calls buf_prepare callback in the driver (if provided), in which</span>
<span class="cm"> *    driver-specific buffer initialization can be performed,</span>
<span class="cm"> *</span>
<span class="cm"> * The return values from this function are intended to be directly returned</span>
<span class="cm"> * from vidioc_prepare_buf handler in driver.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_prepare_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): file io in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): invalid buffer type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): buffer index out of range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">vb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Should never happen */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): buffer is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): invalid memory type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">VB2_BUF_STATE_DEQUEUED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): invalid buffer state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__buf_prepare</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">__fill_v4l2_buffer</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_prepare_buf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_qbuf() - Queue a buffer from userspace</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @b:		buffer structure passed from userspace to vidioc_qbuf handler</span>
<span class="cm"> *		in driver</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called from vidioc_qbuf ioctl handler of a driver.</span>
<span class="cm"> * This function:</span>
<span class="cm"> * 1) verifies the passed buffer,</span>
<span class="cm"> * 2) if necessary, calls buf_prepare callback in the driver (if provided), in</span>
<span class="cm"> *    which driver-specific buffer initialization can be performed,</span>
<span class="cm"> * 3) if streaming is on, queues the buffer in driver by the means of buf_queue</span>
<span class="cm"> *    callback for processing.</span>
<span class="cm"> *</span>
<span class="cm"> * The return values from this function are intended to be directly returned</span>
<span class="cm"> * from vidioc_qbuf handler in driver.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_qbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="o">*</span><span class="n">mmap_sem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case of user pointer buffers vb2 allocator needs to get direct</span>
<span class="cm">	 * access to userspace pages. This requires getting read access on</span>
<span class="cm">	 * mmap semaphore in the current process structure. The same</span>
<span class="cm">	 * semaphore is taken before calling mmap operation, while both mmap</span>
<span class="cm">	 * and qbuf are called by the driver or v4l2 core with driver&#39;s lock</span>
<span class="cm">	 * held. To avoid a AB-BA deadlock (mmap_sem then driver&#39;s lock in</span>
<span class="cm">	 * mmap and driver&#39;s lock then mmap_sem in qbuf) the videobuf2 core</span>
<span class="cm">	 * release driver&#39;s lock, takes mmap_sem and then takes again driver&#39;s</span>
<span class="cm">	 * lock.</span>
<span class="cm">	 *</span>
<span class="cm">	 * To avoid race with other vb2 calls, which might be called after</span>
<span class="cm">	 * releasing driver&#39;s lock, this operation is performed at the</span>
<span class="cm">	 * beggining of qbuf processing. This way the queue status is</span>
<span class="cm">	 * consistent after getting driver&#39;s lock back.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_USERPTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmap_sem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">;</span>
		<span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">wait_prepare</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="n">down_read</span><span class="p">(</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">wait_finish</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;qbuf: file io in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;qbuf: invalid buffer type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;qbuf: buffer index out of range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">vb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Should never happen */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;qbuf: buffer is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;qbuf: invalid memory type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VB2_BUF_STATE_DEQUEUED</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__buf_prepare</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VB2_BUF_STATE_PREPARED</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;qbuf: buffer already in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add to the queued buffers list, a buffer will stay on it until</span>
<span class="cm">	 * dequeued in dqbuf.</span>
<span class="cm">	 */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queued_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_list</span><span class="p">);</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VB2_BUF_STATE_QUEUED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If already streaming, give the buffer to driver for processing.</span>
<span class="cm">	 * If not, the buffer will be given to driver on next streamon.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span>
		<span class="n">__enqueue_in_driver</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>

	<span class="cm">/* Fill buffer information for the userspace */</span>
	<span class="n">__fill_v4l2_buffer</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;qbuf of buffer %d succeeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmap_sem</span><span class="p">)</span>
		<span class="n">up_read</span><span class="p">(</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_qbuf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_wait_for_done_vb() - wait for a buffer to become available</span>
<span class="cm"> * for dequeuing</span>
<span class="cm"> *</span>
<span class="cm"> * Will sleep if required for nonblocking == false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_wait_for_done_vb</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * All operations on vb_done_list are performed under done_lock</span>
<span class="cm">	 * spinlock protection. However, buffers may be removed from</span>
<span class="cm">	 * it and returned to userspace only while holding both driver&#39;s</span>
<span class="cm">	 * lock and the done_lock spinlock. Thus we can be sure that as</span>
<span class="cm">	 * long as we hold the driver&#39;s lock, the list will remain not</span>
<span class="cm">	 * empty if list_empty() check succeeds.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Streaming off, will not wait for buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Found a buffer that we were waiting for.</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nonblocking</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Nonblocking and no buffers to dequeue, &quot;</span>
								<span class="s">&quot;will not wait</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We are streaming and blocking, wait for another buffer to</span>
<span class="cm">		 * become ready or for streamoff. Driver&#39;s lock is released to</span>
<span class="cm">		 * allow streamoff or qbuf to be called while waiting.</span>
<span class="cm">		 */</span>
		<span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">wait_prepare</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * All locks have been released, it is safe to sleep now.</span>
<span class="cm">		 */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Will sleep waiting for buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_wq</span><span class="p">,</span>
				<span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to reevaluate both conditions again after reacquiring</span>
<span class="cm">		 * the locks or return an error if one occurred.</span>
<span class="cm">		 */</span>
		<span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">wait_finish</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_get_done_vb() - get a buffer ready for dequeuing</span>
<span class="cm"> *</span>
<span class="cm"> * Will sleep if required for nonblocking == false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_get_done_vb</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">**</span><span class="n">vb</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for at least one buffer to become available on the done_list.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_wait_for_done_vb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">nonblocking</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Driver&#39;s lock has been held since we last verified that done_list</span>
<span class="cm">	 * is not empty, so no need for another list_empty(done_list) check.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="o">*</span><span class="n">vb</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vb2_buffer</span><span class="p">,</span> <span class="n">done_entry</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">vb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">done_entry</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_wait_for_all_buffers() - wait until all buffers are given back to vb2</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> *</span>
<span class="cm"> * This function will wait until all buffers that have been given to the driver</span>
<span class="cm"> * by buf_queue() are given back to vb2 with vb2_buffer_done(). It doesn&#39;t call</span>
<span class="cm"> * wait_prepare, wait_finish pair. It is intended to be called with all locks</span>
<span class="cm"> * taken, for example from stop_streaming() callback.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_wait_for_all_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Streaming off, will not wait for buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_wq</span><span class="p">,</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_count</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_wait_for_all_buffers</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_dqbuf() - Dequeue a buffer to the userspace</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @b:		buffer structure passed from userspace to vidioc_dqbuf handler</span>
<span class="cm"> *		in driver</span>
<span class="cm"> * @nonblocking: if true, this call will not sleep waiting for a buffer if no</span>
<span class="cm"> *		 buffers ready for dequeuing are present. Normally the driver</span>
<span class="cm"> *		 would be passing (file-&gt;f_flags &amp; O_NONBLOCK) here</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called from vidioc_dqbuf ioctl handler of a driver.</span>
<span class="cm"> * This function:</span>
<span class="cm"> * 1) verifies the passed buffer,</span>
<span class="cm"> * 2) calls buf_finish callback in the driver (if provided), in which</span>
<span class="cm"> *    driver can perform any additional operations that may be required before</span>
<span class="cm"> *    returning the buffer to userspace, such as cache sync,</span>
<span class="cm"> * 3) the buffer struct members are filled with relevant information for</span>
<span class="cm"> *    the userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * The return values from this function are intended to be directly returned</span>
<span class="cm"> * from vidioc_dqbuf handler in driver.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_dqbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">bool</span> <span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;dqbuf: file io in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;dqbuf: invalid buffer type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_get_done_vb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vb</span><span class="p">,</span> <span class="n">nonblocking</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;dqbuf: error getting next done buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">buf_finish</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;dqbuf: buffer finish failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VB2_BUF_STATE_DONE</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;dqbuf: Returning done buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VB2_BUF_STATE_ERROR</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;dqbuf: Returning done buffer with errors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;dqbuf: Invalid buffer state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill buffer information for the userspace */</span>
	<span class="n">__fill_v4l2_buffer</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="cm">/* Remove from videobuf queue */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queued_entry</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;dqbuf of buffer %d, with state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VB2_BUF_STATE_DEQUEUED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_dqbuf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_queue_cancel() - cancel and stop (pause) streaming</span>
<span class="cm"> *</span>
<span class="cm"> * Removes all queued buffers from driver&#39;s queue and all buffers queued by</span>
<span class="cm"> * userspace from videobuf&#39;s queue. Returns to state after reqbufs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vb2_queue_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell driver to stop all transactions and release all queued</span>
<span class="cm">	 * buffers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span>
		<span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">stop_streaming</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove all buffers from videobuf&#39;s list...</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_list</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * ...and done list; userspace will not receive any buffers it</span>
<span class="cm">	 * has not already dequeued before initiating cancel.</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_wq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reinitialize all buffers for next use.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VB2_BUF_STATE_DEQUEUED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_streamon - start streaming</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @type:	type argument passed from userspace to vidioc_streamon handler</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called from vidioc_streamon handler of a driver.</span>
<span class="cm"> * This function:</span>
<span class="cm"> * 1) verifies current state</span>
<span class="cm"> * 2) passes any previously queued buffers to the driver and starts streaming</span>
<span class="cm"> *</span>
<span class="cm"> * The return values from this function are intended to be directly returned</span>
<span class="cm"> * from vidioc_streamon handler in the driver.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_streamon</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;streamon: file io in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;streamon: invalid stream type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;streamon: already streaming</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If any buffers were queued before streamon,</span>
<span class="cm">	 * we can now pass them to driver for processing.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_list</span><span class="p">,</span> <span class="n">queued_entry</span><span class="p">)</span>
		<span class="n">__enqueue_in_driver</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let driver notice that streaming state has been enabled.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">start_streaming</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_count</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;streamon: driver refused to start streaming</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">__vb2_queue_cancel</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Streamon successful</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_streamon</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * vb2_streamoff - stop streaming</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @type:	type argument passed from userspace to vidioc_streamoff handler</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called from vidioc_streamoff handler of a driver.</span>
<span class="cm"> * This function:</span>
<span class="cm"> * 1) verifies current state,</span>
<span class="cm"> * 2) stop streaming and dequeues any queued buffers, including those previously</span>
<span class="cm"> *    passed to the driver (after waiting for the driver to finish).</span>
<span class="cm"> *</span>
<span class="cm"> * This call can be used for pausing playback.</span>
<span class="cm"> * The return values from this function are intended to be directly returned</span>
<span class="cm"> * from vidioc_streamoff handler in the driver</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_streamoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;streamoff: file io in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;streamoff: invalid stream type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;streamoff: not streaming</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cancel will pause streaming and remove all buffers from the driver</span>
<span class="cm">	 * and videobuf, effectively returning control over them to userspace.</span>
<span class="cm">	 */</span>
	<span class="n">__vb2_queue_cancel</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Streamoff successful</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_streamoff</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __find_plane_by_offset() - find plane associated with the given offset off</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__find_plane_by_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">_buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">_plane</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">plane</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Go over all buffers and their planes, comparing the given offset</span>
<span class="cm">	 * with an offset assigned to each plane. If a match is found,</span>
<span class="cm">	 * return its buffer and plane numbers.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">mem_offset</span> <span class="o">==</span> <span class="n">off</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
				<span class="o">*</span><span class="n">_plane</span> <span class="o">=</span> <span class="n">plane</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_mmap() - map video buffers into application address space</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @vma:	vma passed to the mmap file operation handler in the driver</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called from mmap file operation handler of a driver.</span>
<span class="cm"> * This function maps one plane of one of the available video buffers to</span>
<span class="cm"> * userspace. To map whole video memory allocated on reqbufs, this function</span>
<span class="cm"> * has to be called once per each plane per each buffer previously allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * When the userspace application calls mmap, it passes to it an offset returned</span>
<span class="cm"> * to it earlier by the means of vidioc_querybuf handler. That offset acts as</span>
<span class="cm"> * a &quot;cookie&quot;, which is then used to identify the plane to be mapped.</span>
<span class="cm"> * This function finds a plane with a matching offset and a mapping is performed</span>
<span class="cm"> * by the means of a provided memory operation.</span>
<span class="cm"> *</span>
<span class="cm"> * The return values from this function are intended to be directly returned</span>
<span class="cm"> * from the mmap handler in driver.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">plane</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Queue is not currently set up for mmap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check memory area access mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Invalid vma flags, VM_SHARED needed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_TYPE_IS_OUTPUT</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Invalid vma flags, VM_WRITE needed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_READ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Invalid vma flags, VM_READ needed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the plane corresponding to the offset passed by userspace.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__find_plane_by_offset</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">plane</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">];</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_memop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">mmap</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Buffer %d, plane %d successfully mapped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">plane</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_mmap</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_MMU</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vb2_get_unmapped_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span> <span class="o">=</span> <span class="n">pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">plane</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Queue is not currently set up for mmap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the plane corresponding to the offset passed by userspace.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__find_plane_by_offset</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">plane</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">];</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vb2_plane_vaddr</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">plane</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_get_unmapped_area</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__vb2_init_fileio</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__vb2_cleanup_fileio</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_poll() - implements poll userspace operation</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @file:	file argument passed to the poll file operation handler</span>
<span class="cm"> * @wait:	wait argument passed to the poll file operation handler</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements poll file operation handler for a driver.</span>
<span class="cm"> * For CAPTURE queues, if a buffer is ready to be dequeued, the userspace will</span>
<span class="cm"> * be informed that the file descriptor of a video device is available for</span>
<span class="cm"> * reading.</span>
<span class="cm"> * For OUTPUT queues, if a buffer is ready to be dequeued, the file descriptor</span>
<span class="cm"> * will be reported as available for writing.</span>
<span class="cm"> *</span>
<span class="cm"> * If the driver uses struct v4l2_fh, then vb2_poll() will also check for any</span>
<span class="cm"> * pending events.</span>
<span class="cm"> *</span>
<span class="cm"> * The return values from this function are intended to be directly returned</span>
<span class="cm"> * from poll handler in driver.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">vb2_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">vfd</span> <span class="o">=</span> <span class="n">video_devdata</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">req_events</span> <span class="o">=</span> <span class="n">poll_requested_events</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">V4L2_FL_USES_V4L2_FH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vfd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">v4l2_event_pending</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">POLLPRI</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">req_events</span> <span class="o">&amp;</span> <span class="n">POLLPRI</span><span class="p">)</span>
			<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start file I/O emulator only if streaming API has not been used yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">V4L2_TYPE_IS_OUTPUT</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">io_modes</span> <span class="o">&amp;</span> <span class="n">VB2_READ</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">req_events</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__vb2_init_fileio</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">res</span> <span class="o">|</span> <span class="n">POLLERR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_TYPE_IS_OUTPUT</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">io_modes</span> <span class="o">&amp;</span> <span class="n">VB2_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">req_events</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__vb2_init_fileio</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">res</span> <span class="o">|</span> <span class="n">POLLERR</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Write to OUTPUT queue can be done immediately.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="n">res</span> <span class="o">|</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is nothing to wait for if no buffers have already been queued.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">res</span> <span class="o">|</span> <span class="n">POLLERR</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_wq</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take first buffer available for dequeuing.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">))</span>
		<span class="n">vb</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vb2_buffer</span><span class="p">,</span>
					<span class="n">done_entry</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">VB2_BUF_STATE_DONE</span>
			<span class="o">||</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">VB2_BUF_STATE_ERROR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">V4L2_TYPE_IS_OUTPUT</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span> <span class="o">?</span>
				<span class="n">res</span> <span class="o">|</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">:</span>
				<span class="n">res</span> <span class="o">|</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_poll</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_queue_init() - initialize a videobuf2 queue</span>
<span class="cm"> * @q:		videobuf2 queue; this structure should be allocated in driver</span>
<span class="cm"> *</span>
<span class="cm"> * The vb2_queue structure should be allocated by the driver. The driver is</span>
<span class="cm"> * responsible of clearing it&#39;s content and setting initial values for some</span>
<span class="cm"> * required entries before calling this function.</span>
<span class="cm"> * q-&gt;ops, q-&gt;mem_ops, q-&gt;type and q-&gt;io_modes are mandatory. Please refer</span>
<span class="cm"> * to the struct vb2_queue description in include/media/videobuf2-core.h</span>
<span class="cm"> * for more information.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vb2_queue_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">io_modes</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">queue_setup</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">buf_queue</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">buf_struct_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">buf_struct_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_queue_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_queue_release() - stop streaming, release the queue and free memory</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> *</span>
<span class="cm"> * This function stops streaming and performs necessary clean ups, including</span>
<span class="cm"> * freeing video buffer memory. The driver is responsible for freeing</span>
<span class="cm"> * the vb2_queue structure itself.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">vb2_queue_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__vb2_cleanup_fileio</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">__vb2_queue_cancel</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">__vb2_queue_free</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_queue_release</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct vb2_fileio_buf - buffer context used by file io emulator</span>
<span class="cm"> *</span>
<span class="cm"> * vb2 provides a compatibility layer and emulator of file io (read and</span>
<span class="cm"> * write) calls on top of streaming API. This structure is used for</span>
<span class="cm"> * tracking context related to the buffers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vb2_fileio_buf</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queued</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vb2_fileio_data - queue context used by file io emulator</span>
<span class="cm"> *</span>
<span class="cm"> * vb2 provides a compatibility layer and emulator of file io (read and</span>
<span class="cm"> * write) calls on top of streaming API. For proper operation it required</span>
<span class="cm"> * this structure to save the driver state between each call of the read</span>
<span class="cm"> * or write function.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vb2_fileio_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_requestbuffers</span> <span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_fileio_buf</span> <span class="n">bufs</span><span class="p">[</span><span class="n">VIDEO_MAX_FRAME</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">q_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dq_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_init_fileio() - initialize file io emulator</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @read:	mode selector (1 means read, 0 means write)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_init_fileio</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_fileio_data</span> <span class="o">*</span><span class="n">fileio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity check</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">read</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">io_modes</span> <span class="o">&amp;</span> <span class="n">VB2_READ</span><span class="p">))</span> <span class="o">||</span>
	   <span class="p">(</span><span class="o">!</span><span class="n">read</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">io_modes</span> <span class="o">&amp;</span> <span class="n">VB2_WRITE</span><span class="p">)))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if device supports mapping buffers to kernel virtual space.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if streaming api has not been already activated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span> <span class="o">||</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start with count 1, driver can increase it in queue_setup()</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;setting up file io: mode %s, count %d, flags %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">read</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;read&quot;</span> <span class="o">:</span> <span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">io_flags</span><span class="p">);</span>

	<span class="n">fileio</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_fileio_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fileio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">io_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Request buffers and use MMAP type to force driver</span>
<span class="cm">	 * to allocate buffers by itself.</span>
<span class="cm">	 */</span>
	<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">;</span>
	<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_reqbufs</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_kfree</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if plane_count is correct</span>
<span class="cm">	 * (multiplane buffers are not supported).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_planes</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_reqbufs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get kernel address of each buffer.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">vb2_plane_vaddr</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_reqbufs</span><span class="p">;</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">vb2_plane_size</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read mode requires pre queuing of all buffers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Queue all buffers.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">));</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">;</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_qbuf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_reqbufs</span><span class="p">;</span>
			<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Start streaming.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_streamon</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_reqbufs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span> <span class="o">=</span> <span class="n">fileio</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">err_reqbufs:</span>
	<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vb2_reqbufs</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>

<span class="nl">err_kfree:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fileio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_cleanup_fileio() - free resourced used by file io emulator</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_cleanup_fileio</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_fileio_data</span> <span class="o">*</span><span class="n">fileio</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fileio</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Hack fileio context to enable direct calls to vb2 ioctl</span>
<span class="cm">		 * interface.</span>
<span class="cm">		 */</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">vb2_streamoff</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vb2_reqbufs</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">fileio</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;file io emulator closed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __vb2_perform_fileio() - perform a single file io (read or write) operation</span>
<span class="cm"> * @q:		videobuf2 queue</span>
<span class="cm"> * @data:	pointed to target userspace buffer</span>
<span class="cm"> * @count:	number of bytes to read or write</span>
<span class="cm"> * @ppos:	file handle position tracking pointer</span>
<span class="cm"> * @nonblock:	mode selector (1 means blocking calls, 0 means nonblocking)</span>
<span class="cm"> * @read:	access mode selector (1 means read, 0 means write)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">__vb2_perform_fileio</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_fileio_data</span> <span class="o">*</span><span class="n">fileio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_fileio_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;file io: mode %s, offset %ld, count %zd, %sblocking</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">read</span> <span class="o">?</span> <span class="s">&quot;read&quot;</span> <span class="o">:</span> <span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
		<span class="n">nonblock</span> <span class="o">?</span> <span class="s">&quot;non&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize emulator on first call.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_init_fileio</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">read</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;file io: vb2_init_fileio result: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fileio</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hack fileio context to enable direct calls to vb2 ioctl interface.</span>
<span class="cm">	 * The pointer will be restored before returning from this function.</span>
<span class="cm">	 */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we need to dequeue the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Call vb2_dqbuf to get buffer back.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">));</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">;</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_dqbuf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span> <span class="n">nonblock</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;file io: vb2_dqbuf result: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">dq_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get number of bytes filled by the driver</span>
<span class="cm">		 */</span>
		<span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">vb2_get_plane_payload</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Limit count on last few bytes of the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;reducing read count: %zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transfer data to userspace.</span>
<span class="cm">	 */</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;file io: copying %zd bytes - buffer %d, offset %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">count</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;file io: error copying data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update counters.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Queue next buffer if required.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">==</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">||</span>
	   <span class="p">(</span><span class="o">!</span><span class="n">read</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VB2_FILEIO_WRITE_IMMEDIATELY</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check if this is the last buffer to read.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VB2_FILEIO_READ_ONCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">dq_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;file io: read limit reached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Restore fileio pointer and release the context.</span>
<span class="cm">			 */</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span> <span class="o">=</span> <span class="n">fileio</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">__vb2_cleanup_fileio</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Call vb2_qbuf and give buffer to the driver.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">));</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">;</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">bytesused</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_qbuf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;file io: vb2_dbuf result: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Buffer has been queued, update the status</span>
<span class="cm">		 */</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">q_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Switch to the next buffer</span>
<span class="cm">		 */</span>
		<span class="n">fileio</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Start streaming if required.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_streamon</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return proper number of bytes processed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="nl">end:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Restore the fileio context and block vb2 ioctl interface.</span>
<span class="cm">	 */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span> <span class="o">=</span> <span class="n">fileio</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">vb2_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__vb2_perform_fileio</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">nonblocking</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_read</span><span class="p">);</span>

<span class="kt">size_t</span> <span class="nf">vb2_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__vb2_perform_fileio</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">nonblocking</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vb2_write</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver helper framework for Video for Linux 2&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Pawel Osciak &lt;pawel@osciak.com&gt;, Marek Szyprowski&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
