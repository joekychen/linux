<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › omap24xxcam.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>omap24xxcam.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/media/video/omap24xxcam.c</span>
<span class="cm"> *</span>
<span class="cm"> * OMAP 2 camera block driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 MontaVista Software, Inc.</span>
<span class="cm"> * Copyright (C) 2004 Texas Instruments.</span>
<span class="cm"> * Copyright (C) 2007-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact: Sakari Ailus &lt;sakari.ailus@nokia.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on code from Andy Lowe &lt;source@mvista.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;		</span><span class="cm">/* needed for videobufs */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;media/v4l2-common.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-ioctl.h&gt;</span>

<span class="cp">#include &quot;omap24xxcam.h&quot;</span>

<span class="cp">#define OMAP24XXCAM_VERSION &quot;0.0.1&quot;</span>

<span class="cp">#define RESET_TIMEOUT_NS 10000</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">omap24xxcam_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">omap24xxcam_sensor_if_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">omap24xxcam_device_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_int_device</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">omap24xxcam_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="cm">/* module parameters */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">video_nr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* video device minor (-1 ==&gt; auto assign) */</span>
<span class="cm">/*</span>
<span class="cm"> * Maximum amount of memory to use for capture buffers.</span>
<span class="cm"> * Default is 4800KB, enough to double-buffer SXGA.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">capture_mem</span> <span class="o">=</span> <span class="mi">1280</span> <span class="o">*</span> <span class="mi">960</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">v4l2_int_device</span> <span class="n">omap24xxcam</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Clocks.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_clock_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">ick</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">ick</span><span class="p">))</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">ick</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">fck</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">fck</span><span class="p">))</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">fck</span><span class="p">);</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">ick</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">fck</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_clock_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">fck</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fck&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">fck</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t get camera fck&quot;</span><span class="p">);</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">fck</span><span class="p">);</span>
		<span class="n">omap24xxcam_clock_put</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">ick</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ick&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">ick</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t get camera ick&quot;</span><span class="p">);</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">ick</span><span class="p">);</span>
		<span class="n">omap24xxcam_clock_put</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_clock_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">fck</span><span class="p">);</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">ick</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_clock_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">fck</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">ick</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Camera core</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Set xclk.</span>
<span class="cm"> *</span>
<span class="cm"> * To disable xclk, use value zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_core_xclk_set</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">xclk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xclk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">CAM_MCLK</span> <span class="o">/</span> <span class="n">xclk</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">divisor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CC_REG_OFFSET</span><span class="p">,</span>
					    <span class="n">CC_CTRL_XCLK</span><span class="p">,</span>
					    <span class="n">CC_CTRL_XCLK_DIV_BYPASS</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CC_REG_OFFSET</span><span class="p">,</span>
					    <span class="n">CC_CTRL_XCLK</span><span class="p">,</span> <span class="n">divisor</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CC_REG_OFFSET</span><span class="p">,</span>
				    <span class="n">CC_CTRL_XCLK</span><span class="p">,</span> <span class="n">CC_CTRL_XCLK_DIV_STABLE_LOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_core_hwinit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Setting the camera core AUTOIDLE bit causes problems with frame</span>
<span class="cm">	 * synchronization, so we will clear the AUTOIDLE bit instead.</span>
<span class="cm">	 */</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CC_REG_OFFSET</span><span class="p">,</span> <span class="n">CC_SYSCONFIG</span><span class="p">,</span>
			    <span class="n">CC_SYSCONFIG_AUTOIDLE</span><span class="p">);</span>

	<span class="cm">/* program the camera interface DMA packet size */</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CC_REG_OFFSET</span><span class="p">,</span> <span class="n">CC_CTRL_DMA</span><span class="p">,</span>
			    <span class="n">CC_CTRL_DMA_EN</span> <span class="o">|</span> <span class="p">(</span><span class="n">DMA_THRESHOLD</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* enable camera core error interrupts */</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CC_REG_OFFSET</span><span class="p">,</span> <span class="n">CC_IRQENABLE</span><span class="p">,</span>
			    <span class="n">CC_IRQENABLE_FW_ERR_IRQ</span>
			    <span class="o">|</span> <span class="n">CC_IRQENABLE_FSC_ERR_IRQ</span>
			    <span class="o">|</span> <span class="n">CC_IRQENABLE_SSC_ERR_IRQ</span>
			    <span class="o">|</span> <span class="n">CC_IRQENABLE_FIFO_OF_IRQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable the camera core.</span>
<span class="cm"> *</span>
<span class="cm"> * Data transfer to the camera DMA starts from next starting frame.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_core_enable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CC_REG_OFFSET</span><span class="p">,</span> <span class="n">CC_CTRL</span><span class="p">,</span>
			    <span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable camera core.</span>
<span class="cm"> *</span>
<span class="cm"> * The data transfer will be stopped immediately (CC_CTRL_CC_RST). The</span>
<span class="cm"> * core internal state machines will be reset. Use</span>
<span class="cm"> * CC_CTRL_CC_FRAME_TRIG instead if you want to transfer the current</span>
<span class="cm"> * frame completely.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_core_disable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CC_REG_OFFSET</span><span class="p">,</span> <span class="n">CC_CTRL</span><span class="p">,</span>
			    <span class="n">CC_CTRL_CC_RST</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Interrupt service routine for camera core interrupts. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_core_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cc_irqstatus</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">cc_irqstatus_err</span> <span class="o">=</span>
		<span class="n">CC_IRQSTATUS_FW_ERR_IRQ</span>
		<span class="o">|</span> <span class="n">CC_IRQSTATUS_FSC_ERR_IRQ</span>
		<span class="o">|</span> <span class="n">CC_IRQSTATUS_SSC_ERR_IRQ</span>
		<span class="o">|</span> <span class="n">CC_IRQSTATUS_FIFO_UF_IRQ</span>
		<span class="o">|</span> <span class="n">CC_IRQSTATUS_FIFO_OF_IRQ</span><span class="p">;</span>

	<span class="n">cc_irqstatus</span> <span class="o">=</span> <span class="n">omap24xxcam_reg_in</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CC_REG_OFFSET</span><span class="p">,</span>
					  <span class="n">CC_IRQSTATUS</span><span class="p">);</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CC_REG_OFFSET</span><span class="p">,</span> <span class="n">CC_IRQSTATUS</span><span class="p">,</span>
			    <span class="n">cc_irqstatus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc_irqstatus</span> <span class="o">&amp;</span> <span class="n">cc_irqstatus_err</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">in_reset</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resetting camera, cc_irqstatus 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cc_irqstatus</span><span class="p">);</span>
		<span class="n">omap24xxcam_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * videobuf_buffer handling.</span>
<span class="cm"> *</span>
<span class="cm"> * Memory for mmapped videobuf_buffers is not allocated</span>
<span class="cm"> * conventionally, but by several kmalloc allocations and then</span>
<span class="cm"> * creating the scatterlist on our own. User-space buffers are handled</span>
<span class="cm"> * normally.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Free the memory-mapped buffer memory allocated for a</span>
<span class="cm"> * videobuf_buffer and the associated scatterlist.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_vbq_free_mmap_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">alloc_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
		<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">page</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">alloc_size</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">__free_pages</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
			     <span class="n">get_order</span><span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">[</span><span class="n">i</span><span class="p">])));</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">);</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Release all memory related to the videobuf_queue. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_vbq_free_mmap_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">vb_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VIDEO_MAX_FRAME</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_MEMORY_MMAP</span> <span class="o">!=</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">vbq</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">buf_release</span><span class="p">(</span><span class="n">vbq</span><span class="p">,</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">omap24xxcam_vbq_free_mmap_buffer</span><span class="p">(</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">vb_lock</span><span class="p">);</span>

	<span class="n">videobuf_mmap_free</span><span class="p">(</span><span class="n">vbq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate physically as contiguous as possible buffer for video</span>
<span class="cm"> * frame and allocate and build DMA scatter-gather list for it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_vbq_alloc_mmap_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">alloc_size</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">;</span> <span class="cm">/* vb-&gt;bsize is page aligned */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_pages</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate maximum size scatter-gather list. Note this is</span>
<span class="cm">	 * overhead. We may not use as many entries as we allocate</span>
<span class="cm">	 */</span>
	<span class="n">max_pages</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">bsize</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">max_pages</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * do not over-allocate even if we would get larger</span>
<span class="cm">		 * contiguous chunk that way</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">order</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* try to allocate as many contiguous pages as possible */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="cm">/* if allocation fails, try to allocate smaller amount */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">order</span><span class="o">--</span><span class="p">;</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">order</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">);</span>

		<span class="cm">/* append allocated chunk of pages into scatter-gather list */</span>
		<span class="n">sg_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">page</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="o">++</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>

		<span class="n">alloc_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">);</span>

		<span class="cm">/* clear pages before giving them to user space */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>

		<span class="cm">/* mark allocated pages reserved */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">SetPageReserved</span><span class="p">(</span><span class="n">page</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">alloc_size</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * REVISIT: not fully correct to assign nr_pages == sglen but</span>
<span class="cm">	 * video-buf is passing nr_pages for e.g. unmap_sg calls</span>
<span class="cm">	 */</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">omap24xxcam_vbq_free_mmap_buffer</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_vbq_alloc_mmap_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vbq</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">vbq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap24xxcam_fh</span><span class="p">,</span> <span class="n">vbq</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">vb_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">omap24xxcam_vbq_alloc_mmap_buffer</span><span class="p">(</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sglen is %d for buffer %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">vb_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
		<span class="n">omap24xxcam_vbq_free_mmap_buffer</span><span class="p">(</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">vb_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called from interrupt context when a scatter-gather DMA</span>
<span class="cm"> * transfer of a videobuf_buffer completes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_vbq_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_sgdma</span> <span class="o">*</span><span class="n">sgdma</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">csr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">sgdma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap24xxcam_device</span><span class="p">,</span> <span class="n">sgdma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">csr_error</span> <span class="o">=</span> <span class="n">CAMDMA_CSR_MISALIGNED_ERR</span>
		<span class="o">|</span> <span class="n">CAMDMA_CSR_SUPERVISOR_ERR</span> <span class="o">|</span> <span class="n">CAMDMA_CSR_SECURE_ERR</span>
		<span class="o">|</span> <span class="n">CAMDMA_CSR_TRANS_ERR</span> <span class="o">|</span> <span class="n">CAMDMA_CSR_DROP</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">core_enable_disable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sgdma_in_queue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">omap24xxcam_core_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">core_enable_disable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">);</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">field_count</span> <span class="o">=</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="n">csr_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">in_reset</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resetting camera, csr 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>
			<span class="n">omap24xxcam_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_DONE</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_vbq_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vbq</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>

	<span class="cm">/* wait for buffer, especially to get out of the sgdma queue */</span>
	<span class="n">videobuf_waiton</span><span class="p">(</span><span class="n">vbq</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span>
			     <span class="n">dma</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">);</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_NONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">videobuf_dma_unmap</span><span class="p">(</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">));</span>
		<span class="n">videobuf_dma_free</span><span class="p">(</span><span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Limit the number of available kernel image capture buffers based on the</span>
<span class="cm"> * number requested, the currently selected image size, and the maximum</span>
<span class="cm"> * amount of memory permitted for kernel capture buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_vbq_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vbq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cnt</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cnt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">VIDEO_MAX_FRAME</span><span class="p">;</span>	<span class="cm">/* supply a default number of buffers */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">VIDEO_MAX_FRAME</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">VIDEO_MAX_FRAME</span><span class="p">;</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">pix</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>

	<span class="cm">/* accessing fh-&gt;cam-&gt;capture_mem is ok, it&#39;s constant */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span> <span class="o">*</span> <span class="o">*</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">capture_mem</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">capture_mem</span> <span class="o">/</span> <span class="o">*</span><span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_dma_iolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vbq</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_map_sg</span><span class="p">(</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">);</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_vbq_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vbq</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">v4l2_field</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Accessing pix here is okay since it&#39;s constant while</span>
<span class="cm">	 * streaming is on (and we only get called then).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">baddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is a userspace buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">pix</span><span class="p">.</span><span class="n">sizeimage</span> <span class="o">&gt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The buffer isn&#39;t big enough. */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">pix</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We have a kernel bounce buffer that has</span>
<span class="cm">			 * already been allocated.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">pix</span><span class="p">.</span><span class="n">sizeimage</span> <span class="o">&gt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The image size has been changed to</span>
<span class="cm">				 * a larger size since this buffer was</span>
<span class="cm">				 * allocated, so we need to free and</span>
<span class="cm">				 * reallocate it.</span>
<span class="cm">				 */</span>
				<span class="n">omap24xxcam_vbq_release</span><span class="p">(</span><span class="n">vbq</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
				<span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">pix</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* We need to allocate a new kernel bounce buffer. */</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">pix</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">pix</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">pix</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">==</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * we have built the scatter-gather list by ourself so</span>
<span class="cm">			 * do the scatter-gather mapping as well</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">omap24xxcam_dma_iolock</span><span class="p">(</span><span class="n">vbq</span><span class="p">,</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">videobuf_iolock</span><span class="p">(</span><span class="n">vbq</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_PREPARED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">omap24xxcam_vbq_release</span><span class="p">(</span><span class="n">vbq</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_vbq_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vbq</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">videobuf_state</span> <span class="n">state</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: We&#39;re marking the buffer active since we have no</span>
<span class="cm">	 * pretty way of marking it active exactly when the</span>
<span class="cm">	 * scatter-gather transfer starts.</span>
<span class="cm">	 */</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_ACTIVE</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">omap24xxcam_sgdma_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sgdma</span><span class="p">,</span>
				      <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">,</span>
				      <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
				      <span class="n">omap24xxcam_vbq_complete</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">core_enable_disable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sgdma_in_queue</span> <span class="o">==</span> <span class="mi">1</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">in_reset</span><span class="p">))</span>
			<span class="n">omap24xxcam_core_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">core_enable_disable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Oops. We&#39;re not supposed to get any errors here.</span>
<span class="cm">		 * The only way we could get an error is if we ran out</span>
<span class="cm">		 * of scatter-gather DMA slots, but we are supposed to</span>
<span class="cm">		 * have at least as many scatter-gather DMA slots as</span>
<span class="cm">		 * video buffers so that can&#39;t happen.</span>
<span class="cm">		 */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to queue a video buffer for dma!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;likely a bug in the driver!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">videobuf_queue_ops</span> <span class="n">omap24xxcam_vbq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">buf_setup</span>   <span class="o">=</span> <span class="n">omap24xxcam_vbq_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_prepare</span> <span class="o">=</span> <span class="n">omap24xxcam_vbq_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_queue</span>   <span class="o">=</span> <span class="n">omap24xxcam_vbq_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_release</span> <span class="o">=</span> <span class="n">omap24xxcam_vbq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * OMAP main camera system</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Reset camera block to power-on state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_poweron_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_loop</span> <span class="o">=</span> <span class="n">RESET_TIMEOUT_NS</span><span class="p">;</span>

	<span class="cm">/* Reset whole camera subsystem */</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">,</span>
			    <span class="n">CAM_SYSCONFIG</span><span class="p">,</span>
			    <span class="n">CAM_SYSCONFIG_SOFTRESET</span><span class="p">);</span>

	<span class="cm">/* Wait till it&#39;s finished */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">omap24xxcam_reg_in</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">,</span> <span class="n">CAM_SYSSTATUS</span><span class="p">)</span>
		 <span class="o">&amp;</span> <span class="n">CAM_SYSSTATUS_RESETDONE</span><span class="p">)</span>
	       <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">max_loop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ndelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">omap24xxcam_reg_in</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">,</span> <span class="n">CAM_SYSSTATUS</span><span class="p">)</span>
	      <span class="o">&amp;</span> <span class="n">CAM_SYSSTATUS_RESETDONE</span><span class="p">))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;camera soft reset timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * (Re)initialise the camera block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_hwinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">omap24xxcam_poweron_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="cm">/* set the camera subsystem autoidle bit */</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">,</span> <span class="n">CAM_SYSCONFIG</span><span class="p">,</span>
			    <span class="n">CAM_SYSCONFIG_AUTOIDLE</span><span class="p">);</span>

	<span class="cm">/* set the camera MMU autoidle bit */</span>
	<span class="n">omap24xxcam_reg_out</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">,</span>
			    <span class="n">CAMMMU_REG_OFFSET</span> <span class="o">+</span> <span class="n">CAMMMU_SYSCONFIG</span><span class="p">,</span>
			    <span class="n">CAMMMU_SYSCONFIG_AUTOIDLE</span><span class="p">);</span>

	<span class="n">omap24xxcam_core_hwinit</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">omap24xxcam_dma_hwinit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sgdma</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback for dma transfer stalling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_stalled_dma_reset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">in_reset</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;dma stalled, resetting camera</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">omap24xxcam_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop capture. Mark we&#39;re doing a reset, stop DMA transfers and</span>
<span class="cm"> * core. (No new scatter-gather transfers will be queued whilst</span>
<span class="cm"> * in_reset is non-zero.)</span>
<span class="cm"> *</span>
<span class="cm"> * If omap24xxcam_capture_stop is called from several places at</span>
<span class="cm"> * once, only the first call will have an effect. Similarly, the last</span>
<span class="cm"> * call omap24xxcam_streaming_cont will have effect.</span>
<span class="cm"> *</span>
<span class="cm"> * Serialisation is ensured by using cam-&gt;core_enable_disable_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_capture_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">core_enable_disable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">in_reset</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">core_enable_disable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">omap24xxcam_core_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">core_enable_disable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">omap24xxcam_sgdma_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sgdma</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset and continue streaming.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Resetting the camera FIFO via the CC_RST bit in the CC_CTRL</span>
<span class="cm"> * register is supposed to be sufficient to recover from a camera</span>
<span class="cm"> * interface error, but it doesn&#39;t seem to be enough. If we only do</span>
<span class="cm"> * that then subsequent image captures are out of sync by either one</span>
<span class="cm"> * or two times DMA_THRESHOLD bytes. Resetting and re-initializing the</span>
<span class="cm"> * entire camera subsystem prevents the problem with frame</span>
<span class="cm"> * synchronization.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_capture_cont</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">core_enable_disable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">in_reset</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">omap24xxcam_hwinit</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">omap24xxcam_sensor_if_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">omap24xxcam_sgdma_process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sgdma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sgdma_in_queue</span><span class="p">)</span>
		<span class="n">omap24xxcam_core_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">in_reset</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">core_enable_disable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">omap24xxcam_streaming_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span> <span class="o">?</span>  <span class="s">&quot;active&quot;</span> <span class="o">:</span> <span class="s">&quot;inactive&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">streaming</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">omap24xxcam_streaming_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Stop capture and restart it. I.e. reset the camera during use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">omap24xxcam_capture_stop</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">omap24xxcam_capture_cont</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The main interrupt handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">omap24xxcam_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irqstatus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irqhandled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">irqstatus</span> <span class="o">=</span> <span class="n">omap24xxcam_reg_in</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">,</span> <span class="n">CAM_IRQSTATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irqstatus</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="n">CAM_IRQSTATUS_DMA_IRQ2</span> <span class="o">|</span> <span class="n">CAM_IRQSTATUS_DMA_IRQ1</span>
	     <span class="o">|</span> <span class="n">CAM_IRQSTATUS_DMA_IRQ0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">omap24xxcam_dma_isr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sgdma</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">irqhandled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqstatus</span> <span class="o">&amp;</span> <span class="n">CAM_IRQSTATUS_CC_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap24xxcam_core_isr</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">irqhandled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqstatus</span> <span class="o">&amp;</span> <span class="n">CAM_IRQSTATUS_MMU_IRQ</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unhandled camera MMU interrupt!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">irqhandled</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Sensor handling.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Enable the external sensor interface. Try to negotiate interface</span>
<span class="cm"> * parameters with the sensor and start using the new ones. The calls</span>
<span class="cm"> * to sensor_if_enable and sensor_if_disable need not to be balanced.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_sensor_if_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ifparm</span> <span class="n">p</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_g_ifparm</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vidioc_int_g_ifparm failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">if_type</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">if_type</span><span class="p">;</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">=</span> <span class="n">CC_CTRL_CC_EN</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">if_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">V4L2_IF_TYPE_BT656</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">frame_start_on_rising_vs</span><span class="p">)</span>
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_NOBT_SYNCHRO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">bt_sync_correct</span><span class="p">)</span>
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_BT_CORRECT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">swap</span><span class="p">)</span>
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_PAR_ORDERCAM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">latch_clk_inv</span><span class="p">)</span>
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_PAR_CLK_POL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">nobt_hs_inv</span><span class="p">)</span>
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_NOBT_HS_POL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">nobt_vs_inv</span><span class="p">)</span>
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_NOBT_VS_POL</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">V4L2_IF_TYPE_BT656_MODE_NOBT_8BIT</span>:
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_PAR_MODE_NOBT8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">V4L2_IF_TYPE_BT656_MODE_NOBT_10BIT</span>:
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_PAR_MODE_NOBT10</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">V4L2_IF_TYPE_BT656_MODE_NOBT_12BIT</span>:
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_PAR_MODE_NOBT12</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">V4L2_IF_TYPE_BT656_MODE_BT_8BIT</span>:
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_PAR_MODE_BT8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">V4L2_IF_TYPE_BT656_MODE_BT_10BIT</span>:
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cc_ctrl</span> <span class="o">|=</span> <span class="n">CC_CTRL_PAR_MODE_BT10</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;bt656 interface mode %d not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">mode</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The clock rate that the sensor wants has changed.</span>
<span class="cm">		 * We have to adjust the xclk from OMAP 2 side to</span>
<span class="cm">		 * match the sensor&#39;s wish as closely as possible.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">clock_curr</span> <span class="o">!=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">if_u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">xclk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">xclk</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">clock_curr</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">divisor</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">xclk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">xclk</span> <span class="o">&gt;</span> <span class="n">CAM_MCLK</span><span class="p">)</span>
				<span class="n">xclk</span> <span class="o">=</span> <span class="n">CAM_MCLK</span><span class="p">;</span>

			<span class="n">divisor</span> <span class="o">=</span> <span class="n">CAM_MCLK</span> <span class="o">/</span> <span class="n">xclk</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">divisor</span> <span class="o">*</span> <span class="n">xclk</span> <span class="o">&lt;</span> <span class="n">CAM_MCLK</span><span class="p">)</span>
				<span class="n">divisor</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">CAM_MCLK</span> <span class="o">/</span> <span class="n">divisor</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">clock_min</span>
			    <span class="o">&amp;&amp;</span> <span class="n">divisor</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">divisor</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">divisor</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">)</span>
				<span class="n">divisor</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

			<span class="n">xclk</span> <span class="o">=</span> <span class="n">CAM_MCLK</span> <span class="o">/</span> <span class="n">divisor</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">xclk</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">clock_min</span>
			    <span class="o">||</span> <span class="n">xclk</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">clock_max</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">if_u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">xclk</span> <span class="o">=</span> <span class="n">xclk</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">omap24xxcam_core_xclk_set</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">if_u</span><span class="p">.</span><span class="n">bt656</span><span class="p">.</span><span class="n">xclk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* FIXME: how about other interfaces? */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;interface type %d not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">p</span><span class="p">.</span><span class="n">if_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_sensor_if_disable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">if_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">V4L2_IF_TYPE_BT656</span>:
		<span class="n">omap24xxcam_core_xclk_set</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise the sensor hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_sensor_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_int_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>

	<span class="n">omap24xxcam_clock_on</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">omap24xxcam_sensor_if_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sensor interface could not be enabled at &quot;</span>
			<span class="s">&quot;initialisation, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* power up sensor during sensor initialization */</span>
	<span class="n">vidioc_int_s_power</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">vidioc_int_dev_init</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot initialize sensor, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="cm">/* Sensor init failed --- it&#39;s nonexistent to us! */</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sensor is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">omap24xxcam_sensor_if_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">omap24xxcam_clock_off</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">vidioc_int_s_power</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_sensor_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">)</span>
		<span class="n">vidioc_int_dev_exit</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_sensor_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">omap24xxcam_sensor_if_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">omap24xxcam_clock_off</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">vidioc_int_s_power</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Power-up and configure camera sensor. It&#39;s ready for capturing now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_sensor_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">omap24xxcam_clock_on</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">omap24xxcam_sensor_if_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_s_power</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_init</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">omap24xxcam_sensor_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_sensor_reset_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap24xxcam_device</span><span class="p">,</span>
			     <span class="n">sensor_reset_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">omap24xxcam_capture_stop</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vidioc_int_reset</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vidioc_int_init</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Can&#39;t reset it by vidioc_int_reset. */</span>
		<span class="n">omap24xxcam_sensor_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">omap24xxcam_sensor_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">omap24xxcam_capture_cont</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * IOCTL interface.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_querycap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">v4l2_capability</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">CAM_NAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">vfd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">));</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">V4L2_CAP_VIDEO_CAPTURE</span> <span class="o">|</span> <span class="n">V4L2_CAP_STREAMING</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_enum_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">v4l2_fmtdesc</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_enum_fmt_cap</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_g_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_g_fmt_cap</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_s_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_s_fmt_cap</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">.</span><span class="n">vb_lock</span><span class="p">);</span>
		<span class="n">ofh</span><span class="o">-&gt;</span><span class="n">pix</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">.</span><span class="n">vb_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">));</span>
	<span class="n">vidioc_g_fmt_vid_cap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fh</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_try_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_try_fmt_cap</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_reqbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">v4l2_requestbuffers</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">omap24xxcam_vbq_free_mmap_buffers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">videobuf_reqbufs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Either videobuf_reqbufs failed or the buffers are not</span>
<span class="cm">	 * memory-mapped (which would need special attention).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">omap24xxcam_vbq_alloc_mmap_buffers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="n">omap24xxcam_vbq_free_mmap_buffers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_querybuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">videobuf_querybuf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_qbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">videobuf_qbuf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_dqbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

<span class="nl">videobuf_dqbuf_again:</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">videobuf_dqbuf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">vb</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">.</span><span class="n">bufs</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="cm">/* _needs_reset returns -EIO if reset is required. */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_g_needs_reset</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">baddr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_reset_work</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is a hack. We don&#39;t want to show -EIO to the user</span>
<span class="cm">	 * space. Requeue the buffer and try again if we&#39;re not doing</span>
<span class="cm">	 * this in non-blocking mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">videobuf_qbuf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">videobuf_dqbuf_again</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t have a videobuf_buffer now --- maybe next</span>
<span class="cm">		 * time...</span>
<span class="cm">		 */</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_streamon</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">omap24xxcam_sensor_if_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vidioc_int_g_ifparm failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">videobuf_streamon</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
		<span class="n">sysfs_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;streaming&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_streamoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ofh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_disable</span><span class="p">);</span>

	<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_reset_work</span><span class="p">);</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">videobuf_streamoff</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">sysfs_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;streaming&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_disable</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_enum_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">v4l2_input</span> <span class="o">*</span><span class="n">inp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inp</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">inp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;camera&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">inp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_INPUT_TYPE_CAMERA</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_g_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_s_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_queryctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">v4l2_queryctrl</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_queryctrl</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_g_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_g_ctrl</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_s_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_s_ctrl</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_g_parm</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">v4l2_streamparm</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_g_parm</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vidioc_s_parm</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">v4l2_streamparm</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">ofh</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">ofh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_streamparm</span> <span class="n">old_streamparm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">old_streamparm</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">;</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_g_parm</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_streamparm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">vidioc_int_s_parm</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">omap24xxcam_sensor_if_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Revert to old streaming parameters if enabling sensor</span>
<span class="cm">	 * interface with the new ones failed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="n">vidioc_int_s_parm</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_streamparm</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * File operations.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">omap24xxcam_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span> <span class="o">!=</span> <span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">POLLERR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">.</span><span class="n">vb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">.</span><span class="n">stream</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">.</span><span class="n">vb_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">POLLERR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">videobuf_buffer</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">.</span><span class="n">vb_lock</span><span class="p">);</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">VIDEOBUF_DONE</span> <span class="o">||</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_mmap_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vbq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">vb_lock</span><span class="p">);</span>

	<span class="cm">/* look for first buffer to map */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">first</span> <span class="o">&lt;</span> <span class="n">VIDEO_MAX_FRAME</span><span class="p">;</span> <span class="n">first</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">first</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_MEMORY_MMAP</span> <span class="o">!=</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">first</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">first</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">boff</span> <span class="o">==</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* look for last buffer to map */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">last</span> <span class="o">&lt;</span> <span class="n">VIDEO_MAX_FRAME</span><span class="p">;</span> <span class="n">last</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">last</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_MEMORY_MMAP</span> <span class="o">!=</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">last</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">last</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VIDEO_MAX_FRAME</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">remap_pfn_range</span><span class="p">(</span>
				<span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span>
				<span class="n">page_to_pfn</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">[</span><span class="n">j</span><span class="p">])),</span>
				<span class="n">sg_dma_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vbq</span><span class="o">-&gt;</span><span class="n">vb_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="cm">/* let the video-buf mapper check arguments and set-up structures */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">videobuf_mmap_mapper</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>

	<span class="cm">/* do mapping to our allocated buffers */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">omap24xxcam_mmap_buffers</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * In case of error, free vma-&gt;vm_private_data allocated by</span>
<span class="cm">	 * videobuf_mmap_mapper.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">omap24xxcam</span><span class="p">.</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="n">format</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cam</span> <span class="o">||</span> <span class="o">!</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vfd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fh</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_try_module_get</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap24xxcam_hwinit</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">omap24xxcam_sensor_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_omap24xxcam_sensor_enable</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">cam</span> <span class="o">=</span> <span class="n">cam</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">vidioc_int_g_fmt_cap</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">format</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="cm">/* FIXME: how about fh-&gt;pix when there are more users? */</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">pix</span> <span class="o">=</span> <span class="n">format</span><span class="p">.</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq_lock</span><span class="p">);</span>

	<span class="n">videobuf_queue_sg_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omap24xxcam_vbq_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq_lock</span><span class="p">,</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span>
				<span class="n">V4L2_FIELD_NONE</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_buffer</span><span class="p">),</span> <span class="n">fh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_omap24xxcam_sensor_enable:</span>
	<span class="n">omap24xxcam_poweron_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>

<span class="nl">out_try_module_get:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">cam</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_disable</span><span class="p">);</span>

	<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_reset_work</span><span class="p">);</span>

	<span class="cm">/* stop streaming capture */</span>
	<span class="n">videobuf_streamoff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span> <span class="o">==</span> <span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">streaming</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">sysfs_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;streaming&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_disable</span><span class="p">);</span>

	<span class="n">omap24xxcam_vbq_free_mmap_buffers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">vbq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure the reset work we might have scheduled is not</span>
<span class="cm">	 * pending! It may be run *only* if we have users. (And it may</span>
<span class="cm">	 * not be scheduled anymore since streaming is already</span>
<span class="cm">	 * disabled.)</span>
<span class="cm">	 */</span>
	<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_reset_work</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap24xxcam_sensor_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">omap24xxcam_poweron_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">module_put</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">v4l2_file_operations</span> <span class="n">omap24xxcam_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ioctl</span>	 <span class="o">=</span> <span class="n">video_ioctl2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>	 <span class="o">=</span> <span class="n">omap24xxcam_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>	 <span class="o">=</span> <span class="n">omap24xxcam_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>	 <span class="o">=</span> <span class="n">omap24xxcam_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">omap24xxcam_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Power management.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_disable</span><span class="p">))</span>
		<span class="n">omap24xxcam_capture_stop</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">omap24xxcam_sensor_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">omap24xxcam_poweron_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">omap24xxcam_hwinit</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">omap24xxcam_sensor_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_disable</span><span class="p">))</span>
		<span class="n">omap24xxcam_capture_cont</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_ioctl_ops</span> <span class="n">omap24xxcam_ioctl_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">vidioc_querycap</span>	<span class="o">=</span> <span class="n">vidioc_querycap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_enum_fmt_vid_cap</span>	<span class="o">=</span> <span class="n">vidioc_enum_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_fmt_vid_cap</span>	<span class="o">=</span> <span class="n">vidioc_g_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_fmt_vid_cap</span>	<span class="o">=</span> <span class="n">vidioc_s_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_try_fmt_vid_cap</span>	<span class="o">=</span> <span class="n">vidioc_try_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_reqbufs</span>		<span class="o">=</span> <span class="n">vidioc_reqbufs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_querybuf</span>	<span class="o">=</span> <span class="n">vidioc_querybuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_qbuf</span>		<span class="o">=</span> <span class="n">vidioc_qbuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_dqbuf</span>		<span class="o">=</span> <span class="n">vidioc_dqbuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_streamon</span>	<span class="o">=</span> <span class="n">vidioc_streamon</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_streamoff</span>	<span class="o">=</span> <span class="n">vidioc_streamoff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_enum_input</span>	<span class="o">=</span> <span class="n">vidioc_enum_input</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_input</span>		<span class="o">=</span> <span class="n">vidioc_g_input</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_input</span>		<span class="o">=</span> <span class="n">vidioc_s_input</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_queryctrl</span>	<span class="o">=</span> <span class="n">vidioc_queryctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_ctrl</span>		<span class="o">=</span> <span class="n">vidioc_g_ctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_ctrl</span>		<span class="o">=</span> <span class="n">vidioc_s_ctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_parm</span>		<span class="o">=</span> <span class="n">vidioc_g_parm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_parm</span>		<span class="o">=</span> <span class="n">vidioc_s_parm</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Camera device (i.e. /dev/video).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_device_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_int_device</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">vfd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="cm">/* We already have a slave. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device_create_file</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_streaming</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not register sysfs entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize the video_device struct */</span>
	<span class="n">vfd</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">vfd</span> <span class="o">=</span> <span class="n">video_device_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vfd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not allocate video device struct</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vfd</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="n">video_device_release</span><span class="p">;</span>

	<span class="n">vfd</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">vfd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">CAM_NAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vfd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">vfd</span><span class="o">-&gt;</span><span class="n">fops</span>		 <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap24xxcam_fops</span><span class="p">;</span>
	<span class="n">vfd</span><span class="o">-&gt;</span><span class="n">ioctl_ops</span>		 <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap24xxcam_ioctl_fops</span><span class="p">;</span>

	<span class="n">omap24xxcam_hwinit</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">omap24xxcam_sensor_init</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">video_register_device</span><span class="p">(</span><span class="n">vfd</span><span class="p">,</span> <span class="n">VFL_TYPE_GRABBER</span><span class="p">,</span> <span class="n">video_nr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not register V4L device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">omap24xxcam_poweron_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;registered device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">video_device_node_name</span><span class="p">(</span><span class="n">vfd</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">omap24xxcam_device_unregister</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap24xxcam_device_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_int_device</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">omap24xxcam_sensor_exit</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vfd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">video_is_registered</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vfd</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The device was never registered, so release the</span>
<span class="cm">			 * video_device struct directly.</span>
<span class="cm">			 */</span>
			<span class="n">video_device_release</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vfd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The unregister function will release the</span>
<span class="cm">			 * video_device struct as well as</span>
<span class="cm">			 * unregistering it.</span>
<span class="cm">			 */</span>
			<span class="n">video_unregister_device</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vfd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vfd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_streaming</span><span class="p">);</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">v4l2_int_master</span> <span class="n">omap24xxcam_master</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attach</span> <span class="o">=</span> <span class="n">omap24xxcam_device_register</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detach</span> <span class="o">=</span> <span class="n">omap24xxcam_device_unregister</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">v4l2_int_device</span> <span class="n">omap24xxcam</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="n">CAM_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">type</span>	<span class="o">=</span> <span class="n">v4l2_int_type_master</span><span class="p">,</span>
	<span class="p">.</span><span class="n">u</span>	<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">master</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap24xxcam_master</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Driver initialisation and deinitialisation.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">omap24xxcam_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">cam</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cam</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cam</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not allocate memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Impose a lower limit on the amount of memory allocated for</span>
<span class="cm">	 * capture. We require at least enough memory to double-buffer</span>
<span class="cm">	 * QVGA (300KB).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">capture_mem</span> <span class="o">&lt;</span> <span class="mi">320</span> <span class="o">*</span> <span class="mi">240</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">capture_mem</span> <span class="o">=</span> <span class="mi">320</span> <span class="o">*</span> <span class="mi">240</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">capture_mem</span> <span class="o">=</span> <span class="n">capture_mem</span><span class="p">;</span>

	<span class="cm">/* request the mem region for the camera registers */</span>
	<span class="n">mem</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no mem resource?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">mem</span><span class="p">),</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;cannot reserve camera register I/O region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base_phys</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_size</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>

	<span class="cm">/* map the region */</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base_phys</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot map camera register I/O region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no irq for camera?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* install the interrupt service routine */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">omap24xxcam_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CAM_NAME</span><span class="p">,</span> <span class="n">cam</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;could not install interrupt service routine</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap24xxcam_clock_get</span><span class="p">(</span><span class="n">cam</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_reset_work</span><span class="p">,</span> <span class="n">omap24xxcam_sensor_reset_work</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">core_enable_disable_lock</span><span class="p">);</span>

	<span class="n">omap24xxcam_sgdma_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sgdma</span><span class="p">,</span>
			       <span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">CAMDMA_REG_OFFSET</span><span class="p">,</span>
			       <span class="n">omap24xxcam_stalled_dma_reset</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cam</span><span class="p">);</span>

	<span class="n">omap24xxcam</span><span class="p">.</span><span class="n">priv</span> <span class="o">=</span> <span class="n">cam</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v4l2_int_device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">omap24xxcam</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">omap24xxcam_remove</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap24xxcam_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap24xxcam_device</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cam</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap24xxcam</span><span class="p">.</span><span class="n">priv</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">v4l2_int_device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">omap24xxcam</span><span class="p">);</span>
	<span class="n">omap24xxcam</span><span class="p">.</span><span class="n">priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">omap24xxcam_clock_put</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base_phys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base_phys</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_size</span><span class="p">);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio_base_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">omap24xxcam_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>	 <span class="o">=</span> <span class="n">omap24xxcam_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>	 <span class="o">=</span> <span class="n">omap24xxcam_remove</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">omap24xxcam_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>	 <span class="o">=</span> <span class="n">omap24xxcam_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">driver</span>	 <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">CAM_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">omap24xxcam_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Sakari Ailus &lt;sakari.ailus@nokia.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;OMAP24xx Video for Linux camera driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">OMAP24XXCAM_VERSION</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">video_nr</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">video_nr</span><span class="p">,</span>
		 <span class="s">&quot;Minor number for video device (-1 ==&gt; auto assign)&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">capture_mem</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">capture_mem</span><span class="p">,</span> <span class="s">&quot;Maximum amount of memory for capture &quot;</span>
		 <span class="s">&quot;buffers (default 4800kiB)&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
