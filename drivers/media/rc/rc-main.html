<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › rc › rc-main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>rc-main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* rc-main.c - Remote Controller core module</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009-2010 by Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;media/rc-core.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/input.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &quot;rc-core-priv.h&quot;</span>

<span class="cm">/* Sizes are in bytes, 256 bytes allows for 32 entries on x64 */</span>
<span class="cp">#define IR_TAB_MIN_SIZE	256</span>
<span class="cp">#define IR_TAB_MAX_SIZE	8192</span>

<span class="cm">/* FIXME: IR_KEYPRESS_TIMEOUT should be protocol specific */</span>
<span class="cp">#define IR_KEYPRESS_TIMEOUT 250</span>

<span class="cm">/* Used to keep track of known keymaps */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">rc_map_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">rc_map_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rc_map_list</span> <span class="o">*</span><span class="nf">seek_rc_map</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_map_list</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc_map_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">.</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">map</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="nf">rc_map_get</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">rc_map_list</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>

	<span class="n">map</span> <span class="o">=</span> <span class="n">seek_rc_map</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#ifdef MODULE</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">request_module</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Couldn&#39;t load IR keymap %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>	<span class="cm">/* Give some time for IR to register */</span>

		<span class="n">map</span> <span class="o">=</span> <span class="n">seek_rc_map</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;IR keymap %s not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Registered IR keymap %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_map_get</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">rc_map_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_list</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc_map_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_map_register</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rc_map_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_list</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_map_unregister</span><span class="p">);</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">rc_map_table</span> <span class="n">empty</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x2a</span><span class="p">,</span> <span class="n">KEY_COFFEE</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rc_map_list</span> <span class="n">empty_map</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">map</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">scan</span>    <span class="o">=</span> <span class="n">empty</span><span class="p">,</span>
		<span class="p">.</span><span class="n">size</span>    <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">empty</span><span class="p">),</span>
		<span class="p">.</span><span class="n">rc_type</span> <span class="o">=</span> <span class="n">RC_TYPE_UNKNOWN</span><span class="p">,</span>	<span class="cm">/* Legacy IR type */</span>
		<span class="p">.</span><span class="n">name</span>    <span class="o">=</span> <span class="n">RC_MAP_EMPTY</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ir_create_table() - initializes a scancode table</span>
<span class="cm"> * @rc_map:	the rc_map to initialize</span>
<span class="cm"> * @name:	name to assign to the table</span>
<span class="cm"> * @rc_type:	ir type to assign to the new table</span>
<span class="cm"> * @size:	initial size of the table</span>
<span class="cm"> * @return:	zero on success or a negative error code</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will initialize the rc_map and will allocate</span>
<span class="cm"> * memory to hold at least the specified number of elements.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ir_create_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u64</span> <span class="n">rc_type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">rc_type</span> <span class="o">=</span> <span class="n">rc_type</span><span class="p">;</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_table</span><span class="p">));</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_table</span><span class="p">);</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Allocated space for %u keycode entries (%u bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ir_free_table() - frees memory allocated by a scancode table</span>
<span class="cm"> * @rc_map:	the table whose mappings need to be freed</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will free memory alloctaed for key mappings used by given</span>
<span class="cm"> * scancode table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ir_free_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">);</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ir_resize_table() - resizes a scancode table if necessary</span>
<span class="cm"> * @rc_map:	the rc_map to resize</span>
<span class="cm"> * @gfp_flags:	gfp flags to use when allocating memory</span>
<span class="cm"> * @return:	zero on success or a negative error code</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will shrink the rc_map if it has lots of</span>
<span class="cm"> * unused entries and grow it if it is full.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ir_resize_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldalloc</span> <span class="o">=</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">newalloc</span> <span class="o">=</span> <span class="n">oldalloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rc_map_table</span> <span class="o">*</span><span class="n">oldscan</span> <span class="o">=</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rc_map_table</span> <span class="o">*</span><span class="n">newscan</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* All entries in use -&gt; grow keytable */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">&gt;=</span> <span class="n">IR_TAB_MAX_SIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">newalloc</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Growing table to %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">newalloc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">&lt;</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">oldalloc</span> <span class="o">&gt;</span> <span class="n">IR_TAB_MIN_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Less than 1/3 of entries in use -&gt; shrink keytable */</span>
		<span class="n">newalloc</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Shrinking table to %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">newalloc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newalloc</span> <span class="o">==</span> <span class="n">oldalloc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">newscan</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">newalloc</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newscan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Failed to kmalloc %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">newalloc</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">newscan</span><span class="p">,</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">,</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_table</span><span class="p">));</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span> <span class="o">=</span> <span class="n">newscan</span><span class="p">;</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">newalloc</span><span class="p">;</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_table</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">oldscan</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ir_update_mapping() - set a keycode in the scancode-&gt;keycode table</span>
<span class="cm"> * @dev:	the struct rc_dev device descriptor</span>
<span class="cm"> * @rc_map:	scancode table to be adjusted</span>
<span class="cm"> * @index:	index of the mapping that needs to be updated</span>
<span class="cm"> * @keycode:	the desired keycode</span>
<span class="cm"> * @return:	previous keycode assigned to the mapping</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to update scancode-&gt;keycode mapping at given</span>
<span class="cm"> * position.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ir_update_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_keycode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">old_keycode</span> <span class="o">=</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">keycode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Did the user wish to remove the mapping? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_keycode</span> <span class="o">==</span> <span class="n">KEY_RESERVED</span> <span class="o">||</span> <span class="n">new_keycode</span> <span class="o">==</span> <span class="n">KEY_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;#%d: Deleting scan 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">index</span><span class="p">,</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">scancode</span><span class="p">);</span>
		<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">--</span><span class="p">;</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">index</span><span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
			<span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">index</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_table</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;#%d: %s scan 0x%04x with key 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">index</span><span class="p">,</span>
			   <span class="n">old_keycode</span> <span class="o">==</span> <span class="n">KEY_RESERVED</span> <span class="o">?</span> <span class="s">&quot;New&quot;</span> <span class="o">:</span> <span class="s">&quot;Replacing&quot;</span><span class="p">,</span>
			   <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">scancode</span><span class="p">,</span> <span class="n">new_keycode</span><span class="p">);</span>
		<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">keycode</span> <span class="o">=</span> <span class="n">new_keycode</span><span class="p">;</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">new_keycode</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">keybit</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_keycode</span> <span class="o">!=</span> <span class="n">KEY_RESERVED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* A previous mapping was updated... */</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">old_keycode</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">keybit</span><span class="p">);</span>
		<span class="cm">/* ... but another scancode might use the same keycode */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">keycode</span> <span class="o">==</span> <span class="n">old_keycode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__set_bit</span><span class="p">(</span><span class="n">old_keycode</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">keybit</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Possibly shrink the keytable, failure is not a problem */</span>
		<span class="n">ir_resize_table</span><span class="p">(</span><span class="n">rc_map</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">old_keycode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ir_establish_scancode() - set a keycode in the scancode-&gt;keycode table</span>
<span class="cm"> * @dev:	the struct rc_dev device descriptor</span>
<span class="cm"> * @rc_map:	scancode table to be searched</span>
<span class="cm"> * @scancode:	the desired scancode</span>
<span class="cm"> * @resize:	controls whether we allowed to resize the table to</span>
<span class="cm"> *		accommodate not yet present scancodes</span>
<span class="cm"> * @return:	index of the mapping containing scancode in question</span>
<span class="cm"> *		or -1U in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to locate given scancode in rc_map.</span>
<span class="cm"> * If scancode is not yet present the routine will allocate a new slot</span>
<span class="cm"> * for it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ir_establish_scancode</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scancode</span><span class="p">,</span>
					  <span class="n">bool</span> <span class="n">resize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unfortunately, some hardware-based IR decoders don&#39;t provide</span>
<span class="cm">	 * all bits for the complete IR code. In general, they provide only</span>
<span class="cm">	 * the command part of the IR code. Yet, as it is possible to replace</span>
<span class="cm">	 * the provided IR with another one, it is needed to allow loading</span>
<span class="cm">	 * IR tables from other remotes. So, we support specifying a mask to</span>
<span class="cm">	 * indicate the valid bits of the scancodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scanmask</span><span class="p">)</span>
		<span class="n">scancode</span> <span class="o">&amp;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">scanmask</span><span class="p">;</span>

	<span class="cm">/* First check if we already have a mapping for this ir command */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">scancode</span> <span class="o">==</span> <span class="n">scancode</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* Keytable is sorted from lowest to highest scancode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">scancode</span> <span class="o">&gt;=</span> <span class="n">scancode</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* No previous mapping found, we might need to grow the table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resize</span> <span class="o">||</span> <span class="n">ir_resize_table</span><span class="p">(</span><span class="n">rc_map</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1U</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* i is the proper index to insert our new keycode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			<span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_table</span><span class="p">));</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">scancode</span> <span class="o">=</span> <span class="n">scancode</span><span class="p">;</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">keycode</span> <span class="o">=</span> <span class="n">KEY_RESERVED</span><span class="p">;</span>
	<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ir_setkeycode() - set a keycode in the scancode-&gt;keycode table</span>
<span class="cm"> * @idev:	the struct input_dev device descriptor</span>
<span class="cm"> * @scancode:	the desired scancode</span>
<span class="cm"> * @keycode:	result</span>
<span class="cm"> * @return:	-EINVAL if the keycode could not be inserted, otherwise zero.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to handle evdev EVIOCSKEY ioctl.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ir_setkeycode</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">idev</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">input_keymap_entry</span> <span class="o">*</span><span class="n">ke</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">old_keycode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">rdev</span> <span class="o">=</span> <span class="n">input_get_drvdata</span><span class="p">(</span><span class="n">idev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rdev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scancode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ke</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INPUT_KEYMAP_BY_INDEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">ke</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">input_scancode_to_scalar</span><span class="p">(</span><span class="n">ke</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scancode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">ir_establish_scancode</span><span class="p">(</span><span class="n">rdev</span><span class="p">,</span> <span class="n">rc_map</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">old_keycode</span> <span class="o">=</span> <span class="n">ir_update_mapping</span><span class="p">(</span><span class="n">rdev</span><span class="p">,</span> <span class="n">rc_map</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ke</span><span class="o">-&gt;</span><span class="n">keycode</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ir_setkeytable() - sets several entries in the scancode-&gt;keycode table</span>
<span class="cm"> * @dev:	the struct rc_dev device descriptor</span>
<span class="cm"> * @to:		the struct rc_map to copy entries to</span>
<span class="cm"> * @from:	the struct rc_map to copy entries from</span>
<span class="cm"> * @return:	-ENOMEM if all keycodes could not be inserted, otherwise zero.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to handle table initialization.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ir_setkeytable</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ir_create_table</span><span class="p">(</span><span class="n">rc_map</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">from</span><span class="o">-&gt;</span><span class="n">rc_type</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Allocated space for %u keycode entries (%u bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">ir_establish_scancode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rc_map</span><span class="p">,</span>
					      <span class="n">from</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">scancode</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ir_update_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rc_map</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
				  <span class="n">from</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">keycode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">ir_free_table</span><span class="p">(</span><span class="n">rc_map</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ir_lookup_by_scancode() - locate mapping by scancode</span>
<span class="cm"> * @rc_map:	the struct rc_map to search</span>
<span class="cm"> * @scancode:	scancode to look for in the table</span>
<span class="cm"> * @return:	index in the table, -1U if not found</span>
<span class="cm"> *</span>
<span class="cm"> * This routine performs binary search in RC keykeymap table for</span>
<span class="cm"> * given scancode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ir_lookup_by_scancode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scancode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">scancode</span> <span class="o">&lt;</span> <span class="n">scancode</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">scancode</span> <span class="o">&gt;</span> <span class="n">scancode</span><span class="p">)</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1U</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ir_getkeycode() - get a keycode from the scancode-&gt;keycode table</span>
<span class="cm"> * @idev:	the struct input_dev device descriptor</span>
<span class="cm"> * @scancode:	the desired scancode</span>
<span class="cm"> * @keycode:	used to return the keycode, if found, or KEY_RESERVED</span>
<span class="cm"> * @return:	always returns zero.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to handle evdev EVIOCGKEY ioctl.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ir_getkeycode</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">idev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">input_keymap_entry</span> <span class="o">*</span><span class="n">ke</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">rdev</span> <span class="o">=</span> <span class="n">input_get_drvdata</span><span class="p">(</span><span class="n">idev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rdev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rc_map_table</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scancode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ke</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INPUT_KEYMAP_BY_INDEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">ke</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">input_scancode_to_scalar</span><span class="p">(</span><span class="n">ke</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scancode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">ir_lookup_by_scancode</span><span class="p">(</span><span class="n">rc_map</span><span class="p">,</span> <span class="n">scancode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

		<span class="n">ke</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">ke</span><span class="o">-&gt;</span><span class="n">keycode</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">keycode</span><span class="p">;</span>
		<span class="n">ke</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">scancode</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ke</span><span class="o">-&gt;</span><span class="n">scancode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">scancode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">scancode</span><span class="p">));</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ke</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INPUT_KEYMAP_BY_INDEX</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We do not really know the valid range of scancodes</span>
<span class="cm">		 * so let&#39;s respond with KEY_RESERVED to anything we</span>
<span class="cm">		 * do not have mapping for [yet].</span>
<span class="cm">		 */</span>
		<span class="n">ke</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">ke</span><span class="o">-&gt;</span><span class="n">keycode</span> <span class="o">=</span> <span class="n">KEY_RESERVED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rc_g_keycode_from_table() - gets the keycode that corresponds to a scancode</span>
<span class="cm"> * @dev:	the struct rc_dev descriptor of the device</span>
<span class="cm"> * @scancode:	the scancode to look for</span>
<span class="cm"> * @return:	the corresponding keycode, or KEY_RESERVED</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used by drivers which need to convert a scancode to a</span>
<span class="cm"> * keycode. Normally it should not be used since drivers should have no</span>
<span class="cm"> * interest in keycodes.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">rc_g_keycode_from_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scancode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">keycode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">ir_lookup_by_scancode</span><span class="p">(</span><span class="n">rc_map</span><span class="p">,</span> <span class="n">scancode</span><span class="p">);</span>
	<span class="n">keycode</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">?</span>
			<span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">keycode</span> <span class="o">:</span> <span class="n">KEY_RESERVED</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keycode</span> <span class="o">!=</span> <span class="n">KEY_RESERVED</span><span class="p">)</span>
		<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s: scancode 0x%04x keycode 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_name</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">keycode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">keycode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_g_keycode_from_table</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ir_do_keyup() - internal function to signal the release of a keypress</span>
<span class="cm"> * @dev:	the struct rc_dev descriptor of the device</span>
<span class="cm"> * @sync:	whether or not to call input_sync</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used internally to release a keypress, it must be</span>
<span class="cm"> * called with keylock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ir_do_keyup</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keypressed</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;keyup key 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_keycode</span><span class="p">);</span>
	<span class="n">input_report_key</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_keycode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span>
		<span class="n">input_sync</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">keypressed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rc_keyup() - signals the release of a keypress</span>
<span class="cm"> * @dev:	the struct rc_dev descriptor of the device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to signal that a key has been released on the</span>
<span class="cm"> * remote control.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rc_keyup</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ir_do_keyup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_keyup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ir_timer_keyup() - generates a keyup event after a timeout</span>
<span class="cm"> * @cookie:	a pointer to the struct rc_dev for the device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will generate a keyup event some time after a keydown event</span>
<span class="cm"> * is generated when no further activity has been detected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ir_timer_keyup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="p">)</span><span class="n">cookie</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ir-&gt;keyup_jiffies is used to prevent a race condition if a</span>
<span class="cm">	 * hardware interrupt occurs at this point and the keyup timer</span>
<span class="cm">	 * event is moved further into the future as a result.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The timer will then be reactivated and this function called</span>
<span class="cm">	 * again in the future. We need to exit gracefully in that case</span>
<span class="cm">	 * to allow the input subsystem to do its auto-repeat magic or</span>
<span class="cm">	 * a keyup event might follow immediately after the keydown.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_is_before_eq_jiffies</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keyup_jiffies</span><span class="p">))</span>
		<span class="n">ir_do_keyup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rc_repeat() - signals that a key is still pressed</span>
<span class="cm"> * @dev:	the struct rc_dev descriptor of the device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used by IR decoders when a repeat message which does</span>
<span class="cm"> * not include the necessary bits to reproduce the scancode has been</span>
<span class="cm"> * received.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rc_repeat</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">input_event</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">EV_MSC</span><span class="p">,</span> <span class="n">MSC_SCAN</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_scancode</span><span class="p">);</span>
	<span class="n">input_sync</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keypressed</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">keyup_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">IR_KEYPRESS_TIMEOUT</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">timer_keyup</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">keyup_jiffies</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_repeat</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ir_do_keydown() - internal function to process a keypress</span>
<span class="cm"> * @dev:	the struct rc_dev descriptor of the device</span>
<span class="cm"> * @scancode:   the scancode of the keypress</span>
<span class="cm"> * @keycode:    the keycode of the keypress</span>
<span class="cm"> * @toggle:     the toggle value of the keypress</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used internally to register a keypress, it must be</span>
<span class="cm"> * called with keylock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ir_do_keydown</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scancode</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">keycode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">toggle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">new_event</span> <span class="o">=</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keypressed</span> <span class="o">||</span>
			 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_scancode</span> <span class="o">!=</span> <span class="n">scancode</span> <span class="o">||</span>
			 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_toggle</span> <span class="o">!=</span> <span class="n">toggle</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_event</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">keypressed</span><span class="p">)</span>
		<span class="n">ir_do_keyup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">input_event</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">EV_MSC</span><span class="p">,</span> <span class="n">MSC_SCAN</span><span class="p">,</span> <span class="n">scancode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_event</span> <span class="o">&amp;&amp;</span> <span class="n">keycode</span> <span class="o">!=</span> <span class="n">KEY_RESERVED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Register a keypress */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">keypressed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_scancode</span> <span class="o">=</span> <span class="n">scancode</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_toggle</span> <span class="o">=</span> <span class="n">toggle</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_keycode</span> <span class="o">=</span> <span class="n">keycode</span><span class="p">;</span>

		<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s: key down event, &quot;</span>
			   <span class="s">&quot;key 0x%04x, scancode 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_name</span><span class="p">,</span> <span class="n">keycode</span><span class="p">,</span> <span class="n">scancode</span><span class="p">);</span>
		<span class="n">input_report_key</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">keycode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">input_sync</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rc_keydown() - generates input event for a key press</span>
<span class="cm"> * @dev:	the struct rc_dev descriptor of the device</span>
<span class="cm"> * @scancode:   the scancode that we&#39;re seeking</span>
<span class="cm"> * @toggle:     the toggle value (protocol dependent, if the protocol doesn&#39;t</span>
<span class="cm"> *              support toggle values, this should be set to zero)</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to signal that a key has been pressed on the</span>
<span class="cm"> * remote control.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rc_keydown</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">toggle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">keycode</span> <span class="o">=</span> <span class="n">rc_g_keycode_from_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scancode</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ir_do_keydown</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">keycode</span><span class="p">,</span> <span class="n">toggle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keypressed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">keyup_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">IR_KEYPRESS_TIMEOUT</span><span class="p">);</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">timer_keyup</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">keyup_jiffies</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_keydown</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rc_keydown_notimeout() - generates input event for a key press without</span>
<span class="cm"> *                          an automatic keyup event at a later time</span>
<span class="cm"> * @dev:	the struct rc_dev descriptor of the device</span>
<span class="cm"> * @scancode:   the scancode that we&#39;re seeking</span>
<span class="cm"> * @toggle:     the toggle value (protocol dependent, if the protocol doesn&#39;t</span>
<span class="cm"> *              support toggle values, this should be set to zero)</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to signal that a key has been pressed on the</span>
<span class="cm"> * remote control. The driver must manually call rc_keyup() at a later stage.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rc_keydown_notimeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">toggle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">keycode</span> <span class="o">=</span> <span class="n">rc_g_keycode_from_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scancode</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ir_do_keydown</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">keycode</span><span class="p">,</span> <span class="n">toggle</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_keydown_notimeout</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ir_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">idev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">rdev</span> <span class="o">=</span> <span class="n">input_get_drvdata</span><span class="p">(</span><span class="n">idev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rdev</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">rdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ir_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">idev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">rdev</span> <span class="o">=</span> <span class="n">input_get_drvdata</span><span class="p">(</span><span class="n">idev</span><span class="p">);</span>

	 <span class="k">if</span> <span class="p">(</span><span class="n">rdev</span><span class="p">)</span>
		<span class="n">rdev</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">rdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* class for /sys/class/rc */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ir_devnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;rc/%s&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">ir_input_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rc&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">devnode</span>	<span class="o">=</span> <span class="n">ir_devnode</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">type</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">proto_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">RC_TYPE_UNKNOWN</span><span class="p">,</span>	<span class="s">&quot;unknown&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">RC_TYPE_RC5</span><span class="p">,</span>		<span class="s">&quot;rc-5&quot;</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">RC_TYPE_NEC</span><span class="p">,</span>		<span class="s">&quot;nec&quot;</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">RC_TYPE_RC6</span><span class="p">,</span>		<span class="s">&quot;rc-6&quot;</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">RC_TYPE_JVC</span><span class="p">,</span>		<span class="s">&quot;jvc&quot;</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">RC_TYPE_SONY</span><span class="p">,</span>		<span class="s">&quot;sony&quot;</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">RC_TYPE_RC5_SZ</span><span class="p">,</span>	<span class="s">&quot;rc-5-sz&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">RC_TYPE_SANYO</span><span class="p">,</span>	<span class="s">&quot;sanyo&quot;</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">RC_TYPE_MCE_KBD</span><span class="p">,</span>	<span class="s">&quot;mce_kbd&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">RC_TYPE_LIRC</span><span class="p">,</span>		<span class="s">&quot;lirc&quot;</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">RC_TYPE_OTHER</span><span class="p">,</span>	<span class="s">&quot;other&quot;</span>		<span class="p">},</span>
<span class="p">};</span>

<span class="cp">#define PROTO_NONE	&quot;none&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * show_protocols() - shows the current IR protocol(s)</span>
<span class="cm"> * @device:	the device descriptor</span>
<span class="cm"> * @mattr:	the device attribute struct (unused)</span>
<span class="cm"> * @buf:	a pointer to the output buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is a callback routine for input read the IR protocol type(s).</span>
<span class="cm"> * it is trigged by reading /sys/class/rc/rc?/protocols.</span>
<span class="cm"> * It returns the protocol names of supported protocols.</span>
<span class="cm"> * Enabled protocols are printed in brackets.</span>
<span class="cm"> *</span>
<span class="cm"> * dev-&gt;lock is taken to guard against races between device</span>
<span class="cm"> * registration, store_protocols and show_protocols.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_protocols</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">mattr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">to_rc_dev</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">allowed</span><span class="p">,</span> <span class="n">enabled</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Device is being removed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_type</span> <span class="o">==</span> <span class="n">RC_DRIVER_SCANCODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enabled</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">.</span><span class="n">rc_type</span><span class="p">;</span>
		<span class="n">allowed</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">allowed_protos</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">enabled</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">enabled_protocols</span><span class="p">;</span>
		<span class="n">allowed</span> <span class="o">=</span> <span class="n">ir_raw_get_allowed_protocols</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;allowed - 0x%llx, enabled - 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">allowed</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">enabled</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">proto_names</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">allowed</span> <span class="o">&amp;</span> <span class="n">enabled</span> <span class="o">&amp;</span> <span class="n">proto_names</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">)</span>
			<span class="n">tmp</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;[%s] &quot;</span><span class="p">,</span> <span class="n">proto_names</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">allowed</span> <span class="o">&amp;</span> <span class="n">proto_names</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">)</span>
			<span class="n">tmp</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">proto_names</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">buf</span><span class="p">)</span>
		<span class="n">tmp</span><span class="o">--</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * store_protocols() - changes the current IR protocol(s)</span>
<span class="cm"> * @device:	the device descriptor</span>
<span class="cm"> * @mattr:	the device attribute struct (unused)</span>
<span class="cm"> * @buf:	a pointer to the input buffer</span>
<span class="cm"> * @len:	length of the input buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is for changing the IR protocol type.</span>
<span class="cm"> * It is trigged by writing to /sys/class/rc/rc?/protocols.</span>
<span class="cm"> * Writing &quot;+proto&quot; will add a protocol to the list of enabled protocols.</span>
<span class="cm"> * Writing &quot;-proto&quot; will remove a protocol from the list of enabled protocols.</span>
<span class="cm"> * Writing &quot;proto&quot; will enable only &quot;proto&quot;.</span>
<span class="cm"> * Writing &quot;none&quot; will disable all protocols.</span>
<span class="cm"> * Returns -EINVAL if an invalid protocol combination or unknown protocol name</span>
<span class="cm"> * is used, otherwise @len.</span>
<span class="cm"> *</span>
<span class="cm"> * dev-&gt;lock is taken to guard against races between device</span>
<span class="cm"> * registration, store_protocols and show_protocols.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_protocols</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">mattr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">to_rc_dev</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">enable</span><span class="p">,</span> <span class="n">disable</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Device is being removed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_type</span> <span class="o">==</span> <span class="n">RC_DRIVER_SCANCODE</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">.</span><span class="n">rc_type</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">enabled_protocols</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Protocol switching not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">((</span><span class="kt">char</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">tmp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">tmp</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">enable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">disable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">tmp</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">tmp</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">disable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">tmp</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">disable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">disable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">PROTO_NONE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROTO_NONE</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROTO_NONE</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">proto_names</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">proto_names</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">tmp</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">proto_names</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
					<span class="n">mask</span> <span class="o">=</span> <span class="n">proto_names</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">proto_names</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Unknown protocol: &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">disable</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Protocol not specified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">change_protocol</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">change_protocol</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Error setting protocols to 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">type</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_type</span> <span class="o">==</span> <span class="n">RC_DRIVER_SCANCODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">.</span><span class="n">rc_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">enabled_protocols</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Current protocol(s): 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">type</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rc_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#define ADD_HOTPLUG_VAR(fmt, val...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		int err = add_uevent_var(env, fmt, val);		\</span>
<span class="cp">		if (err)						\</span>
<span class="cp">			return err;					\</span>
<span class="cp">	} while (0)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rc_dev_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">to_rc_dev</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
		<span class="n">ADD_HOTPLUG_VAR</span><span class="p">(</span><span class="s">&quot;NAME=%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_name</span><span class="p">)</span>
		<span class="n">ADD_HOTPLUG_VAR</span><span class="p">(</span><span class="s">&quot;DRV_NAME=%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Static device attribute struct with the sysfs attributes for IR&#39;s</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">protocols</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">show_protocols</span><span class="p">,</span> <span class="n">store_protocols</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">rc_dev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_protocols</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">rc_dev_attr_grp</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span>	<span class="o">=</span> <span class="n">rc_dev_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">rc_dev_attr_groups</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">rc_dev_attr_grp</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">rc_dev_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">groups</span>		<span class="o">=</span> <span class="n">rc_dev_attr_groups</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">rc_dev_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uevent</span>		<span class="o">=</span> <span class="n">rc_dev_uevent</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="nf">rc_allocate_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span> <span class="o">=</span> <span class="n">input_allocate_device</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">getkeycode</span> <span class="o">=</span> <span class="n">ir_getkeycode</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">setkeycode</span> <span class="o">=</span> <span class="n">ir_setkeycode</span><span class="p">;</span>
	<span class="n">input_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">keylock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">timer_keyup</span><span class="p">,</span> <span class="n">ir_timer_keyup</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc_dev_type</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ir_input_class</span><span class="p">;</span>
	<span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">__module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_allocate_device</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rc_free_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">)</span>
		<span class="n">input_free_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>

	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_free_device</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">rc_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">bool</span> <span class="n">raw_init</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* raw decoders loaded? */</span>
	<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">devno</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rc_map</span> <span class="o">*</span><span class="n">rc_map</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">map_name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rc_map</span> <span class="o">=</span> <span class="n">rc_map_get</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">map_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_map</span><span class="p">)</span>
		<span class="n">rc_map</span> <span class="o">=</span> <span class="n">rc_map_get</span><span class="p">(</span><span class="n">RC_MAP_EMPTY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_map</span> <span class="o">||</span> <span class="o">!</span><span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">scan</span> <span class="o">||</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">EV_KEY</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">evbit</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">EV_REP</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">evbit</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">EV_MSC</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">evbit</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">MSC_SCAN</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">mscbit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">open</span> <span class="o">=</span> <span class="n">ir_open</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">close</span> <span class="o">=</span> <span class="n">ir_close</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take the lock here, as the device sysfs node will appear</span>
<span class="cm">	 * when device_add() is called, which may trigger an ir-keytable udev</span>
<span class="cm">	 * rule, which will in turn call show_protocols and access either</span>
<span class="cm">	 * dev-&gt;rc_map.rc_type or dev-&gt;raw-&gt;enabled_protocols before it has</span>
<span class="cm">	 * been initialized.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devno</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rc%ld&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ir_setkeytable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rc_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dev</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_id</span><span class="p">));</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">phys</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_phys</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_name</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">input_register_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_table</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Default delay of 250ms is too short for some protocols, especially</span>
<span class="cm">	 * since the timeout is currently set to 250ms. Increase it to 500ms,</span>
<span class="cm">	 * to avoid wrong repetition of the keycodes. Note that this must be</span>
<span class="cm">	 * set after the call to input_register_device().</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">rep</span><span class="p">[</span><span class="n">REP_DELAY</span><span class="p">]</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * As a repeat event on protocols like RC-5 and NEC take as long as</span>
<span class="cm">	 * 110/114ms, using 33ms as a repeat period is not the right thing</span>
<span class="cm">	 * to do.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">rep</span><span class="p">[</span><span class="n">REP_PERIOD</span><span class="p">]</span> <span class="o">=</span> <span class="mi">125</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">kobject_get_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: %s as %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_name</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_name</span> <span class="o">:</span> <span class="s">&quot;Unspecified device&quot;</span><span class="p">,</span>
		<span class="n">path</span> <span class="o">?</span> <span class="n">path</span> <span class="o">:</span> <span class="s">&quot;N/A&quot;</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_type</span> <span class="o">==</span> <span class="n">RC_DRIVER_IR_RAW</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Load raw decoders, if they aren&#39;t already */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw_init</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Loading raw decoders</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ir_raw_init</span><span class="p">();</span>
			<span class="n">raw_init</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ir_raw_event_register</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_input</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">change_protocol</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">change_protocol</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">rc_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_raw</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Registered rc%ld (driver: %s, remote: %s, mode %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_name</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_name</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">,</span>
		   <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">?</span> <span class="n">rc_map</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_type</span> <span class="o">==</span> <span class="n">RC_DRIVER_IR_RAW</span> <span class="o">?</span> <span class="s">&quot;raw&quot;</span> <span class="o">:</span> <span class="s">&quot;cooked&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_raw:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_type</span> <span class="o">==</span> <span class="n">RC_DRIVER_IR_RAW</span><span class="p">)</span>
		<span class="n">ir_raw_event_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">out_input:</span>
	<span class="n">input_unregister_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_table:</span>
	<span class="n">ir_free_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">);</span>
<span class="nl">out_dev:</span>
	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_register_device</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rc_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">timer_keyup</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_type</span> <span class="o">==</span> <span class="n">RC_DRIVER_IR_RAW</span><span class="p">)</span>
		<span class="n">ir_raw_event_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Freeing the table should also call the stop callback */</span>
	<span class="n">ir_free_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rc_map</span><span class="p">);</span>
	<span class="n">IR_dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Freed keycode table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">input_unregister_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">input_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rc_free_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_unregister_device</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Init/exit code for the module. Basically, creates/removes /sys/class/rc</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rc_core_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ir_input_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rc_core: unable to register rc class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc_map_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty_map</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">rc_core_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ir_input_class</span><span class="p">);</span>
	<span class="n">rc_map_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">rc_core_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">rc_core_exit</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">rc_core_debug</span><span class="p">;</span>    <span class="cm">/* ir_debug level (0,1,2) */</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rc_core_debug</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">rc_core_debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
