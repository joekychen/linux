<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › dvb › dvb-core › dvb_ringbuffer.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>dvb_ringbuffer.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * dvb_ringbuffer.h: ring buffer implementation for the dvb driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003 Oliver Endriss</span>
<span class="cm"> * Copyright (C) 2004 Andrew de Quincey</span>
<span class="cm"> *</span>
<span class="cm"> * based on code originally found in av7110.c &amp; dvb_ci.c:</span>
<span class="cm"> * Copyright (C) 1999-2003 Ralph Metzler &amp; Marcus Metzler</span>
<span class="cm"> *                         for convergence integrated media GmbH</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU Lesser General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version 2.1</span>
<span class="cm"> * of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _DVB_RINGBUFFER_H_</span>
<span class="cp">#define _DVB_RINGBUFFER_H_</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>

<span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="p">{</span>
	<span class="n">u8</span>               <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">ssize_t</span>           <span class="n">size</span><span class="p">;</span>
	<span class="kt">ssize_t</span>           <span class="n">pread</span><span class="p">;</span>
	<span class="kt">ssize_t</span>           <span class="n">pwrite</span><span class="p">;</span>
	<span class="kt">int</span>               <span class="n">error</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> <span class="n">queue</span><span class="p">;</span>
	<span class="n">spinlock_t</span>        <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DVB_RINGBUFFER_PKTHDRSIZE 3</span>


<span class="cm">/*</span>
<span class="cm">** Notes:</span>
<span class="cm">** ------</span>
<span class="cm">** (1) For performance reasons read and write routines don&#39;t check buffer sizes</span>
<span class="cm">**     and/or number of bytes free/available. This has to be done before these</span>
<span class="cm">**     routines are called. For example:</span>
<span class="cm">**</span>
<span class="cm">**     *** write &lt;buflen&gt; bytes ***</span>
<span class="cm">**     free = dvb_ringbuffer_free(rbuf);</span>
<span class="cm">**     if (free &gt;= buflen)</span>
<span class="cm">**         count = dvb_ringbuffer_write(rbuf, buffer, buflen);</span>
<span class="cm">**     else</span>
<span class="cm">**         ...</span>
<span class="cm">**</span>
<span class="cm">**     *** read min. 1000, max. &lt;bufsize&gt; bytes ***</span>
<span class="cm">**     avail = dvb_ringbuffer_avail(rbuf);</span>
<span class="cm">**     if (avail &gt;= 1000)</span>
<span class="cm">**         count = dvb_ringbuffer_read(rbuf, buffer, min(avail, bufsize));</span>
<span class="cm">**     else</span>
<span class="cm">**         ...</span>
<span class="cm">**</span>
<span class="cm">** (2) If there is exactly one reader and one writer, there is no need</span>
<span class="cm">**     to lock read or write operations.</span>
<span class="cm">**     Two or more readers must be locked against each other.</span>
<span class="cm">**     Flushing the buffer counts as a read operation.</span>
<span class="cm">**     Resetting the buffer counts as a read and write operation.</span>
<span class="cm">**     Two or more writers must be locked against each other.</span>
<span class="cm">*/</span>

<span class="cm">/* initialize ring buffer, lock and queue */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dvb_ringbuffer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* test whether buffer is empty */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dvb_ringbuffer_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">);</span>

<span class="cm">/* return the number of free bytes in the buffer */</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">dvb_ringbuffer_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">);</span>

<span class="cm">/* return the number of bytes waiting in the buffer */</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">dvb_ringbuffer_avail</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">** Reset the read and write pointers to zero and flush the buffer</span>
<span class="cm">** This counts as a read and write operation</span>
<span class="cm">*/</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dvb_ringbuffer_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">);</span>


<span class="cm">/* read routines &amp; macros */</span>
<span class="cm">/* ---------------------- */</span>
<span class="cm">/* flush buffer */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dvb_ringbuffer_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">);</span>

<span class="cm">/* flush buffer protected by spinlock and wake-up waiting task(s) */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dvb_ringbuffer_flush_spinlock_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">);</span>

<span class="cm">/* peek at byte &lt;offs&gt; in the buffer */</span>
<span class="cp">#define DVB_RINGBUFFER_PEEK(rbuf,offs)	\</span>
<span class="cp">			(rbuf)-&gt;data[((rbuf)-&gt;pread+(offs))%(rbuf)-&gt;size]</span>

<span class="cm">/* advance read ptr by &lt;num&gt; bytes */</span>
<span class="cp">#define DVB_RINGBUFFER_SKIP(rbuf,num)	\</span>
<span class="cp">			(rbuf)-&gt;pread=((rbuf)-&gt;pread+(num))%(rbuf)-&gt;size</span>

<span class="cm">/*</span>
<span class="cm">** read &lt;len&gt; bytes from ring buffer into &lt;buf&gt;</span>
<span class="cm">** &lt;usermem&gt; specifies whether &lt;buf&gt; resides in user space</span>
<span class="cm">** returns number of bytes transferred or -EFAULT</span>
<span class="cm">*/</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">dvb_ringbuffer_read_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dvb_ringbuffer_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>


<span class="cm">/* write routines &amp; macros */</span>
<span class="cm">/* ----------------------- */</span>
<span class="cm">/* write single byte to ring buffer */</span>
<span class="cp">#define DVB_RINGBUFFER_WRITE_BYTE(rbuf,byte)	\</span>
<span class="cp">			{ (rbuf)-&gt;data[(rbuf)-&gt;pwrite]=(byte); \</span>
<span class="cp">			(rbuf)-&gt;pwrite=((rbuf)-&gt;pwrite+1)%(rbuf)-&gt;size; }</span>
<span class="cm">/*</span>
<span class="cm">** write &lt;len&gt; bytes to ring buffer</span>
<span class="cm">** &lt;usermem&gt; specifies whether &lt;buf&gt; resides in user space</span>
<span class="cm">** returns number of bytes transferred or -EFAULT</span>
<span class="cm">*/</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">dvb_ringbuffer_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * Write a packet into the ringbuffer.</span>
<span class="cm"> *</span>
<span class="cm"> * &lt;rbuf&gt; Ringbuffer to write to.</span>
<span class="cm"> * &lt;buf&gt; Buffer to write.</span>
<span class="cm"> * &lt;len&gt; Length of buffer (currently limited to 65535 bytes max).</span>
<span class="cm"> * returns Number of bytes written, or -EFAULT, -ENOMEM, -EVINAL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">dvb_ringbuffer_pkt_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span> <span class="n">u8</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Read from a packet in the ringbuffer. Note: unlike dvb_ringbuffer_read(), this</span>
<span class="cm"> * does NOT update the read pointer in the ringbuffer. You must use</span>
<span class="cm"> * dvb_ringbuffer_pkt_dispose() to mark a packet as no longer required.</span>
<span class="cm"> *</span>
<span class="cm"> * &lt;rbuf&gt; Ringbuffer concerned.</span>
<span class="cm"> * &lt;idx&gt; Packet index as returned by dvb_ringbuffer_pkt_next().</span>
<span class="cm"> * &lt;offset&gt; Offset into packet to read from.</span>
<span class="cm"> * &lt;buf&gt; Destination buffer for data.</span>
<span class="cm"> * &lt;len&gt; Size of destination buffer.</span>
<span class="cm"> * &lt;usermem&gt; Set to 1 if &lt;buf&gt; is in userspace.</span>
<span class="cm"> * returns Number of bytes read, or -EFAULT.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">dvb_ringbuffer_pkt_read_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">dvb_ringbuffer_pkt_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Dispose of a packet in the ring buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * &lt;rbuf&gt; Ring buffer concerned.</span>
<span class="cm"> * &lt;idx&gt; Packet index as returned by dvb_ringbuffer_pkt_next().</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dvb_ringbuffer_pkt_dispose</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Get the index of the next packet in a ringbuffer.</span>
<span class="cm"> *</span>
<span class="cm"> * &lt;rbuf&gt; Ringbuffer concerned.</span>
<span class="cm"> * &lt;idx&gt; Previous packet index, or -1 to return the first packet index.</span>
<span class="cm"> * &lt;pktlen&gt; On success, will be updated to contain the length of the packet in bytes.</span>
<span class="cm"> * returns Packet index (if &gt;=0), or -1 if no packets available.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">dvb_ringbuffer_pkt_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_ringbuffer</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">pktlen</span><span class="p">);</span>


<span class="cp">#endif </span><span class="cm">/* _DVB_RINGBUFFER_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
