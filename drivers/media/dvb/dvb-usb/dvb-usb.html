<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › dvb › dvb-usb › dvb-usb.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>dvb-usb.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* dvb-usb.h is part of the DVB USB library.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-6 Patrick Boettcher (patrick.boettcher@desy.de)</span>
<span class="cm"> * see dvb-usb-init.c for copyright information.</span>
<span class="cm"> *</span>
<span class="cm"> * the headerfile, all dvb-usb-drivers have to include.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: clean-up the structures for unused fields and update the comments</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __DVB_USB_H__</span>
<span class="cp">#define __DVB_USB_H__</span>

<span class="cp">#include &lt;linux/input.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;media/rc-core.h&gt;</span>

<span class="cp">#include &quot;dvb_frontend.h&quot;</span>
<span class="cp">#include &quot;dvb_demux.h&quot;</span>
<span class="cp">#include &quot;dvb_net.h&quot;</span>
<span class="cp">#include &quot;dmxdev.h&quot;</span>

<span class="cp">#include &quot;dvb-pll.h&quot;</span>

<span class="cp">#include &quot;dvb-usb-ids.h&quot;</span>

<span class="cm">/* debug */</span>
<span class="cp">#ifdef CONFIG_DVB_USB_DEBUG</span>
<span class="cp">#define dprintk(var,level,args...) \</span>
<span class="cp">	    do { if ((var &amp; level)) { printk(args); } } while (0)</span>

<span class="cp">#define debug_dump(b,l,func) {\</span>
<span class="cp">	int loop_; \</span>
<span class="cp">	for (loop_ = 0; loop_ &lt; l; loop_++) func(&quot;%02x &quot;, b[loop_]); \</span>
<span class="cp">	func(&quot;\n&quot;);\</span>
<span class="cp">}</span>
<span class="cp">#define DVB_USB_DEBUG_STATUS</span>
<span class="cp">#else</span>
<span class="cp">#define dprintk(args...)</span>
<span class="cp">#define debug_dump(b,l,func)</span>

<span class="cp">#define DVB_USB_DEBUG_STATUS &quot; (debugging is not enabled)&quot;</span>

<span class="cp">#endif</span>

<span class="cm">/* generic log methods - taken from usb.h */</span>
<span class="cp">#ifndef DVB_USB_LOG_PREFIX</span>
 <span class="cp">#define DVB_USB_LOG_PREFIX &quot;dvb-usb (please define a log prefix)&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#undef err</span>
<span class="cp">#define err(format, arg...)  printk(KERN_ERR     DVB_USB_LOG_PREFIX &quot;: &quot; format &quot;\n&quot; , ## arg)</span>
<span class="cp">#undef info</span>
<span class="cp">#define info(format, arg...) printk(KERN_INFO    DVB_USB_LOG_PREFIX &quot;: &quot; format &quot;\n&quot; , ## arg)</span>
<span class="cp">#undef warn</span>
<span class="cp">#define warn(format, arg...) printk(KERN_WARNING DVB_USB_LOG_PREFIX &quot;: &quot; format &quot;\n&quot; , ## arg)</span>

<span class="cm">/**</span>
<span class="cm"> * struct dvb_usb_device_description - name and its according USB IDs</span>
<span class="cm"> * @name: real name of the box, regardless which DVB USB device class is in use</span>
<span class="cm"> * @cold_ids: array of struct usb_device_id which describe the device in</span>
<span class="cm"> *  pre-firmware state</span>
<span class="cm"> * @warm_ids: array of struct usb_device_id which describe the device in</span>
<span class="cm"> *  post-firmware state</span>
<span class="cm"> *</span>
<span class="cm"> * Each DVB USB device class can have one or more actual devices, this struct</span>
<span class="cm"> * assigns a name to it.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dvb_usb_device_description</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

<span class="cp">#define DVB_USB_ID_MAX_NUM 15</span>
	<span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">cold_ids</span><span class="p">[</span><span class="n">DVB_USB_ID_MAX_NUM</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">warm_ids</span><span class="p">[</span><span class="n">DVB_USB_ID_MAX_NUM</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">rc5_custom</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_table</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">scancode</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">rc5_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_table</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">scancode</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">rc5_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_map_table</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">scancode</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dvb_usb_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dvb_usb_adapter</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">usb_data_stream</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Properties of USB streaming - TODO this structure should be somewhere else</span>
<span class="cm"> * describes the kind of USB transfer used for data-streaming.</span>
<span class="cm"> *  (BULK or ISOC)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_data_stream_properties</span> <span class="p">{</span>
<span class="cp">#define USB_BULK  1</span>
<span class="cp">#define USB_ISOC  2</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">endpoint</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">buffersize</span><span class="p">;</span> <span class="cm">/* per URB */</span>
		<span class="p">}</span> <span class="n">bulk</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">framesperurb</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">framesize</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">interval</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">isoc</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dvb_usb_adapter_properties - properties of a dvb-usb-adapter.</span>
<span class="cm"> *    A DVB-USB-Adapter is basically a dvb_adapter which is present on a USB-device.</span>
<span class="cm"> * @caps: capabilities of the DVB USB device.</span>
<span class="cm"> * @pid_filter_count: number of PID filter position in the optional hardware</span>
<span class="cm"> *  PID-filter.</span>
<span class="cm"> * @num_frontends: number of frontends of the DVB USB adapter.</span>
<span class="cm"> * @frontend_ctrl: called to power on/off active frontend.</span>
<span class="cm"> * @streaming_ctrl: called to start and stop the MPEG2-TS streaming of the</span>
<span class="cm"> *  device (not URB submitting/killing).</span>
<span class="cm"> * @pid_filter_ctrl: called to en/disable the PID filter, if any.</span>
<span class="cm"> * @pid_filter: called to set/unset a PID for filtering.</span>
<span class="cm"> * @frontend_attach: called to attach the possible frontends (fill fe-field</span>
<span class="cm"> *  of struct dvb_usb_device).</span>
<span class="cm"> * @tuner_attach: called to attach the correct tuner and to fill pll_addr,</span>
<span class="cm"> *  pll_desc and pll_init_buf of struct dvb_usb_device).</span>
<span class="cm"> * @stream: configuration of the USB streaming</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dvb_usb_adapter_fe_properties</span> <span class="p">{</span>
<span class="cp">#define DVB_USB_ADAP_HAS_PID_FILTER               0x01</span>
<span class="cp">#define DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF 0x02</span>
<span class="cp">#define DVB_USB_ADAP_NEED_PID_FILTERING           0x04</span>
<span class="cp">#define DVB_USB_ADAP_RECEIVES_204_BYTE_TS         0x08</span>
<span class="cp">#define DVB_USB_ADAP_RECEIVES_RAW_PAYLOAD         0x10</span>
	<span class="kt">int</span> <span class="n">caps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pid_filter_count</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">streaming_ctrl</span><span class="p">)</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pid_filter_ctrl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pid_filter</span><span class="p">)</span>      <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">frontend_attach</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_adapter</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tuner_attach</span><span class="p">)</span>    <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_adapter</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">usb_data_stream_properties</span> <span class="n">stream</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">size_of_priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define MAX_NO_OF_FE_PER_ADAP 3</span>
<span class="k">struct</span> <span class="n">dvb_usb_adapter_properties</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">size_of_priv</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">frontend_ctrl</span><span class="p">)</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fe_ioctl_override</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">num_frontends</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_usb_adapter_fe_properties</span> <span class="n">fe</span><span class="p">[</span><span class="n">MAX_NO_OF_FE_PER_ADAP</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dvb_rc_legacy - old properties of remote controller</span>
<span class="cm"> * @rc_map_table: a hard-wired array of struct rc_map_table (NULL to disable</span>
<span class="cm"> *  remote control handling).</span>
<span class="cm"> * @rc_map_size: number of items in @rc_map_table.</span>
<span class="cm"> * @rc_query: called to query an event event.</span>
<span class="cm"> * @rc_interval: time in ms between two queries.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dvb_rc_legacy</span> <span class="p">{</span>
<span class="cm">/* remote control properties */</span>
<span class="cp">#define REMOTE_NO_KEY_PRESSED      0x00</span>
<span class="cp">#define REMOTE_KEY_PRESSED         0x01</span>
<span class="cp">#define REMOTE_KEY_REPEAT          0x02</span>
	<span class="k">struct</span> <span class="n">rc_map_table</span>  <span class="o">*</span><span class="n">rc_map_table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc_map_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rc_query</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc_interval</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dvb_rc properties of remote controller, using rc-core</span>
<span class="cm"> * @rc_codes: name of rc codes table</span>
<span class="cm"> * @protocol: type of protocol(s) currently used by the driver</span>
<span class="cm"> * @allowed_protos: protocol(s) supported by the driver</span>
<span class="cm"> * @driver_type: Used to point if a device supports raw mode</span>
<span class="cm"> * @change_protocol: callback to change protocol</span>
<span class="cm"> * @rc_query: called to query an event event.</span>
<span class="cm"> * @rc_interval: time in ms between two queries.</span>
<span class="cm"> * @bulk_mode: device supports bulk mode for RC (disable polling mode)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dvb_rc</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">rc_codes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">allowed_protos</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">rc_driver_type</span> <span class="n">driver_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">change_protocol</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">rc_type</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">module_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rc_query</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_device</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc_interval</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bulk_mode</span><span class="p">;</span>				<span class="cm">/* uses bulk mode */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum dvb_usb_mode - Specifies if it is using a legacy driver or a new one</span>
<span class="cm"> *		       based on rc-core</span>
<span class="cm"> * This is initialized/used only inside dvb-usb-remote.c.</span>
<span class="cm"> * It shouldn&#39;t be set by the drivers.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">dvb_usb_mode</span> <span class="p">{</span>
	<span class="n">DVB_RC_LEGACY</span><span class="p">,</span>
	<span class="n">DVB_RC_CORE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dvb_usb_device_properties - properties of a dvb-usb-device</span>
<span class="cm"> * @usb_ctrl: which USB device-side controller is in use. Needed for firmware</span>
<span class="cm"> *  download.</span>
<span class="cm"> * @firmware: name of the firmware file.</span>
<span class="cm"> * @download_firmware: called to download the firmware when the usb_ctrl is</span>
<span class="cm"> *  DEVICE_SPECIFIC.</span>
<span class="cm"> * @no_reconnect: device doesn&#39;t do a reconnect after downloading the firmware,</span>
<span class="cm"> *  so do the warm initialization right after it</span>
<span class="cm"> *</span>
<span class="cm"> * @size_of_priv: how many bytes shall be allocated for the private field</span>
<span class="cm"> *  of struct dvb_usb_device.</span>
<span class="cm"> *</span>
<span class="cm"> * @power_ctrl: called to enable/disable power of the device.</span>
<span class="cm"> * @read_mac_address: called to read the MAC address of the device.</span>
<span class="cm"> * @identify_state: called to determine the state (cold or warm), when it</span>
<span class="cm"> *  is not distinguishable by the USB IDs.</span>
<span class="cm"> *</span>
<span class="cm"> * @rc: remote controller properties</span>
<span class="cm"> *</span>
<span class="cm"> * @i2c_algo: i2c_algorithm if the device has I2CoverUSB.</span>
<span class="cm"> *</span>
<span class="cm"> * @generic_bulk_ctrl_endpoint: most of the DVB USB devices have a generic</span>
<span class="cm"> *  endpoint which received control messages with bulk transfers. When this</span>
<span class="cm"> *  is non-zero, one can use dvb_usb_generic_rw and dvb_usb_generic_write-</span>
<span class="cm"> *  helper functions.</span>
<span class="cm"> *</span>
<span class="cm"> * @generic_bulk_ctrl_endpoint_response: some DVB USB devices use a separate</span>
<span class="cm"> *  endpoint for responses to control messages sent with bulk transfers via</span>
<span class="cm"> *  the generic_bulk_ctrl_endpoint. When this is non-zero, this will be used</span>
<span class="cm"> *  instead of the generic_bulk_ctrl_endpoint when reading usb responses in</span>
<span class="cm"> *  the dvb_usb_generic_rw helper function.</span>
<span class="cm"> *</span>
<span class="cm"> * @num_device_descs: number of struct dvb_usb_device_description in @devices</span>
<span class="cm"> * @devices: array of struct dvb_usb_device_description compatibles with these</span>
<span class="cm"> *  properties.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_NO_OF_ADAPTER_PER_DEVICE 2</span>
<span class="k">struct</span> <span class="n">dvb_usb_device_properties</span> <span class="p">{</span>

<span class="cp">#define DVB_USB_IS_AN_I2C_ADAPTER            0x01</span>
	<span class="kt">int</span> <span class="n">caps</span><span class="p">;</span>

<span class="cp">#define DEVICE_SPECIFIC 0</span>
<span class="cp">#define CYPRESS_AN2135  1</span>
<span class="cp">#define CYPRESS_AN2235  2</span>
<span class="cp">#define CYPRESS_FX2     3</span>
	<span class="kt">int</span>        <span class="n">usb_ctrl</span><span class="p">;</span>
	<span class="kt">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">download_firmware</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">firmware</span><span class="p">;</span>
	<span class="kt">int</span>        <span class="n">no_reconnect</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">size_of_priv</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">num_adapters</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_usb_adapter_properties</span> <span class="n">adapter</span><span class="p">[</span><span class="n">MAX_NO_OF_ADAPTER_PER_DEVICE</span><span class="p">];</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">power_ctrl</span><span class="p">)</span>       <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_mac_address</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="p">[]);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">identify_state</span><span class="p">)</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dvb_usb_device_properties</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dvb_usb_device_description</span> <span class="o">**</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">dvb_usb_mode</span> <span class="n">mode</span><span class="p">;</span>	<span class="cm">/* Drivers shouldn&#39;t touch on it */</span>
		<span class="k">struct</span> <span class="n">dvb_rc_legacy</span> <span class="n">legacy</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dvb_rc</span> <span class="n">core</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">i2c_algorithm</span> <span class="o">*</span><span class="n">i2c_algo</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">generic_bulk_ctrl_endpoint</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">generic_bulk_ctrl_endpoint_response</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">num_device_descs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_usb_device_description</span> <span class="n">devices</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_data_stream - generic object of an USB stream</span>
<span class="cm"> * @buf_num: number of buffer allocated.</span>
<span class="cm"> * @buf_size: size of each buffer in buf_list.</span>
<span class="cm"> * @buf_list: array containing all allocate buffers for streaming.</span>
<span class="cm"> * @dma_addr: list of dma_addr_t for each buffer in buf_list.</span>
<span class="cm"> *</span>
<span class="cm"> * @urbs_initialized: number of URBs initialized.</span>
<span class="cm"> * @urbs_submitted: number of URBs submitted.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_NO_URBS_FOR_DATA_STREAM 10</span>
<span class="k">struct</span> <span class="n">usb_data_stream</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>                 <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_data_stream_properties</span>  <span class="n">props</span><span class="p">;</span>

<span class="cp">#define USB_STATE_INIT    0x00</span>
<span class="cp">#define USB_STATE_URB_BUF 0x01</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">complete</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_data_stream</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">urb</span>    <span class="o">*</span><span class="n">urb_list</span><span class="p">[</span><span class="n">MAX_NO_URBS_FOR_DATA_STREAM</span><span class="p">];</span>
	<span class="kt">int</span>            <span class="n">buf_num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">buf_size</span><span class="p">;</span>
	<span class="n">u8</span>            <span class="o">*</span><span class="n">buf_list</span><span class="p">[</span><span class="n">MAX_NO_URBS_FOR_DATA_STREAM</span><span class="p">];</span>
	<span class="n">dma_addr_t</span>     <span class="n">dma_addr</span><span class="p">[</span><span class="n">MAX_NO_URBS_FOR_DATA_STREAM</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">urbs_initialized</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">urbs_submitted</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">user_priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dvb_usb_adapter - a DVB adapter on a USB device</span>
<span class="cm"> * @id: index of this adapter (starting with 0).</span>
<span class="cm"> *</span>
<span class="cm"> * @feedcount: number of reqested feeds (used for streaming-activation)</span>
<span class="cm"> * @pid_filtering: is hardware pid_filtering used or not.</span>
<span class="cm"> *</span>
<span class="cm"> * @pll_addr: I2C address of the tuner for programming</span>
<span class="cm"> * @pll_init: array containing the initialization buffer</span>
<span class="cm"> * @pll_desc: pointer to the appropriate struct dvb_pll_desc</span>
<span class="cm"> * @tuner_pass_ctrl: called to (de)activate tuner passthru of the demod or the board</span>
<span class="cm"> *</span>
<span class="cm"> * @dvb_adap: device&#39;s dvb_adapter.</span>
<span class="cm"> * @dmxdev: device&#39;s dmxdev.</span>
<span class="cm"> * @demux: device&#39;s software demuxer.</span>
<span class="cm"> * @dvb_net: device&#39;s dvb_net interfaces.</span>
<span class="cm"> * @dvb_frontend: device&#39;s frontend.</span>
<span class="cm"> * @max_feed_count: how many feeds can be handled simultaneously by this</span>
<span class="cm"> *  device</span>
<span class="cm"> *</span>
<span class="cm"> * @fe_init:  rerouted frontend-init (wakeup) function.</span>
<span class="cm"> * @fe_sleep: rerouted frontend-sleep function.</span>
<span class="cm"> *</span>
<span class="cm"> * @stream: the usb data stream.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dvb_usb_fe_adapter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fe_init</span><span class="p">)</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fe_sleep</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">usb_data_stream</span> <span class="n">stream</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">pid_filtering</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_feed_count</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dvb_usb_adapter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dvb_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_usb_adapter_properties</span> <span class="n">props</span><span class="p">;</span>

<span class="cp">#define DVB_USB_ADAP_STATE_INIT 0x000</span>
<span class="cp">#define DVB_USB_ADAP_STATE_DVB  0x001</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">u8</span>  <span class="n">id</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">feedcount</span><span class="p">;</span>

	<span class="cm">/* dvb */</span>
	<span class="k">struct</span> <span class="n">dvb_adapter</span>   <span class="n">dvb_adap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmxdev</span>        <span class="n">dmxdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_demux</span>     <span class="n">demux</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_net</span>       <span class="n">dvb_net</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dvb_usb_fe_adapter</span> <span class="n">fe_adap</span><span class="p">[</span><span class="n">MAX_NO_OF_FE_PER_ADAP</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">active_fe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_frontends_initialized</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dvb_usb_device - object of a DVB USB device</span>
<span class="cm"> * @props: copy of the struct dvb_usb_properties this device belongs to.</span>
<span class="cm"> * @desc: pointer to the device&#39;s struct dvb_usb_device_description.</span>
<span class="cm"> * @state: initialization and runtime state of the device.</span>
<span class="cm"> *</span>
<span class="cm"> * @powered: indicated whether the device is power or not.</span>
<span class="cm"> *  Powered is in/decremented for each call to modify the state.</span>
<span class="cm"> * @udev: pointer to the device&#39;s struct usb_device.</span>
<span class="cm"> *</span>
<span class="cm"> * @usb_mutex: semaphore of USB control messages (reading needs two messages)</span>
<span class="cm"> * @i2c_mutex: semaphore for i2c-transfers</span>
<span class="cm"> *</span>
<span class="cm"> * @i2c_adap: device&#39;s i2c_adapter if it uses I2CoverUSB</span>
<span class="cm"> *</span>
<span class="cm"> * @rc_dev: rc device for the remote control (rc-core mode)</span>
<span class="cm"> * @input_dev: input device for the remote control (legacy mode)</span>
<span class="cm"> * @rc_query_work: struct work_struct frequent rc queries</span>
<span class="cm"> * @last_event: last triggered event</span>
<span class="cm"> * @last_state: last state (no, pressed, repeat)</span>
<span class="cm"> * @owner: owner of the dvb_adapter</span>
<span class="cm"> * @priv: private data of the actual driver (allocate by dvb-usb, size defined</span>
<span class="cm"> *  in size_of_priv of dvb_usb_properties).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dvb_usb_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dvb_usb_device_properties</span> <span class="n">props</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_usb_device_description</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>

<span class="cp">#define DVB_USB_STATE_INIT        0x000</span>
<span class="cp">#define DVB_USB_STATE_I2C         0x001</span>
<span class="cp">#define DVB_USB_STATE_DVB         0x002</span>
<span class="cp">#define DVB_USB_STATE_REMOTE      0x004</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">powered</span><span class="p">;</span>

	<span class="cm">/* locking */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">usb_mutex</span><span class="p">;</span>

	<span class="cm">/* i2c */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">i2c_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="n">i2c_adap</span><span class="p">;</span>

	<span class="kt">int</span>                    <span class="n">num_adapters_initialized</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_usb_adapter</span> <span class="n">adapter</span><span class="p">[</span><span class="n">MAX_NO_OF_ADAPTER_PER_DEVICE</span><span class="p">];</span>

	<span class="cm">/* remote control */</span>
	<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">rc_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">input_dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">rc_phys</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">rc_query_work</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_state</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">dvb_usb_device_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dvb_usb_device_properties</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dvb_usb_device</span> <span class="o">**</span><span class="p">,</span>
			       <span class="kt">short</span> <span class="o">*</span><span class="n">adapter_nums</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dvb_usb_device_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* the generic read/write method for device control */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dvb_usb_generic_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dvb_usb_generic_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>

<span class="cm">/* commonly used remote control parsing */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dvb_usb_nec_rc_key_to_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">[],</span> <span class="n">u32</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* commonly used firmware download types and function */</span>
<span class="k">struct</span> <span class="n">hexline</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">chk</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_cypress_load_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dvb_usb_get_hexline</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hexline</span> <span class="o">*</span><span class="n">hx</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>


<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
