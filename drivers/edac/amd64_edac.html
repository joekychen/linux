<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › edac › amd64_edac.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>amd64_edac.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &quot;amd64_edac.h&quot;</span>
<span class="cp">#include &lt;asm/amd_nb.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">amd64_ctl_pci</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">report_gart_errors</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">report_gart_errors</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Set by command line parameter. If BIOS has enabled the ECC, this override is</span>
<span class="cm"> * cleared to prevent re-enabling the hardware by this driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ecc_enable_override</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ecc_enable_override</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">msr</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">msrs</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * count successfully initialized driver instances for setup_pci_device()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">drv_instances</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Per-node driver instances */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">**</span><span class="n">mcis</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ecc_settings</span> <span class="o">**</span><span class="n">ecc_stngs</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Valid scrub rates for the K8 hardware memory scrubber. We map the scrubbing</span>
<span class="cm"> * bandwidth to a valid bit pattern. The &#39;set&#39; operation finds the &#39;matching-</span>
<span class="cm"> * or higher value&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> *FIXME: Produce a better mapping/linearisation.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">scrubrate</span> <span class="p">{</span>
       <span class="n">u32</span> <span class="n">scrubval</span><span class="p">;</span>           <span class="cm">/* bit pattern for scrub rate */</span>
       <span class="n">u32</span> <span class="n">bandwidth</span><span class="p">;</span>          <span class="cm">/* bandwidth consumed (bytes/sec) */</span>
<span class="p">}</span> <span class="n">scrubrates</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mi">1600000000UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mi">800000000UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mi">400000000UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mi">200000000UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mi">100000000UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mi">50000000UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mi">25000000UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mi">12284069UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x09</span><span class="p">,</span> <span class="mi">6274509UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x0A</span><span class="p">,</span> <span class="mi">3121951UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x0B</span><span class="p">,</span> <span class="mi">1560975UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x0C</span><span class="p">,</span> <span class="mi">781440UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x0D</span><span class="p">,</span> <span class="mi">390720UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x0E</span><span class="p">,</span> <span class="mi">195300UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x0F</span><span class="p">,</span> <span class="mi">97650UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mi">48854UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mi">24427UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x12</span><span class="p">,</span> <span class="mi">12213UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x13</span><span class="p">,</span> <span class="mi">6101UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mi">3051UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x15</span><span class="p">,</span> <span class="mi">1523UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x16</span><span class="p">,</span> <span class="mi">761UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">},</span>        <span class="cm">/* scrubbing off */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__amd64_read_pci_cfg_dword</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;%s: error reading F%dx%03x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">func</span><span class="p">,</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__amd64_write_pci_cfg_dword</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;%s: error writing to F%dx%03x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">func</span><span class="p">,</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Depending on the family, F2 DCT reads need special handling:</span>
<span class="cm"> *</span>
<span class="cm"> * K8: has a single DCT only</span>
<span class="cm"> *</span>
<span class="cm"> * F10h: each DCT has its own set of regs</span>
<span class="cm"> *	DCT0 -&gt; F2x040..</span>
<span class="cm"> *	DCT1 -&gt; F2x140..</span>
<span class="cm"> *</span>
<span class="cm"> * F15h: we select which DCT we access using F1x10C[DctCfgSel]</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">k8_read_dct_pci_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="mh">0x100</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__amd64_read_pci_cfg_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">f10_read_dct_pci_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__amd64_read_pci_cfg_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Select DCT to which PCI cfg accesses are routed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">f15h_select_dct</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">DCT_CFG_SEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="mh">0xfffffffe</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="n">dct</span><span class="p">;</span>
	<span class="n">amd64_write_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">DCT_CFG_SEL</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">f15_read_dct_pci_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">dct</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="mh">0x140</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;=</span> <span class="mh">0x1a0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dct</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="mh">0x100</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">f15h_select_dct</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">dct</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__amd64_read_pci_cfg_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Memory scrubber control interface. For K8, memory scrubbing is handled by</span>
<span class="cm"> * hardware and can involve L2 cache, dcache as well as the main memory. With</span>
<span class="cm"> * F10, this is extended to L3 cache scrubbing on CPU models sporting that</span>
<span class="cm"> * functionality.</span>
<span class="cm"> *</span>
<span class="cm"> * This causes the &quot;units&quot; for the scrubbing speed to vary from 64 byte blocks</span>
<span class="cm"> * (dram) over to cache lines. This is nasty, so we will use bandwidth in</span>
<span class="cm"> * bytes/sec for the setting.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently, we only do dram scrubbing. If the scrubbing is done in software on</span>
<span class="cm"> * other archs, we might not have access to the caches directly.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * scan the scrub rate mapping table for a close or matching bandwidth value to</span>
<span class="cm"> * issue. If requested is too big, then use last maximum value found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__amd64_set_scrub_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">ctl</span><span class="p">,</span> <span class="n">u32</span> <span class="n">new_bw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">min_rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">scrubval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * map the configured rate (new_bw) to a value specific to the AMD64</span>
<span class="cm">	 * memory controller and apply to register. Search for the first</span>
<span class="cm">	 * bandwidth entry that is greater or equal than the setting requested</span>
<span class="cm">	 * and program that. If at last entry, turn off DRAM scrubbing.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">scrubrates</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * skip scrub rates which aren&#39;t recommended</span>
<span class="cm">		 * (see F10 BKDG, F3x58)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scrubrates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">scrubval</span> <span class="o">&lt;</span> <span class="n">min_rate</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scrubrates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bandwidth</span> <span class="o">&lt;=</span> <span class="n">new_bw</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if no suitable bandwidth found, turn off DRAM scrubbing</span>
<span class="cm">		 * entirely by falling back to the last element in the</span>
<span class="cm">		 * scrubrates array.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="n">scrubval</span> <span class="o">=</span> <span class="n">scrubrates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">scrubval</span><span class="p">;</span>

	<span class="n">pci_write_bits32</span><span class="p">(</span><span class="n">ctl</span><span class="p">,</span> <span class="n">SCRCTRL</span><span class="p">,</span> <span class="n">scrubval</span><span class="p">,</span> <span class="mh">0x001F</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scrubval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">scrubrates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bandwidth</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">amd64_set_scrub_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min_scrubrate</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span><span class="p">)</span>
		<span class="n">min_scrubrate</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="cm">/* F15h Erratum #505 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x15</span><span class="p">)</span>
		<span class="n">f15h_select_dct</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__amd64_set_scrub_rate</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F3</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">min_scrubrate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">amd64_get_scrub_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">scrubval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* F15h Erratum #505 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x15</span><span class="p">)</span>
		<span class="n">f15h_select_dct</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F3</span><span class="p">,</span> <span class="n">SCRCTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scrubval</span><span class="p">);</span>

	<span class="n">scrubval</span> <span class="o">=</span> <span class="n">scrubval</span> <span class="o">&amp;</span> <span class="mh">0x001F</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">scrubrates</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scrubrates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">scrubval</span> <span class="o">==</span> <span class="n">scrubval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">scrubrates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bandwidth</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns true if the SysAddr given by sys_addr matches the</span>
<span class="cm"> * DRAM base/limit associated with node_id</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">amd64_base_limit_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/* The K8 treats this as a 40-bit value.  However, bits 63-40 will be</span>
<span class="cm">	 * all ones if the most significant implemented address bit is 1.</span>
<span class="cm">	 * Here we discard bits 63-40.  See section 3.4.2 of AMD publication</span>
<span class="cm">	 * 24592: AMD x86-64 Architecture Programmer&#39;s Manual Volume 1</span>
<span class="cm">	 * Application Programming.</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">sys_addr</span> <span class="o">&amp;</span> <span class="mh">0x000000ffffffffffull</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">get_dram_base</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">nid</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">addr</span> <span class="o">&lt;=</span> <span class="n">get_dram_limit</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">nid</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to map a SysAddr to a node. On success, return a pointer to the</span>
<span class="cm"> * mem_ctl_info structure for the node that the SysAddr maps to.</span>
<span class="cm"> *</span>
<span class="cm"> * On failure, return NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="nf">find_mc_by_sys_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
						<span class="n">u64</span> <span class="n">sys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">node_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intlv_en</span><span class="p">,</span> <span class="n">bits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here we use the DRAM Base (section 3.4.4.1) and DRAM Limit (section</span>
<span class="cm">	 * 3.4.4.2) registers to map the SysAddr to a node ID.</span>
<span class="cm">	 */</span>
	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The value of this field should be the same for all DRAM Base</span>
<span class="cm">	 * registers.  Therefore we arbitrarily choose to read it from the</span>
<span class="cm">	 * register for node 0.</span>
<span class="cm">	 */</span>
	<span class="n">intlv_en</span> <span class="o">=</span> <span class="n">dram_intlv_en</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intlv_en</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">node_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">node_id</span> <span class="o">&lt;</span> <span class="n">DRAM_RANGES</span><span class="p">;</span> <span class="n">node_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">amd64_base_limit_match</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">,</span> <span class="n">node_id</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">err_no_match</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">intlv_en</span> <span class="o">!=</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">intlv_en</span> <span class="o">!=</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">intlv_en</span> <span class="o">!=</span> <span class="mh">0x07</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;DRAM Base[IntlvEn] junk value: 0x%x, BIOS bug?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">intlv_en</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bits</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span> <span class="n">sys_addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">intlv_en</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">node_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dram_intlv_sel</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">intlv_en</span><span class="p">)</span> <span class="o">==</span> <span class="n">bits</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* intlv_sel field matches */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">node_id</span> <span class="o">&gt;=</span> <span class="n">DRAM_RANGES</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_no_match</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* sanity test for sys_addr */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">amd64_base_limit_match</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;%s: sys_addr 0x%llx falls outside base/limit address&quot;</span>
			   <span class="s">&quot;range for node %d with node interleaving enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">,</span> <span class="n">node_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">found:</span>
	<span class="k">return</span> <span class="n">edac_mc_find</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">node_id</span><span class="p">);</span>

<span class="nl">err_no_match:</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;sys_addr 0x%lx doesn&#39;t match any node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sys_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute the CS base address of the @csrow on the DRAM controller @dct.</span>
<span class="cm"> * For details see F2x[5C:40] in the processor&#39;s BKDG</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_cs_base_and_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">csrow</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dct</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">csbase</span><span class="p">,</span> <span class="n">csmask</span><span class="p">,</span> <span class="n">base_bits</span><span class="p">,</span> <span class="n">mask_bits</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">addr_shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span> <span class="o">&amp;&amp;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">&lt;</span> <span class="n">K8_REV_F</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">csbase</span>		<span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="n">dct</span><span class="p">].</span><span class="n">csbases</span><span class="p">[</span><span class="n">csrow</span><span class="p">];</span>
		<span class="n">csmask</span>		<span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="n">dct</span><span class="p">].</span><span class="n">csmasks</span><span class="p">[</span><span class="n">csrow</span><span class="p">];</span>
		<span class="n">base_bits</span>	<span class="o">=</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span> <span class="o">|</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
		<span class="n">mask_bits</span>	<span class="o">=</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">29</span><span class="p">)</span> <span class="o">|</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
		<span class="n">addr_shift</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">csbase</span>		<span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="n">dct</span><span class="p">].</span><span class="n">csbases</span><span class="p">[</span><span class="n">csrow</span><span class="p">];</span>
		<span class="n">csmask</span>		<span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="n">dct</span><span class="p">].</span><span class="n">csmasks</span><span class="p">[</span><span class="n">csrow</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">addr_shift</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x15</span><span class="p">)</span>
			<span class="n">base_bits</span> <span class="o">=</span> <span class="n">mask_bits</span> <span class="o">=</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span> <span class="o">|</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">13</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">base_bits</span> <span class="o">=</span> <span class="n">mask_bits</span> <span class="o">=</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span><span class="mi">28</span><span class="p">)</span> <span class="o">|</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">13</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">base</span>  <span class="o">=</span> <span class="p">(</span><span class="n">csbase</span> <span class="o">&amp;</span> <span class="n">base_bits</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">addr_shift</span><span class="p">;</span>

	<span class="o">*</span><span class="n">mask</span>  <span class="o">=</span> <span class="o">~</span><span class="mi">0ULL</span><span class="p">;</span>
	<span class="cm">/* poke holes for the csmask */</span>
	<span class="o">*</span><span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">mask_bits</span> <span class="o">&lt;&lt;</span> <span class="n">addr_shift</span><span class="p">);</span>
	<span class="cm">/* OR them in */</span>
	<span class="o">*</span><span class="n">mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">csmask</span> <span class="o">&amp;</span> <span class="n">mask_bits</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">addr_shift</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define for_each_chip_select(i, dct, pvt) \</span>
<span class="cp">	for (i = 0; i &lt; pvt-&gt;csels[dct].b_cnt; i++)</span>

<span class="cp">#define chip_select_base(i, dct, pvt) \</span>
<span class="cp">	pvt-&gt;csels[dct].csbases[i]</span>

<span class="cp">#define for_each_chip_select_mask(i, dct, pvt) \</span>
<span class="cp">	for (i = 0; i &lt; pvt-&gt;csels[dct].m_cnt; i++)</span>

<span class="cm">/*</span>
<span class="cm"> * @input_addr is an InputAddr associated with the node given by mci. Return the</span>
<span class="cm"> * csrow that input_addr maps to, or -1 on failure (no csrow claims input_addr).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">input_addr_to_csrow</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u64</span> <span class="n">input_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csrow</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">base</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">for_each_chip_select</span><span class="p">(</span><span class="n">csrow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pvt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">csrow_enabled</span><span class="p">(</span><span class="n">csrow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pvt</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">get_cs_base_and_mask</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">csrow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>

		<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">input_addr</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">base</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;InputAddr 0x%lx matches csrow %d (node %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">input_addr</span><span class="p">,</span> <span class="n">csrow</span><span class="p">,</span>
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">csrow</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;no matching csrow for InputAddr 0x%lx (MC node %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">input_addr</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Obtain info from the DRAM Hole Address Register (section 3.4.8, pub #26094)</span>
<span class="cm"> * for the node represented by mci. Info is passed back in *hole_base,</span>
<span class="cm"> * *hole_offset, and *hole_size.  Function returns 0 if info is valid or 1 if</span>
<span class="cm"> * info is invalid. Info may be invalid for either of the following reasons:</span>
<span class="cm"> *</span>
<span class="cm"> * - The revision of the node is not E or greater.  In this case, the DRAM Hole</span>
<span class="cm"> *   Address Register does not exist.</span>
<span class="cm"> *</span>
<span class="cm"> * - The DramHoleValid bit is cleared in the DRAM Hole Address Register,</span>
<span class="cm"> *   indicating that its contents are not valid.</span>
<span class="cm"> *</span>
<span class="cm"> * The values passed back in *hole_base, *hole_offset, and *hole_size are</span>
<span class="cm"> * complete 32-bit values despite the fact that the bitfields in the DHAR</span>
<span class="cm"> * only represent bits 31-24 of the base and offset values.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">amd64_get_dram_hole_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">hole_base</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="o">*</span><span class="n">hole_offset</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">hole_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">base</span><span class="p">;</span>

	<span class="cm">/* only revE and later have the DRAM Hole Address Register */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span> <span class="o">&amp;&amp;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">&lt;</span> <span class="n">K8_REV_E</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  revision %d for node %d does not support DHAR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* valid for Fam10h and above */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mh">0x10</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dhar_mem_hoist_valid</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  Dram Memory Hoisting is DISABLED on this system</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dhar_valid</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  Dram Memory Hoisting is DISABLED on this node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This node has Memory Hoisting */</span>

	<span class="cm">/* +------------------+--------------------+--------------------+-----</span>
<span class="cm">	 * | memory           | DRAM hole          | relocated          |</span>
<span class="cm">	 * | [0, (x - 1)]     | [x, 0xffffffff]    | addresses from     |</span>
<span class="cm">	 * |                  |                    | DRAM hole          |</span>
<span class="cm">	 * |                  |                    | [0x100000000,      |</span>
<span class="cm">	 * |                  |                    |  (0x100000000+     |</span>
<span class="cm">	 * |                  |                    |   (0xffffffff-x))] |</span>
<span class="cm">	 * +------------------+--------------------+--------------------+-----</span>
<span class="cm">	 *</span>
<span class="cm">	 * Above is a diagram of physical memory showing the DRAM hole and the</span>
<span class="cm">	 * relocated addresses from the DRAM hole.  As shown, the DRAM hole</span>
<span class="cm">	 * starts at address x (the base address) and extends through address</span>
<span class="cm">	 * 0xffffffff.  The DRAM Hole Address Register (DHAR) relocates the</span>
<span class="cm">	 * addresses in the hole so that they start at 0x100000000.</span>
<span class="cm">	 */</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">dhar_base</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

	<span class="o">*</span><span class="n">hole_base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="o">*</span><span class="n">hole_size</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;</span> <span class="mh">0xf</span><span class="p">)</span>
		<span class="o">*</span><span class="n">hole_offset</span> <span class="o">=</span> <span class="n">f10_dhar_offset</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">hole_offset</span> <span class="o">=</span> <span class="n">k8_dhar_offset</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  DHAR info for node %d base 0x%lx offset 0x%lx size 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">hole_base</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">hole_offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">hole_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">amd64_get_dram_hole_info</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return the DramAddr that the SysAddr given by @sys_addr maps to.  It is</span>
<span class="cm"> * assumed that sys_addr maps to the node given by mci.</span>
<span class="cm"> *</span>
<span class="cm"> * The first part of section 3.4.4 (p. 70) shows how the DRAM Base (section</span>
<span class="cm"> * 3.4.4.1) and DRAM Limit (section 3.4.4.2) registers are used to translate a</span>
<span class="cm"> * SysAddr to a DramAddr. If the DRAM Hole Address Register (DHAR) is enabled,</span>
<span class="cm"> * then it is also involved in translating a SysAddr to a DramAddr. Sections</span>
<span class="cm"> * 3.4.8 and 3.5.8.2 describe the DHAR and how it is used for memory hoisting.</span>
<span class="cm"> * These parts of the documentation are unclear. I interpret them as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * When node n receives a SysAddr, it processes the SysAddr as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. It extracts the DRAMBase and DRAMLimit values from the DRAM Base and DRAM</span>
<span class="cm"> *    Limit registers for node n. If the SysAddr is not within the range</span>
<span class="cm"> *    specified by the base and limit values, then node n ignores the Sysaddr</span>
<span class="cm"> *    (since it does not map to node n). Otherwise continue to step 2 below.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. If the DramHoleValid bit of the DHAR for node n is clear, the DHAR is</span>
<span class="cm"> *    disabled so skip to step 3 below. Otherwise see if the SysAddr is within</span>
<span class="cm"> *    the range of relocated addresses (starting at 0x100000000) from the DRAM</span>
<span class="cm"> *    hole. If not, skip to step 3 below. Else get the value of the</span>
<span class="cm"> *    DramHoleOffset field from the DHAR. To obtain the DramAddr, subtract the</span>
<span class="cm"> *    offset defined by this value from the SysAddr.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. Obtain the base address for node n from the DRAMBase field of the DRAM</span>
<span class="cm"> *    Base register for node n. To obtain the DramAddr, subtract the base</span>
<span class="cm"> *    address from the SysAddr, as shown near the start of section 3.4.4 (p.70).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">sys_addr_to_dram_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dram_base</span><span class="p">,</span> <span class="n">hole_base</span><span class="p">,</span> <span class="n">hole_offset</span><span class="p">,</span> <span class="n">hole_size</span><span class="p">,</span> <span class="n">dram_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dram_base</span> <span class="o">=</span> <span class="n">get_dram_base</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">amd64_get_dram_hole_info</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hole_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hole_offset</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">hole_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sys_addr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sys_addr</span> <span class="o">&lt;</span> <span class="p">((</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="n">hole_size</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* use DHAR to translate SysAddr to DramAddr */</span>
			<span class="n">dram_addr</span> <span class="o">=</span> <span class="n">sys_addr</span> <span class="o">-</span> <span class="n">hole_offset</span><span class="p">;</span>

			<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;using DHAR to translate SysAddr 0x%lx to &quot;</span>
				<span class="s">&quot;DramAddr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sys_addr</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dram_addr</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">dram_addr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Translate the SysAddr to a DramAddr as shown near the start of</span>
<span class="cm">	 * section 3.4.4 (p. 70).  Although sys_addr is a 64-bit value, the k8</span>
<span class="cm">	 * only deals with 40-bit values.  Therefore we discard bits 63-40 of</span>
<span class="cm">	 * sys_addr below.  If bit 39 of sys_addr is 1 then the bits we</span>
<span class="cm">	 * discard are all 1s.  Otherwise the bits we discard are all 0s.  See</span>
<span class="cm">	 * section 3.4.2 of AMD publication 24592: AMD x86-64 Architecture</span>
<span class="cm">	 * Programmer&#39;s Manual Volume 1 Application Programming.</span>
<span class="cm">	 */</span>
	<span class="n">dram_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sys_addr</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">39</span><span class="p">))</span> <span class="o">-</span> <span class="n">dram_base</span><span class="p">;</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;using DRAM Base register to translate SysAddr 0x%lx to &quot;</span>
		<span class="s">&quot;DramAddr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sys_addr</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dram_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dram_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @intlv_en is the value of the IntlvEn field from a DRAM Base register</span>
<span class="cm"> * (section 3.4.4.1).  Return the number of bits from a SysAddr that are used</span>
<span class="cm"> * for node interleaving.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">num_node_interleave_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">intlv_en</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">intlv_shift_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">intlv_en</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">intlv_shift_table</span><span class="p">[</span><span class="n">intlv_en</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Translate the DramAddr given by @dram_addr to an InputAddr. */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">dram_addr_to_input_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dram_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">intlv_shift</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">input_addr</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * See the start of section 3.4.4 (p. 70, BKDG #26094, K8, revA-E)</span>
<span class="cm">	 * concerning translating a DramAddr to an InputAddr.</span>
<span class="cm">	 */</span>
	<span class="n">intlv_shift</span> <span class="o">=</span> <span class="n">num_node_interleave_bits</span><span class="p">(</span><span class="n">dram_intlv_en</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">input_addr</span> <span class="o">=</span> <span class="p">((</span><span class="n">dram_addr</span> <span class="o">&gt;&gt;</span> <span class="n">intlv_shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">35</span><span class="p">))</span> <span class="o">+</span>
		      <span class="p">(</span><span class="n">dram_addr</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">);</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;  Intlv Shift=%d DramAddr=0x%lx maps to InputAddr=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">intlv_shift</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dram_addr</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">input_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">input_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Translate the SysAddr represented by @sys_addr to an InputAddr.  It is</span>
<span class="cm"> * assumed that @sys_addr maps to the node given by mci.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">sys_addr_to_input_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">input_addr</span><span class="p">;</span>

	<span class="n">input_addr</span> <span class="o">=</span>
	    <span class="n">dram_addr_to_input_addr</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">sys_addr_to_dram_addr</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">));</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;SysAdddr 0x%lx translates to InputAddr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sys_addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">input_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">input_addr</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * @input_addr is an InputAddr associated with the node represented by mci.</span>
<span class="cm"> * Translate @input_addr to a DramAddr and return the result.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">input_addr_to_dram_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u64</span> <span class="n">input_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">intlv_shift</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bits</span><span class="p">,</span> <span class="n">dram_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intlv_sel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Near the start of section 3.4.4 (p. 70, BKDG #26094, K8, revA-E)</span>
<span class="cm">	 * shows how to translate a DramAddr to an InputAddr. Here we reverse</span>
<span class="cm">	 * this procedure. When translating from a DramAddr to an InputAddr, the</span>
<span class="cm">	 * bits used for node interleaving are discarded.  Here we recover these</span>
<span class="cm">	 * bits from the IntlvSel field of the DRAM Limit register (section</span>
<span class="cm">	 * 3.4.4.2) for the node that input_addr is associated with.</span>
<span class="cm">	 */</span>
	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">node_id</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">node_id</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">);</span>

	<span class="n">intlv_shift</span> <span class="o">=</span> <span class="n">num_node_interleave_bits</span><span class="p">(</span><span class="n">dram_intlv_en</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intlv_shift</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;    InputAddr 0x%lx translates to DramAddr of &quot;</span>
			<span class="s">&quot;same value</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>	<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">input_addr</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">input_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">input_addr</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">35</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">intlv_shift</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">input_addr</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">);</span>

	<span class="n">intlv_sel</span> <span class="o">=</span> <span class="n">dram_intlv_sel</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">intlv_shift</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dram_addr</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="p">(</span><span class="n">intlv_sel</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;InputAddr 0x%lx translates to DramAddr 0x%lx &quot;</span>
		<span class="s">&quot;(%d node interleave bits)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">input_addr</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dram_addr</span><span class="p">,</span> <span class="n">intlv_shift</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dram_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @dram_addr is a DramAddr that maps to the node represented by mci. Convert</span>
<span class="cm"> * @dram_addr to a SysAddr.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">dram_addr_to_sys_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dram_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hole_base</span><span class="p">,</span> <span class="n">hole_offset</span><span class="p">,</span> <span class="n">hole_size</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">amd64_get_dram_hole_info</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hole_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hole_offset</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">hole_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dram_addr</span> <span class="o">&gt;=</span> <span class="n">hole_base</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">dram_addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">hole_base</span> <span class="o">+</span> <span class="n">hole_size</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">sys_addr</span> <span class="o">=</span> <span class="n">dram_addr</span> <span class="o">+</span> <span class="n">hole_offset</span><span class="p">;</span>

			<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;using DHAR to translate DramAddr 0x%lx to &quot;</span>
				<span class="s">&quot;SysAddr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dram_addr</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sys_addr</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">sys_addr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">base</span>     <span class="o">=</span> <span class="n">get_dram_base</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">);</span>
	<span class="n">sys_addr</span> <span class="o">=</span> <span class="n">dram_addr</span> <span class="o">+</span> <span class="n">base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The sys_addr we have computed up to this point is a 40-bit value</span>
<span class="cm">	 * because the k8 deals with 40-bit values.  However, the value we are</span>
<span class="cm">	 * supposed to return is a full 64-bit physical address.  The AMD</span>
<span class="cm">	 * x86-64 architecture specifies that the most significant implemented</span>
<span class="cm">	 * address bit through bit 63 of a physical address must be either all</span>
<span class="cm">	 * 0s or all 1s.  Therefore we sign-extend the 40-bit sys_addr to a</span>
<span class="cm">	 * 64-bit value below.  See section 3.4.2 of AMD publication 24592:</span>
<span class="cm">	 * AMD x86-64 Architecture Programmer&#39;s Manual Volume 1 Application</span>
<span class="cm">	 * Programming.</span>
<span class="cm">	 */</span>
	<span class="n">sys_addr</span> <span class="o">|=</span> <span class="o">~</span><span class="p">((</span><span class="n">sys_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">39</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;    Node %d, DramAddr 0x%lx to SysAddr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dram_addr</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sys_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sys_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @input_addr is an InputAddr associated with the node given by mci. Translate</span>
<span class="cm"> * @input_addr to a SysAddr.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">input_addr_to_sys_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
					 <span class="n">u64</span> <span class="n">input_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dram_addr_to_sys_addr</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span>
				     <span class="n">input_addr_to_dram_addr</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">input_addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Map the Error address to a PAGE and PAGE OFFSET. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">error_address_to_page_and_offset</span><span class="p">(</span><span class="n">u64</span> <span class="n">error_address</span><span class="p">,</span>
						    <span class="n">u32</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">error_address</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">error_address</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @sys_addr is an error address (a SysAddr) extracted from the MCA NB Address</span>
<span class="cm"> * Low (section 3.6.4.5) and MCA NB Address High (section 3.6.4.6) registers</span>
<span class="cm"> * of a node that detected an ECC memory error.  mci represents the node that</span>
<span class="cm"> * the error address maps to (possibly different from the node that detected</span>
<span class="cm"> * the error).  Return the number of the csrow that sys_addr maps to, or -1 on</span>
<span class="cm"> * error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sys_addr_to_csrow</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">csrow</span><span class="p">;</span>

	<span class="n">csrow</span> <span class="o">=</span> <span class="n">input_addr_to_csrow</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">sys_addr_to_input_addr</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">csrow</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">amd64_mc_err</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="s">&quot;Failed to translate InputAddr to csrow for &quot;</span>
				  <span class="s">&quot;address 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sys_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">csrow</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">get_channel_from_ecc_syndrome</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if the DIMMs have ECC enabled. ECC is enabled ONLY if all the DIMMs</span>
<span class="cm"> * are ECC capable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">amd64_determine_edac_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">bit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">edac_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>

	<span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;</span> <span class="mh">0xf</span> <span class="o">||</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">&gt;=</span> <span class="n">K8_REV_F</span><span class="p">)</span>
		<span class="o">?</span> <span class="mi">19</span>
		<span class="o">:</span> <span class="mi">17</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">bit</span><span class="p">))</span>
		<span class="n">edac_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_SECDED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">edac_cap</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">amd64_debug_display_dimm_sizes</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">amd64_dump_dramcfg_low</span><span class="p">(</span><span class="n">u32</span> <span class="n">dclr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;F2x%d90 (DRAM Cfg Low): 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">dclr</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  DIMM type: %sbuffered; all DIMMs support ECC: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span> <span class="o">?</span>  <span class="s">&quot;un&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  PAR/ERR parity: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="o">?</span>  <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x10</span><span class="p">)</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  DCT 128bit mode width: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span> <span class="o">?</span>  <span class="s">&quot;128b&quot;</span> <span class="o">:</span> <span class="s">&quot;64b&quot;</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  x4 logical DIMMs present: L0: %s L1: %s L2: %s L3: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span> <span class="o">?</span>  <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span> <span class="o">?</span>  <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span> <span class="o">?</span>  <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span> <span class="o">?</span>  <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Display and decode various NB registers for debug purposes. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_misc_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;F3xE8 (NB Cap): 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcap</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  NB two channel DRAM capable: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcap</span> <span class="o">&amp;</span> <span class="n">NBCAP_DCT_DUAL</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  ECC capable: %s, ChipKill ECC capable: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcap</span> <span class="o">&amp;</span> <span class="n">NBCAP_SECDED</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcap</span> <span class="o">&amp;</span> <span class="n">NBCAP_CHIPKILL</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">);</span>

	<span class="n">amd64_dump_dramcfg_low</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;F3xB0 (Online Spare): 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">online_spare</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;F1xF0 (DRAM Hole Address): 0x%08x, base: 0x%08x, &quot;</span>
			<span class="s">&quot;offset: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dhar</span><span class="p">,</span> <span class="n">dhar_base</span><span class="p">(</span><span class="n">pvt</span><span class="p">),</span>
			<span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">?</span> <span class="n">k8_dhar_offset</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span>
						   <span class="o">:</span> <span class="n">f10_dhar_offset</span><span class="p">(</span><span class="n">pvt</span><span class="p">));</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  DramHoleValid: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dhar_valid</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">);</span>

	<span class="n">amd64_debug_display_dimm_sizes</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* everything below this point is Fam10h and above */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">amd64_debug_display_dimm_sizes</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">amd64_info</span><span class="p">(</span><span class="s">&quot;using %s syndromes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">((</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ecc_sym_sz</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;x8&quot;</span> <span class="o">:</span> <span class="s">&quot;x4&quot;</span><span class="p">));</span>

	<span class="cm">/* Only if NOT ganged does dclr1 have valid info */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span>
		<span class="n">amd64_dump_dramcfg_low</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * see BKDG, F2x[1,0][5C:40], F2[1,0][6C:60]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">prep_chip_selects</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span> <span class="o">&amp;&amp;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">&lt;</span> <span class="n">K8_REV_F</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">b_cnt</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">b_cnt</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_cnt</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_cnt</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">b_cnt</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">b_cnt</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_cnt</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_cnt</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function 2 Offset F10_DCSB0; read in the DCS Base and DCS Mask registers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_dct_base_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cs</span><span class="p">;</span>

	<span class="n">prep_chip_selects</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

	<span class="n">for_each_chip_select</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pvt</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">reg0</span>   <span class="o">=</span> <span class="n">DCSB0</span> <span class="o">+</span> <span class="p">(</span><span class="n">cs</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">reg1</span>   <span class="o">=</span> <span class="n">DCSB1</span> <span class="o">+</span> <span class="p">(</span><span class="n">cs</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">base0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">csbases</span><span class="p">[</span><span class="n">cs</span><span class="p">];</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">base1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">csbases</span><span class="p">[</span><span class="n">cs</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">reg0</span><span class="p">,</span> <span class="n">base0</span><span class="p">))</span>
			<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;  DCSB0[%d]=0x%08x reg: F2x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cs</span><span class="p">,</span> <span class="o">*</span><span class="n">base0</span><span class="p">,</span> <span class="n">reg0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span> <span class="o">||</span> <span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">base1</span><span class="p">))</span>
			<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;  DCSB1[%d]=0x%08x reg: F2x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cs</span><span class="p">,</span> <span class="o">*</span><span class="n">base1</span><span class="p">,</span> <span class="n">reg1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">for_each_chip_select_mask</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pvt</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">reg0</span>   <span class="o">=</span> <span class="n">DCSM0</span> <span class="o">+</span> <span class="p">(</span><span class="n">cs</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">reg1</span>   <span class="o">=</span> <span class="n">DCSM1</span> <span class="o">+</span> <span class="p">(</span><span class="n">cs</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">mask0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">csmasks</span><span class="p">[</span><span class="n">cs</span><span class="p">];</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">mask1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">csmasks</span><span class="p">[</span><span class="n">cs</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">reg0</span><span class="p">,</span> <span class="n">mask0</span><span class="p">))</span>
			<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;    DCSM0[%d]=0x%08x reg: F2x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cs</span><span class="p">,</span> <span class="o">*</span><span class="n">mask0</span><span class="p">,</span> <span class="n">reg0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span> <span class="o">||</span> <span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">mask1</span><span class="p">))</span>
			<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;    DCSM1[%d]=0x%08x reg: F2x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cs</span><span class="p">,</span> <span class="o">*</span><span class="n">mask1</span><span class="p">,</span> <span class="n">reg1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">mem_type</span> <span class="nf">amd64_determine_memory_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">mem_type</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* F15h supports only DDR3 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mh">0x15</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span> <span class="o">?</span>	<span class="n">MEM_DDR3</span> <span class="o">:</span> <span class="n">MEM_RDDR3</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x10</span> <span class="o">||</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">&gt;=</span> <span class="n">K8_REV_F</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dchr0</span> <span class="o">&amp;</span> <span class="n">DDR3_MODE</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span> <span class="o">?</span>	<span class="n">MEM_DDR3</span> <span class="o">:</span> <span class="n">MEM_RDDR3</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span> <span class="o">?</span> <span class="n">MEM_DDR2</span> <span class="o">:</span> <span class="n">MEM_RDDR2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">18</span><span class="p">))</span> <span class="o">?</span> <span class="n">MEM_DDR</span> <span class="o">:</span> <span class="n">MEM_RDDR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">amd64_info</span><span class="p">(</span><span class="s">&quot;CS%d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">edac_mem_types</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the number of DCT channels the memory controller is using. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">k8_early_channel_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">&gt;=</span> <span class="n">K8_REV_F</span><span class="p">)</span>
		<span class="cm">/* RevF (NPT) and later */</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span> <span class="o">&amp;</span> <span class="n">WIDTH_128</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* RevE and earlier */</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span> <span class="o">&amp;</span> <span class="n">REVE_WIDTH_128</span><span class="p">;</span>

	<span class="cm">/* not used */</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* On F10h and later ErrAddr is MC4_ADDR[47:1] */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">get_error_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">start_bit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">end_bit</span>   <span class="o">=</span> <span class="mi">47</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_bit</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">end_bit</span>   <span class="o">=</span> <span class="mi">39</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="n">start_bit</span><span class="p">,</span> <span class="n">end_bit</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Erratum 637 workaround</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x15</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">cc6_base</span><span class="p">,</span> <span class="n">tmp_addr</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">mce_nid</span><span class="p">,</span> <span class="n">intlv_en</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">47</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span> <span class="o">!=</span> <span class="mh">0x00fdf7</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

		<span class="n">mce_nid</span>	<span class="o">=</span> <span class="n">amd_get_nb_id</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">extcpu</span><span class="p">);</span>
		<span class="n">pvt</span>	<span class="o">=</span> <span class="n">mcis</span><span class="p">[</span><span class="n">mce_nid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

		<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">DRAM_LOCAL_NODE_LIM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">intlv_en</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>

		<span class="cm">/* add [47:27] + 3 trailing bits */</span>
		<span class="n">cc6_base</span>  <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

		<span class="cm">/* reverse and add DramIntlvEn */</span>
		<span class="n">cc6_base</span> <span class="o">|=</span> <span class="n">intlv_en</span> <span class="o">^</span> <span class="mh">0x7</span><span class="p">;</span>

		<span class="cm">/* pin at [47:24] */</span>
		<span class="n">cc6_base</span> <span class="o">&lt;&lt;=</span> <span class="mi">24</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intlv_en</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cc6_base</span> <span class="o">|</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">));</span>

		<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">DRAM_LOCAL_NODE_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>

							<span class="cm">/* faster log2 */</span>
		<span class="n">tmp_addr</span>  <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">23</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">__fls</span><span class="p">(</span><span class="n">intlv_en</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* OR DramIntlvSel into bits [14:12] */</span>
		<span class="n">tmp_addr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">23</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>

		<span class="cm">/* add remaining [11:0] bits from original MC4_ADDR */</span>
		<span class="n">tmp_addr</span> <span class="o">|=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">cc6_base</span> <span class="o">|</span> <span class="n">tmp_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_dram_base_limit_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">range</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">DRAM_BASE_LO</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">range</span><span class="p">].</span><span class="n">base</span><span class="p">.</span><span class="n">lo</span><span class="p">);</span>
	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">DRAM_LIMIT_LO</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">range</span><span class="p">].</span><span class="n">lim</span><span class="p">.</span><span class="n">lo</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dram_rw</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">DRAM_BASE_HI</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">range</span><span class="p">].</span><span class="n">base</span><span class="p">.</span><span class="n">hi</span><span class="p">);</span>
	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">DRAM_LIMIT_HI</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">range</span><span class="p">].</span><span class="n">lim</span><span class="p">.</span><span class="n">hi</span><span class="p">);</span>

	<span class="cm">/* Factor in CC6 save area by reading dst node&#39;s limit reg */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x15</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">f1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">dram_dst_node</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">llim</span><span class="p">;</span>

		<span class="n">f1</span> <span class="o">=</span> <span class="n">pci_get_domain_bus_and_slot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="mh">0x18</span> <span class="o">+</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">f1</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">DRAM_LOCAL_NODE_LIM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">llim</span><span class="p">);</span>

		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">range</span><span class="p">].</span><span class="n">lim</span><span class="p">.</span><span class="n">lo</span> <span class="o">&amp;=</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>

					    <span class="cm">/* {[39:27],111b} */</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">range</span><span class="p">].</span><span class="n">lim</span><span class="p">.</span><span class="n">lo</span> <span class="o">|=</span> <span class="p">((</span><span class="n">llim</span> <span class="o">&amp;</span> <span class="mh">0x1fff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span> <span class="o">|</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">range</span><span class="p">].</span><span class="n">lim</span><span class="p">.</span><span class="n">hi</span> <span class="o">&amp;=</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>

					    <span class="cm">/* [47:40] */</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">range</span><span class="p">].</span><span class="n">lim</span><span class="p">.</span><span class="n">hi</span> <span class="o">|=</span> <span class="n">llim</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">;</span>

		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">k8_map_sysaddr_to_csrow</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">,</span>
				    <span class="n">u16</span> <span class="n">syndrome</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">src_mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="n">csrow</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">error_address_to_page_and_offset</span><span class="p">(</span><span class="n">sys_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find out which node the error address belongs to. This may be</span>
<span class="cm">	 * different from the node that detected the error.</span>
<span class="cm">	 */</span>
	<span class="n">src_mci</span> <span class="o">=</span> <span class="n">find_mc_by_sys_addr</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src_mci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amd64_mc_err</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="s">&quot;failed to map error addr 0x%lx to a node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sys_addr</span><span class="p">);</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				     <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">,</span>
				     <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				     <span class="n">EDAC_MOD_STR</span><span class="p">,</span>
				     <span class="s">&quot;failed to map error addr to a node&quot;</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now map the sys_addr to a CSROW */</span>
	<span class="n">csrow</span> <span class="o">=</span> <span class="n">sys_addr_to_csrow</span><span class="p">(</span><span class="n">src_mci</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csrow</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				     <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">,</span>
				     <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				     <span class="n">EDAC_MOD_STR</span><span class="p">,</span>
				     <span class="s">&quot;failed to map error addr to a csrow&quot;</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* CHIPKILL enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcfg</span> <span class="o">&amp;</span> <span class="n">NBCFG_CHIPKILL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">get_channel_from_ecc_syndrome</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Syndrome didn&#39;t map, so we don&#39;t know which of the</span>
<span class="cm">			 * 2 DIMMs is in error. So we need to ID &#39;both&#39; of them</span>
<span class="cm">			 * as suspect.</span>
<span class="cm">			 */</span>
			<span class="n">amd64_mc_warn</span><span class="p">(</span><span class="n">src_mci</span><span class="p">,</span> <span class="s">&quot;unknown syndrome 0x%04x - &quot;</span>
				      <span class="s">&quot;possible error reporting race</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">syndrome</span><span class="p">);</span>
			<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
					     <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">,</span>
					     <span class="n">csrow</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					     <span class="n">EDAC_MOD_STR</span><span class="p">,</span>
					     <span class="s">&quot;unknown syndrome - possible error reporting race&quot;</span><span class="p">,</span>
					     <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * non-chipkill ecc mode</span>
<span class="cm">		 *</span>
<span class="cm">		 * The k8 documentation is unclear about how to determine the</span>
<span class="cm">		 * channel number when using non-chipkill memory.  This method</span>
<span class="cm">		 * was obtained from email communication with someone at AMD.</span>
<span class="cm">		 * (Wish the email was placed in this comment - norsk)</span>
<span class="cm">		 */</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="p">((</span><span class="n">sys_addr</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">src_mci</span><span class="p">,</span>
			     <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">,</span>
			     <span class="n">csrow</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
			     <span class="n">EDAC_MOD_STR</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddr2_cs_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">bool</span> <span class="n">dct_width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">128</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="o">!!</span><span class="n">dct_width</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">k8_dbam_to_chip_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dct</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="n">cs_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dclr</span> <span class="o">=</span> <span class="n">dct</span> <span class="o">?</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr1</span> <span class="o">:</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">&gt;=</span> <span class="n">K8_REV_F</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cs_mode</span> <span class="o">&gt;</span> <span class="mi">11</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ddr2_cs_size</span><span class="p">(</span><span class="n">cs_mode</span><span class="p">,</span> <span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">WIDTH_128</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">&gt;=</span> <span class="n">K8_REV_D</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">diff</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cs_mode</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * the below calculation, besides trying to win an obfuscated C</span>
<span class="cm">		 * contest, maps cs_mode values to DIMM chip select sizes. The</span>
<span class="cm">		 * mappings are:</span>
<span class="cm">		 *</span>
<span class="cm">		 * cs_mode	CS size (mb)</span>
<span class="cm">		 * =======	============</span>
<span class="cm">		 * 0		32</span>
<span class="cm">		 * 1		64</span>
<span class="cm">		 * 2		128</span>
<span class="cm">		 * 3		128</span>
<span class="cm">		 * 4		256</span>
<span class="cm">		 * 5		512</span>
<span class="cm">		 * 6		256</span>
<span class="cm">		 * 7		512</span>
<span class="cm">		 * 8		1024</span>
<span class="cm">		 * 9		1024</span>
<span class="cm">		 * 10		2048</span>
<span class="cm">		 *</span>
<span class="cm">		 * Basically, it calculates a value with which to shift the</span>
<span class="cm">		 * smallest CS size of 32MB.</span>
<span class="cm">		 *</span>
<span class="cm">		 * ddr[23]_cs_size have a similar purpose.</span>
<span class="cm">		 */</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="n">cs_mode</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">cs_mode</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">32</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">cs_mode</span> <span class="o">-</span> <span class="n">diff</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cs_mode</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">32</span> <span class="o">&lt;&lt;</span> <span class="n">cs_mode</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the number of DCT channels in use.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *	number of Memory Channels in operation</span>
<span class="cm"> * Pass back:</span>
<span class="cm"> *	contents of the DCL0_LOW register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">f1x_early_channel_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* On F10h, if we are in 128 bit mode, then we are using 2 channels */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x10</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span> <span class="o">&amp;</span> <span class="n">WIDTH_128</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to check if in unganged mode: In such, there are 2 channels,</span>
<span class="cm">	 * but they are not in 128 bit mode and thus the above &#39;dclr0&#39; status</span>
<span class="cm">	 * bit will be OFF.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Need to check DCT0[0] and DCT1[0] to see if only one of them has</span>
<span class="cm">	 * their CSEnable bit on. If so, then SINGLE DIMM case.</span>
<span class="cm">	 */</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Data width is not 128 bits - need more decoding</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check DRAM Bank Address Mapping values for each DIMM to see if there</span>
<span class="cm">	 * is more than just one DIMM present in unganged mode. Need to check</span>
<span class="cm">	 * both controllers since DIMMs can be placed in either one.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">dbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">?</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dbam1</span> <span class="o">:</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dbam0</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">DBAM_DIMM</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dbam</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">channels</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channels</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">channels</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">amd64_info</span><span class="p">(</span><span class="s">&quot;MCT channel count: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channels</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">channels</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddr3_cs_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">bool</span> <span class="n">dct_width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cs_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">cs_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cs_size</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cs_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">128</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">!!</span><span class="n">dct_width</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cs_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">f10_dbam_to_chip_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dct</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">cs_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dclr</span> <span class="o">=</span> <span class="n">dct</span> <span class="o">?</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr1</span> <span class="o">:</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cs_mode</span> <span class="o">&gt;</span> <span class="mi">11</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dchr0</span> <span class="o">&amp;</span> <span class="n">DDR3_MODE</span> <span class="o">||</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dchr1</span> <span class="o">&amp;</span> <span class="n">DDR3_MODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ddr3_cs_size</span><span class="p">(</span><span class="n">cs_mode</span><span class="p">,</span> <span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">WIDTH_128</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">ddr2_cs_size</span><span class="p">(</span><span class="n">cs_mode</span><span class="p">,</span> <span class="n">dclr</span> <span class="o">&amp;</span> <span class="n">WIDTH_128</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * F15h supports only 64bit DCT interfaces</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">f15_dbam_to_chip_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dct</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">cs_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cs_mode</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ddr3_cs_size</span><span class="p">(</span><span class="n">cs_mode</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_dram_ctl_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">DCT_SEL_LO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dct_sel_lo</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;F2x110 (DCTSelLow): 0x%08x, High range addrs at: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dct_sel_lo</span><span class="p">,</span> <span class="n">dct_sel_baseaddr</span><span class="p">(</span><span class="n">pvt</span><span class="p">));</span>

		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;  DCTs operate in %s mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ganged&quot;</span> <span class="o">:</span> <span class="s">&quot;unganged&quot;</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span>
			<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;  Address range split per DCT: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">dct_high_range_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">));</span>

		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;  data interleave for ECC: %s, &quot;</span>
			<span class="s">&quot;DRAM cleared since last warm reset: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">dct_data_intlv_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">),</span>
			<span class="p">(</span><span class="n">dct_memory_cleared</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">));</span>

		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;  channel interleave: %s, &quot;</span>
			<span class="s">&quot;interleave bits selector: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">dct_interleave_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">),</span>
			<span class="n">dct_sel_interleave_addr</span><span class="p">(</span><span class="n">pvt</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">DCT_SEL_HI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dct_sel_hi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine channel (DCT) based on the interleaving mode: F10h BKDG, 2.8.9 Memory</span>
<span class="cm"> * Interleaving Modes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">f1x_determine_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">hi_range_sel</span><span class="p">,</span> <span class="n">u8</span> <span class="n">intlv_en</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">dct_sel_high</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dct_sel_lo</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hi_range_sel</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dct_sel_high</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * see F2x110[DctSelIntLvAddr] - channel interleave mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dct_interleave_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">intlv_addr</span> <span class="o">=</span> <span class="n">dct_sel_interleave_addr</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

		<span class="cm">/* return DCT select function: 0=DCT0, 1=DCT1 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intlv_addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intlv_addr</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">intlv_addr</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="o">?</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">6</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">hweight_long</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">sys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">))</span> <span class="o">%</span> <span class="mi">2</span><span class="p">;</span>

			<span class="k">return</span> <span class="p">((</span><span class="n">sys_addr</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">temp</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="p">(</span><span class="n">sys_addr</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">12</span> <span class="o">+</span> <span class="n">hweight8</span><span class="p">(</span><span class="n">intlv_en</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dct_high_range_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">~</span><span class="n">dct_sel_high</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert the sys_addr to the normalized DCT address */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">f1x_get_norm_dct_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">range</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">hi_rng</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">dct_sel_base_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">chan_off</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dram_base</span>		<span class="o">=</span> <span class="n">get_dram_base</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">hole_off</span>		<span class="o">=</span> <span class="n">f10_dhar_offset</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">dct_sel_base_off</span>	<span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dct_sel_hi</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFC00</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hi_rng</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if</span>
<span class="cm">		 * base address of high range is below 4Gb</span>
<span class="cm">		 * (bits [47:27] at [31:11])</span>
<span class="cm">		 * DRAM address space on this DCT is hoisted above 4Gb	&amp;&amp;</span>
<span class="cm">		 * sys_addr &gt; 4Gb</span>
<span class="cm">		 *</span>
<span class="cm">		 *	remove hole offset from sys_addr</span>
<span class="cm">		 * else</span>
<span class="cm">		 *	remove high range offset from sys_addr</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">dct_sel_base_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">dct_sel_base_addr</span> <span class="o">&lt;</span> <span class="n">dhar_base</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">dhar_valid</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sys_addr</span> <span class="o">&gt;=</span> <span class="n">BIT_64</span><span class="p">(</span><span class="mi">32</span><span class="p">)))</span>
			<span class="n">chan_off</span> <span class="o">=</span> <span class="n">hole_off</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">chan_off</span> <span class="o">=</span> <span class="n">dct_sel_base_off</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if</span>
<span class="cm">		 * we have a valid hole		&amp;&amp;</span>
<span class="cm">		 * sys_addr &gt; 4Gb</span>
<span class="cm">		 *</span>
<span class="cm">		 *	remove hole</span>
<span class="cm">		 * else</span>
<span class="cm">		 *	remove dram base to normalize to DCT address</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dhar_valid</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sys_addr</span> <span class="o">&gt;=</span> <span class="n">BIT_64</span><span class="p">(</span><span class="mi">32</span><span class="p">)))</span>
			<span class="n">chan_off</span> <span class="o">=</span> <span class="n">hole_off</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">chan_off</span> <span class="o">=</span> <span class="n">dram_base</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">sys_addr</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">47</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">chan_off</span> <span class="o">&amp;</span> <span class="n">GENMASK</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">47</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * checks if the csrow passed in is marked as SPARED, if so returns the new</span>
<span class="cm"> * spare row</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">f10_process_possible_spare</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dct</span><span class="p">,</span> <span class="kt">int</span> <span class="n">csrow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp_cs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">online_spare_swap_done</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">csrow</span> <span class="o">==</span> <span class="n">online_spare_bad_dramcs</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">dct</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">for_each_chip_select</span><span class="p">(</span><span class="n">tmp_cs</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="n">pvt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chip_select_base</span><span class="p">(</span><span class="n">tmp_cs</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="n">pvt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">csrow</span> <span class="o">=</span> <span class="n">tmp_cs</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">csrow</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Iterate over the DRAM DCT &quot;base&quot; and &quot;mask&quot; registers looking for a</span>
<span class="cm"> * SystemAddr match on the specified &#39;ChannelSelect&#39; and &#39;NodeID&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *	-EINVAL:  NOT FOUND</span>
<span class="cm"> *	0..csrow = Chip-Select Row</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">f1x_lookup_addr_in_dct</span><span class="p">(</span><span class="n">u64</span> <span class="n">in_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">nid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cs_base</span><span class="p">,</span> <span class="n">cs_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cs_found</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csrow</span><span class="p">;</span>

	<span class="n">mci</span> <span class="o">=</span> <span class="n">mcis</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mci</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cs_found</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;input addr: 0x%llx, DCT: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">in_addr</span><span class="p">,</span> <span class="n">dct</span><span class="p">);</span>

	<span class="n">for_each_chip_select</span><span class="p">(</span><span class="n">csrow</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="n">pvt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">csrow_enabled</span><span class="p">(</span><span class="n">csrow</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="n">pvt</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">get_cs_base_and_mask</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">csrow</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs_mask</span><span class="p">);</span>

		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;    CSROW=%d CSBase=0x%llx CSMask=0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">csrow</span><span class="p">,</span> <span class="n">cs_base</span><span class="p">,</span> <span class="n">cs_mask</span><span class="p">);</span>

		<span class="n">cs_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">cs_mask</span><span class="p">;</span>

		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;    (InputAddr &amp; ~CSMask)=0x%llx &quot;</span>
			<span class="s">&quot;(CSBase &amp; ~CSMask)=0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">in_addr</span> <span class="o">&amp;</span> <span class="n">cs_mask</span><span class="p">),</span> <span class="p">(</span><span class="n">cs_base</span> <span class="o">&amp;</span> <span class="n">cs_mask</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">in_addr</span> <span class="o">&amp;</span> <span class="n">cs_mask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">cs_base</span> <span class="o">&amp;</span> <span class="n">cs_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cs_found</span> <span class="o">=</span> <span class="n">f10_process_possible_spare</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="n">csrow</span><span class="p">);</span>

			<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot; MATCH csrow=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cs_found</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cs_found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See F2x10C. Non-interleaved graphics framebuffer memory under the 16G is</span>
<span class="cm"> * swapped with a region located at the bottom of memory so that the GPU can use</span>
<span class="cm"> * the interleaved region and thus two channels.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">f1x_swap_interleaved_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">swap_reg</span><span class="p">,</span> <span class="n">swap_base</span><span class="p">,</span> <span class="n">swap_limit</span><span class="p">,</span> <span class="n">rgn_size</span><span class="p">,</span> <span class="n">tmp_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* only revC3 and revE have that feature */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_model</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_model</span> <span class="o">&lt;</span> <span class="mh">0xa</span> <span class="o">&amp;&amp;</span>
		     <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_mask</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">sys_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">SWAP_INTLV_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">swap_reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">swap_reg</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sys_addr</span><span class="p">;</span>

	<span class="n">swap_base</span>	<span class="o">=</span> <span class="p">(</span><span class="n">swap_reg</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="n">swap_limit</span>	<span class="o">=</span> <span class="p">(</span><span class="n">swap_reg</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="n">rgn_size</span>	<span class="o">=</span> <span class="p">(</span><span class="n">swap_reg</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="n">tmp_addr</span>	<span class="o">=</span> <span class="n">sys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">27</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">34</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(((</span><span class="n">tmp_addr</span> <span class="o">&gt;=</span> <span class="n">swap_base</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">tmp_addr</span> <span class="o">&lt;=</span> <span class="n">swap_limit</span><span class="p">))</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">tmp_addr</span> <span class="o">&lt;</span> <span class="n">rgn_size</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sys_addr</span> <span class="o">^</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">swap_base</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sys_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* For a given @dram_range, check if @sys_addr falls within it. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">f1x_match_to_this_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">range</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">chan_sel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cs_found</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">chan_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dct_sel_base</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">high_range</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">node_id</span>    <span class="o">=</span> <span class="n">dram_dst_node</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">intlv_en</span>   <span class="o">=</span> <span class="n">dram_intlv_en</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">intlv_sel</span> <span class="o">=</span> <span class="n">dram_intlv_sel</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;(range %d) SystemAddr= 0x%llx Limit=0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">range</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">,</span> <span class="n">get_dram_limit</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dhar_valid</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dhar_base</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sys_addr</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sys_addr</span> <span class="o">&lt;</span> <span class="n">BIT_64</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;Huh? Address is in the MMIO hole: 0x%016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">sys_addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intlv_en</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">intlv_sel</span> <span class="o">!=</span> <span class="p">((</span><span class="n">sys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">intlv_en</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sys_addr</span> <span class="o">=</span> <span class="n">f1x_swap_interleaved_region</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">);</span>

	<span class="n">dct_sel_base</span> <span class="o">=</span> <span class="n">dct_sel_baseaddr</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * check whether addresses &gt;= DctSelBaseAddr[47:27] are to be used to</span>
<span class="cm">	 * select between DCT0 and DCT1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dct_high_range_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="o">!</span><span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">((</span><span class="n">sys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">27</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">dct_sel_base</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)))</span>
		<span class="n">high_range</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">channel</span> <span class="o">=</span> <span class="n">f1x_determine_channel</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">,</span> <span class="n">high_range</span><span class="p">,</span> <span class="n">intlv_en</span><span class="p">);</span>

	<span class="n">chan_addr</span> <span class="o">=</span> <span class="n">f1x_get_norm_dct_addr</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">,</span>
					  <span class="n">high_range</span><span class="p">,</span> <span class="n">dct_sel_base</span><span class="p">);</span>

	<span class="cm">/* Remove node interleaving, see F1x120 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intlv_en</span><span class="p">)</span>
		<span class="n">chan_addr</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan_addr</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">12</span> <span class="o">+</span> <span class="n">hweight8</span><span class="p">(</span><span class="n">intlv_en</span><span class="p">)))</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span>
			    <span class="p">(</span><span class="n">chan_addr</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">);</span>

	<span class="cm">/* remove channel interleave */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dct_interleave_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="o">!</span><span class="n">dct_high_range_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="o">!</span><span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dct_sel_interleave_addr</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dct_sel_interleave_addr</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3</span><span class="p">)</span>
				<span class="cm">/* hash 9 */</span>
				<span class="n">chan_addr</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">|</span>
					     <span class="p">(</span><span class="n">chan_addr</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="cm">/* A[6] or hash 6 */</span>
				<span class="n">chan_addr</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">|</span>
					     <span class="p">(</span><span class="n">chan_addr</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* A[12] */</span>
			<span class="n">chan_addr</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span>
				     <span class="p">(</span><span class="n">chan_addr</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;   Normalized DCT addr: 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan_addr</span><span class="p">);</span>

	<span class="n">cs_found</span> <span class="o">=</span> <span class="n">f1x_lookup_addr_in_dct</span><span class="p">(</span><span class="n">chan_addr</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cs_found</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">nid</span> <span class="o">=</span> <span class="n">node_id</span><span class="p">;</span>
		<span class="o">*</span><span class="n">chan_sel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cs_found</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">f1x_translate_sysaddr_to_cs</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">chan_sel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cs_found</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">range</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">range</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">range</span> <span class="o">&lt;</span> <span class="n">DRAM_RANGES</span><span class="p">;</span> <span class="n">range</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dram_rw</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">get_dram_base</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">)</span>  <span class="o">&lt;=</span> <span class="n">sys_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">get_dram_limit</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">sys_addr</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">cs_found</span> <span class="o">=</span> <span class="n">f1x_match_to_this_node</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span>
							  <span class="n">sys_addr</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span>
							  <span class="n">chan_sel</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cs_found</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cs_found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For reference see &quot;2.8.5 Routing DRAM Requests&quot; in F10 BKDG. This code maps</span>
<span class="cm"> * a @sys_addr to NodeID, DCT (channel) and chip select (CSROW).</span>
<span class="cm"> *</span>
<span class="cm"> * The @sys_addr is usually an error address received from the hardware</span>
<span class="cm"> * (MCX_ADDR).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">f1x_map_sysaddr_to_csrow</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sys_addr</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="n">syndrome</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">csrow</span><span class="p">,</span> <span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error_address_to_page_and_offset</span><span class="p">(</span><span class="n">sys_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>

	<span class="n">csrow</span> <span class="o">=</span> <span class="n">f1x_translate_sysaddr_to_cs</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">csrow</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				     <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">,</span>
				     <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				     <span class="n">EDAC_MOD_STR</span><span class="p">,</span>
				     <span class="s">&quot;failed to map error addr to a csrow&quot;</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need the syndromes for channel detection only when we&#39;re</span>
<span class="cm">	 * ganged. Otherwise @chan should already contain the channel at</span>
<span class="cm">	 * this point.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span>
		<span class="n">chan</span> <span class="o">=</span> <span class="n">get_channel_from_ecc_syndrome</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">);</span>

	<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
			     <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">,</span>
			     <span class="n">csrow</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
			     <span class="n">EDAC_MOD_STR</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * debug routine to display the memory sizes of all logical DIMMs and its</span>
<span class="cm"> * CSROWs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">amd64_debug_display_dimm_sizes</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dimm</span><span class="p">,</span> <span class="n">size0</span><span class="p">,</span> <span class="n">size1</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dcsb</span> <span class="o">=</span> <span class="n">ctrl</span> <span class="o">?</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">csbases</span> <span class="o">:</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">csbases</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dbam</span>  <span class="o">=</span> <span class="n">ctrl</span> <span class="o">?</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dbam1</span> <span class="o">:</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dbam0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span> <span class="o">&amp;</span> <span class="n">WIDTH_128</span><span class="p">)</span>
			<span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* K8 families &lt; revF not supported yet */</span>
	       <span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">&lt;</span> <span class="n">K8_REV_F</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	       <span class="k">else</span>
		       <span class="n">WARN_ON</span><span class="p">(</span><span class="n">ctrl</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span> <span class="o">?</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dbam1</span> <span class="o">:</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dbam0</span><span class="p">;</span>
	<span class="n">dcsb</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span> <span class="o">?</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">csbases</span>
						   <span class="o">:</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">csbases</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;F2x%d80 (DRAM Bank Address Mapping): 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">dbam</span><span class="p">);</span>

	<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">EDAC_MC</span><span class="p">,</span> <span class="s">&quot;DCT%d chip selects:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="cm">/* Dump memory sizes for DIMM and its CSROWs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">dimm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dimm</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">dimm</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">size0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dcsb</span><span class="p">[</span><span class="n">dimm</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">DCSB_CS_ENABLE</span><span class="p">)</span>
			<span class="n">size0</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dbam_to_cs</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">,</span>
						     <span class="n">DBAM_DIMM</span><span class="p">(</span><span class="n">dimm</span><span class="p">,</span> <span class="n">dbam</span><span class="p">));</span>

		<span class="n">size1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dcsb</span><span class="p">[</span><span class="n">dimm</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">DCSB_CS_ENABLE</span><span class="p">)</span>
			<span class="n">size1</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dbam_to_cs</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">,</span>
						     <span class="n">DBAM_DIMM</span><span class="p">(</span><span class="n">dimm</span><span class="p">,</span> <span class="n">dbam</span><span class="p">));</span>

		<span class="n">amd64_info</span><span class="p">(</span><span class="n">EDAC_MC</span> <span class="s">&quot;: %d: %5dMB %d: %5dMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dimm</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>     <span class="n">size0</span> <span class="o">&lt;&lt;</span> <span class="n">factor</span><span class="p">,</span>
				<span class="n">dimm</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size1</span> <span class="o">&lt;&lt;</span> <span class="n">factor</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">amd64_family_type</span> <span class="n">amd64_family_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">K8_CPUS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ctl_name</span> <span class="o">=</span> <span class="s">&quot;K8&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">f1_id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_AMD_K8_NB_ADDRMAP</span><span class="p">,</span>
		<span class="p">.</span><span class="n">f3_id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_AMD_K8_NB_MISC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">early_channel_count</span>	<span class="o">=</span> <span class="n">k8_early_channel_count</span><span class="p">,</span>
			<span class="p">.</span><span class="n">map_sysaddr_to_csrow</span>	<span class="o">=</span> <span class="n">k8_map_sysaddr_to_csrow</span><span class="p">,</span>
			<span class="p">.</span><span class="n">dbam_to_cs</span>		<span class="o">=</span> <span class="n">k8_dbam_to_chip_select</span><span class="p">,</span>
			<span class="p">.</span><span class="n">read_dct_pci_cfg</span>	<span class="o">=</span> <span class="n">k8_read_dct_pci_cfg</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">F10_CPUS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ctl_name</span> <span class="o">=</span> <span class="s">&quot;F10h&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">f1_id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_AMD_10H_NB_MAP</span><span class="p">,</span>
		<span class="p">.</span><span class="n">f3_id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_AMD_10H_NB_MISC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">early_channel_count</span>	<span class="o">=</span> <span class="n">f1x_early_channel_count</span><span class="p">,</span>
			<span class="p">.</span><span class="n">map_sysaddr_to_csrow</span>	<span class="o">=</span> <span class="n">f1x_map_sysaddr_to_csrow</span><span class="p">,</span>
			<span class="p">.</span><span class="n">dbam_to_cs</span>		<span class="o">=</span> <span class="n">f10_dbam_to_chip_select</span><span class="p">,</span>
			<span class="p">.</span><span class="n">read_dct_pci_cfg</span>	<span class="o">=</span> <span class="n">f10_read_dct_pci_cfg</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">F15_CPUS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ctl_name</span> <span class="o">=</span> <span class="s">&quot;F15h&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">f1_id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_AMD_15H_NB_F1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">f3_id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_AMD_15H_NB_F3</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">early_channel_count</span>	<span class="o">=</span> <span class="n">f1x_early_channel_count</span><span class="p">,</span>
			<span class="p">.</span><span class="n">map_sysaddr_to_csrow</span>	<span class="o">=</span> <span class="n">f1x_map_sysaddr_to_csrow</span><span class="p">,</span>
			<span class="p">.</span><span class="n">dbam_to_cs</span>		<span class="o">=</span> <span class="n">f15_dbam_to_chip_select</span><span class="p">,</span>
			<span class="p">.</span><span class="n">read_dct_pci_cfg</span>	<span class="o">=</span> <span class="n">f15_read_dct_pci_cfg</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="nf">pci_get_related_function</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vendor</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">related</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">vendor</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">==</span> <span class="n">related</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">related</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">vendor</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These are tables of eigenvectors (one per line) which can be used for the</span>
<span class="cm"> * construction of the syndrome tables. The modified syndrome search algorithm</span>
<span class="cm"> * uses those to find the symbol in error and thus the DIMM.</span>
<span class="cm"> *</span>
<span class="cm"> * Algorithm courtesy of Ross LaFetra from AMD.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">x4_vectors</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x2f57</span><span class="p">,</span> <span class="mh">0x1afe</span><span class="p">,</span> <span class="mh">0x66cc</span><span class="p">,</span> <span class="mh">0xdd88</span><span class="p">,</span>
	<span class="mh">0x11eb</span><span class="p">,</span> <span class="mh">0x3396</span><span class="p">,</span> <span class="mh">0x7f4c</span><span class="p">,</span> <span class="mh">0xeac8</span><span class="p">,</span>
	<span class="mh">0x0001</span><span class="p">,</span> <span class="mh">0x0002</span><span class="p">,</span> <span class="mh">0x0004</span><span class="p">,</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="mh">0x1013</span><span class="p">,</span> <span class="mh">0x3032</span><span class="p">,</span> <span class="mh">0x4044</span><span class="p">,</span> <span class="mh">0x8088</span><span class="p">,</span>
	<span class="mh">0x106b</span><span class="p">,</span> <span class="mh">0x30d6</span><span class="p">,</span> <span class="mh">0x70fc</span><span class="p">,</span> <span class="mh">0xe0a8</span><span class="p">,</span>
	<span class="mh">0x4857</span><span class="p">,</span> <span class="mh">0xc4fe</span><span class="p">,</span> <span class="mh">0x13cc</span><span class="p">,</span> <span class="mh">0x3288</span><span class="p">,</span>
	<span class="mh">0x1ac5</span><span class="p">,</span> <span class="mh">0x2f4a</span><span class="p">,</span> <span class="mh">0x5394</span><span class="p">,</span> <span class="mh">0xa1e8</span><span class="p">,</span>
	<span class="mh">0x1f39</span><span class="p">,</span> <span class="mh">0x251e</span><span class="p">,</span> <span class="mh">0xbd6c</span><span class="p">,</span> <span class="mh">0x6bd8</span><span class="p">,</span>
	<span class="mh">0x15c1</span><span class="p">,</span> <span class="mh">0x2a42</span><span class="p">,</span> <span class="mh">0x89ac</span><span class="p">,</span> <span class="mh">0x4758</span><span class="p">,</span>
	<span class="mh">0x2b03</span><span class="p">,</span> <span class="mh">0x1602</span><span class="p">,</span> <span class="mh">0x4f0c</span><span class="p">,</span> <span class="mh">0xca08</span><span class="p">,</span>
	<span class="mh">0x1f07</span><span class="p">,</span> <span class="mh">0x3a0e</span><span class="p">,</span> <span class="mh">0x6b04</span><span class="p">,</span> <span class="mh">0xbd08</span><span class="p">,</span>
	<span class="mh">0x8ba7</span><span class="p">,</span> <span class="mh">0x465e</span><span class="p">,</span> <span class="mh">0x244c</span><span class="p">,</span> <span class="mh">0x1cc8</span><span class="p">,</span>
	<span class="mh">0x2b87</span><span class="p">,</span> <span class="mh">0x164e</span><span class="p">,</span> <span class="mh">0x642c</span><span class="p">,</span> <span class="mh">0xdc18</span><span class="p">,</span>
	<span class="mh">0x40b9</span><span class="p">,</span> <span class="mh">0x80de</span><span class="p">,</span> <span class="mh">0x1094</span><span class="p">,</span> <span class="mh">0x20e8</span><span class="p">,</span>
	<span class="mh">0x27db</span><span class="p">,</span> <span class="mh">0x1eb6</span><span class="p">,</span> <span class="mh">0x9dac</span><span class="p">,</span> <span class="mh">0x7b58</span><span class="p">,</span>
	<span class="mh">0x11c1</span><span class="p">,</span> <span class="mh">0x2242</span><span class="p">,</span> <span class="mh">0x84ac</span><span class="p">,</span> <span class="mh">0x4c58</span><span class="p">,</span>
	<span class="mh">0x1be5</span><span class="p">,</span> <span class="mh">0x2d7a</span><span class="p">,</span> <span class="mh">0x5e34</span><span class="p">,</span> <span class="mh">0xa718</span><span class="p">,</span>
	<span class="mh">0x4b39</span><span class="p">,</span> <span class="mh">0x8d1e</span><span class="p">,</span> <span class="mh">0x14b4</span><span class="p">,</span> <span class="mh">0x28d8</span><span class="p">,</span>
	<span class="mh">0x4c97</span><span class="p">,</span> <span class="mh">0xc87e</span><span class="p">,</span> <span class="mh">0x11fc</span><span class="p">,</span> <span class="mh">0x33a8</span><span class="p">,</span>
	<span class="mh">0x8e97</span><span class="p">,</span> <span class="mh">0x497e</span><span class="p">,</span> <span class="mh">0x2ffc</span><span class="p">,</span> <span class="mh">0x1aa8</span><span class="p">,</span>
	<span class="mh">0x16b3</span><span class="p">,</span> <span class="mh">0x3d62</span><span class="p">,</span> <span class="mh">0x4f34</span><span class="p">,</span> <span class="mh">0x8518</span><span class="p">,</span>
	<span class="mh">0x1e2f</span><span class="p">,</span> <span class="mh">0x391a</span><span class="p">,</span> <span class="mh">0x5cac</span><span class="p">,</span> <span class="mh">0xf858</span><span class="p">,</span>
	<span class="mh">0x1d9f</span><span class="p">,</span> <span class="mh">0x3b7a</span><span class="p">,</span> <span class="mh">0x572c</span><span class="p">,</span> <span class="mh">0xfe18</span><span class="p">,</span>
	<span class="mh">0x15f5</span><span class="p">,</span> <span class="mh">0x2a5a</span><span class="p">,</span> <span class="mh">0x5264</span><span class="p">,</span> <span class="mh">0xa3b8</span><span class="p">,</span>
	<span class="mh">0x1dbb</span><span class="p">,</span> <span class="mh">0x3b66</span><span class="p">,</span> <span class="mh">0x715c</span><span class="p">,</span> <span class="mh">0xe3f8</span><span class="p">,</span>
	<span class="mh">0x4397</span><span class="p">,</span> <span class="mh">0xc27e</span><span class="p">,</span> <span class="mh">0x17fc</span><span class="p">,</span> <span class="mh">0x3ea8</span><span class="p">,</span>
	<span class="mh">0x1617</span><span class="p">,</span> <span class="mh">0x3d3e</span><span class="p">,</span> <span class="mh">0x6464</span><span class="p">,</span> <span class="mh">0xb8b8</span><span class="p">,</span>
	<span class="mh">0x23ff</span><span class="p">,</span> <span class="mh">0x12aa</span><span class="p">,</span> <span class="mh">0xab6c</span><span class="p">,</span> <span class="mh">0x56d8</span><span class="p">,</span>
	<span class="mh">0x2dfb</span><span class="p">,</span> <span class="mh">0x1ba6</span><span class="p">,</span> <span class="mh">0x913c</span><span class="p">,</span> <span class="mh">0x7328</span><span class="p">,</span>
	<span class="mh">0x185d</span><span class="p">,</span> <span class="mh">0x2ca6</span><span class="p">,</span> <span class="mh">0x7914</span><span class="p">,</span> <span class="mh">0x9e28</span><span class="p">,</span>
	<span class="mh">0x171b</span><span class="p">,</span> <span class="mh">0x3e36</span><span class="p">,</span> <span class="mh">0x7d7c</span><span class="p">,</span> <span class="mh">0xebe8</span><span class="p">,</span>
	<span class="mh">0x4199</span><span class="p">,</span> <span class="mh">0x82ee</span><span class="p">,</span> <span class="mh">0x19f4</span><span class="p">,</span> <span class="mh">0x2e58</span><span class="p">,</span>
	<span class="mh">0x4807</span><span class="p">,</span> <span class="mh">0xc40e</span><span class="p">,</span> <span class="mh">0x130c</span><span class="p">,</span> <span class="mh">0x3208</span><span class="p">,</span>
	<span class="mh">0x1905</span><span class="p">,</span> <span class="mh">0x2e0a</span><span class="p">,</span> <span class="mh">0x5804</span><span class="p">,</span> <span class="mh">0xac08</span><span class="p">,</span>
	<span class="mh">0x213f</span><span class="p">,</span> <span class="mh">0x132a</span><span class="p">,</span> <span class="mh">0xadfc</span><span class="p">,</span> <span class="mh">0x5ba8</span><span class="p">,</span>
	<span class="mh">0x19a9</span><span class="p">,</span> <span class="mh">0x2efe</span><span class="p">,</span> <span class="mh">0xb5cc</span><span class="p">,</span> <span class="mh">0x6f88</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">u16</span> <span class="n">x8_vectors</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x0145</span><span class="p">,</span> <span class="mh">0x028a</span><span class="p">,</span> <span class="mh">0x2374</span><span class="p">,</span> <span class="mh">0x43c8</span><span class="p">,</span> <span class="mh">0xa1f0</span><span class="p">,</span> <span class="mh">0x0520</span><span class="p">,</span> <span class="mh">0x0a40</span><span class="p">,</span> <span class="mh">0x1480</span><span class="p">,</span>
	<span class="mh">0x0211</span><span class="p">,</span> <span class="mh">0x0422</span><span class="p">,</span> <span class="mh">0x0844</span><span class="p">,</span> <span class="mh">0x1088</span><span class="p">,</span> <span class="mh">0x01b0</span><span class="p">,</span> <span class="mh">0x44e0</span><span class="p">,</span> <span class="mh">0x23c0</span><span class="p">,</span> <span class="mh">0xed80</span><span class="p">,</span>
	<span class="mh">0x1011</span><span class="p">,</span> <span class="mh">0x0116</span><span class="p">,</span> <span class="mh">0x022c</span><span class="p">,</span> <span class="mh">0x0458</span><span class="p">,</span> <span class="mh">0x08b0</span><span class="p">,</span> <span class="mh">0x8c60</span><span class="p">,</span> <span class="mh">0x2740</span><span class="p">,</span> <span class="mh">0x4e80</span><span class="p">,</span>
	<span class="mh">0x0411</span><span class="p">,</span> <span class="mh">0x0822</span><span class="p">,</span> <span class="mh">0x1044</span><span class="p">,</span> <span class="mh">0x0158</span><span class="p">,</span> <span class="mh">0x02b0</span><span class="p">,</span> <span class="mh">0x2360</span><span class="p">,</span> <span class="mh">0x46c0</span><span class="p">,</span> <span class="mh">0xab80</span><span class="p">,</span>
	<span class="mh">0x0811</span><span class="p">,</span> <span class="mh">0x1022</span><span class="p">,</span> <span class="mh">0x012c</span><span class="p">,</span> <span class="mh">0x0258</span><span class="p">,</span> <span class="mh">0x04b0</span><span class="p">,</span> <span class="mh">0x4660</span><span class="p">,</span> <span class="mh">0x8cc0</span><span class="p">,</span> <span class="mh">0x2780</span><span class="p">,</span>
	<span class="mh">0x2071</span><span class="p">,</span> <span class="mh">0x40e2</span><span class="p">,</span> <span class="mh">0xa0c4</span><span class="p">,</span> <span class="mh">0x0108</span><span class="p">,</span> <span class="mh">0x0210</span><span class="p">,</span> <span class="mh">0x0420</span><span class="p">,</span> <span class="mh">0x0840</span><span class="p">,</span> <span class="mh">0x1080</span><span class="p">,</span>
	<span class="mh">0x4071</span><span class="p">,</span> <span class="mh">0x80e2</span><span class="p">,</span> <span class="mh">0x0104</span><span class="p">,</span> <span class="mh">0x0208</span><span class="p">,</span> <span class="mh">0x0410</span><span class="p">,</span> <span class="mh">0x0820</span><span class="p">,</span> <span class="mh">0x1040</span><span class="p">,</span> <span class="mh">0x2080</span><span class="p">,</span>
	<span class="mh">0x8071</span><span class="p">,</span> <span class="mh">0x0102</span><span class="p">,</span> <span class="mh">0x0204</span><span class="p">,</span> <span class="mh">0x0408</span><span class="p">,</span> <span class="mh">0x0810</span><span class="p">,</span> <span class="mh">0x1020</span><span class="p">,</span> <span class="mh">0x2040</span><span class="p">,</span> <span class="mh">0x4080</span><span class="p">,</span>
	<span class="mh">0x019d</span><span class="p">,</span> <span class="mh">0x03d6</span><span class="p">,</span> <span class="mh">0x136c</span><span class="p">,</span> <span class="mh">0x2198</span><span class="p">,</span> <span class="mh">0x50b0</span><span class="p">,</span> <span class="mh">0xb2e0</span><span class="p">,</span> <span class="mh">0x0740</span><span class="p">,</span> <span class="mh">0x0e80</span><span class="p">,</span>
	<span class="mh">0x0189</span><span class="p">,</span> <span class="mh">0x03ea</span><span class="p">,</span> <span class="mh">0x072c</span><span class="p">,</span> <span class="mh">0x0e58</span><span class="p">,</span> <span class="mh">0x1cb0</span><span class="p">,</span> <span class="mh">0x56e0</span><span class="p">,</span> <span class="mh">0x37c0</span><span class="p">,</span> <span class="mh">0xf580</span><span class="p">,</span>
	<span class="mh">0x01fd</span><span class="p">,</span> <span class="mh">0x0376</span><span class="p">,</span> <span class="mh">0x06ec</span><span class="p">,</span> <span class="mh">0x0bb8</span><span class="p">,</span> <span class="mh">0x1110</span><span class="p">,</span> <span class="mh">0x2220</span><span class="p">,</span> <span class="mh">0x4440</span><span class="p">,</span> <span class="mh">0x8880</span><span class="p">,</span>
	<span class="mh">0x0163</span><span class="p">,</span> <span class="mh">0x02c6</span><span class="p">,</span> <span class="mh">0x1104</span><span class="p">,</span> <span class="mh">0x0758</span><span class="p">,</span> <span class="mh">0x0eb0</span><span class="p">,</span> <span class="mh">0x2be0</span><span class="p">,</span> <span class="mh">0x6140</span><span class="p">,</span> <span class="mh">0xc280</span><span class="p">,</span>
	<span class="mh">0x02fd</span><span class="p">,</span> <span class="mh">0x01c6</span><span class="p">,</span> <span class="mh">0x0b5c</span><span class="p">,</span> <span class="mh">0x1108</span><span class="p">,</span> <span class="mh">0x07b0</span><span class="p">,</span> <span class="mh">0x25a0</span><span class="p">,</span> <span class="mh">0x8840</span><span class="p">,</span> <span class="mh">0x6180</span><span class="p">,</span>
	<span class="mh">0x0801</span><span class="p">,</span> <span class="mh">0x012e</span><span class="p">,</span> <span class="mh">0x025c</span><span class="p">,</span> <span class="mh">0x04b8</span><span class="p">,</span> <span class="mh">0x1370</span><span class="p">,</span> <span class="mh">0x26e0</span><span class="p">,</span> <span class="mh">0x57c0</span><span class="p">,</span> <span class="mh">0xb580</span><span class="p">,</span>
	<span class="mh">0x0401</span><span class="p">,</span> <span class="mh">0x0802</span><span class="p">,</span> <span class="mh">0x015c</span><span class="p">,</span> <span class="mh">0x02b8</span><span class="p">,</span> <span class="mh">0x22b0</span><span class="p">,</span> <span class="mh">0x13e0</span><span class="p">,</span> <span class="mh">0x7140</span><span class="p">,</span> <span class="mh">0xe280</span><span class="p">,</span>
	<span class="mh">0x0201</span><span class="p">,</span> <span class="mh">0x0402</span><span class="p">,</span> <span class="mh">0x0804</span><span class="p">,</span> <span class="mh">0x01b8</span><span class="p">,</span> <span class="mh">0x11b0</span><span class="p">,</span> <span class="mh">0x31a0</span><span class="p">,</span> <span class="mh">0x8040</span><span class="p">,</span> <span class="mh">0x7180</span><span class="p">,</span>
	<span class="mh">0x0101</span><span class="p">,</span> <span class="mh">0x0202</span><span class="p">,</span> <span class="mh">0x0404</span><span class="p">,</span> <span class="mh">0x0808</span><span class="p">,</span> <span class="mh">0x1010</span><span class="p">,</span> <span class="mh">0x2020</span><span class="p">,</span> <span class="mh">0x4040</span><span class="p">,</span> <span class="mh">0x8080</span><span class="p">,</span>
	<span class="mh">0x0001</span><span class="p">,</span> <span class="mh">0x0002</span><span class="p">,</span> <span class="mh">0x0004</span><span class="p">,</span> <span class="mh">0x0008</span><span class="p">,</span> <span class="mh">0x0010</span><span class="p">,</span> <span class="mh">0x0020</span><span class="p">,</span> <span class="mh">0x0040</span><span class="p">,</span> <span class="mh">0x0080</span><span class="p">,</span>
	<span class="mh">0x0100</span><span class="p">,</span> <span class="mh">0x0200</span><span class="p">,</span> <span class="mh">0x0400</span><span class="p">,</span> <span class="mh">0x0800</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="mh">0x4000</span><span class="p">,</span> <span class="mh">0x8000</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_syndrome</span><span class="p">(</span><span class="n">u16</span> <span class="n">syndrome</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">vectors</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">num_vecs</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="n">v_dim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err_sym</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">err_sym</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">err_sym</span> <span class="o">&lt;</span> <span class="n">num_vecs</span> <span class="o">/</span> <span class="n">v_dim</span><span class="p">;</span> <span class="n">err_sym</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">s</span> <span class="o">=</span> <span class="n">syndrome</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">v_idx</span> <span class="o">=</span>  <span class="n">err_sym</span> <span class="o">*</span> <span class="n">v_dim</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">v_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">err_sym</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_dim</span><span class="p">;</span>

		<span class="cm">/* walk over all 16 bits of the syndrome */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* if bit is set in that eigenvector... */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">v_idx</span> <span class="o">&lt;</span> <span class="n">v_end</span> <span class="o">&amp;&amp;</span> <span class="n">vectors</span><span class="p">[</span><span class="n">v_idx</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u16</span> <span class="n">ev_comp</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[</span><span class="n">v_idx</span><span class="o">++</span><span class="p">];</span>

				<span class="cm">/* ... and bit set in the modified syndrome, */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* remove it. */</span>
					<span class="n">s</span> <span class="o">^=</span> <span class="n">ev_comp</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
						<span class="k">return</span> <span class="n">err_sym</span><span class="p">;</span>
				<span class="p">}</span>

			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span>
				<span class="cm">/* can&#39;t get to zero, move to next symbol */</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;syndrome(%x) not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">map_err_sym_to_channel</span><span class="p">(</span><span class="kt">int</span> <span class="n">err_sym</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sym_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">err_sym</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x20</span>:
		<span class="k">case</span> <span class="mh">0x21</span>:
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x22</span>:
		<span class="k">case</span> <span class="mh">0x23</span>:
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">err_sym</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="cm">/* x8 symbols */</span>
	<span class="k">else</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">err_sym</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* imaginary bits not in a DIMM */</span>
		<span class="k">case</span> <span class="mh">0x10</span>:
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;Invalid error symbol: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">err_sym</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x11</span>:
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x12</span>:
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">err_sym</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_channel_from_ecc_syndrome</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u16</span> <span class="n">syndrome</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err_sym</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ecc_sym_sz</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">err_sym</span> <span class="o">=</span> <span class="n">decode_syndrome</span><span class="p">(</span><span class="n">syndrome</span><span class="p">,</span> <span class="n">x8_vectors</span><span class="p">,</span>
					  <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">x8_vectors</span><span class="p">),</span>
					  <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ecc_sym_sz</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ecc_sym_sz</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">err_sym</span> <span class="o">=</span> <span class="n">decode_syndrome</span><span class="p">(</span><span class="n">syndrome</span><span class="p">,</span> <span class="n">x4_vectors</span><span class="p">,</span>
					  <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">x4_vectors</span><span class="p">),</span>
					  <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ecc_sym_sz</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;Illegal syndrome type: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ecc_sym_sz</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err_sym</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">map_err_sym_to_channel</span><span class="p">(</span><span class="n">err_sym</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ecc_sym_sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle any Correctable Errors (CEs) that have occurred. Check for valid ERROR</span>
<span class="cm"> * ADDRESS and process.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">amd64_handle_ce</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">sys_addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">syndrome</span><span class="p">;</span>

	<span class="cm">/* Ensure that the Error Address is VALID */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_ADDRV</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">amd64_mc_err</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="s">&quot;HW has no ERROR_ADDRESS available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				     <span class="n">EDAC_MOD_STR</span><span class="p">,</span>
				     <span class="s">&quot;HW has no ERROR_ADDRESS available&quot;</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sys_addr</span> <span class="o">=</span> <span class="n">get_error_address</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">syndrome</span> <span class="o">=</span> <span class="n">extract_syndrome</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="n">amd64_mc_err</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="s">&quot;CE ERROR_ADDRESS= 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">);</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">map_sysaddr_to_csrow</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle any Un-correctable Errors (UEs) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">amd64_handle_ue</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">log_mci</span><span class="p">,</span> <span class="o">*</span><span class="n">src_mci</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csrow</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">sys_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">log_mci</span> <span class="o">=</span> <span class="n">mci</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_ADDRV</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">amd64_mc_err</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="s">&quot;HW has no ERROR_ADDRESS available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_UNCORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				     <span class="n">EDAC_MOD_STR</span><span class="p">,</span>
				     <span class="s">&quot;HW has no ERROR_ADDRESS available&quot;</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sys_addr</span> <span class="o">=</span> <span class="n">get_error_address</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">error_address_to_page_and_offset</span><span class="p">(</span><span class="n">sys_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find out which node the error address belongs to. This may be</span>
<span class="cm">	 * different from the node that detected the error.</span>
<span class="cm">	 */</span>
	<span class="n">src_mci</span> <span class="o">=</span> <span class="n">find_mc_by_sys_addr</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src_mci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amd64_mc_err</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="s">&quot;ERROR ADDRESS (0x%lx) NOT mapped to a MC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sys_addr</span><span class="p">);</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_UNCORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				     <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				     <span class="n">EDAC_MOD_STR</span><span class="p">,</span>
				     <span class="s">&quot;ERROR ADDRESS NOT mapped to a MC&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">log_mci</span> <span class="o">=</span> <span class="n">src_mci</span><span class="p">;</span>

	<span class="n">csrow</span> <span class="o">=</span> <span class="n">sys_addr_to_csrow</span><span class="p">(</span><span class="n">log_mci</span><span class="p">,</span> <span class="n">sys_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csrow</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amd64_mc_err</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="s">&quot;ERROR_ADDRESS (0x%lx) NOT mapped to CS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sys_addr</span><span class="p">);</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_UNCORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				     <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				     <span class="n">EDAC_MOD_STR</span><span class="p">,</span>
				     <span class="s">&quot;ERROR ADDRESS NOT mapped to CS&quot;</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_UNCORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				     <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">csrow</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				     <span class="n">EDAC_MOD_STR</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__amd64_decode_bus_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">ec</span> <span class="o">=</span> <span class="n">EC</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">xec</span> <span class="o">=</span> <span class="n">XEC</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">ecc_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&gt;&gt;</span> <span class="mi">45</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>

	<span class="cm">/* Bail early out if this was an &#39;observed&#39; error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="p">(</span><span class="n">ec</span><span class="p">)</span> <span class="o">==</span> <span class="n">NBSL_PP_OBS</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Do only ECC errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xec</span> <span class="o">&amp;&amp;</span> <span class="n">xec</span> <span class="o">!=</span> <span class="n">F10_NBSL_EXT_ERR_ECC</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ecc_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">amd64_handle_ce</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ecc_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">amd64_handle_ue</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">amd64_decode_bus_error</span><span class="p">(</span><span class="kt">int</span> <span class="n">node_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__amd64_decode_bus_error</span><span class="p">(</span><span class="n">mcis</span><span class="p">[</span><span class="n">node_id</span><span class="p">],</span> <span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use pvt-&gt;F2 which contains the F2 CPU PCI device to get the related</span>
<span class="cm"> * F1 (AddrMap) and F3 (Misc) devices. Return negative value on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reserve_mc_sibling_devs</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u16</span> <span class="n">f1_id</span><span class="p">,</span> <span class="n">u16</span> <span class="n">f3_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Reserve the ADDRESS MAP Device */</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span> <span class="o">=</span> <span class="n">pci_get_related_function</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">f1_id</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amd64_err</span><span class="p">(</span><span class="s">&quot;error address map device not found: &quot;</span>
			  <span class="s">&quot;vendor %x device 0x%x (broken BIOS?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">f1_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reserve the MISC Device */</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F3</span> <span class="o">=</span> <span class="n">pci_get_related_function</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">f3_id</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">);</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">amd64_err</span><span class="p">(</span><span class="s">&quot;error F3 device not found: &quot;</span>
			  <span class="s">&quot;vendor %x device 0x%x (broken BIOS?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">f3_id</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;F1: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">));</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;F2: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="p">));</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;F3: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F3</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_mc_sibling_devs</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieve the hardware registers of the memory controller (this includes the</span>
<span class="cm"> * &#39;Address Map&#39; and &#39;Misc&#39; device regs)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_mc_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">msr_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">range</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Retrieve TOP_MEM and TOP_MEM2; no masking off of reserved bits since</span>
<span class="cm">	 * those are Read-As-Zero</span>
<span class="cm">	 */</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_K8_TOP_MEM1</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">top_mem</span><span class="p">);</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;  TOP_MEM:  0x%016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">top_mem</span><span class="p">);</span>

	<span class="cm">/* check first whether TOP_MEM2 is enabled */</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_K8_SYSCFG</span><span class="p">,</span> <span class="n">msr_val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_K8_TOP_MEM2</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">top_mem2</span><span class="p">);</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;  TOP_MEM2: 0x%016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">top_mem2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;  TOP_MEM2 disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcap</span><span class="p">);</span>

	<span class="n">read_dram_ctl_register</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">range</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">range</span> <span class="o">&lt;</span> <span class="n">DRAM_RANGES</span><span class="p">;</span> <span class="n">range</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">rw</span><span class="p">;</span>

		<span class="cm">/* read settings for this DRAM range */</span>
		<span class="n">read_dram_base_limit_regs</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>

		<span class="n">rw</span> <span class="o">=</span> <span class="n">dram_rw</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rw</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  DRAM range[%d], base: 0x%016llx; limit: 0x%016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">range</span><span class="p">,</span>
			<span class="n">get_dram_base</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">),</span>
			<span class="n">get_dram_limit</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">));</span>

		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;   IntlvEn=%s; Range access: %s%s IntlvSel=%d DstNode=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dram_intlv_en</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;Disabled&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;R&quot;</span> <span class="o">:</span> <span class="s">&quot;-&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;W&quot;</span> <span class="o">:</span> <span class="s">&quot;-&quot;</span><span class="p">,</span>
			<span class="n">dram_intlv_sel</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">),</span>
			<span class="n">dram_dst_node</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">range</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">read_dct_base_mask</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">DHAR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dhar</span><span class="p">);</span>
	<span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">DBAM0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dbam0</span><span class="p">);</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F3</span><span class="p">,</span> <span class="n">F10_ONLINE_SPARE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">online_spare</span><span class="p">);</span>

	<span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">DCLR0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr0</span><span class="p">);</span>
	<span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">DCHR0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dchr0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dct_ganging_enabled</span><span class="p">(</span><span class="n">pvt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">DCLR1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dclr1</span><span class="p">);</span>
		<span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">DCHR1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dchr1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ecc_sym_sz</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F3</span><span class="p">,</span> <span class="n">EXT_NB_MCA_CFG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">amd64_read_dct_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">DBAM1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dbam1</span><span class="p">);</span>

		<span class="cm">/* F10h, revD and later can do x8 ECC too */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">&gt;</span> <span class="mh">0x10</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span>
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ecc_sym_sz</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dump_misc_regs</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: CPU Revision Dependent code</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *	@csrow_nr ChipSelect Row Number (0..NUM_CHIPSELECTS-1)</span>
<span class="cm"> *	k8 private pointer to --&gt;</span>
<span class="cm"> *			DRAM Bank Address mapping register</span>
<span class="cm"> *			node_id</span>
<span class="cm"> *			DCL register where dual_channel_active is</span>
<span class="cm"> *</span>
<span class="cm"> * The DBAM register consists of 4 sets of 4 bits each definitions:</span>
<span class="cm"> *</span>
<span class="cm"> * Bits:	CSROWs</span>
<span class="cm"> * 0-3		CSROWs 0 and 1</span>
<span class="cm"> * 4-7		CSROWs 2 and 3</span>
<span class="cm"> * 8-11		CSROWs 4 and 5</span>
<span class="cm"> * 12-15	CSROWs 6 and 7</span>
<span class="cm"> *</span>
<span class="cm"> * Values range from: 0 to 15</span>
<span class="cm"> * The meaning of the values depends on CPU revision and dual-channel state,</span>
<span class="cm"> * see relevant BKDG more info.</span>
<span class="cm"> *</span>
<span class="cm"> * The memory controller provides for total of only 8 CSROWs in its current</span>
<span class="cm"> * architecture. Each &quot;pair&quot; of CSROWs normally represents just one DIMM in</span>
<span class="cm"> * single channel or two (2) DIMMs in dual channel mode.</span>
<span class="cm"> *</span>
<span class="cm"> * The following code logic collapses the various tables for CSROW based on CPU</span>
<span class="cm"> * revision.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	The number of PAGE_SIZE pages on the specified CSROW number it</span>
<span class="cm"> *	encompasses</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">amd64_csrow_nr_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dct</span><span class="p">,</span> <span class="kt">int</span> <span class="n">csrow_nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cs_mode</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dbam</span> <span class="o">=</span> <span class="n">dct</span> <span class="o">?</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dbam1</span> <span class="o">:</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dbam0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The math on this doesn&#39;t look right on the surface because x/2*4 can</span>
<span class="cm">	 * be simplified to x*2 but this expression makes use of the fact that</span>
<span class="cm">	 * it is integral math where 1/2=0. This intermediate value becomes the</span>
<span class="cm">	 * number of bits to shift the DBAM register to extract the proper CSROW</span>
<span class="cm">	 * field.</span>
<span class="cm">	 */</span>
	<span class="n">cs_mode</span> <span class="o">=</span>  <span class="p">(</span><span class="n">dbam</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">csrow_nr</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>

	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dbam_to_cs</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="n">cs_mode</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;  (csrow=%d) DBAM map index= %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow_nr</span><span class="p">,</span> <span class="n">cs_mode</span><span class="p">);</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;    nr_pages/channel= %u  channel-count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">nr_pages</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">channel_count</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr_pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the array of csrow attribute instances, based on the values</span>
<span class="cm"> * from pci config hardware registers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_csrows</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">base</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mem_type</span> <span class="n">mtype</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">edac_type</span> <span class="n">edac_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCFG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcfg</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;node %d, NBCFG=0x%08x[ChipKillEccCap: %d|DramEccEn: %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
		<span class="o">!!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">NBCFG_CHIPKILL</span><span class="p">),</span> <span class="o">!!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">NBCFG_ECC_ENABLE</span><span class="p">));</span>

	<span class="n">for_each_chip_select</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pvt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">csrow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">csrow_enabled</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pvt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">csrow_enabled</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pvt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;----CSROW %d EMPTY for node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;----CSROW %d VALID for MC node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">);</span>

		<span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csrow_enabled</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pvt</span><span class="p">))</span>
			<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">amd64_csrow_nr_pages</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csrow_enabled</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pvt</span><span class="p">))</span>
			<span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">amd64_csrow_nr_pages</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">get_cs_base_and_mask</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
		<span class="cm">/* 8 bytes of resolution */</span>

		<span class="n">mtype</span> <span class="o">=</span> <span class="n">amd64_determine_memory_type</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;  for MC node %d csrow %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;    nr_pages: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_pages</span> <span class="o">*</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">channel_count</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * determine whether CHIPKILL or JUST ECC or NO ECC is operating</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcfg</span> <span class="o">&amp;</span> <span class="n">NBCFG_ECC_ENABLE</span><span class="p">)</span>
			<span class="n">edac_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcfg</span> <span class="o">&amp;</span> <span class="n">NBCFG_CHIPKILL</span><span class="p">)</span> <span class="o">?</span>
				    <span class="n">EDAC_S4ECD4ED</span> <span class="o">:</span> <span class="n">EDAC_SECDED</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">edac_mode</span> <span class="o">=</span> <span class="n">EDAC_NONE</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">channel_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">mtype</span> <span class="o">=</span> <span class="n">mtype</span><span class="p">;</span>
			<span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">edac_mode</span> <span class="o">=</span> <span class="n">edac_mode</span><span class="p">;</span>
			<span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">empty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* get all cores on this DCT */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_cpus_on_this_dct_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amd_get_nb_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* check MCG_CTL on all the cpus on this node */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">amd64_nb_mce_bank_enabled_on_node</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">nbe</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;%s: Error allocating mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">get_cpus_on_this_dct_cpumask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>

	<span class="n">rdmsr_on_cpus</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">MSR_IA32_MCG_CTL</span><span class="p">,</span> <span class="n">msrs</span><span class="p">);</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">msr</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">msrs</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">nbe</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&amp;</span> <span class="n">MSR_MCGCTL_NBE</span><span class="p">;</span>

		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;core: %u, MCG_CTL: 0x%llx, NB MSR is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cpu</span><span class="p">,</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span>
			<span class="p">(</span><span class="n">nbe</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nbe</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">toggle_ecc_err_reporting</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecc_settings</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">u8</span> <span class="n">nid</span><span class="p">,</span> <span class="n">bool</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">cmask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;%s: error allocating mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">get_cpus_on_this_dct_cpumask</span><span class="p">(</span><span class="n">cmask</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>

	<span class="n">rdmsr_on_cpus</span><span class="p">(</span><span class="n">cmask</span><span class="p">,</span> <span class="n">MSR_IA32_MCG_CTL</span><span class="p">,</span> <span class="n">msrs</span><span class="p">);</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cmask</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">struct</span> <span class="n">msr</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">msrs</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&amp;</span> <span class="n">MSR_MCGCTL_NBE</span><span class="p">)</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">nb_mce_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">|=</span> <span class="n">MSR_MCGCTL_NBE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Turn off NB MCE reporting only when it was off before</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">nb_mce_enable</span><span class="p">)</span>
				<span class="n">reg</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_MCGCTL_NBE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">wrmsr_on_cpus</span><span class="p">(</span><span class="n">cmask</span><span class="p">,</span> <span class="n">MSR_IA32_MCG_CTL</span><span class="p">,</span> <span class="n">msrs</span><span class="p">);</span>

	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cmask</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">enable_ecc_error_reporting</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecc_settings</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">u8</span> <span class="n">nid</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">F3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">;</span>		<span class="cm">/* UECC/CECC enable */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">toggle_ecc_err_reporting</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">ON</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;Error enabling ECC reporting over MCGCTL!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">old_nbctl</span>   <span class="o">=</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">nbctl_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">value</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">amd64_write_pci_cfg</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCTL</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCFG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;1: node %d, NBCFG=0x%08x[DramEccEn: %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">nid</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">NBCFG_ECC_ENABLE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">NBCFG_ECC_ENABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;DRAM ECC disabled on this node, enabling...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">nb_ecc_prev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Attempt to turn on DRAM ECC Enable */</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">NBCFG_ECC_ENABLE</span><span class="p">;</span>
		<span class="n">amd64_write_pci_cfg</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCFG</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

		<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCFG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">NBCFG_ECC_ENABLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;Hardware rejected DRAM ECC enable,&quot;</span>
				   <span class="s">&quot;check memory DIMM configuration.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">amd64_info</span><span class="p">(</span><span class="s">&quot;Hardware accepted DRAM ECC Enable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">nb_ecc_prev</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;2: node %d, NBCFG=0x%08x[DramEccEn: %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">nid</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">NBCFG_ECC_ENABLE</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_ecc_error_reporting</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecc_settings</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">u8</span> <span class="n">nid</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">F3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">;</span>		<span class="cm">/* UECC/CECC enable */</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">nbctl_valid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">old_nbctl</span><span class="p">;</span>

	<span class="n">amd64_write_pci_cfg</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCTL</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="cm">/* restore previous BIOS DRAM ECC &quot;off&quot; setting we force-enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">nb_ecc_prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCFG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NBCFG_ECC_ENABLE</span><span class="p">;</span>
		<span class="n">amd64_write_pci_cfg</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCFG</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* restore the NB Enable MCGCTL bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">toggle_ecc_err_reporting</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">OFF</span><span class="p">))</span>
		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;Error restoring NB MCGCTL settings!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * EDAC requires that the BIOS have ECC enabled before</span>
<span class="cm"> * taking over the processing of ECC errors. A command line</span>
<span class="cm"> * option allows to force-enable hardware ECC later in</span>
<span class="cm"> * enable_ecc_error_reporting().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ecc_msg</span> <span class="o">=</span>
	<span class="s">&quot;ECC disabled in the BIOS or no ECC capability, module will not load.</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot; Either enable ECC checking or force module loading by setting &quot;</span>
	<span class="s">&quot;&#39;ecc_enable_override&#39;.</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot; (Note that use of the override may cause unknown side effects.)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">ecc_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">F3</span><span class="p">,</span> <span class="n">u8</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ecc_en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">nb_mce_en</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">amd64_read_pci_cfg</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">NBCFG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

	<span class="n">ecc_en</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">NBCFG_ECC_ENABLE</span><span class="p">);</span>
	<span class="n">amd64_info</span><span class="p">(</span><span class="s">&quot;DRAM ECC %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ecc_en</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">));</span>

	<span class="n">nb_mce_en</span> <span class="o">=</span> <span class="n">amd64_nb_mce_bank_enabled_on_node</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nb_mce_en</span><span class="p">)</span>
		<span class="n">amd64_notice</span><span class="p">(</span><span class="s">&quot;NB MCE bank disabled, set MSR &quot;</span>
			     <span class="s">&quot;0x%08x[4] on node %d to enable.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">MSR_IA32_MCG_CTL</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ecc_en</span> <span class="o">||</span> <span class="o">!</span><span class="n">nb_mce_en</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amd64_notice</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">ecc_msg</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="n">sysfs_attrs</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">amd64_dbg_attrs</span><span class="p">)</span> <span class="o">+</span>
					  <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">amd64_inj_attrs</span><span class="p">)</span> <span class="o">+</span>
					  <span class="mi">1</span><span class="p">];</span>

<span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="n">terminator</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">}</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_mc_sysfs_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">amd64_dbg_attrs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sysfs_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">amd64_dbg_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mh">0x10</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">amd64_inj_attrs</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">sysfs_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">amd64_inj_attrs</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

	<span class="n">sysfs_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">terminator</span><span class="p">;</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_driver_sysfs_attributes</span> <span class="o">=</span> <span class="n">sysfs_attrs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_mci_misc_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">amd64_family_type</span> <span class="o">*</span><span class="n">fam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mtype_cap</span>		<span class="o">=</span> <span class="n">MEM_FLAG_DDR2</span> <span class="o">|</span> <span class="n">MEM_FLAG_RDDR2</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_ctl_cap</span>	<span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcap</span> <span class="o">&amp;</span> <span class="n">NBCAP_SECDED</span><span class="p">)</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_ctl_cap</span> <span class="o">|=</span> <span class="n">EDAC_FLAG_SECDED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">nbcap</span> <span class="o">&amp;</span> <span class="n">NBCAP_CHIPKILL</span><span class="p">)</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_ctl_cap</span> <span class="o">|=</span> <span class="n">EDAC_FLAG_S4ECD4ED</span><span class="p">;</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span>		<span class="o">=</span> <span class="n">amd64_determine_edac_cap</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_name</span>		<span class="o">=</span> <span class="n">EDAC_MOD_STR</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_ver</span>		<span class="o">=</span> <span class="n">EDAC_AMD64_VERSION</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span>		<span class="o">=</span> <span class="n">fam</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev_name</span>		<span class="o">=</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="p">);</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_page_to_phys</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* memory scrubber interface */</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">set_sdram_scrub_rate</span> <span class="o">=</span> <span class="n">amd64_set_scrub_rate</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">get_sdram_scrub_rate</span> <span class="o">=</span> <span class="n">amd64_get_scrub_rate</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns a pointer to the family descriptor on success, NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">amd64_family_type</span> <span class="o">*</span><span class="nf">amd64_per_family_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">fam</span> <span class="o">=</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">amd64_family_type</span> <span class="o">*</span><span class="n">fam_type</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fam</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0xf</span>:
		<span class="n">fam_type</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">amd64_family_types</span><span class="p">[</span><span class="n">K8_CPUS</span><span class="p">];</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">amd64_family_types</span><span class="p">[</span><span class="n">K8_CPUS</span><span class="p">].</span><span class="n">ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mh">0x10</span>:
		<span class="n">fam_type</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">amd64_family_types</span><span class="p">[</span><span class="n">F10_CPUS</span><span class="p">];</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">amd64_family_types</span><span class="p">[</span><span class="n">F10_CPUS</span><span class="p">].</span><span class="n">ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mh">0x15</span>:
		<span class="n">fam_type</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">amd64_family_types</span><span class="p">[</span><span class="n">F15_CPUS</span><span class="p">];</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">amd64_family_types</span><span class="p">[</span><span class="n">F15_CPUS</span><span class="p">].</span><span class="n">ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">amd64_err</span><span class="p">(</span><span class="s">&quot;Unsupported family!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">=</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_model</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">amd64_info</span><span class="p">(</span><span class="s">&quot;%s %sdetected (node %d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fam_type</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">fam</span> <span class="o">==</span> <span class="mh">0xf</span> <span class="o">?</span>
				<span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ext_model</span> <span class="o">&gt;=</span> <span class="n">K8_REV_F</span>  <span class="o">?</span> <span class="s">&quot;revF or later &quot;</span>
							     <span class="o">:</span> <span class="s">&quot;revE or earlier &quot;</span><span class="p">)</span>
				 <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">),</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fam_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">amd64_init_one_instance</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">F2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">amd64_family_type</span> <span class="o">*</span><span class="n">fam_type</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="n">layers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">get_node_id</span><span class="p">(</span><span class="n">F2</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">pvt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">amd64_pvt</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ret</span><span class="p">;</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_node_id</span>	<span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span> <span class="o">=</span> <span class="n">F2</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">fam_type</span> <span class="o">=</span> <span class="n">amd64_per_family_init</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fam_type</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">reserve_mc_sibling_devs</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">fam_type</span><span class="o">-&gt;</span><span class="n">f1_id</span><span class="p">,</span> <span class="n">fam_type</span><span class="o">-&gt;</span><span class="n">f3_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>

	<span class="n">read_mc_regs</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to determine how many memory channels there are. Then use</span>
<span class="cm">	 * that information for calculating the size of the dynamic instance</span>
<span class="cm">	 * tables in the &#39;mci&#39; structure.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">channel_count</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">early_channel_count</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">channel_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_siblings</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_CHIP_SELECT</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">csels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">b_cnt</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_CHANNEL</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">channel_count</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">edac_mc_alloc</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">layers</span><span class="p">),</span> <span class="n">layers</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mci</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_siblings</span><span class="p">;</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span> <span class="o">=</span> <span class="n">pvt</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">setup_mci_misc_attrs</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">fam_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init_csrows</span><span class="p">(</span><span class="n">mci</span><span class="p">))</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>

	<span class="n">set_mc_sysfs_attrs</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edac_mc_add_mc</span><span class="p">(</span><span class="n">mci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;failed edac_mc_add_mc()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_add_mc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* register stuff with EDAC MCE */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">report_gart_errors</span><span class="p">)</span>
		<span class="n">amd_report_gart_errors</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

	<span class="n">amd_register_ecc_decoder</span><span class="p">(</span><span class="n">amd64_decode_bus_error</span><span class="p">);</span>

	<span class="n">mcis</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">mci</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_instances</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_add_mc:</span>
	<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

<span class="nl">err_siblings:</span>
	<span class="n">free_mc_sibling_devs</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

<span class="nl">err_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

<span class="nl">err_ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">amd64_probe_one_instance</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">mc_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">get_node_id</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">F3</span> <span class="o">=</span> <span class="n">node_to_amd_nb</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ecc_settings</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecc_settings</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">ecc_stngs</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ecc_enabled</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">nid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ecc_enable_override</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_enable</span><span class="p">;</span>

		<span class="n">amd64_warn</span><span class="p">(</span><span class="s">&quot;Forcing ECC on!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_ecc_error_reporting</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">F3</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_enable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">amd64_init_one_instance</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amd64_err</span><span class="p">(</span><span class="s">&quot;Error probing instance: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">restore_ecc_error_reporting</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">F3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">err_enable:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">ecc_stngs</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">amd64_remove_one_instance</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">get_node_id</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">F3</span> <span class="o">=</span> <span class="n">node_to_amd_nb</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ecc_settings</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">ecc_stngs</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>

	<span class="cm">/* Remove from EDAC CORE tracking list */</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">edac_mc_del_mc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mci</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">restore_ecc_error_reporting</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">F3</span><span class="p">);</span>

	<span class="n">free_mc_sibling_devs</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

	<span class="cm">/* unregister from EDAC MCE */</span>
	<span class="n">amd_report_gart_errors</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">amd_unregister_ecc_decoder</span><span class="p">(</span><span class="n">amd64_decode_bus_error</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ecc_stngs</span><span class="p">[</span><span class="n">nid</span><span class="p">]);</span>
	<span class="n">ecc_stngs</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Free the EDAC CORE resources */</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mcis</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>
	<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This table is part of the interface for loading drivers for PCI devices. The</span>
<span class="cm"> * PCI core identifies what devices are on a system during boot, and then</span>
<span class="cm"> * inquiry this table to see if this driver is for a given device found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">amd64_pci_table</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">vendor</span>		<span class="o">=</span> <span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">device</span>		<span class="o">=</span> <span class="n">PCI_DEVICE_ID_AMD_K8_NB_MEMCTL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span>	<span class="o">=</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span>	<span class="o">=</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">class</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">class_mask</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">vendor</span>		<span class="o">=</span> <span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">device</span>		<span class="o">=</span> <span class="n">PCI_DEVICE_ID_AMD_10H_NB_DRAM</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span>	<span class="o">=</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span>	<span class="o">=</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">class</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">class_mask</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">vendor</span>		<span class="o">=</span> <span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">device</span>		<span class="o">=</span> <span class="n">PCI_DEVICE_ID_AMD_15H_NB_F2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span>	<span class="o">=</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span>	<span class="o">=</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">class</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">class_mask</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">amd64_pci_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">amd64_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">EDAC_MOD_STR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">amd64_probe_one_instance</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">amd64_remove_one_instance</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">amd64_pci_table</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_pci_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">amd64_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">amd64_ctl_pci</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mci</span> <span class="o">=</span> <span class="n">mcis</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
		<span class="n">amd64_ctl_pci</span> <span class="o">=</span>
			<span class="n">edac_pci_create_generic_ctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">F2</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">EDAC_MOD_STR</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">amd64_ctl_pci</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s(): Unable to create PCI control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>

			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s(): PCI error report via EDAC not set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">amd64_edac_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;AMD64 EDAC driver v%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">EDAC_AMD64_VERSION</span><span class="p">);</span>

	<span class="n">opstate_init</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">amd_cache_northbridges</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ret</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">mcis</span>	  <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">amd_nb_num</span><span class="p">()</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mcis</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">ecc_stngs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">amd_nb_num</span><span class="p">()</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ecc_stngs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mcis</span> <span class="o">&amp;&amp;</span> <span class="n">ecc_stngs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>

	<span class="n">msrs</span> <span class="o">=</span> <span class="n">msrs_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msrs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd64_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_pci</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_instances</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_no_instances</span><span class="p">;</span>

	<span class="n">setup_pci_device</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_no_instances:</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd64_pci_driver</span><span class="p">);</span>

<span class="nl">err_pci:</span>
	<span class="n">msrs_free</span><span class="p">(</span><span class="n">msrs</span><span class="p">);</span>
	<span class="n">msrs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">err_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mcis</span><span class="p">);</span>
	<span class="n">mcis</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ecc_stngs</span><span class="p">);</span>
	<span class="n">ecc_stngs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">err_ret:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">amd64_edac_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amd64_ctl_pci</span><span class="p">)</span>
		<span class="n">edac_pci_release_generic_ctl</span><span class="p">(</span><span class="n">amd64_ctl_pci</span><span class="p">);</span>

	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd64_pci_driver</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ecc_stngs</span><span class="p">);</span>
	<span class="n">ecc_stngs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">mcis</span><span class="p">);</span>
	<span class="n">mcis</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">msrs_free</span><span class="p">(</span><span class="n">msrs</span><span class="p">);</span>
	<span class="n">msrs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">amd64_edac_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">amd64_edac_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;SoftwareBitMaker: Doug Thompson, &quot;</span>
		<span class="s">&quot;Dave Peterson, Thayne Harbaugh&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MC support for AMD64 memory controllers - &quot;</span>
		<span class="n">EDAC_AMD64_VERSION</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">edac_op_state</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edac_op_state</span><span class="p">,</span> <span class="s">&quot;EDAC Error Reporting state: 0=Poll,1=NMI&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
