<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › edac › edac_mc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>edac_mc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * edac_mc kernel module</span>
<span class="cm"> * (C) 2005, 2006 Linux Networx (http://lnxi.com)</span>
<span class="cm"> * This file may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License.</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Thayne Harbaugh</span>
<span class="cm"> * Based on work by Dan Hollis &lt;goemon at anime dot net&gt; and others.</span>
<span class="cm"> *	http://www.anime.net/~goemon/linux-ecc/</span>
<span class="cm"> *</span>
<span class="cm"> * Modified by Dave Peterson and Doug Thompson</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/edac.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/edac.h&gt;</span>
<span class="cp">#include &quot;edac_core.h&quot;</span>
<span class="cp">#include &quot;edac_module.h&quot;</span>

<span class="cm">/* lock to memory controller&#39;s control array */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">mc_devices</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_EDAC_DEBUG</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_mc_dump_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">rank_info</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">channel = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">channel-&gt;chan_idx = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">chan_idx</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">channel-&gt;csrow = %p</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">csrow</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">channel-&gt;dimm = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">dimm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_mc_dump_dimm</span><span class="p">(</span><span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">dimm = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dimm</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">dimm-&gt;label = &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">dimm-&gt;nr_pages = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">dimm location &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;.&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">dimm-&gt;grain = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">grain</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">dimm-&gt;nr_pages = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_mc_dump_csrow</span><span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">csrow = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">csrow-&gt;csrow_idx = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">csrow_idx</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">csrow-&gt;first_page = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">first_page</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">csrow-&gt;last_page = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">last_page</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">csrow-&gt;page_mask = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">page_mask</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">csrow-&gt;nr_channels = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">csrow-&gt;channels = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">csrow-&gt;mci = %p</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">mci</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_mc_dump_mci</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">mci = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="p">);</span>
	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">mci-&gt;mtype_cap = %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mtype_cap</span><span class="p">);</span>
	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">mci-&gt;edac_ctl_cap = %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_ctl_cap</span><span class="p">);</span>
	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">mci-&gt;edac_cap = %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">mci-&gt;edac_check = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_check</span><span class="p">);</span>
	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">mci-&gt;nr_csrows = %d, csrows = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">);</span>
	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">mci-&gt;nr_dimms = %d, dimms = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">tot_dimms</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">dimms</span><span class="p">);</span>
	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">dev = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">mod_name:ctl_name = %s:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">);</span>
	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">pvt_info = %p</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif				</span><span class="cm">/* CONFIG_EDAC_DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * keep those in sync with the enum mem_type</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">edac_mem_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Empty csrow&quot;</span><span class="p">,</span>
	<span class="s">&quot;Reserved csrow type&quot;</span><span class="p">,</span>
	<span class="s">&quot;Unknown csrow type&quot;</span><span class="p">,</span>
	<span class="s">&quot;Fast page mode RAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Extended data out RAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Burst Extended data out RAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Single data rate SDRAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Registered single data rate SDRAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Double data rate SDRAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Registered Double data rate SDRAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Rambus DRAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Unbuffered DDR2 RAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Fully buffered DDR2&quot;</span><span class="p">,</span>
	<span class="s">&quot;Registered DDR2 RAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Rambus XDR&quot;</span><span class="p">,</span>
	<span class="s">&quot;Unbuffered DDR3 RAM&quot;</span><span class="p">,</span>
	<span class="s">&quot;Registered DDR3 RAM&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">edac_mem_types</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edac_align_ptr - Prepares the pointer offsets for a single-shot allocation</span>
<span class="cm"> * @p:		pointer to a pointer with the memory offset to be used. At</span>
<span class="cm"> *		return, this will be incremented to point to the next offset</span>
<span class="cm"> * @size:	Size of the data structure to be reserved</span>
<span class="cm"> * @n_elems:	Number of elements that should be reserved</span>
<span class="cm"> *</span>
<span class="cm"> * If &#39;size&#39; is a constant, the compiler will optimize this whole function</span>
<span class="cm"> * down to either a no-op or the addition of a constant to the value of &#39;*p&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * The &#39;p&#39; pointer is absolutely needed to keep the proper advancing</span>
<span class="cm"> * further in memory to the proper offsets when allocating the struct along</span>
<span class="cm"> * with its embedded structs, as edac_device_alloc_ctl_info() does it</span>
<span class="cm"> * above, for example.</span>
<span class="cm"> *</span>
<span class="cm"> * At return, the pointer &#39;p&#39; will be incremented to be used on a next call</span>
<span class="cm"> * to this function.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">edac_align_ptr</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_elems</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">align</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">*</span> <span class="n">n_elems</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * &#39;p&#39; can possibly be an unaligned item X such that sizeof(X) is</span>
<span class="cm">	 * &#39;size&#39;.  Adjust &#39;p&#39; so that its alignment is at least as</span>
<span class="cm">	 * stringent as what the compiler would provide for X and return</span>
<span class="cm">	 * the aligned result.</span>
<span class="cm">	 * Here we assume that the alignment of a &quot;long long&quot; is the most</span>
<span class="cm">	 * stringent alignment that the compiler will ever provide by default.</span>
<span class="cm">	 * As far as I know, this is a reasonable assumption.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">))</span>
		<span class="n">align</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="n">align</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">))</span>
		<span class="n">align</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">))</span>
		<span class="n">align</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span> <span class="o">%</span> <span class="n">align</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p</span> <span class="o">+=</span> <span class="n">align</span> <span class="o">-</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="n">align</span> <span class="o">-</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * edac_mc_alloc: Allocate and partially fill a struct mem_ctl_info structure</span>
<span class="cm"> * @mc_num:		Memory controller number</span>
<span class="cm"> * @n_layers:		Number of MC hierarchy layers</span>
<span class="cm"> * layers:		Describes each layer as seen by the Memory Controller</span>
<span class="cm"> * @size_pvt:		size of private storage needed</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Everything is kmalloc&#39;ed as one big chunk - more efficient.</span>
<span class="cm"> * Only can be used if all structures have the same lifetime - otherwise</span>
<span class="cm"> * you have to allocate and initialize your own structures.</span>
<span class="cm"> *</span>
<span class="cm"> * Use edac_mc_free() to free mc structures allocated by this function.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: drivers handle multi-rank memories in different ways: in some</span>
<span class="cm"> * drivers, one multi-rank memory stick is mapped as one entry, while, in</span>
<span class="cm"> * others, a single multi-rank memory stick would be mapped into several</span>
<span class="cm"> * entries. Currently, this function will allocate multiple struct dimm_info</span>
<span class="cm"> * on such scenarios, as grouping the multiple ranks require drivers change.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	On failure: NULL</span>
<span class="cm"> *	On success: struct mem_ctl_info pointer</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="nf">edac_mc_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">mc_num</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">n_layers</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="o">*</span><span class="n">layers</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">sz_pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="o">*</span><span class="n">layer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csi</span><span class="p">,</span> <span class="o">*</span><span class="n">csr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rank_info</span> <span class="o">*</span><span class="n">chi</span><span class="p">,</span> <span class="o">*</span><span class="n">chp</span><span class="p">,</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">ce_per_layer</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">],</span> <span class="o">*</span><span class="n">ue_per_layer</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">pos</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">size</span><span class="p">,</span> <span class="n">tot_dimms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tot_csrows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tot_channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tot_errcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">chn</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">per_rank</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n_layers</span> <span class="o">&gt;</span> <span class="n">EDAC_MAX_LAYERS</span> <span class="o">||</span> <span class="n">n_layers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Calculate the total amount of dimms and csrows/cschannels while</span>
<span class="cm">	 * in the old API emulation mode</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_layers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tot_dimms</span> <span class="o">*=</span> <span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_virt_csrow</span><span class="p">)</span>
			<span class="n">tot_csrows</span> <span class="o">*=</span> <span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tot_channels</span> <span class="o">*=</span> <span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">EDAC_MC_LAYER_CHIP_SELECT</span><span class="p">)</span>
			<span class="n">per_rank</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Figure out the offsets of the various items from the start of an mc</span>
<span class="cm">	 * structure.  We want the alignment of each item to be at least as</span>
<span class="cm">	 * stringent as what the compiler would provide if we could simply</span>
<span class="cm">	 * hardcode everything into a single struct.</span>
<span class="cm">	 */</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">edac_align_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mci</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">layer</span> <span class="o">=</span> <span class="n">edac_align_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">layer</span><span class="p">),</span> <span class="n">n_layers</span><span class="p">);</span>
	<span class="n">csi</span> <span class="o">=</span> <span class="n">edac_align_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">csi</span><span class="p">),</span> <span class="n">tot_csrows</span><span class="p">);</span>
	<span class="n">chi</span> <span class="o">=</span> <span class="n">edac_align_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chi</span><span class="p">),</span> <span class="n">tot_csrows</span> <span class="o">*</span> <span class="n">tot_channels</span><span class="p">);</span>
	<span class="n">dimm</span> <span class="o">=</span> <span class="n">edac_align_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dimm</span><span class="p">),</span> <span class="n">tot_dimms</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_layers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">*=</span> <span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
		<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s: errcount layer %d size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">ce_per_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">edac_align_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">ue_per_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">edac_align_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">tot_errcount</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s: allocating %d error counters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tot_errcount</span><span class="p">);</span>
	<span class="n">pvt</span> <span class="o">=</span> <span class="n">edac_align_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">sz_pvt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pvt</span><span class="p">)</span> <span class="o">+</span> <span class="n">sz_pvt</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s(): allocating %u bytes for mci data (%d %s, %d csrows/channels)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
		<span class="n">tot_dimms</span><span class="p">,</span>
		<span class="n">per_rank</span> <span class="o">?</span> <span class="s">&quot;ranks&quot;</span> <span class="o">:</span> <span class="s">&quot;dimms&quot;</span><span class="p">,</span>
		<span class="n">tot_csrows</span> <span class="o">*</span> <span class="n">tot_channels</span><span class="p">);</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Adjust pointers so they point within the memory we just allocated</span>
<span class="cm">	 * rather than an imaginary chunk of memory located at address 0.</span>
<span class="cm">	 */</span>
	<span class="n">layer</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mci</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">layer</span><span class="p">));</span>
	<span class="n">csi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mci</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">csi</span><span class="p">));</span>
	<span class="n">chi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rank_info</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mci</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">chi</span><span class="p">));</span>
	<span class="n">dimm</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mci</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dimm</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_layers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ce_per_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mci</span> <span class="o">+</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ce_per_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ue_per_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mci</span> <span class="o">+</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ue_per_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="n">pvt</span> <span class="o">=</span> <span class="n">sz_pvt</span> <span class="o">?</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mci</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pvt</span><span class="p">))</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* setup index and various internal pointers */</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span> <span class="o">=</span> <span class="n">mc_num</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span> <span class="o">=</span> <span class="n">csi</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dimms</span>  <span class="o">=</span> <span class="n">dimm</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">tot_dimms</span> <span class="o">=</span> <span class="n">tot_dimms</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span> <span class="o">=</span> <span class="n">pvt</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span> <span class="o">=</span> <span class="n">n_layers</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span> <span class="o">=</span> <span class="n">layer</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">layer</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_layers</span><span class="p">);</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span> <span class="o">=</span> <span class="n">tot_csrows</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">num_cschannel</span> <span class="o">=</span> <span class="n">tot_channels</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mem_is_per_rank</span> <span class="o">=</span> <span class="n">per_rank</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill the csrow struct</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">tot_csrows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">csr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">csi</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>
		<span class="n">csr</span><span class="o">-&gt;</span><span class="n">csrow_idx</span> <span class="o">=</span> <span class="n">row</span><span class="p">;</span>
		<span class="n">csr</span><span class="o">-&gt;</span><span class="n">mci</span> <span class="o">=</span> <span class="n">mci</span><span class="p">;</span>
		<span class="n">csr</span><span class="o">-&gt;</span><span class="n">nr_channels</span> <span class="o">=</span> <span class="n">tot_channels</span><span class="p">;</span>
		<span class="n">chp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chi</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">tot_channels</span><span class="p">];</span>
		<span class="n">csr</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">=</span> <span class="n">chp</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">chn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chn</span> <span class="o">&lt;</span> <span class="n">tot_channels</span><span class="p">;</span> <span class="n">chn</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chan</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chp</span><span class="p">[</span><span class="n">chn</span><span class="p">];</span>
			<span class="n">chan</span><span class="o">-&gt;</span><span class="n">chan_idx</span> <span class="o">=</span> <span class="n">chn</span><span class="p">;</span>
			<span class="n">chan</span><span class="o">-&gt;</span><span class="n">csrow</span> <span class="o">=</span> <span class="n">csr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill the dimm struct</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pos</span><span class="p">));</span>
	<span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">chn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s: initializing %d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tot_dimms</span><span class="p">,</span>
		<span class="n">per_rank</span> <span class="o">?</span> <span class="s">&quot;ranks&quot;</span> <span class="o">:</span> <span class="s">&quot;dimms&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tot_dimms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">csi</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">channels</span><span class="p">[</span><span class="n">chn</span><span class="p">];</span>
		<span class="n">dimm</span> <span class="o">=</span> <span class="n">EDAC_DIMM_PTR</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">dimms</span><span class="p">,</span> <span class="n">n_layers</span><span class="p">,</span>
			       <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">mci</span> <span class="o">=</span> <span class="n">mci</span><span class="p">;</span>

		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s: %d: %s%zd (%d:%d:%d): row %d, chan %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">per_rank</span> <span class="o">?</span> <span class="s">&quot;rank&quot;</span> <span class="o">:</span> <span class="s">&quot;dimm&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">dimm</span> <span class="o">-</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">dimms</span><span class="p">),</span>
			<span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">row</span><span class="p">,</span> <span class="n">chn</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Copy DIMM location and initialize it.</span>
<span class="cm">		 */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;mc#%u&quot;</span><span class="p">,</span> <span class="n">mc_num</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_layers</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s#%u&quot;</span><span class="p">,</span>
				     <span class="n">edac_layer_name</span><span class="p">[</span><span class="n">layers</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">type</span><span class="p">],</span>
				     <span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Link it to the csrows old API data */</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">dimm</span> <span class="o">=</span> <span class="n">dimm</span><span class="p">;</span>
		<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">csrow</span> <span class="o">=</span> <span class="n">row</span><span class="p">;</span>
		<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">cschannel</span> <span class="o">=</span> <span class="n">chn</span><span class="p">;</span>

		<span class="cm">/* Increment csrow location */</span>
		<span class="n">row</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">tot_csrows</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">chn</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Increment dimm location */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">n_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">layers</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">size</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">op_state</span> <span class="o">=</span> <span class="n">OP_ALLOC</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">grp_kobj_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the &#39;root&#39; kobj for the edac_mc controller</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">edac_mc_register_sysfs_main_kobj</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* at this point, the root kobj is valid, and in order to</span>
<span class="cm">	 * &#39;free&#39; the object, then the function:</span>
<span class="cm">	 *      edac_mc_unregister_sysfs_main_kobj() must be called</span>
<span class="cm">	 * which will perform kobj unregistration and the actual free</span>
<span class="cm">	 * will occur during the kobject callback operation</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">mci</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">edac_mc_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edac_mc_free</span>
<span class="cm"> *	&#39;Free&#39; a previously allocated &#39;mci&#39; structure</span>
<span class="cm"> * @mci: pointer to a struct mem_ctl_info structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_mc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">edac_mc_unregister_sysfs_main_kobj</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="cm">/* free the mci instance memory here */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">edac_mc_free</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * find_mci_by_dev</span>
<span class="cm"> *</span>
<span class="cm"> *	scan list of controllers looking for the one that manages</span>
<span class="cm"> *	the &#39;dev&#39; device</span>
<span class="cm"> * @dev: pointer to a struct device related with the MCI</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="nf">find_mci_by_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>

	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc_devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mci</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mci</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">find_mci_by_dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * handler for EDAC to check if NMI type handler has asserted interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_mc_assert_error_check_and_clear</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">old_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_op_state</span> <span class="o">==</span> <span class="n">EDAC_OPSTATE_POLL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">old_state</span> <span class="o">=</span> <span class="n">edac_err_assert</span><span class="p">;</span>
	<span class="n">edac_err_assert</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">old_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_mc_workq_function</span>
<span class="cm"> *	performs the operation scheduled by a workq request</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_mc_workq_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">d_work</span> <span class="o">=</span> <span class="n">to_delayed_work</span><span class="p">(</span><span class="n">work_req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span> <span class="o">=</span> <span class="n">to_edac_mem_ctl_work</span><span class="p">(</span><span class="n">d_work</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>

	<span class="cm">/* if this control struct has movd to offline state, we are done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">op_state</span> <span class="o">==</span> <span class="n">OP_OFFLINE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Only poll controllers that are running polled and have a check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edac_mc_assert_error_check_and_clear</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_check</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_check</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>

	<span class="cm">/* Reschedule */</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">edac_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span>
			<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">edac_mc_get_poll_msec</span><span class="p">()));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_mc_workq_setup</span>
<span class="cm"> *	initialize a workq item for this mci</span>
<span class="cm"> *	passing in the new delay period in msec</span>
<span class="cm"> *</span>
<span class="cm"> *	locking model:</span>
<span class="cm"> *</span>
<span class="cm"> *		called with the mem_ctls_mutex held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_mc_workq_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">msec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* if this instance is not in the POLL state, then simply return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">op_state</span> <span class="o">!=</span> <span class="n">OP_RUNNING_POLL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">edac_mc_workq_function</span><span class="p">);</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">edac_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">msec</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_mc_workq_teardown</span>
<span class="cm"> *	stop the workq processing on this mci</span>
<span class="cm"> *</span>
<span class="cm"> *	locking model:</span>
<span class="cm"> *</span>
<span class="cm"> *		called WITHOUT lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_mc_workq_teardown</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">op_state</span> <span class="o">!=</span> <span class="n">OP_RUNNING_POLL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() not canceled, flush the queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* workq instance might be running, wait for it */</span>
		<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">edac_workqueue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_mc_reset_delay_period(unsigned long value)</span>
<span class="cm"> *</span>
<span class="cm"> *	user space has updated our poll period value, need to</span>
<span class="cm"> *	reset our workq delays</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_mc_reset_delay_period</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>

	<span class="cm">/* scan the list and turn off all workq timers, doing so under lock</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc_devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mci</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">op_state</span> <span class="o">==</span> <span class="n">OP_RUNNING_POLL</span><span class="p">)</span>
			<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>


	<span class="cm">/* re-walk the list, and reset the poll delay */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc_devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mci</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>

		<span class="n">edac_mc_workq_setup</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* Return 0 on success, 1 on failure.</span>
<span class="cm"> * Before calling this function, caller must</span>
<span class="cm"> * assign a unique value to mci-&gt;mc_idx.</span>
<span class="cm"> *</span>
<span class="cm"> *	locking model:</span>
<span class="cm"> *</span>
<span class="cm"> *		called with the mem_ctls_mutex lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_mc_to_global_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">insert_before</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">insert_before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mc_devices</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">find_mci_by_dev</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc_devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mc_idx</span> <span class="o">&gt;=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mc_idx</span> <span class="o">==</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>

			<span class="n">insert_before</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">insert_before</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_handlers</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail0:</span>
	<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">EDAC_MC</span><span class="p">,</span>
		<span class="s">&quot;%s (%s) %s %s already assigned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
		<span class="n">edac_dev_name</span><span class="p">(</span><span class="n">mci</span><span class="p">),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">fail1:</span>
	<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">EDAC_MC</span><span class="p">,</span>
		<span class="s">&quot;bug in low-level driver: attempt to assign</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    duplicate mc_idx %d in %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">del_mc_from_global_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_handlers</span><span class="p">);</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="cm">/* these are for safe removal of devices from global list while</span>
<span class="cm">	 * NMI handlers may be traversing list</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * edac_mc_find: Search for a mem_ctl_info structure whose index is &#39;idx&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * If found, return a pointer to the structure.</span>
<span class="cm"> * Else return NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold mem_ctls_mutex.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="nf">edac_mc_find</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc_devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mci</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span> <span class="o">&gt;=</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">mci</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edac_mc_find</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edac_mc_add_mc: Insert the &#39;mci&#39; structure into the mci global list and</span>
<span class="cm"> *                 create sysfs entries associated with mci structure</span>
<span class="cm"> * @mci: pointer to the mci structure to be added to the list</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *	0	Success</span>
<span class="cm"> *	!0	Failure</span>
<span class="cm"> */</span>

<span class="cm">/* FIXME - should a warning be printed if no error detection? correction? */</span>
<span class="kt">int</span> <span class="nf">edac_mc_add_mc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_EDAC_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edac_debug_level</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">edac_mc_dump_mci</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_debug_level</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

			<span class="n">edac_mc_dump_csrow</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nr_channels</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">edac_mc_dump_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
						<span class="n">channels</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">tot_dimms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">edac_mc_dump_dimm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">dimms</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_mc_to_global_list</span><span class="p">(</span><span class="n">mci</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>

	<span class="cm">/* set load time so that error rate can be tracked */</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_create_sysfs_mci_device</span><span class="p">(</span><span class="n">mci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">edac_mc_printk</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
			<span class="s">&quot;failed to create sysfs device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If there IS a check routine, then we are running POLLED */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_check</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This instance is NOW RUNNING */</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">op_state</span> <span class="o">=</span> <span class="n">OP_RUNNING_POLL</span><span class="p">;</span>

		<span class="n">edac_mc_workq_setup</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">edac_mc_get_poll_msec</span><span class="p">());</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">op_state</span> <span class="o">=</span> <span class="n">OP_RUNNING_INTERRUPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Report action taken */</span>
	<span class="n">edac_mc_printk</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;Giving out device to &#39;%s&#39; &#39;%s&#39;:&quot;</span>
		<span class="s">&quot; DEV %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">,</span> <span class="n">edac_dev_name</span><span class="p">(</span><span class="n">mci</span><span class="p">));</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail1:</span>
	<span class="n">del_mc_from_global_list</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

<span class="nl">fail0:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">edac_mc_add_mc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edac_mc_del_mc: Remove sysfs entries for specified mci structure and</span>
<span class="cm"> *                 remove mci structure from global list</span>
<span class="cm"> * @pdev: Pointer to &#39;struct device&#39; representing mci structure to remove.</span>
<span class="cm"> *</span>
<span class="cm"> * Return pointer to removed mci structure, or NULL if device not found.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="nf">edac_mc_del_mc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>

	<span class="cm">/* find the requested mci struct in the global list */</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">find_mci_by_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">del_mc_from_global_list</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_ctls_mutex</span><span class="p">);</span>

	<span class="cm">/* flush workq processes */</span>
	<span class="n">edac_mc_workq_teardown</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="cm">/* marking MCI offline */</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">op_state</span> <span class="o">=</span> <span class="n">OP_OFFLINE</span><span class="p">;</span>

	<span class="cm">/* remove from sysfs */</span>
	<span class="n">edac_remove_sysfs_mci_device</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">EDAC_MC</span><span class="p">,</span>
		<span class="s">&quot;Removed device %d for %s %s: DEV %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">,</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">,</span> <span class="n">edac_dev_name</span><span class="p">(</span><span class="n">mci</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">mci</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">edac_mc_del_mc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_mc_scrub_block</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virt_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* ECC error page was not in our memory. Ignore it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Find the actual page structure then map it and fix */</span>
	<span class="n">pg</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">pg</span><span class="p">))</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">virt_addr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>

	<span class="cm">/* Perform architecture specific atomic scrub operation */</span>
	<span class="n">atomic_scrub</span><span class="p">(</span><span class="n">virt_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Unmap and complete */</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">virt_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">pg</span><span class="p">))</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* FIXME - should return -1 */</span>
<span class="kt">int</span> <span class="nf">edac_mc_find_csrow_by_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrows</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;MC%d: %s(): 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">row</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">csrows</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span> <span class="o">=</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dimm</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">+=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;MC%d: %s(): first(0x%lx) page(0x%lx) last(0x%lx) &quot;</span>
			<span class="s">&quot;mask(0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">csrow</span><span class="o">-&gt;</span><span class="n">first_page</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">last_page</span><span class="p">,</span>
			<span class="n">csrow</span><span class="o">-&gt;</span><span class="n">page_mask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">page</span> <span class="o">&gt;=</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">first_page</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">page</span> <span class="o">&lt;=</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">last_page</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">page</span> <span class="o">&amp;</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">page_mask</span><span class="p">)</span> <span class="o">==</span>
		     <span class="p">(</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">first_page</span> <span class="o">&amp;</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">page_mask</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">row</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">edac_mc_printk</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="s">&quot;could not look up page error address %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">row</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">edac_mc_find_csrow_by_page</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">edac_layer_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">EDAC_MC_LAYER_BRANCH</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;branch&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_MC_LAYER_CHANNEL</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;channel&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_MC_LAYER_SLOT</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;slot&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_MC_LAYER_CHIP_SELECT</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;csrow&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">edac_layer_name</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_inc_ce_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				    <span class="n">bool</span> <span class="n">enable_per_layer_report</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ce_mc</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_per_layer_report</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ce_noinfo_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">+=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ce_per_layer</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">*=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_inc_ue_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				    <span class="n">bool</span> <span class="n">enable_per_layer_report</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ue_mc</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_per_layer_report</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ce_noinfo_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">+=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ue_per_layer</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">*=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_ce_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">],</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">other_detail</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">bool</span> <span class="n">enable_per_layer_report</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_frame_number</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset_in_page</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">grain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remapped_page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_mc_get_log_ce</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">other_detail</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">other_detail</span><span class="p">)</span>
			<span class="n">edac_mc_printk</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
				       <span class="s">&quot;CE %s on %s (%s%s - %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">msg</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span>
				       <span class="n">detail</span><span class="p">,</span> <span class="n">other_detail</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">edac_mc_printk</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
				       <span class="s">&quot;CE %s on %s (%s%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">msg</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span>
				       <span class="n">detail</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">edac_inc_ce_error</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">enable_per_layer_report</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">scrub_mode</span> <span class="o">&amp;</span> <span class="n">SCRUB_SW_SRC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">			* Some memory controllers (called MCs below) can remap</span>
<span class="cm">			* memory so that it is still available at a different</span>
<span class="cm">			* address when PCI devices map into memory.</span>
<span class="cm">			* MC&#39;s that can&#39;t do this, lose the memory where PCI</span>
<span class="cm">			* devices are mapped. This mapping is MC-dependent</span>
<span class="cm">			* and so we call back into the MC driver for it to</span>
<span class="cm">			* map the MC page to a physical (CPU) page which can</span>
<span class="cm">			* then be mapped to a virtual page - which can then</span>
<span class="cm">			* be scrubbed.</span>
<span class="cm">			*/</span>
		<span class="n">remapped_page</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_page_to_phys</span> <span class="o">?</span>
			<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_page_to_phys</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">page_frame_number</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">page_frame_number</span><span class="p">;</span>

		<span class="n">edac_mc_scrub_block</span><span class="p">(</span><span class="n">remapped_page</span><span class="p">,</span>
					<span class="n">offset_in_page</span><span class="p">,</span> <span class="n">grain</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_ue_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">],</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">other_detail</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">bool</span> <span class="n">enable_per_layer_report</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edac_mc_get_log_ue</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">other_detail</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">other_detail</span><span class="p">)</span>
			<span class="n">edac_mc_printk</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
				       <span class="s">&quot;UE %s on %s (%s%s - %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			               <span class="n">msg</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">detail</span><span class="p">,</span>
				       <span class="n">other_detail</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">edac_mc_printk</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
				       <span class="s">&quot;UE %s on %s (%s%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			               <span class="n">msg</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_mc_get_panic_on_ue</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">other_detail</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">other_detail</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;UE %s on %s (%s%s - %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">msg</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">detail</span><span class="p">,</span> <span class="n">other_detail</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;UE %s on %s (%s%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">msg</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">edac_inc_ue_error</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">enable_per_layer_report</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define OTHER_LABEL &quot; or &quot;</span>
<span class="kt">void</span> <span class="nf">edac_mc_handle_error</span><span class="p">(</span><span class="k">const</span> <span class="k">enum</span> <span class="n">hw_event_mc_err_type</span> <span class="n">type</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_frame_number</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset_in_page</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">syndrome</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">int</span> <span class="n">layer0</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">int</span> <span class="n">layer1</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">int</span> <span class="n">layer2</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">other_detail</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mcelog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME: too much for stack: move it to some pre-alocated area */</span>
	<span class="kt">char</span> <span class="n">detail</span><span class="p">[</span><span class="mi">80</span><span class="p">],</span> <span class="n">location</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">label</span><span class="p">[(</span><span class="n">EDAC_MC_LABEL_LEN</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">OTHER_LABEL</span><span class="p">))</span> <span class="o">*</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">tot_dimms</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">chan</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">layer0</span><span class="p">,</span> <span class="n">layer1</span><span class="p">,</span> <span class="n">layer2</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">grain</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">enable_per_layer_report</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;MC%d: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the event report is consistent and if the memory</span>
<span class="cm">	 * location is known. If it is known, enable_per_layer_report will be</span>
<span class="cm">	 * true, the DIMM(s) label info will be filled and the per-layer</span>
<span class="cm">	 * error counters will be incremented.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">)</span>
				<span class="n">p</span> <span class="o">=</span> <span class="s">&quot;CE&quot;</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">p</span> <span class="o">=</span> <span class="s">&quot;UE&quot;</span><span class="p">;</span>

			<span class="n">edac_mc_printk</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
				       <span class="s">&quot;INTERNAL ERROR: %s value is out of range (%d &gt;= %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">edac_layer_name</span><span class="p">[</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">],</span>
				       <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Instead of just returning it, let&#39;s use what&#39;s</span>
<span class="cm">			 * known about the error. The increment routines and</span>
<span class="cm">			 * the DIMM filter logic will do the right thing by</span>
<span class="cm">			 * pointing the likely damaged DIMMs.</span>
<span class="cm">			 */</span>
			<span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">enable_per_layer_report</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the dimm label/grain that applies to the match criteria.</span>
<span class="cm">	 * As the error algorithm may not be able to point to just one memory</span>
<span class="cm">	 * stick, the logic here will get all possible labels that could</span>
<span class="cm">	 * pottentially be affected by the error.</span>
<span class="cm">	 * On FB-DIMM memory controllers, for uncorrected errors, it is common</span>
<span class="cm">	 * to have only the MC channel and the MC dimm (also called &quot;branch&quot;)</span>
<span class="cm">	 * but the channel is not known, as the memory is arranged in pairs,</span>
<span class="cm">	 * where each memory belongs to a separate channel within the same</span>
<span class="cm">	 * branch.</span>
<span class="cm">	 */</span>
	<span class="n">grain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">tot_dimms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">dimms</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">layer0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">layer0</span> <span class="o">!=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">layer1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">layer1</span> <span class="o">!=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">layer2</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">layer2</span> <span class="o">!=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* get the max grain, over the error match range */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">grain</span> <span class="o">&gt;</span> <span class="n">grain</span><span class="p">)</span>
			<span class="n">grain</span> <span class="o">=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">grain</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the error is memory-controller wide, there&#39;s no need to</span>
<span class="cm">		 * seek for the affected DIMMs because the whole</span>
<span class="cm">		 * channel/memory controller/...  may be affected.</span>
<span class="cm">		 * Also, don&#39;t show errors for empty DIMM slots.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enable_per_layer_report</span> <span class="o">&amp;&amp;</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">label</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">OTHER_LABEL</span><span class="p">);</span>
				<span class="n">p</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">OTHER_LABEL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * get csrow/channel of the DIMM, in order to allow</span>
<span class="cm">			 * incrementing the compat API counters</span>
<span class="cm">			 */</span>
			<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s: %s csrows map: (%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span>
				<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mem_is_per_rank</span> <span class="o">?</span> <span class="s">&quot;rank&quot;</span> <span class="o">:</span> <span class="s">&quot;dimm&quot;</span><span class="p">,</span>
				<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">csrow</span><span class="p">,</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">cschannel</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">row</span> <span class="o">=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">csrow</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">!=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">csrow</span><span class="p">)</span>
				<span class="n">row</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">chan</span> <span class="o">=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">cschannel</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">chan</span> <span class="o">!=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">cschannel</span><span class="p">)</span>
				<span class="n">chan</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_per_layer_report</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;any memory&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s: csrow/channel to increment: (%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;unknown memory&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">ce_count</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">].</span><span class="n">ce_count</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">ue_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill the RAM location data */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">location</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%s:%d &quot;</span><span class="p">,</span>
			     <span class="n">edac_layer_name</span><span class="p">[</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">],</span>
			     <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* Memory type dependent details about the error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">detail</span><span class="p">),</span>
			<span class="s">&quot;page:0x%lx offset:0x%lx grain:%d syndrome:0x%lx&quot;</span><span class="p">,</span>
			<span class="n">page_frame_number</span><span class="p">,</span> <span class="n">offset_in_page</span><span class="p">,</span>
			<span class="n">grain</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">);</span>
		<span class="n">edac_ce_error</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">detail</span><span class="p">,</span>
			      <span class="n">other_detail</span><span class="p">,</span> <span class="n">enable_per_layer_report</span><span class="p">,</span>
			      <span class="n">page_frame_number</span><span class="p">,</span> <span class="n">offset_in_page</span><span class="p">,</span> <span class="n">grain</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">detail</span><span class="p">),</span>
			<span class="s">&quot;page:0x%lx offset:0x%lx grain:%d&quot;</span><span class="p">,</span>
			<span class="n">page_frame_number</span><span class="p">,</span> <span class="n">offset_in_page</span><span class="p">,</span> <span class="n">grain</span><span class="p">);</span>

		<span class="n">edac_ue_error</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">detail</span><span class="p">,</span>
			      <span class="n">other_detail</span><span class="p">,</span> <span class="n">enable_per_layer_report</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">edac_mc_handle_error</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
