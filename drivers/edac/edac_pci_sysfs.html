<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › edac › edac_pci_sysfs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>edac_pci_sysfs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * (C) 2005, 2006 Linux Networx (http://lnxi.com)</span>
<span class="cm"> * This file may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License.</span>
<span class="cm"> *</span>
<span class="cm"> * Written Doug Thompson &lt;norsk5@xmission.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/edac.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>

<span class="cp">#include &quot;edac_core.h&quot;</span>
<span class="cp">#include &quot;edac_module.h&quot;</span>

<span class="cm">/* Turn off this whole feature if PCI is not configured */</span>
<span class="cp">#ifdef CONFIG_PCI</span>

<span class="cp">#define EDAC_PCI_SYMLINK	&quot;device&quot;</span>

<span class="cm">/* data variables exported via sysfs */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">check_pci_errors</span><span class="p">;</span>		<span class="cm">/* default NO check PCI parity */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">edac_pci_panic_on_pe</span><span class="p">;</span>	<span class="cm">/* default NO panic on PCI Parity */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">edac_pci_log_pe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* log PCI parity errors */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">edac_pci_log_npe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* log PCI non-parity error errors */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">edac_pci_poll_msec</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>	<span class="cm">/* one second workq period */</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">pci_parity_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">pci_nonparity_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">edac_pci_top_main_kobj</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">edac_pci_sysfs_refcount</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cm">/* getter functions for the data variables */</span>
<span class="kt">int</span> <span class="nf">edac_pci_get_check_errors</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">check_pci_errors</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_pci_get_log_pe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edac_pci_log_pe</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_pci_get_log_npe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edac_pci_log_npe</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_pci_get_panic_on_pe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edac_pci_panic_on_pe</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">edac_pci_get_poll_msec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edac_pci_poll_msec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************** EDAC PCI sysfs instance *******************/</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">instance_pe_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">.</span><span class="n">pe_count</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">instance_npe_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">.</span><span class="n">npe_count</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define to_instance(k) container_of(k, struct edac_pci_ctl_info, kobj)</span>
<span class="cp">#define to_instance_attr(a) container_of(a, struct instance_attribute, attr)</span>

<span class="cm">/* DEVICE instance kobject release() function */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_pci_instance_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Form pointer to containing struct, the pci control struct */</span>
	<span class="n">pci</span> <span class="o">=</span> <span class="n">to_instance</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="cm">/* decrement reference count on top main kobj */</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">edac_pci_top_main_kobj</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>	<span class="cm">/* Free the control struct */</span>
<span class="p">}</span>

<span class="cm">/* instance specific attribute structure */</span>
<span class="k">struct</span> <span class="n">instance_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* Function to &#39;show&#39; fields from the edac_pci &#39;instance&#39; structure */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_pci_instance_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span> <span class="o">=</span> <span class="n">to_instance</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">instance_attribute</span> <span class="o">*</span><span class="n">instance_attr</span> <span class="o">=</span> <span class="n">to_instance_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">instance_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function to &#39;store&#39; fields into the edac_pci &#39;instance&#39; structure */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_pci_instance_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span> <span class="o">=</span> <span class="n">to_instance</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">instance_attribute</span> <span class="o">*</span><span class="n">instance_attr</span> <span class="o">=</span> <span class="n">to_instance_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">instance_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* fs_ops table */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">pci_instance_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">edac_pci_instance_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">edac_pci_instance_store</span>
<span class="p">};</span>

<span class="cp">#define INSTANCE_ATTR(_name, _mode, _show, _store)	\</span>
<span class="cp">static struct instance_attribute attr_instance_##_name = {	\</span>
<span class="cp">	.attr	= {.name = __stringify(_name), .mode = _mode },	\</span>
<span class="cp">	.show	= _show,					\</span>
<span class="cp">	.store	= _store,					\</span>
<span class="cp">};</span>

<span class="n">INSTANCE_ATTR</span><span class="p">(</span><span class="n">pe_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">instance_pe_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">INSTANCE_ATTR</span><span class="p">(</span><span class="n">npe_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">instance_npe_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* pci instance attributes */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">instance_attribute</span> <span class="o">*</span><span class="n">pci_instance_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">attr_instance_pe_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_instance_npe_count</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="cm">/* the ktype for a pci instance */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">ktype_pci_instance</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">edac_pci_instance_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci_instance_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">default_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">**</span><span class="p">)</span><span class="n">pci_instance_attr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * edac_pci_create_instance_kobj</span>
<span class="cm"> *</span>
<span class="cm"> *	construct one EDAC PCI instance&#39;s kobject for use</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_pci_create_instance_kobj</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">main_kobj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* First bump the ref count on the top main kobj, which will</span>
<span class="cm">	 * track the number of PCI instances we have, and thus nest</span>
<span class="cm">	 * properly on keeping the module loaded</span>
<span class="cm">	 */</span>
	<span class="n">main_kobj</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="n">edac_pci_top_main_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">main_kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* And now register this new kobject under the main kobj */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktype_pci_instance</span><span class="p">,</span>
				   <span class="n">edac_pci_top_main_kobj</span><span class="p">,</span> <span class="s">&quot;pci%d&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s() failed to register instance pci%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">edac_pci_top_main_kobj</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() Register instance &#39;pci%d&#39; kobject</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Error unwind statck */</span>
<span class="nl">error_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_pci_unregister_sysfs_instance_kobj</span>
<span class="cm"> *</span>
<span class="cm"> *	unregister the kobj for the EDAC PCI instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_pci_unregister_sysfs_instance_kobj</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Unregister the instance kobject and allow its release</span>
<span class="cm">	 * function release the main reference count and then</span>
<span class="cm">	 * kfree the memory</span>
<span class="cm">	 */</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/***************************** EDAC PCI sysfs root **********************/</span>
<span class="cp">#define to_edacpci(k) container_of(k, struct edac_pci_ctl_info, kobj)</span>
<span class="cp">#define to_edacpci_attr(a) container_of(a, struct edac_pci_attr, attr)</span>

<span class="cm">/* simple show/store functions for attributes */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_pci_int_show</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_pci_int_store</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">))</span>
		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">edac_pci_dev_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
	 <span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	 <span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* Set of show/store abstract level functions for PCI Parity object */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_pci_dev_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_pci_dev_attribute</span> <span class="o">*</span><span class="n">edac_pci_dev</span><span class="p">;</span>
	<span class="n">edac_pci_dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_dev_attribute</span> <span class="o">*</span><span class="p">)</span><span class="n">attr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_pci_dev</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">edac_pci_dev</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">edac_pci_dev</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_pci_dev_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_pci_dev_attribute</span> <span class="o">*</span><span class="n">edac_pci_dev</span><span class="p">;</span>
	<span class="n">edac_pci_dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_dev_attribute</span> <span class="o">*</span><span class="p">)</span><span class="n">attr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_pci_dev</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">edac_pci_dev</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">edac_pci_dev</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">edac_pci_sysfs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">edac_pci_dev_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">edac_pci_dev_store</span>
<span class="p">};</span>

<span class="cp">#define EDAC_PCI_ATTR(_name,_mode,_show,_store)			\</span>
<span class="cp">static struct edac_pci_dev_attribute edac_pci_attr_##_name = {		\</span>
<span class="cp">	.attr = {.name = __stringify(_name), .mode = _mode },	\</span>
<span class="cp">	.value  = &amp;_name,					\</span>
<span class="cp">	.show   = _show,					\</span>
<span class="cp">	.store  = _store,					\</span>
<span class="cp">};</span>

<span class="cp">#define EDAC_PCI_STRING_ATTR(_name,_data,_mode,_show,_store)	\</span>
<span class="cp">static struct edac_pci_dev_attribute edac_pci_attr_##_name = {		\</span>
<span class="cp">	.attr = {.name = __stringify(_name), .mode = _mode },	\</span>
<span class="cp">	.value  = _data,					\</span>
<span class="cp">	.show   = _show,					\</span>
<span class="cp">	.store  = _store,					\</span>
<span class="cp">};</span>

<span class="cm">/* PCI Parity control files */</span>
<span class="n">EDAC_PCI_ATTR</span><span class="p">(</span><span class="n">check_pci_errors</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">edac_pci_int_show</span><span class="p">,</span>
	<span class="n">edac_pci_int_store</span><span class="p">);</span>
<span class="n">EDAC_PCI_ATTR</span><span class="p">(</span><span class="n">edac_pci_log_pe</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">edac_pci_int_show</span><span class="p">,</span>
	<span class="n">edac_pci_int_store</span><span class="p">);</span>
<span class="n">EDAC_PCI_ATTR</span><span class="p">(</span><span class="n">edac_pci_log_npe</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">edac_pci_int_show</span><span class="p">,</span>
	<span class="n">edac_pci_int_store</span><span class="p">);</span>
<span class="n">EDAC_PCI_ATTR</span><span class="p">(</span><span class="n">edac_pci_panic_on_pe</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">edac_pci_int_show</span><span class="p">,</span>
	<span class="n">edac_pci_int_store</span><span class="p">);</span>
<span class="n">EDAC_PCI_ATTR</span><span class="p">(</span><span class="n">pci_parity_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">edac_pci_int_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">EDAC_PCI_ATTR</span><span class="p">(</span><span class="n">pci_nonparity_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">edac_pci_int_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* Base Attributes of the memory ECC object */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">edac_pci_dev_attribute</span> <span class="o">*</span><span class="n">edac_pci_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">edac_pci_attr_check_pci_errors</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">edac_pci_attr_edac_pci_log_pe</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">edac_pci_attr_edac_pci_log_npe</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">edac_pci_attr_edac_pci_panic_on_pe</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">edac_pci_attr_pci_parity_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">edac_pci_attr_pci_nonparity_count</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * edac_pci_release_main_kobj</span>
<span class="cm"> *</span>
<span class="cm"> *	This release function is called when the reference count to the</span>
<span class="cm"> *	passed kobj goes to zero.</span>
<span class="cm"> *</span>
<span class="cm"> *	This kobj is the &#39;main&#39; kobject that EDAC PCI instances</span>
<span class="cm"> *	link to, and thus provide for proper nesting counts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_pci_release_main_kobj</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() here to module_put(THIS_MODULE)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="cm">/* last reference to top EDAC PCI kobject has been removed,</span>
<span class="cm">	 * NOW release our ref count on the core module</span>
<span class="cm">	 */</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ktype struct for the EDAC PCI main kobj */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">ktype_edac_pci_main_kobj</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">edac_pci_release_main_kobj</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">edac_pci_sysfs_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">default_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">**</span><span class="p">)</span><span class="n">edac_pci_attr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * edac_pci_main_kobj_setup()</span>
<span class="cm"> *</span>
<span class="cm"> *	setup the sysfs for EDAC PCI attributes</span>
<span class="cm"> *	assumes edac_subsys has already been initialized</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_pci_main_kobj_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">edac_subsys</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* check and count if we have already created the main kobject */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_pci_sysfs_refcount</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* First time, so create the main kobject and its</span>
<span class="cm">	 * controls and attributes</span>
<span class="cm">	 */</span>
	<span class="n">edac_subsys</span> <span class="o">=</span> <span class="n">edac_get_sysfs_subsys</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edac_subsys</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() no edac_subsys</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">decrement_count_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Bump the reference count on this module to ensure the</span>
<span class="cm">	 * modules isn&#39;t unloaded until we deconstruct the top</span>
<span class="cm">	 * level main kobj for EDAC PCI</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() try_module_get() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">mod_get_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">edac_pci_top_main_kobj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edac_pci_top_main_kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;Failed to allocate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">kzalloc_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Instanstiate the pci object */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="n">edac_pci_top_main_kobj</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">ktype_edac_pci_main_kobj</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">edac_subsys</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;pci&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;Failed to register &#39;.../edac/pci&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">kobject_init_and_add_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* At this point, to &#39;release&#39; the top level kobject</span>
<span class="cm">	 * for EDAC PCI, then edac_pci_main_kobj_teardown()</span>
<span class="cm">	 * must be used, for resources to be cleaned up properly</span>
<span class="cm">	 */</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="n">edac_pci_top_main_kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;Registered &#39;.../edac/pci&#39; kobject</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Error unwind statck */</span>
<span class="nl">kobject_init_and_add_fail:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">edac_pci_top_main_kobj</span><span class="p">);</span>

<span class="nl">kzalloc_fail:</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>

<span class="nl">mod_get_fail:</span>
	<span class="n">edac_put_sysfs_subsys</span><span class="p">();</span>

<span class="nl">decrement_count_fail:</span>
	<span class="cm">/* if are on this error exit, nothing to tear down */</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_pci_sysfs_refcount</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_pci_main_kobj_teardown()</span>
<span class="cm"> *</span>
<span class="cm"> *	if no longer linked (needed) remove the top level EDAC PCI</span>
<span class="cm"> *	kobject with its controls and attributes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_pci_main_kobj_teardown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Decrement the count and only if no more controller instances</span>
<span class="cm">	 * are connected perform the unregisteration of the top level</span>
<span class="cm">	 * main kobj</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_pci_sysfs_refcount</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() called kobject_put on main kobj</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">edac_pci_top_main_kobj</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">edac_put_sysfs_subsys</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * edac_pci_create_sysfs</span>
<span class="cm"> *</span>
<span class="cm"> *	Create the controls/attributes for the specified EDAC PCI device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edac_pci_create_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">edac_kobj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() idx=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">pci_idx</span><span class="p">);</span>

	<span class="cm">/* create the top main EDAC PCI kobject, IF needed */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">edac_pci_main_kobj_setup</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Create this instance&#39;s kobject under the MAIN kobject */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">edac_pci_create_instance_kobj</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">pci_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unregister_cleanup</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="n">edac_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">EDAC_PCI_SYMLINK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() sysfs_create_link() returned err= %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">symlink_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Error unwind stack */</span>
<span class="nl">symlink_fail:</span>
	<span class="n">edac_pci_unregister_sysfs_instance_kobj</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>

<span class="nl">unregister_cleanup:</span>
	<span class="n">edac_pci_main_kobj_teardown</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_pci_remove_sysfs</span>
<span class="cm"> *</span>
<span class="cm"> *	remove the controls and attributes for this EDAC PCI device</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_pci_remove_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() index=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">pci_idx</span><span class="p">);</span>

	<span class="cm">/* Remove the symlink */</span>
	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">EDAC_PCI_SYMLINK</span><span class="p">);</span>

	<span class="cm">/* remove this PCI instance&#39;s sysfs entries */</span>
	<span class="n">edac_pci_unregister_sysfs_instance_kobj</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>

	<span class="cm">/* Call the main unregister function, which will determine</span>
<span class="cm">	 * if this &#39;pci&#39; is the last instance.</span>
<span class="cm">	 * If it is, the main kobject will be unregistered as a result</span>
<span class="cm">	 */</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() calling edac_pci_main_kobj_teardown()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">edac_pci_main_kobj_teardown</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/************************ PCI error handling *************************/</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">get_pci_parity_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">where</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">where</span> <span class="o">=</span> <span class="n">secondary</span> <span class="o">?</span> <span class="n">PCI_SEC_STATUS</span> <span class="o">:</span> <span class="n">PCI_STATUS</span><span class="p">;</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* If we get back 0xFFFF then we must suspect that the card has been</span>
<span class="cm">	 * pulled but the Linux PCI layer has not yet finished cleaning up.</span>
<span class="cm">	 * We don&#39;t want to report on such devices</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">sanity</span><span class="p">;</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sanity</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sanity</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">&amp;=</span> <span class="n">PCI_STATUS_DETECTED_PARITY</span> <span class="o">|</span> <span class="n">PCI_STATUS_SIG_SYSTEM_ERROR</span> <span class="o">|</span>
		<span class="n">PCI_STATUS_PARITY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="cm">/* reset only the bits we are interested in */</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Clear any PCI parity errors logged by this device. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_pci_dev_parity_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">header_type</span><span class="p">;</span>

	<span class="n">get_pci_parity_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* read the device TYPE, looking for bridges */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_HEADER_TYPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">header_type</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE_BRIDGE</span><span class="p">)</span>
		<span class="n">get_pci_parity_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  PCI Parity polling</span>
<span class="cm"> *</span>
<span class="cm"> *	Function to retrieve the current parity status</span>
<span class="cm"> *	and decode it</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_pci_dev_parity_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">header_type</span><span class="p">;</span>

	<span class="cm">/* stop any interrupts until we can acquire the status */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* read the STATUS register on this device */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">get_pci_parity_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* read the device TYPE, looking for bridges */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_HEADER_TYPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header_type</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;PCI STATUS= 0x%04x %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="cm">/* check the status reg for errors on boards NOT marked as broken</span>
<span class="cm">	 * if broken, we cannot trust any of the status bits</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">broken_parity_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCI_STATUS_SIG_SYSTEM_ERROR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_CRIT</span><span class="p">,</span> <span class="n">EDAC_PCI</span><span class="p">,</span>
				<span class="s">&quot;Signaled System Error on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_nonparity_count</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCI_STATUS_PARITY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_CRIT</span><span class="p">,</span> <span class="n">EDAC_PCI</span><span class="p">,</span>
				<span class="s">&quot;Master Data Parity Error on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_parity_count</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCI_STATUS_DETECTED_PARITY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_CRIT</span><span class="p">,</span> <span class="n">EDAC_PCI</span><span class="p">,</span>
				<span class="s">&quot;Detected Parity Error on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_parity_count</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;PCI HEADER TYPE= 0x%02x %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">header_type</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">header_type</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE_BRIDGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* On bridges, need to examine secondary status register  */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">get_pci_parity_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;PCI SEC_STATUS= 0x%04x %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

		<span class="cm">/* check the secondary status reg for errors,</span>
<span class="cm">		 * on NOT broken boards</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">broken_parity_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCI_STATUS_SIG_SYSTEM_ERROR</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_CRIT</span><span class="p">,</span> <span class="n">EDAC_PCI</span><span class="p">,</span> <span class="s">&quot;Bridge &quot;</span>
					<span class="s">&quot;Signaled System Error on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_nonparity_count</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCI_STATUS_PARITY</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_CRIT</span><span class="p">,</span> <span class="n">EDAC_PCI</span><span class="p">,</span> <span class="s">&quot;Bridge &quot;</span>
					<span class="s">&quot;Master Data Parity Error on &quot;</span>
					<span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_parity_count</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCI_STATUS_DETECTED_PARITY</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_CRIT</span><span class="p">,</span> <span class="n">EDAC_PCI</span><span class="p">,</span> <span class="s">&quot;Bridge &quot;</span>
					<span class="s">&quot;Detected Parity Error on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_parity_count</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* reduce some complexity in definition of the iterator */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pci_parity_check_fn_t</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * pci_dev parity list iterator</span>
<span class="cm"> *	Scan the PCI device list for one pass, looking for SERRORs</span>
<span class="cm"> *	Master Parity ERRORS or Parity ERRORs on primary or secondary devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edac_pci_dev_parity_iterator</span><span class="p">(</span><span class="n">pci_parity_check_fn_t</span> <span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* request for kernel access to the next PCI device, if any,</span>
<span class="cm">	 * and while we are looking at it have its reference count</span>
<span class="cm">	 * bumped until we are done with it</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fn</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_pci_do_parity_check</span>
<span class="cm"> *</span>
<span class="cm"> *	performs the actual PCI parity check operation</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_pci_do_parity_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">before_count</span><span class="p">;</span>

	<span class="n">debugf3</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* if policy has PCI check off, leave now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_pci_errors</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">before_count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_parity_count</span><span class="p">);</span>

	<span class="cm">/* scan all PCI devices looking for a Parity Error on devices and</span>
<span class="cm">	 * bridges.</span>
<span class="cm">	 * The iterator calls pci_get_device() which might sleep, thus</span>
<span class="cm">	 * we cannot disable interrupts in this scan.</span>
<span class="cm">	 */</span>
	<span class="n">edac_pci_dev_parity_iterator</span><span class="p">(</span><span class="n">edac_pci_dev_parity_test</span><span class="p">);</span>

	<span class="cm">/* Only if operator has selected panic on PCI Error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edac_pci_get_panic_on_pe</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* If the count is different &#39;after&#39; from &#39;before&#39; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">before_count</span> <span class="o">!=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_parity_count</span><span class="p">))</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;EDAC: PCI Parity Error&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_pci_clear_parity_errors</span>
<span class="cm"> *</span>
<span class="cm"> *	function to perform an iteration over the PCI devices</span>
<span class="cm"> *	and clearn their current status</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_pci_clear_parity_errors</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clear any PCI bus parity errors that devices initially have logged</span>
<span class="cm">	 * in their registers.</span>
<span class="cm">	 */</span>
	<span class="n">edac_pci_dev_parity_iterator</span><span class="p">(</span><span class="n">edac_pci_dev_parity_clear</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_pci_handle_pe</span>
<span class="cm"> *</span>
<span class="cm"> *	Called to handle a PARITY ERROR event</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_pci_handle_pe</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* global PE counter incremented by edac_pci_do_parity_check() */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">.</span><span class="n">pe_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_pci_get_log_pe</span><span class="p">())</span>
		<span class="n">edac_pci_printk</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
				<span class="s">&quot;Parity Error ctl: %s %d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pci</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">pci_idx</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * poke all PCI devices and see which one is the troublemaker</span>
<span class="cm">	 * panic() is called if set</span>
<span class="cm">	 */</span>
	<span class="n">edac_pci_do_parity_check</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">edac_pci_handle_pe</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * edac_pci_handle_npe</span>
<span class="cm"> *</span>
<span class="cm"> *	Called to handle a NON-PARITY ERROR event</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_pci_handle_npe</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* global NPE counter incremented by edac_pci_do_parity_check() */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">.</span><span class="n">npe_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_pci_get_log_npe</span><span class="p">())</span>
		<span class="n">edac_pci_printk</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
				<span class="s">&quot;Non-Parity Error ctl: %s %d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pci</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">pci_idx</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * poke all PCI devices and see which one is the troublemaker</span>
<span class="cm">	 * panic() is called if set</span>
<span class="cm">	 */</span>
	<span class="n">edac_pci_do_parity_check</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">edac_pci_handle_npe</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Define the PCI parameter to the module</span>
<span class="cm"> */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">check_pci_errors</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">check_pci_errors</span><span class="p">,</span>
		 <span class="s">&quot;Check for PCI bus parity errors: 0=off 1=on&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">edac_pci_panic_on_pe</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edac_pci_panic_on_pe</span><span class="p">,</span>
		 <span class="s">&quot;Panic on PCI Bus Parity error: 0=off 1=on&quot;</span><span class="p">);</span>

<span class="cp">#endif				</span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
