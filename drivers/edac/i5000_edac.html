<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › edac › i5000_edac.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>i5000_edac.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Intel 5000(P/V/X) class Memory Controllers kernel module</span>
<span class="cm"> *</span>
<span class="cm"> * This file may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License.</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Douglas Thompson Linux Networx (http://lnxi.com)</span>
<span class="cm"> *	norsk5@xmission.com</span>
<span class="cm"> *</span>
<span class="cm"> * This module is based on the following document:</span>
<span class="cm"> *</span>
<span class="cm"> * Intel 5000X Chipset Memory Controller Hub (MCH) - Datasheet</span>
<span class="cm"> * 	http://developer.intel.com/design/chipsets/datashts/313070.htm</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pci_ids.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/edac.h&gt;</span>
<span class="cp">#include &lt;asm/mmzone.h&gt;</span>

<span class="cp">#include &quot;edac_core.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Alter this version for the I5000 module when modifications are made</span>
<span class="cm"> */</span>
<span class="cp">#define I5000_REVISION    &quot; Ver: 2.0.12&quot;</span>
<span class="cp">#define EDAC_MOD_STR      &quot;i5000_edac&quot;</span>

<span class="cp">#define i5000_printk(level, fmt, arg...) \</span>
<span class="cp">        edac_printk(level, &quot;i5000&quot;, fmt, ##arg)</span>

<span class="cp">#define i5000_mc_printk(mci, level, fmt, arg...) \</span>
<span class="cp">        edac_mc_chipset_printk(mci, level, &quot;i5000&quot;, fmt, ##arg)</span>

<span class="cp">#ifndef PCI_DEVICE_ID_INTEL_FBD_0</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_FBD_0	0x25F5</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef PCI_DEVICE_ID_INTEL_FBD_1</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_FBD_1	0x25F6</span>
<span class="cp">#endif</span>

<span class="cm">/* Device 16,</span>
<span class="cm"> * Function 0: System Address</span>
<span class="cm"> * Function 1: Memory Branch Map, Control, Errors Register</span>
<span class="cm"> * Function 2: FSB Error Registers</span>
<span class="cm"> *</span>
<span class="cm"> * All 3 functions of Device 16 (0,1,2) share the SAME DID</span>
<span class="cm"> */</span>
<span class="cp">#define	PCI_DEVICE_ID_INTEL_I5000_DEV16	0x25F0</span>

<span class="cm">/* OFFSETS for Function 0 */</span>

<span class="cm">/* OFFSETS for Function 1 */</span>
<span class="cp">#define		AMBASE			0x48</span>
<span class="cp">#define		MAXCH			0x56</span>
<span class="cp">#define		MAXDIMMPERCH		0x57</span>
<span class="cp">#define		TOLM			0x6C</span>
<span class="cp">#define		REDMEMB			0x7C</span>
<span class="cp">#define			RED_ECC_LOCATOR(x)	((x) &amp; 0x3FFFF)</span>
<span class="cp">#define			REC_ECC_LOCATOR_EVEN(x)	((x) &amp; 0x001FF)</span>
<span class="cp">#define			REC_ECC_LOCATOR_ODD(x)	((x) &amp; 0x3FE00)</span>
<span class="cp">#define		MIR0			0x80</span>
<span class="cp">#define		MIR1			0x84</span>
<span class="cp">#define		MIR2			0x88</span>
<span class="cp">#define		AMIR0			0x8C</span>
<span class="cp">#define		AMIR1			0x90</span>
<span class="cp">#define		AMIR2			0x94</span>

<span class="cp">#define		FERR_FAT_FBD		0x98</span>
<span class="cp">#define		NERR_FAT_FBD		0x9C</span>
<span class="cp">#define			EXTRACT_FBDCHAN_INDX(x)	(((x)&gt;&gt;28) &amp; 0x3)</span>
<span class="cp">#define			FERR_FAT_FBDCHAN 0x30000000</span>
<span class="cp">#define			FERR_FAT_M3ERR	0x00000004</span>
<span class="cp">#define			FERR_FAT_M2ERR	0x00000002</span>
<span class="cp">#define			FERR_FAT_M1ERR	0x00000001</span>
<span class="cp">#define			FERR_FAT_MASK	(FERR_FAT_M1ERR | \</span>
<span class="cp">						FERR_FAT_M2ERR | \</span>
<span class="cp">						FERR_FAT_M3ERR)</span>

<span class="cp">#define		FERR_NF_FBD		0xA0</span>

<span class="cm">/* Thermal and SPD or BFD errors */</span>
<span class="cp">#define			FERR_NF_M28ERR	0x01000000</span>
<span class="cp">#define			FERR_NF_M27ERR	0x00800000</span>
<span class="cp">#define			FERR_NF_M26ERR	0x00400000</span>
<span class="cp">#define			FERR_NF_M25ERR	0x00200000</span>
<span class="cp">#define			FERR_NF_M24ERR	0x00100000</span>
<span class="cp">#define			FERR_NF_M23ERR	0x00080000</span>
<span class="cp">#define			FERR_NF_M22ERR	0x00040000</span>
<span class="cp">#define			FERR_NF_M21ERR	0x00020000</span>

<span class="cm">/* Correctable errors */</span>
<span class="cp">#define			FERR_NF_M20ERR	0x00010000</span>
<span class="cp">#define			FERR_NF_M19ERR	0x00008000</span>
<span class="cp">#define			FERR_NF_M18ERR	0x00004000</span>
<span class="cp">#define			FERR_NF_M17ERR	0x00002000</span>

<span class="cm">/* Non-Retry or redundant Retry errors */</span>
<span class="cp">#define			FERR_NF_M16ERR	0x00001000</span>
<span class="cp">#define			FERR_NF_M15ERR	0x00000800</span>
<span class="cp">#define			FERR_NF_M14ERR	0x00000400</span>
<span class="cp">#define			FERR_NF_M13ERR	0x00000200</span>

<span class="cm">/* Uncorrectable errors */</span>
<span class="cp">#define			FERR_NF_M12ERR	0x00000100</span>
<span class="cp">#define			FERR_NF_M11ERR	0x00000080</span>
<span class="cp">#define			FERR_NF_M10ERR	0x00000040</span>
<span class="cp">#define			FERR_NF_M9ERR	0x00000020</span>
<span class="cp">#define			FERR_NF_M8ERR	0x00000010</span>
<span class="cp">#define			FERR_NF_M7ERR	0x00000008</span>
<span class="cp">#define			FERR_NF_M6ERR	0x00000004</span>
<span class="cp">#define			FERR_NF_M5ERR	0x00000002</span>
<span class="cp">#define			FERR_NF_M4ERR	0x00000001</span>

<span class="cp">#define			FERR_NF_UNCORRECTABLE	(FERR_NF_M12ERR | \</span>
<span class="cp">							FERR_NF_M11ERR | \</span>
<span class="cp">							FERR_NF_M10ERR | \</span>
<span class="cp">							FERR_NF_M9ERR | \</span>
<span class="cp">							FERR_NF_M8ERR | \</span>
<span class="cp">							FERR_NF_M7ERR | \</span>
<span class="cp">							FERR_NF_M6ERR | \</span>
<span class="cp">							FERR_NF_M5ERR | \</span>
<span class="cp">							FERR_NF_M4ERR)</span>
<span class="cp">#define			FERR_NF_CORRECTABLE	(FERR_NF_M20ERR | \</span>
<span class="cp">							FERR_NF_M19ERR | \</span>
<span class="cp">							FERR_NF_M18ERR | \</span>
<span class="cp">							FERR_NF_M17ERR)</span>
<span class="cp">#define			FERR_NF_DIMM_SPARE	(FERR_NF_M27ERR | \</span>
<span class="cp">							FERR_NF_M28ERR)</span>
<span class="cp">#define			FERR_NF_THERMAL		(FERR_NF_M26ERR | \</span>
<span class="cp">							FERR_NF_M25ERR | \</span>
<span class="cp">							FERR_NF_M24ERR | \</span>
<span class="cp">							FERR_NF_M23ERR)</span>
<span class="cp">#define			FERR_NF_SPD_PROTOCOL	(FERR_NF_M22ERR)</span>
<span class="cp">#define			FERR_NF_NORTH_CRC	(FERR_NF_M21ERR)</span>
<span class="cp">#define			FERR_NF_NON_RETRY	(FERR_NF_M13ERR | \</span>
<span class="cp">							FERR_NF_M14ERR | \</span>
<span class="cp">							FERR_NF_M15ERR)</span>

<span class="cp">#define		NERR_NF_FBD		0xA4</span>
<span class="cp">#define			FERR_NF_MASK		(FERR_NF_UNCORRECTABLE | \</span>
<span class="cp">							FERR_NF_CORRECTABLE | \</span>
<span class="cp">							FERR_NF_DIMM_SPARE | \</span>
<span class="cp">							FERR_NF_THERMAL | \</span>
<span class="cp">							FERR_NF_SPD_PROTOCOL | \</span>
<span class="cp">							FERR_NF_NORTH_CRC | \</span>
<span class="cp">							FERR_NF_NON_RETRY)</span>

<span class="cp">#define		EMASK_FBD		0xA8</span>
<span class="cp">#define			EMASK_FBD_M28ERR	0x08000000</span>
<span class="cp">#define			EMASK_FBD_M27ERR	0x04000000</span>
<span class="cp">#define			EMASK_FBD_M26ERR	0x02000000</span>
<span class="cp">#define			EMASK_FBD_M25ERR	0x01000000</span>
<span class="cp">#define			EMASK_FBD_M24ERR	0x00800000</span>
<span class="cp">#define			EMASK_FBD_M23ERR	0x00400000</span>
<span class="cp">#define			EMASK_FBD_M22ERR	0x00200000</span>
<span class="cp">#define			EMASK_FBD_M21ERR	0x00100000</span>
<span class="cp">#define			EMASK_FBD_M20ERR	0x00080000</span>
<span class="cp">#define			EMASK_FBD_M19ERR	0x00040000</span>
<span class="cp">#define			EMASK_FBD_M18ERR	0x00020000</span>
<span class="cp">#define			EMASK_FBD_M17ERR	0x00010000</span>

<span class="cp">#define			EMASK_FBD_M15ERR	0x00004000</span>
<span class="cp">#define			EMASK_FBD_M14ERR	0x00002000</span>
<span class="cp">#define			EMASK_FBD_M13ERR	0x00001000</span>
<span class="cp">#define			EMASK_FBD_M12ERR	0x00000800</span>
<span class="cp">#define			EMASK_FBD_M11ERR	0x00000400</span>
<span class="cp">#define			EMASK_FBD_M10ERR	0x00000200</span>
<span class="cp">#define			EMASK_FBD_M9ERR		0x00000100</span>
<span class="cp">#define			EMASK_FBD_M8ERR		0x00000080</span>
<span class="cp">#define			EMASK_FBD_M7ERR		0x00000040</span>
<span class="cp">#define			EMASK_FBD_M6ERR		0x00000020</span>
<span class="cp">#define			EMASK_FBD_M5ERR		0x00000010</span>
<span class="cp">#define			EMASK_FBD_M4ERR		0x00000008</span>
<span class="cp">#define			EMASK_FBD_M3ERR		0x00000004</span>
<span class="cp">#define			EMASK_FBD_M2ERR		0x00000002</span>
<span class="cp">#define			EMASK_FBD_M1ERR		0x00000001</span>

<span class="cp">#define			ENABLE_EMASK_FBD_FATAL_ERRORS	(EMASK_FBD_M1ERR | \</span>
<span class="cp">							EMASK_FBD_M2ERR | \</span>
<span class="cp">							EMASK_FBD_M3ERR)</span>

<span class="cp">#define 		ENABLE_EMASK_FBD_UNCORRECTABLE	(EMASK_FBD_M4ERR | \</span>
<span class="cp">							EMASK_FBD_M5ERR | \</span>
<span class="cp">							EMASK_FBD_M6ERR | \</span>
<span class="cp">							EMASK_FBD_M7ERR | \</span>
<span class="cp">							EMASK_FBD_M8ERR | \</span>
<span class="cp">							EMASK_FBD_M9ERR | \</span>
<span class="cp">							EMASK_FBD_M10ERR | \</span>
<span class="cp">							EMASK_FBD_M11ERR | \</span>
<span class="cp">							EMASK_FBD_M12ERR)</span>
<span class="cp">#define 		ENABLE_EMASK_FBD_CORRECTABLE	(EMASK_FBD_M17ERR | \</span>
<span class="cp">							EMASK_FBD_M18ERR | \</span>
<span class="cp">							EMASK_FBD_M19ERR | \</span>
<span class="cp">							EMASK_FBD_M20ERR)</span>
<span class="cp">#define			ENABLE_EMASK_FBD_DIMM_SPARE	(EMASK_FBD_M27ERR | \</span>
<span class="cp">							EMASK_FBD_M28ERR)</span>
<span class="cp">#define			ENABLE_EMASK_FBD_THERMALS	(EMASK_FBD_M26ERR | \</span>
<span class="cp">							EMASK_FBD_M25ERR | \</span>
<span class="cp">							EMASK_FBD_M24ERR | \</span>
<span class="cp">							EMASK_FBD_M23ERR)</span>
<span class="cp">#define			ENABLE_EMASK_FBD_SPD_PROTOCOL	(EMASK_FBD_M22ERR)</span>
<span class="cp">#define			ENABLE_EMASK_FBD_NORTH_CRC	(EMASK_FBD_M21ERR)</span>
<span class="cp">#define			ENABLE_EMASK_FBD_NON_RETRY	(EMASK_FBD_M15ERR | \</span>
<span class="cp">							EMASK_FBD_M14ERR | \</span>
<span class="cp">							EMASK_FBD_M13ERR)</span>

<span class="cp">#define		ENABLE_EMASK_ALL	(ENABLE_EMASK_FBD_NON_RETRY | \</span>
<span class="cp">					ENABLE_EMASK_FBD_NORTH_CRC | \</span>
<span class="cp">					ENABLE_EMASK_FBD_SPD_PROTOCOL | \</span>
<span class="cp">					ENABLE_EMASK_FBD_THERMALS | \</span>
<span class="cp">					ENABLE_EMASK_FBD_DIMM_SPARE | \</span>
<span class="cp">					ENABLE_EMASK_FBD_FATAL_ERRORS | \</span>
<span class="cp">					ENABLE_EMASK_FBD_CORRECTABLE | \</span>
<span class="cp">					ENABLE_EMASK_FBD_UNCORRECTABLE)</span>

<span class="cp">#define		ERR0_FBD		0xAC</span>
<span class="cp">#define		ERR1_FBD		0xB0</span>
<span class="cp">#define		ERR2_FBD		0xB4</span>
<span class="cp">#define		MCERR_FBD		0xB8</span>
<span class="cp">#define		NRECMEMA		0xBE</span>
<span class="cp">#define			NREC_BANK(x)		(((x)&gt;&gt;12) &amp; 0x7)</span>
<span class="cp">#define			NREC_RDWR(x)		(((x)&gt;&gt;11) &amp; 1)</span>
<span class="cp">#define			NREC_RANK(x)		(((x)&gt;&gt;8) &amp; 0x7)</span>
<span class="cp">#define		NRECMEMB		0xC0</span>
<span class="cp">#define			NREC_CAS(x)		(((x)&gt;&gt;16) &amp; 0xFFFFFF)</span>
<span class="cp">#define			NREC_RAS(x)		((x) &amp; 0x7FFF)</span>
<span class="cp">#define		NRECFGLOG		0xC4</span>
<span class="cp">#define		NREEECFBDA		0xC8</span>
<span class="cp">#define		NREEECFBDB		0xCC</span>
<span class="cp">#define		NREEECFBDC		0xD0</span>
<span class="cp">#define		NREEECFBDD		0xD4</span>
<span class="cp">#define		NREEECFBDE		0xD8</span>
<span class="cp">#define		REDMEMA			0xDC</span>
<span class="cp">#define		RECMEMA			0xE2</span>
<span class="cp">#define			REC_BANK(x)		(((x)&gt;&gt;12) &amp; 0x7)</span>
<span class="cp">#define			REC_RDWR(x)		(((x)&gt;&gt;11) &amp; 1)</span>
<span class="cp">#define			REC_RANK(x)		(((x)&gt;&gt;8) &amp; 0x7)</span>
<span class="cp">#define		RECMEMB			0xE4</span>
<span class="cp">#define			REC_CAS(x)		(((x)&gt;&gt;16) &amp; 0xFFFFFF)</span>
<span class="cp">#define			REC_RAS(x)		((x) &amp; 0x7FFF)</span>
<span class="cp">#define		RECFGLOG		0xE8</span>
<span class="cp">#define		RECFBDA			0xEC</span>
<span class="cp">#define		RECFBDB			0xF0</span>
<span class="cp">#define		RECFBDC			0xF4</span>
<span class="cp">#define		RECFBDD			0xF8</span>
<span class="cp">#define		RECFBDE			0xFC</span>

<span class="cm">/* OFFSETS for Function 2 */</span>

<span class="cm">/*</span>
<span class="cm"> * Device 21,</span>
<span class="cm"> * Function 0: Memory Map Branch 0</span>
<span class="cm"> *</span>
<span class="cm"> * Device 22,</span>
<span class="cm"> * Function 0: Memory Map Branch 1</span>
<span class="cm"> */</span>
<span class="cp">#define PCI_DEVICE_ID_I5000_BRANCH_0	0x25F5</span>
<span class="cp">#define PCI_DEVICE_ID_I5000_BRANCH_1	0x25F6</span>

<span class="cp">#define AMB_PRESENT_0	0x64</span>
<span class="cp">#define AMB_PRESENT_1	0x66</span>
<span class="cp">#define MTR0		0x80</span>
<span class="cp">#define MTR1		0x84</span>
<span class="cp">#define MTR2		0x88</span>
<span class="cp">#define MTR3		0x8C</span>

<span class="cp">#define NUM_MTRS		4</span>
<span class="cp">#define CHANNELS_PER_BRANCH	2</span>
<span class="cp">#define MAX_BRANCHES		2</span>

<span class="cm">/* Defines to extract the vaious fields from the</span>
<span class="cm"> *	MTRx - Memory Technology Registers</span>
<span class="cm"> */</span>
<span class="cp">#define MTR_DIMMS_PRESENT(mtr)		((mtr) &amp; (0x1 &lt;&lt; 8))</span>
<span class="cp">#define MTR_DRAM_WIDTH(mtr)		((((mtr) &gt;&gt; 6) &amp; 0x1) ? 8 : 4)</span>
<span class="cp">#define MTR_DRAM_BANKS(mtr)		((((mtr) &gt;&gt; 5) &amp; 0x1) ? 8 : 4)</span>
<span class="cp">#define MTR_DRAM_BANKS_ADDR_BITS(mtr)	((MTR_DRAM_BANKS(mtr) == 8) ? 3 : 2)</span>
<span class="cp">#define MTR_DIMM_RANK(mtr)		(((mtr) &gt;&gt; 4) &amp; 0x1)</span>
<span class="cp">#define MTR_DIMM_RANK_ADDR_BITS(mtr)	(MTR_DIMM_RANK(mtr) ? 2 : 1)</span>
<span class="cp">#define MTR_DIMM_ROWS(mtr)		(((mtr) &gt;&gt; 2) &amp; 0x3)</span>
<span class="cp">#define MTR_DIMM_ROWS_ADDR_BITS(mtr)	(MTR_DIMM_ROWS(mtr) + 13)</span>
<span class="cp">#define MTR_DIMM_COLS(mtr)		((mtr) &amp; 0x3)</span>
<span class="cp">#define MTR_DIMM_COLS_ADDR_BITS(mtr)	(MTR_DIMM_COLS(mtr) + 10)</span>

<span class="cp">#ifdef CONFIG_EDAC_DEBUG</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">numrow_toString</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;8,192 - 13 rows&quot;</span><span class="p">,</span>
	<span class="s">&quot;16,384 - 14 rows&quot;</span><span class="p">,</span>
	<span class="s">&quot;32,768 - 15 rows&quot;</span><span class="p">,</span>
	<span class="s">&quot;reserved&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">numcol_toString</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;1,024 - 10 columns&quot;</span><span class="p">,</span>
	<span class="s">&quot;2,048 - 11 columns&quot;</span><span class="p">,</span>
	<span class="s">&quot;4,096 - 12 columns&quot;</span><span class="p">,</span>
	<span class="s">&quot;reserved&quot;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* enables the report of miscellaneous messages as CE errors - default off */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">misc_messages</span><span class="p">;</span>

<span class="cm">/* Enumeration of supported devices */</span>
<span class="k">enum</span> <span class="n">i5000_chips</span> <span class="p">{</span>
	<span class="n">I5000P</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">I5000V</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* future */</span>
	<span class="n">I5000X</span> <span class="o">=</span> <span class="mi">2</span>		<span class="cm">/* future */</span>
<span class="p">};</span>

<span class="cm">/* Device name and register DID (Device ID) */</span>
<span class="k">struct</span> <span class="n">i5000_dev_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctl_name</span><span class="p">;</span>	<span class="cm">/* name for this device */</span>
	<span class="n">u16</span> <span class="n">fsb_mapping_errors</span><span class="p">;</span>	<span class="cm">/* DID for the branchmap,control */</span>
<span class="p">};</span>

<span class="cm">/* Table of devices attributes supported by this driver */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i5000_dev_info</span> <span class="n">i5000_devs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">I5000P</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ctl_name</span> <span class="o">=</span> <span class="s">&quot;I5000&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fsb_mapping_errors</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_INTEL_I5000_DEV16</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">i5000_dimm_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">megabytes</span><span class="p">;</span>		<span class="cm">/* size, 0 means not present  */</span>
	<span class="kt">int</span> <span class="n">dual_rank</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define	MAX_CHANNELS	6	</span><span class="cm">/* max possible channels */</span><span class="cp"></span>
<span class="cp">#define MAX_CSROWS	(8*2)	</span><span class="cm">/* max possible csrows per channel */</span><span class="cp"></span>

<span class="cm">/* driver private data structure */</span>
<span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">system_address</span><span class="p">;</span>	<span class="cm">/* 16.0 */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">branchmap_werrors</span><span class="p">;</span>	<span class="cm">/* 16.1 */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">fsb_error_regs</span><span class="p">;</span>	<span class="cm">/* 16.2 */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">branch_0</span><span class="p">;</span>	<span class="cm">/* 21.0 */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">branch_1</span><span class="p">;</span>	<span class="cm">/* 22.0 */</span>

	<span class="n">u16</span> <span class="n">tolm</span><span class="p">;</span>		<span class="cm">/* top of low memory */</span>
	<span class="n">u64</span> <span class="n">ambase</span><span class="p">;</span>		<span class="cm">/* AMB BAR */</span>

	<span class="n">u16</span> <span class="n">mir0</span><span class="p">,</span> <span class="n">mir1</span><span class="p">,</span> <span class="n">mir2</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">b0_mtr</span><span class="p">[</span><span class="n">NUM_MTRS</span><span class="p">];</span>	<span class="cm">/* Memory Technlogy Reg */</span>
	<span class="n">u16</span> <span class="n">b0_ambpresent0</span><span class="p">;</span>	<span class="cm">/* Branch 0, Channel 0 */</span>
	<span class="n">u16</span> <span class="n">b0_ambpresent1</span><span class="p">;</span>	<span class="cm">/* Brnach 0, Channel 1 */</span>

	<span class="n">u16</span> <span class="n">b1_mtr</span><span class="p">[</span><span class="n">NUM_MTRS</span><span class="p">];</span>	<span class="cm">/* Memory Technlogy Reg */</span>
	<span class="n">u16</span> <span class="n">b1_ambpresent0</span><span class="p">;</span>	<span class="cm">/* Branch 1, Channel 8 */</span>
	<span class="n">u16</span> <span class="n">b1_ambpresent1</span><span class="p">;</span>	<span class="cm">/* Branch 1, Channel 1 */</span>

	<span class="cm">/* DIMM information matrix, allocating architecture maximums */</span>
	<span class="k">struct</span> <span class="n">i5000_dimm_info</span> <span class="n">dimm_info</span><span class="p">[</span><span class="n">MAX_CSROWS</span><span class="p">][</span><span class="n">MAX_CHANNELS</span><span class="p">];</span>

	<span class="cm">/* Actual values for this controller */</span>
	<span class="kt">int</span> <span class="n">maxch</span><span class="p">;</span>		<span class="cm">/* Max channels */</span>
	<span class="kt">int</span> <span class="n">maxdimmperch</span><span class="p">;</span>	<span class="cm">/* Max DIMMs per channel */</span>
<span class="p">};</span>

<span class="cm">/* I5000 MCH error information retrieved from Hardware */</span>
<span class="k">struct</span> <span class="n">i5000_error_info</span> <span class="p">{</span>

	<span class="cm">/* These registers are always read from the MC */</span>
	<span class="n">u32</span> <span class="n">ferr_fat_fbd</span><span class="p">;</span>	<span class="cm">/* First Errors Fatal */</span>
	<span class="n">u32</span> <span class="n">nerr_fat_fbd</span><span class="p">;</span>	<span class="cm">/* Next Errors Fatal */</span>
	<span class="n">u32</span> <span class="n">ferr_nf_fbd</span><span class="p">;</span>	<span class="cm">/* First Errors Non-Fatal */</span>
	<span class="n">u32</span> <span class="n">nerr_nf_fbd</span><span class="p">;</span>	<span class="cm">/* Next Errors Non-Fatal */</span>

	<span class="cm">/* These registers are input ONLY if there was a Recoverable  Error */</span>
	<span class="n">u32</span> <span class="n">redmemb</span><span class="p">;</span>		<span class="cm">/* Recoverable Mem Data Error log B */</span>
	<span class="n">u16</span> <span class="n">recmema</span><span class="p">;</span>		<span class="cm">/* Recoverable Mem Error log A */</span>
	<span class="n">u32</span> <span class="n">recmemb</span><span class="p">;</span>		<span class="cm">/* Recoverable Mem Error log B */</span>

	<span class="cm">/* These registers are input ONLY if there was a</span>
<span class="cm">	 * Non-Recoverable Error */</span>
	<span class="n">u16</span> <span class="n">nrecmema</span><span class="p">;</span>		<span class="cm">/* Non-Recoverable Mem log A */</span>
	<span class="n">u16</span> <span class="n">nrecmemb</span><span class="p">;</span>		<span class="cm">/* Non-Recoverable Mem log B */</span>

<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">i5000_pci</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_get_error_info	Retrieve the hardware error information from</span>
<span class="cm"> *				the hardware and cache it in the &#39;info&#39;</span>
<span class="cm"> *				structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i5000_get_error_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">i5000_error_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/* read in the 1st FATAL error register */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span> <span class="n">FERR_FAT_FBD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

	<span class="cm">/* Mask only the bits that the doc says are valid</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">FERR_FAT_FBDCHAN</span> <span class="o">|</span> <span class="n">FERR_FAT_MASK</span><span class="p">);</span>

	<span class="cm">/* If there is an error, then read in the */</span>
	<span class="cm">/* NEXT FATAL error register and the Memory Error Log Register A */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">FERR_FAT_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ferr_fat_fbd</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

		<span class="cm">/* harvest the various error data we need */</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span>
				<span class="n">NERR_FAT_FBD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nerr_fat_fbd</span><span class="p">);</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span>
				<span class="n">NRECMEMA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmema</span><span class="p">);</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span>
				<span class="n">NRECMEMB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmemb</span><span class="p">);</span>

		<span class="cm">/* Clear the error bits, by writing them back */</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span>
				<span class="n">FERR_FAT_FBD</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ferr_fat_fbd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">nerr_fat_fbd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmema</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmemb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* read in the 1st NON-FATAL error register */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span> <span class="n">FERR_NF_FBD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

	<span class="cm">/* If there is an error, then read in the 1st NON-FATAL error</span>
<span class="cm">	 * register as well */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">FERR_NF_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ferr_nf_fbd</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

		<span class="cm">/* harvest the various error data we need */</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span>
				<span class="n">NERR_NF_FBD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nerr_nf_fbd</span><span class="p">);</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span>
				<span class="n">RECMEMA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">recmema</span><span class="p">);</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span>
				<span class="n">RECMEMB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">recmemb</span><span class="p">);</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span>
				<span class="n">REDMEMB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">redmemb</span><span class="p">);</span>

		<span class="cm">/* Clear the error bits, by writing them back */</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span>
				<span class="n">FERR_NF_FBD</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ferr_nf_fbd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">nerr_nf_fbd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">recmema</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">recmemb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">redmemb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * i5000_process_fatal_error_info(struct mem_ctl_info *mci,</span>
<span class="cm"> * 					struct i5000_error_info *info,</span>
<span class="cm"> * 					int handle_errors);</span>
<span class="cm"> *</span>
<span class="cm"> *	handle the Intel FATAL errors, if any</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i5000_process_fatal_error_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">i5000_error_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">handle_errors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="n">EDAC_MC_LABEL_LEN</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">160</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">specific</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">allErrors</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bank</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rank</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rdwr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ras</span><span class="p">,</span> <span class="n">cas</span><span class="p">;</span>

	<span class="cm">/* mask off the Error bits that are possible */</span>
	<span class="n">allErrors</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ferr_fat_fbd</span> <span class="o">&amp;</span> <span class="n">FERR_FAT_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allErrors</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* if no error, return now */</span>

	<span class="n">channel</span> <span class="o">=</span> <span class="n">EXTRACT_FBDCHAN_INDX</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ferr_fat_fbd</span><span class="p">);</span>

	<span class="cm">/* Use the NON-Recoverable macros to extract data */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">NREC_BANK</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmema</span><span class="p">);</span>
	<span class="n">rank</span> <span class="o">=</span> <span class="n">NREC_RANK</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmema</span><span class="p">);</span>
	<span class="n">rdwr</span> <span class="o">=</span> <span class="n">NREC_RDWR</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmema</span><span class="p">);</span>
	<span class="n">ras</span> <span class="o">=</span> <span class="n">NREC_RAS</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmemb</span><span class="p">);</span>
	<span class="n">cas</span> <span class="o">=</span> <span class="n">NREC_CAS</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmemb</span><span class="p">);</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">CSROW= %d  Channel= %d &quot;</span>
		<span class="s">&quot;(DRAM Bank= %d rdwr= %s ras= %d cas= %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">rank</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span>
		<span class="n">rdwr</span> <span class="o">?</span> <span class="s">&quot;Write&quot;</span> <span class="o">:</span> <span class="s">&quot;Read&quot;</span><span class="p">,</span> <span class="n">ras</span><span class="p">,</span> <span class="n">cas</span><span class="p">);</span>

	<span class="cm">/* Only 1 bit will be on */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">allErrors</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FERR_FAT_M1ERR</span>:
		<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Alert on non-redundant retry or fast &quot;</span>
				<span class="s">&quot;reset timeout&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FERR_FAT_M2ERR</span>:
		<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Northbound CRC error on non-redundant &quot;</span>
				<span class="s">&quot;retry&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FERR_FAT_M3ERR</span>:
		<span class="p">{</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">done</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This error is generated to inform that the intelligent</span>
<span class="cm">		 * throttling is disabled and the temperature passed the</span>
<span class="cm">		 * specified middle point. Since this is something the BIOS</span>
<span class="cm">		 * should take care of, we&#39;ll warn only once to avoid</span>
<span class="cm">		 * worthlessly flooding the log.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">done</span><span class="o">++</span><span class="p">;</span>

		<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;&gt;Tmid Thermal event with intelligent &quot;</span>
			   <span class="s">&quot;throttling disabled&quot;</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Form out message */</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span>
		 <span class="s">&quot;Bank=%d RAS=%d CAS=%d FATAL Err=0x%x (%s)&quot;</span><span class="p">,</span>
		 <span class="n">bank</span><span class="p">,</span> <span class="n">ras</span><span class="p">,</span> <span class="n">cas</span><span class="p">,</span> <span class="n">allErrors</span><span class="p">,</span> <span class="n">specific</span><span class="p">);</span>

	<span class="cm">/* Call the helper to output message */</span>
	<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_FATAL</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">channel</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span>
			     <span class="n">rdwr</span> <span class="o">?</span> <span class="s">&quot;Write error&quot;</span> <span class="o">:</span> <span class="s">&quot;Read error&quot;</span><span class="p">,</span>
			     <span class="n">msg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * i5000_process_fatal_error_info(struct mem_ctl_info *mci,</span>
<span class="cm"> * 				struct i5000_error_info *info,</span>
<span class="cm"> * 				int handle_errors);</span>
<span class="cm"> *</span>
<span class="cm"> *	handle the Intel NON-FATAL errors, if any</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i5000_process_nonfatal_error_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">i5000_error_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">handle_errors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="n">EDAC_MC_LABEL_LEN</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">170</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">specific</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">allErrors</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ue_errors</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ce_errors</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">misc_errors</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">branch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bank</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rank</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rdwr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ras</span><span class="p">,</span> <span class="n">cas</span><span class="p">;</span>

	<span class="cm">/* mask off the Error bits that are possible */</span>
	<span class="n">allErrors</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ferr_nf_fbd</span> <span class="o">&amp;</span> <span class="n">FERR_NF_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allErrors</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* if no error, return now */</span>

	<span class="cm">/* ONLY ONE of the possible error bits will be set, as per the docs */</span>
	<span class="n">ue_errors</span> <span class="o">=</span> <span class="n">allErrors</span> <span class="o">&amp;</span> <span class="n">FERR_NF_UNCORRECTABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ue_errors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Uncorrected bits= 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ue_errors</span><span class="p">);</span>

		<span class="n">branch</span> <span class="o">=</span> <span class="n">EXTRACT_FBDCHAN_INDX</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ferr_nf_fbd</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * According with i5000 datasheet, bit 28 has no significance</span>
<span class="cm">		 * for errors M4Err-M12Err and M17Err-M21Err, on FERR_NF_FBD</span>
<span class="cm">		 */</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">branch</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">bank</span> <span class="o">=</span> <span class="n">NREC_BANK</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmema</span><span class="p">);</span>
		<span class="n">rank</span> <span class="o">=</span> <span class="n">NREC_RANK</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmema</span><span class="p">);</span>
		<span class="n">rdwr</span> <span class="o">=</span> <span class="n">NREC_RDWR</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmema</span><span class="p">);</span>
		<span class="n">ras</span> <span class="o">=</span> <span class="n">NREC_RAS</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmemb</span><span class="p">);</span>
		<span class="n">cas</span> <span class="o">=</span> <span class="n">NREC_CAS</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nrecmemb</span><span class="p">);</span>

		<span class="n">debugf0</span>
			<span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">CSROW= %d  Channels= %d,%d  (Branch= %d &quot;</span>
			<span class="s">&quot;DRAM Bank= %d rdwr= %s ras= %d cas= %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rank</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">channel</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">branch</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span>
			<span class="n">rdwr</span> <span class="o">?</span> <span class="s">&quot;Write&quot;</span> <span class="o">:</span> <span class="s">&quot;Read&quot;</span><span class="p">,</span> <span class="n">ras</span><span class="p">,</span> <span class="n">cas</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ue_errors</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FERR_NF_M12ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Non-Aliased Uncorrectable Patrol Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M11ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Non-Aliased Uncorrectable Spare-Copy &quot;</span>
					<span class="s">&quot;Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M10ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Non-Aliased Uncorrectable Mirrored Demand &quot;</span>
					<span class="s">&quot;Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M9ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Non-Aliased Uncorrectable Non-Mirrored &quot;</span>
					<span class="s">&quot;Demand Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M8ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Aliased Uncorrectable Patrol Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M7ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Aliased Uncorrectable Spare-Copy Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M6ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Aliased Uncorrectable Mirrored Demand &quot;</span>
					<span class="s">&quot;Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M5ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Aliased Uncorrectable Non-Mirrored Demand &quot;</span>
					<span class="s">&quot;Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M4ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Uncorrectable Data ECC on Replay&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Form out message */</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span>
			 <span class="s">&quot;Rank=%d Bank=%d RAS=%d CAS=%d, UE Err=0x%x (%s)&quot;</span><span class="p">,</span>
			 <span class="n">rank</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span> <span class="n">ras</span><span class="p">,</span> <span class="n">cas</span><span class="p">,</span> <span class="n">ue_errors</span><span class="p">,</span> <span class="n">specific</span><span class="p">);</span>

		<span class="cm">/* Call the helper to output message */</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_UNCORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span>
				<span class="n">rdwr</span> <span class="o">?</span> <span class="s">&quot;Write error&quot;</span> <span class="o">:</span> <span class="s">&quot;Read error&quot;</span><span class="p">,</span>
				<span class="n">msg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check correctable errors */</span>
	<span class="n">ce_errors</span> <span class="o">=</span> <span class="n">allErrors</span> <span class="o">&amp;</span> <span class="n">FERR_NF_CORRECTABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ce_errors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Corrected bits= 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ce_errors</span><span class="p">);</span>

		<span class="n">branch</span> <span class="o">=</span> <span class="n">EXTRACT_FBDCHAN_INDX</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ferr_nf_fbd</span><span class="p">);</span>

		<span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">REC_ECC_LOCATOR_ODD</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">redmemb</span><span class="p">))</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Convert channel to be based from zero, instead of</span>
<span class="cm">		 * from branch base of 0 */</span>
		<span class="n">channel</span> <span class="o">+=</span> <span class="n">branch</span><span class="p">;</span>

		<span class="n">bank</span> <span class="o">=</span> <span class="n">REC_BANK</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">recmema</span><span class="p">);</span>
		<span class="n">rank</span> <span class="o">=</span> <span class="n">REC_RANK</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">recmema</span><span class="p">);</span>
		<span class="n">rdwr</span> <span class="o">=</span> <span class="n">REC_RDWR</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">recmema</span><span class="p">);</span>
		<span class="n">ras</span> <span class="o">=</span> <span class="n">REC_RAS</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">recmemb</span><span class="p">);</span>
		<span class="n">cas</span> <span class="o">=</span> <span class="n">REC_CAS</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">recmemb</span><span class="p">);</span>

		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">CSROW= %d Channel= %d  (Branch %d &quot;</span>
			<span class="s">&quot;DRAM Bank= %d rdwr= %s ras= %d cas= %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rank</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">branch</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span>
			<span class="n">rdwr</span> <span class="o">?</span> <span class="s">&quot;Write&quot;</span> <span class="o">:</span> <span class="s">&quot;Read&quot;</span><span class="p">,</span> <span class="n">ras</span><span class="p">,</span> <span class="n">cas</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ce_errors</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FERR_NF_M17ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Correctable Non-Mirrored Demand Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M18ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Correctable Mirrored Demand Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M19ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Correctable Spare-Copy Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M20ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Correctable Patrol Data ECC&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Form out message */</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span>
			 <span class="s">&quot;Rank=%d Bank=%d RDWR=%s RAS=%d &quot;</span>
			 <span class="s">&quot;CAS=%d, CE Err=0x%x (%s))&quot;</span><span class="p">,</span> <span class="n">branch</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span>
			 <span class="n">rdwr</span> <span class="o">?</span> <span class="s">&quot;Write&quot;</span> <span class="o">:</span> <span class="s">&quot;Read&quot;</span><span class="p">,</span> <span class="n">ras</span><span class="p">,</span> <span class="n">cas</span><span class="p">,</span> <span class="n">ce_errors</span><span class="p">,</span>
			 <span class="n">specific</span><span class="p">);</span>

		<span class="cm">/* Call the helper to output message */</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">channel</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span>
				<span class="n">rdwr</span> <span class="o">?</span> <span class="s">&quot;Write error&quot;</span> <span class="o">:</span> <span class="s">&quot;Read error&quot;</span><span class="p">,</span>
				<span class="n">msg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">misc_messages</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">misc_errors</span> <span class="o">=</span> <span class="n">allErrors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FERR_NF_NON_RETRY</span> <span class="o">|</span> <span class="n">FERR_NF_NORTH_CRC</span> <span class="o">|</span>
				   <span class="n">FERR_NF_SPD_PROTOCOL</span> <span class="o">|</span> <span class="n">FERR_NF_DIMM_SPARE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">misc_errors</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">misc_errors</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FERR_NF_M13ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Non-Retry or Redundant Retry FBD Memory &quot;</span>
					<span class="s">&quot;Alert or Redundant Fast Reset Timeout&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M14ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Non-Retry or Redundant Retry FBD &quot;</span>
					<span class="s">&quot;Configuration Alert&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M15ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;Non-Retry or Redundant Retry FBD &quot;</span>
					<span class="s">&quot;Northbound CRC error on read data&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M21ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;FBD Northbound CRC error on &quot;</span>
					<span class="s">&quot;FBD Sync Status&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M22ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;SPD protocol error&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M27ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;DIMM-spare copy started&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FERR_NF_M28ERR</span>:
			<span class="n">specific</span> <span class="o">=</span> <span class="s">&quot;DIMM-spare copy completed&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">branch</span> <span class="o">=</span> <span class="n">EXTRACT_FBDCHAN_INDX</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ferr_nf_fbd</span><span class="p">);</span>

		<span class="cm">/* Form out message */</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span>
			 <span class="s">&quot;Err=%#x (%s)&quot;</span><span class="p">,</span> <span class="n">misc_errors</span><span class="p">,</span> <span class="n">specific</span><span class="p">);</span>

		<span class="cm">/* Call the helper to output message */</span>
		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">branch</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;Misc error&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_process_error_info	Process the error info that is</span>
<span class="cm"> *	in the &#39;info&#39; structure, previously retrieved from hardware</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i5000_process_error_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">i5000_error_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">handle_errors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* First handle any fatal errors that occurred */</span>
	<span class="n">i5000_process_fatal_error_info</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">handle_errors</span><span class="p">);</span>

	<span class="cm">/* now handle any non-fatal errors that occurred */</span>
	<span class="n">i5000_process_nonfatal_error_info</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">handle_errors</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_clear_error	Retrieve any error from the hardware</span>
<span class="cm"> *				but do NOT process that error.</span>
<span class="cm"> *				Used for &#39;clearing&#39; out of previous errors</span>
<span class="cm"> *				Called by the Core module.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i5000_clear_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i5000_error_info</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">i5000_get_error_info</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_check_error	Retrieve and process errors reported by the</span>
<span class="cm"> *				hardware. Called by the Core module.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i5000_check_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i5000_error_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;MC%d: %s: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">i5000_get_error_info</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="n">i5000_process_error_info</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_get_devices	Find and perform &#39;get&#39; operation on the MCH&#39;s</span>
<span class="cm"> *			device/functions we want to reference for this driver</span>
<span class="cm"> *</span>
<span class="cm"> *			Need to &#39;get&#39; device 16 func 1 and func 2</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i5000_get_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev_idx</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>const struct i5000<em>dev</em>info *i5000<em>dev = &amp;i5000</em>devs[dev_idx];</p></td><td class="code"><div class="highlight"><pre>	<span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/* Attempt to &#39;get&#39; the MCH register we want */</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
				<span class="n">PCI_DEVICE_ID_INTEL_I5000_DEV16</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

		<span class="cm">/* End of list, leave */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i5000_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
				<span class="s">&quot;&#39;system address,Process Bus&#39; &quot;</span>
				<span class="s">&quot;device not found:&quot;</span>
				<span class="s">&quot;vendor 0x%x device 0x%x FUNC 1 &quot;</span>
				<span class="s">&quot;(broken BIOS?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
				<span class="n">PCI_DEVICE_ID_INTEL_I5000_DEV16</span><span class="p">);</span>

			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Scan for device 16 func 1 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* Attempt to &#39;get&#39; the MCH register we want */</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
				<span class="n">PCI_DEVICE_ID_INTEL_I5000_DEV16</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i5000_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
				<span class="s">&quot;MC: &#39;branchmap,control,errors&#39; &quot;</span>
				<span class="s">&quot;device not found:&quot;</span>
				<span class="s">&quot;vendor 0x%x device 0x%x Func 2 &quot;</span>
				<span class="s">&quot;(broken BIOS?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
				<span class="n">PCI_DEVICE_ID_INTEL_I5000_DEV16</span><span class="p">);</span>

			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Scan for device 16 func 1 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">fsb_error_regs</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;System Address, processor bus- PCI Bus ID: %s  %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pci_name</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">system_address</span><span class="p">),</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">system_address</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">system_address</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;Branchmap, control and errors - PCI Bus ID: %s  %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pci_name</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">),</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;FSB Error Regs - PCI Bus ID: %s  %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pci_name</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">fsb_error_regs</span><span class="p">),</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">fsb_error_regs</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">fsb_error_regs</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_I5000_BRANCH_0</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i5000_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="s">&quot;MC: &#39;BRANCH 0&#39; device not found:&quot;</span>
			<span class="s">&quot;vendor 0x%x device 0x%x Func 0 (broken BIOS?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_I5000_BRANCH_0</span><span class="p">);</span>

		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">);</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">fsb_error_regs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_0</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* If this device claims to have more than 2 channels then</span>
<span class="cm">	 * fetch Branch 1&#39;s information</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span> <span class="o">&gt;=</span> <span class="n">CHANNELS_PER_BRANCH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
				<span class="n">PCI_DEVICE_ID_I5000_BRANCH_1</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i5000_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
				<span class="s">&quot;MC: &#39;BRANCH 1&#39; device not found:&quot;</span>
				<span class="s">&quot;vendor 0x%x device 0x%x Func 0 &quot;</span>
				<span class="s">&quot;(broken BIOS?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
				<span class="n">PCI_DEVICE_ID_I5000_BRANCH_1</span><span class="p">);</span>

			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">);</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">fsb_error_regs</span><span class="p">);</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_0</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_1</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_put_devices	&#39;put&#39; all the devices that we have</span>
<span class="cm"> *				reserved via &#39;get&#39;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i5000_put_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">);</span>	<span class="cm">/* FUNC 1 */</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">fsb_error_regs</span><span class="p">);</span>	<span class="cm">/* FUNC 2 */</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_0</span><span class="p">);</span>	<span class="cm">/* DEV 21 */</span>

	<span class="cm">/* Only if more than 2 channels do we release the second branch */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span> <span class="o">&gt;=</span> <span class="n">CHANNELS_PER_BRANCH</span><span class="p">)</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_1</span><span class="p">);</span>	<span class="cm">/* DEV 22 */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	determine_amb_resent</span>
<span class="cm"> *</span>
<span class="cm"> *		the information is contained in NUM_MTRS different registers</span>
<span class="cm"> *		determineing which of the NUM_MTRS requires knowing</span>
<span class="cm"> *		which channel is in question</span>
<span class="cm"> *</span>
<span class="cm"> *	2 branches, each with 2 channels</span>
<span class="cm"> *		b0_ambpresent0 for channel &#39;0&#39;</span>
<span class="cm"> *		b0_ambpresent1 for channel &#39;1&#39;</span>
<span class="cm"> *		b1_ambpresent0 for channel &#39;2&#39;</span>
<span class="cm"> *		b1_ambpresent1 for channel &#39;3&#39;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">determine_amb_present_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">amb_present</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">CHANNELS_PER_BRANCH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
			<span class="n">amb_present</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b0_ambpresent1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">amb_present</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b0_ambpresent0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
			<span class="n">amb_present</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_ambpresent1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">amb_present</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_ambpresent0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">amb_present</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * determine_mtr(pvt, csrow, channel)</span>
<span class="cm"> *</span>
<span class="cm"> *	return the proper MTR register as determine by the csrow and channel desired</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">determine_mtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mtr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">CHANNELS_PER_BRANCH</span><span class="p">)</span>
		<span class="n">mtr</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b0_mtr</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">mtr</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_mtr</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">mtr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_mtr</span><span class="p">(</span><span class="kt">int</span> <span class="n">slot_row</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mtr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ans</span><span class="p">;</span>

	<span class="n">ans</span> <span class="o">=</span> <span class="n">MTR_DIMMS_PRESENT</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">MTR%d=0x%x:  DIMMs are %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot_row</span><span class="p">,</span> <span class="n">mtr</span><span class="p">,</span>
		<span class="n">ans</span> <span class="o">?</span> <span class="s">&quot;Present&quot;</span> <span class="o">:</span> <span class="s">&quot;NOT Present&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ans</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">WIDTH: x%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MTR_DRAM_WIDTH</span><span class="p">(</span><span class="n">mtr</span><span class="p">));</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">NUMBANK: %d bank(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MTR_DRAM_BANKS</span><span class="p">(</span><span class="n">mtr</span><span class="p">));</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">NUMRANK: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MTR_DIMM_RANK</span><span class="p">(</span><span class="n">mtr</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;double&quot;</span> <span class="o">:</span> <span class="s">&quot;single&quot;</span><span class="p">);</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">NUMROW: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">numrow_toString</span><span class="p">[</span><span class="n">MTR_DIMM_ROWS</span><span class="p">(</span><span class="n">mtr</span><span class="p">)]);</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">NUMCOL: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">numcol_toString</span><span class="p">[</span><span class="n">MTR_DIMM_COLS</span><span class="p">(</span><span class="n">mtr</span><span class="p">)]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">i5000_dimm_info</span> <span class="o">*</span><span class="n">dinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mtr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">amb_present_reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addrBits</span><span class="p">;</span>

	<span class="n">mtr</span> <span class="o">=</span> <span class="n">determine_mtr</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MTR_DIMMS_PRESENT</span><span class="p">(</span><span class="n">mtr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">amb_present_reg</span> <span class="o">=</span> <span class="n">determine_amb_present_reg</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>

		<span class="cm">/* Determine if there is a DIMM present in this DIMM slot */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amb_present_reg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dinfo</span><span class="o">-&gt;</span><span class="n">dual_rank</span> <span class="o">=</span> <span class="n">MTR_DIMM_RANK</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>

			<span class="cm">/* Start with the number of bits for a Bank</span>
<span class="cm">				* on the DRAM */</span>
			<span class="n">addrBits</span> <span class="o">=</span> <span class="n">MTR_DRAM_BANKS_ADDR_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>
			<span class="cm">/* Add the number of ROW bits */</span>
			<span class="n">addrBits</span> <span class="o">+=</span> <span class="n">MTR_DIMM_ROWS_ADDR_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>
			<span class="cm">/* add the number of COLUMN bits */</span>
			<span class="n">addrBits</span> <span class="o">+=</span> <span class="n">MTR_DIMM_COLS_ADDR_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>

			<span class="n">addrBits</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>	<span class="cm">/* add 64 bits per DIMM */</span>
			<span class="n">addrBits</span> <span class="o">-=</span> <span class="mi">20</span><span class="p">;</span>	<span class="cm">/* divide by 2^^20 */</span>
			<span class="n">addrBits</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* 8 bits per bytes */</span>

			<span class="n">dinfo</span><span class="o">-&gt;</span><span class="n">megabytes</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">addrBits</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	calculate_dimm_size</span>
<span class="cm"> *</span>
<span class="cm"> *	also will output a DIMM matrix map, if debug is enabled, for viewing</span>
<span class="cm"> *	how the DIMMs are populated</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">calculate_dimm_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i5000_dimm_info</span> <span class="o">*</span><span class="n">dinfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">branch</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">mem_buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">space</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* ================= Generate some debug output ================= */</span>
	<span class="n">space</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">mem_buffer</span> <span class="o">=</span> <span class="n">p</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i5000_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;MC: %s:%s() kmalloc() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Scan all the actual slots</span>
<span class="cm">	 * and calculate the information for each DIMM</span>
<span class="cm">	 * Start with the highest slot first, to display it first</span>
<span class="cm">	 * and work toward the 0th slot</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxdimmperch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">slot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* on an odd slot, first output a &#39;boundary&#39; marker,</span>
<span class="cm">		 * then reset the message buffer  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;--------------------------&quot;</span>
				<span class="s">&quot;--------------------------------&quot;</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_buffer</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">mem_buffer</span><span class="p">;</span>
			<span class="n">space</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;slot %2d    &quot;</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">channel</span> <span class="o">&lt;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span><span class="p">;</span> <span class="n">channel</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dimm_info</span><span class="p">[</span><span class="n">slot</span><span class="p">][</span><span class="n">channel</span><span class="p">];</span>
			<span class="n">handle_channel</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">dinfo</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dinfo</span><span class="o">-&gt;</span><span class="n">megabytes</span><span class="p">)</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;%4d MB %dR| &quot;</span><span class="p">,</span>
					     <span class="n">dinfo</span><span class="o">-&gt;</span><span class="n">megabytes</span><span class="p">,</span> <span class="n">dinfo</span><span class="o">-&gt;</span><span class="n">dual_rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;%4d MB   | &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_buffer</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">mem_buffer</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Output the last bottom &#39;boundary&#39; marker */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;--------------------------&quot;</span>
		<span class="s">&quot;--------------------------------&quot;</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_buffer</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">mem_buffer</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="cm">/* now output the &#39;channel&#39; labels */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;           &quot;</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">channel</span> <span class="o">&lt;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span><span class="p">;</span> <span class="n">channel</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;channel %d | &quot;</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_buffer</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">mem_buffer</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;           &quot;</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">branch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">branch</span> <span class="o">&lt;</span> <span class="n">MAX_BRANCHES</span><span class="p">;</span> <span class="n">branch</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;       branch %d       | &quot;</span><span class="p">,</span> <span class="n">branch</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* output the last message and free buffer */</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_buffer</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mem_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_get_mc_regs	read in the necessary registers and</span>
<span class="cm"> *				cache locally</span>
<span class="cm"> *</span>
<span class="cm"> *			Fills in the private data members</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i5000_get_mc_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">actual_tolm</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">limit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot_row</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxdimmperch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">way0</span><span class="p">,</span> <span class="n">way1</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">system_address</span><span class="p">,</span> <span class="n">AMBASE</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ambase</span><span class="p">);</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">system_address</span><span class="p">,</span> <span class="n">AMBASE</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
			<span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ambase</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>

	<span class="n">maxdimmperch</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxdimmperch</span><span class="p">;</span>
	<span class="n">maxch</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span><span class="p">;</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;AMBASE= 0x%lx  MAXCH= %d  MAX-DIMM-Per-CH= %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ambase</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxdimmperch</span><span class="p">);</span>

	<span class="cm">/* Get the Branch Map regs */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span> <span class="n">TOLM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span><span class="p">);</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span> <span class="o">&gt;&gt;=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">TOLM (number of 256M regions) =%u (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span><span class="p">);</span>

	<span class="n">actual_tolm</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">;</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;Actual TOLM byte addr=%u (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">actual_tolm</span><span class="p">,</span> <span class="n">actual_tolm</span><span class="p">);</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span> <span class="n">MIR0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir0</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span> <span class="n">MIR1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir1</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span> <span class="n">MIR2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir2</span><span class="p">);</span>

	<span class="cm">/* Get the MIR[0-2] regs */</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir0</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0FFF</span><span class="p">;</span>
	<span class="n">way0</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir0</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">way1</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir0</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">;</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MIR0: limit= 0x%x  WAY1= %u  WAY0= %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">way1</span><span class="p">,</span> <span class="n">way0</span><span class="p">);</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir1</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0FFF</span><span class="p">;</span>
	<span class="n">way0</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir1</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">way1</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir1</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">;</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MIR1: limit= 0x%x  WAY1= %u  WAY0= %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">way1</span><span class="p">,</span> <span class="n">way0</span><span class="p">);</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir2</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0FFF</span><span class="p">;</span>
	<span class="n">way0</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir2</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">way1</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir2</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">;</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MIR2: limit= 0x%x  WAY1= %u  WAY0= %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">way1</span><span class="p">,</span> <span class="n">way0</span><span class="p">);</span>

	<span class="cm">/* Get the MTR[0-3] regs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">slot_row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot_row</span> <span class="o">&lt;</span> <span class="n">NUM_MTRS</span><span class="p">;</span> <span class="n">slot_row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">where</span> <span class="o">=</span> <span class="n">MTR0</span> <span class="o">+</span> <span class="p">(</span><span class="n">slot_row</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>

		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_0</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b0_mtr</span><span class="p">[</span><span class="n">slot_row</span><span class="p">]);</span>

		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MTR%d where=0x%x B0 value=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot_row</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span>
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b0_mtr</span><span class="p">[</span><span class="n">slot_row</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span> <span class="o">&gt;=</span> <span class="n">CHANNELS_PER_BRANCH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_1</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_mtr</span><span class="p">[</span><span class="n">slot_row</span><span class="p">]);</span>
			<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MTR%d where=0x%x B1 value=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot_row</span><span class="p">,</span>
				<span class="n">where</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_mtr</span><span class="p">[</span><span class="n">slot_row</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_mtr</span><span class="p">[</span><span class="n">slot_row</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Read and dump branch 0&#39;s MTRs */</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Memory Technology Registers:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;   Branch 0:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">slot_row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot_row</span> <span class="o">&lt;</span> <span class="n">NUM_MTRS</span><span class="p">;</span> <span class="n">slot_row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">decode_mtr</span><span class="p">(</span><span class="n">slot_row</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b0_mtr</span><span class="p">[</span><span class="n">slot_row</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_0</span><span class="p">,</span> <span class="n">AMB_PRESENT_0</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b0_ambpresent0</span><span class="p">);</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">AMB-Branch 0-present0 0x%x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b0_ambpresent0</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_0</span><span class="p">,</span> <span class="n">AMB_PRESENT_1</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b0_ambpresent1</span><span class="p">);</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">AMB-Branch 0-present1 0x%x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b0_ambpresent1</span><span class="p">);</span>

	<span class="cm">/* Only if we have 2 branchs (4 channels) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span> <span class="o">&lt;</span> <span class="n">CHANNELS_PER_BRANCH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_ambpresent0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_ambpresent1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Read and dump  branch 1&#39;s MTRs */</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;   Branch 1:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">slot_row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot_row</span> <span class="o">&lt;</span> <span class="n">NUM_MTRS</span><span class="p">;</span> <span class="n">slot_row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">decode_mtr</span><span class="p">(</span><span class="n">slot_row</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_mtr</span><span class="p">[</span><span class="n">slot_row</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_1</span><span class="p">,</span> <span class="n">AMB_PRESENT_0</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_ambpresent0</span><span class="p">);</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">AMB-Branch 1-present0 0x%x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_ambpresent0</span><span class="p">);</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branch_1</span><span class="p">,</span> <span class="n">AMB_PRESENT_1</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_ambpresent1</span><span class="p">);</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">AMB-Branch 1-present1 0x%x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">b1_ambpresent1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Go and determine the size of each DIMM and place in an</span>
<span class="cm">	 * orderly matrix */</span>
	<span class="n">calculate_dimm_size</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_init_csrows	Initialize the &#39;csrows&#39; table within</span>
<span class="cm"> *				the mci control	structure with the</span>
<span class="cm"> *				addressing of memory.</span>
<span class="cm"> *</span>
<span class="cm"> *	return:</span>
<span class="cm"> *		0	success</span>
<span class="cm"> *		1	no actual memory found on this MC</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i5000_init_csrows</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">empty</span><span class="p">,</span> <span class="n">channel_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_csrows</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csrow_megs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">channel_count</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span><span class="p">;</span>
	<span class="n">max_csrows</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxdimmperch</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Assume NO memory */</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: The memory layout used to map slot/channel into the</span>
<span class="cm">	 * real memory architecture is weird: branch+slot are &quot;csrows&quot;</span>
<span class="cm">	 * and channel is channel. That required an extra array (dimm_info)</span>
<span class="cm">	 * to map the dimms. A good cleanup would be to remove this array,</span>
<span class="cm">	 * and do a loop here with branch, channel, slot</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="n">max_csrows</span><span class="p">;</span> <span class="n">slot</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">channel</span> <span class="o">&lt;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span><span class="p">;</span> <span class="n">channel</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">mtr</span> <span class="o">=</span> <span class="n">determine_mtr</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MTR_DIMMS_PRESENT</span><span class="p">(</span><span class="n">mtr</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">dimm</span> <span class="o">=</span> <span class="n">EDAC_DIMM_PTR</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">dimms</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span><span class="p">,</span>
				       <span class="n">channel</span> <span class="o">/</span> <span class="n">MAX_BRANCHES</span><span class="p">,</span>
				       <span class="n">channel</span> <span class="o">%</span> <span class="n">MAX_BRANCHES</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

			<span class="n">csrow_megs</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dimm_info</span><span class="p">[</span><span class="n">slot</span><span class="p">][</span><span class="n">channel</span><span class="p">].</span><span class="n">megabytes</span><span class="p">;</span>
			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">grain</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

			<span class="cm">/* Assume DDR2 for now */</span>
			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">mtype</span> <span class="o">=</span> <span class="n">MEM_FB_DDR2</span><span class="p">;</span>

			<span class="cm">/* ask what device type on this row */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">MTR_DRAM_WIDTH</span><span class="p">(</span><span class="n">mtr</span><span class="p">))</span>
				<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">DEV_X8</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">DEV_X4</span><span class="p">;</span>

			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">edac_mode</span> <span class="o">=</span> <span class="n">EDAC_S8ECD8ED</span><span class="p">;</span>
			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">csrow_megs</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">empty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_enable_error_reporting</span>
<span class="cm"> *			Turn on the memory reporting features of the hardware</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i5000_enable_error_reporting</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fbd_error_mask</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/* Read the FBD Error Mask Register */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span> <span class="n">EMASK_FBD</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">fbd_error_mask</span><span class="p">);</span>

	<span class="cm">/* Enable with a &#39;0&#39; */</span>
	<span class="n">fbd_error_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ENABLE_EMASK_ALL</span><span class="p">);</span>

	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">branchmap_werrors</span><span class="p">,</span> <span class="n">EMASK_FBD</span><span class="p">,</span>
			<span class="n">fbd_error_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * i5000_get_dimm_and_channel_counts(pdev, &amp;nr_csrows, &amp;num_channels)</span>
<span class="cm"> *</span>
<span class="cm"> *	ask the device how many channels are present and how many CSROWS</span>
<span class="cm"> *	 as well</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i5000_get_dimm_and_channel_counts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
					<span class="kt">int</span> <span class="o">*</span><span class="n">num_dimms_per_channel</span><span class="p">,</span>
					<span class="kt">int</span> <span class="o">*</span><span class="n">num_channels</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">value</span><span class="p">;</span>

	<span class="cm">/* Need to retrieve just how many channels and dimms per channel are</span>
<span class="cm">	 * supported on this memory controller</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">MAXDIMMPERCH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="o">*</span><span class="n">num_dimms_per_channel</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">MAXCH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="o">*</span><span class="n">num_channels</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_probe1	Probe for ONE instance of device to see if it is</span>
<span class="cm"> *			present.</span>
<span class="cm"> *	return:</span>
<span class="cm"> *		0 for FOUND a device</span>
<span class="cm"> *		&lt; 0 for error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i5000_probe1</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="n">layers</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">i5000_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_channels</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_dimms_per_channel</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: %s: %s(), pdev bus %u dev=0x%x fn=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
		<span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">));</span>

	<span class="cm">/* We only are looking for func 0 of the set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Ask the devices for the number of CSROWS and CHANNELS so</span>
<span class="cm">	 * that we can calculate the memory resources, etc</span>
<span class="cm">	 *</span>
<span class="cm">	 * The Chipset will report what it can handle which will be greater</span>
<span class="cm">	 * or equal to what the motherboard manufacturer will implement.</span>
<span class="cm">	 *</span>
<span class="cm">	 * As we don&#39;t have a motherboard identification routine to determine</span>
<span class="cm">	 * actual number of slots/dimms per channel, we thus utilize the</span>
<span class="cm">	 * resource as specified by the chipset. Thus, we might have</span>
<span class="cm">	 * have more DIMMs per channel than actually on the mobo, but this</span>
<span class="cm">	 * allows the driver to support up to the chipset max, without</span>
<span class="cm">	 * some fancy mobo determination.</span>
<span class="cm">	 */</span>
	<span class="n">i5000_get_dimm_and_channel_counts</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_dimms_per_channel</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">num_channels</span><span class="p">);</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: %s(): Number of Branches=2 Channels= %d  DIMMS= %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">num_channels</span><span class="p">,</span> <span class="n">num_dimms_per_channel</span><span class="p">);</span>

	<span class="cm">/* allocate a new MC control structure */</span>

	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_BRANCH</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">MAX_BRANCHES</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_CHANNEL</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">num_channels</span> <span class="o">/</span> <span class="n">MAX_BRANCHES</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_SLOT</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">num_dimms_per_channel</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">edac_mc_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">layers</span><span class="p">),</span> <span class="n">layers</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pvt</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">);</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: %s: %s(): mci = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">mci</span><span class="p">);</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>	<span class="cm">/* record ptr  to the generic device */</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">system_address</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>	<span class="cm">/* Record this device in our private */</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxch</span> <span class="o">=</span> <span class="n">num_channels</span><span class="p">;</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">maxdimmperch</span> <span class="o">=</span> <span class="n">num_dimms_per_channel</span><span class="p">;</span>

	<span class="cm">/* &#39;get&#39; the pci devices we want to reserve for our use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i5000_get_devices</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">dev_idx</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>

	<span class="cm">/* Time to get serious */</span>
	<span class="n">i5000_get_mc_regs</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>	<span class="cm">/* retrieve the hardware registers */</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mtype_cap</span> <span class="o">=</span> <span class="n">MEM_FLAG_FB_DDR2</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_ctl_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_name</span> <span class="o">=</span> <span class="s">&quot;i5000_edac.c&quot;</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_ver</span> <span class="o">=</span> <span class="n">I5000_REVISION</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span> <span class="o">=</span> <span class="n">i5000_devs</span><span class="p">[</span><span class="n">dev_idx</span><span class="p">].</span><span class="n">ctl_name</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev_name</span> <span class="o">=</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_page_to_phys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Set the function pointer to an actual operation function */</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_check</span> <span class="o">=</span> <span class="n">i5000_check_error</span><span class="p">;</span>

	<span class="cm">/* initialize the MC control structure &#39;csrows&#39; table</span>
<span class="cm">	 * with the mapping and control information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i5000_init_csrows</span><span class="p">(</span><span class="n">mci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: Setting mci-&gt;edac_cap to EDAC_FLAG_NONE</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;    because i5000_init_csrows() returned nonzero &quot;</span>
			<span class="s">&quot;value</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>	<span class="cm">/* no csrows found */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;MC: Enable error reporting now</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">i5000_enable_error_reporting</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* add this new MC control structure to EDAC&#39;s list of MCs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edac_mc_add_mc</span><span class="p">(</span><span class="n">mci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: %s: %s(): failed edac_mc_add_mc()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* FIXME: perhaps some code should go here that disables error</span>
<span class="cm">		 * reporting if we just enabled it</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i5000_clear_error</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="cm">/* allocating generic PCI control info */</span>
	<span class="n">i5000_pci</span> <span class="o">=</span> <span class="n">edac_pci_create_generic_ctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">EDAC_MOD_STR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i5000_pci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;%s(): Unable to create PCI control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;%s(): PCI error report via EDAC not setup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Error exit unwinding stack */</span>
<span class="nl">fail1:</span>

	<span class="n">i5000_put_devices</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

<span class="nl">fail0:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">);</span>
	<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_init_one	constructor for one instance of device</span>
<span class="cm"> *</span>
<span class="cm"> * 	returns:</span>
<span class="cm"> *		negative on error</span>
<span class="cm"> *		count (&gt;= 0)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">i5000_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: %s: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* wake up device */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* now probe and enable the device */</span>
	<span class="k">return</span> <span class="n">i5000_probe1</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_remove_one	destructor for one instance of device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">i5000_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i5000_pci</span><span class="p">)</span>
		<span class="n">edac_pci_release_generic_ctl</span><span class="p">(</span><span class="n">i5000_pci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mci</span> <span class="o">=</span> <span class="n">edac_mc_del_mc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* retrieve references to resources, and free those resources */</span>
	<span class="n">i5000_put_devices</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">);</span>
	<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	pci_device_id	table for which devices we are looking for</span>
<span class="cm"> *</span>
<span class="cm"> *	The &quot;E500P&quot; device is the first device supported.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">i5000_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_I5000_DEV16</span><span class="p">),</span>
	 <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">I5000P</span><span class="p">},</span>

	<span class="p">{</span><span class="mi">0</span><span class="p">,}</span>			<span class="cm">/* 0 terminated list. */</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">i5000_pci_tbl</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_driver	pci_driver structure for this module</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">i5000_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">KBUILD_BASENAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">i5000_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">i5000_remove_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">i5000_pci_tbl</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_init		Module entry function</span>
<span class="cm"> *			Try to initialize this module for its devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">i5000_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pci_rc</span><span class="p">;</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MC: %s: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

       <span class="cm">/* Ensure that the OPSTATE is set correctly for POLL or NMI */</span>
       <span class="n">opstate_init</span><span class="p">();</span>

	<span class="n">pci_rc</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i5000_driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">pci_rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">pci_rc</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i5000_exit()	Module exit function</span>
<span class="cm"> *			Unregister the driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">i5000_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MC: %s: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i5000_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">i5000_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">i5000_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span>
    <span class="p">(</span><span class="s">&quot;Linux Networx (http://lnxi.com) Doug Thompson &lt;norsk5@xmission.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MC Driver for Intel I5000 memory controllers - &quot;</span>
		<span class="n">I5000_REVISION</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">edac_op_state</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edac_op_state</span><span class="p">,</span> <span class="s">&quot;EDAC Error Reporting state: 0=Poll,1=NMI&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">misc_messages</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">misc_messages</span><span class="p">,</span> <span class="s">&quot;Log miscellaneous non fatal messages&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
