<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › edac › edac_core.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>edac_core.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Defines, structures, APIs for edac_core module</span>
<span class="cm"> *</span>
<span class="cm"> * (C) 2007 Linux Networx (http://lnxi.com)</span>
<span class="cm"> * This file may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License.</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Thayne Harbaugh</span>
<span class="cm"> * Based on work by Dan Hollis &lt;goemon at anime dot net&gt; and others.</span>
<span class="cm"> *	http://www.anime.net/~goemon/linux-ecc/</span>
<span class="cm"> *</span>
<span class="cm"> * NMI handling support added by</span>
<span class="cm"> *     Dave Peterson &lt;dsp@llnl.gov&gt; &lt;dave_peterson@pobox.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Refactored for multi-source files:</span>
<span class="cm"> *	Doug Thompson &lt;norsk5@xmission.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _EDAC_CORE_H_</span>
<span class="cp">#define _EDAC_CORE_H_</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/nmi.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/edac.h&gt;</span>

<span class="cp">#define EDAC_DEVICE_NAME_LEN	31</span>
<span class="cp">#define EDAC_ATTRIB_VALUE_LEN	15</span>

<span class="cp">#if PAGE_SHIFT &lt; 20</span>
<span class="cp">#define PAGES_TO_MiB(pages)	((pages) &gt;&gt; (20 - PAGE_SHIFT))</span>
<span class="cp">#define MiB_TO_PAGES(mb)	((mb) &lt;&lt; (20 - PAGE_SHIFT))</span>
<span class="cp">#else				</span><span class="cm">/* PAGE_SHIFT &gt; 20 */</span><span class="cp"></span>
<span class="cp">#define PAGES_TO_MiB(pages)	((pages) &lt;&lt; (PAGE_SHIFT - 20))</span>
<span class="cp">#define MiB_TO_PAGES(mb)	((mb) &gt;&gt; (PAGE_SHIFT - 20))</span>
<span class="cp">#endif</span>

<span class="cp">#define edac_printk(level, prefix, fmt, arg...) \</span>
<span class="cp">	printk(level &quot;EDAC &quot; prefix &quot;: &quot; fmt, ##arg)</span>

<span class="cp">#define edac_mc_printk(mci, level, fmt, arg...) \</span>
<span class="cp">	printk(level &quot;EDAC MC%d: &quot; fmt, mci-&gt;mc_idx, ##arg)</span>

<span class="cp">#define edac_mc_chipset_printk(mci, level, prefix, fmt, arg...) \</span>
<span class="cp">	printk(level &quot;EDAC &quot; prefix &quot; MC%d: &quot; fmt, mci-&gt;mc_idx, ##arg)</span>

<span class="cp">#define edac_device_printk(ctl, level, fmt, arg...) \</span>
<span class="cp">	printk(level &quot;EDAC DEVICE%d: &quot; fmt, ctl-&gt;dev_idx, ##arg)</span>

<span class="cp">#define edac_pci_printk(ctl, level, fmt, arg...) \</span>
<span class="cp">	printk(level &quot;EDAC PCI%d: &quot; fmt, ctl-&gt;pci_idx, ##arg)</span>

<span class="cm">/* prefixes for edac_printk() and edac_mc_printk() */</span>
<span class="cp">#define EDAC_MC &quot;MC&quot;</span>
<span class="cp">#define EDAC_PCI &quot;PCI&quot;</span>
<span class="cp">#define EDAC_DEBUG &quot;DEBUG&quot;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">edac_mem_types</span><span class="p">[];</span>

<span class="cp">#ifdef CONFIG_EDAC_DEBUG</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_debug_level</span><span class="p">;</span>

<span class="cp">#define edac_debug_printk(level, fmt, arg...)                           \</span>
<span class="cp">	do {                                                            \</span>
<span class="cp">		if (level &lt;= edac_debug_level)                          \</span>
<span class="cp">			edac_printk(KERN_DEBUG, EDAC_DEBUG,		\</span>
<span class="cp">				    &quot;%s: &quot; fmt, __func__, ##arg);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define debugf0( ... ) edac_debug_printk(0, __VA_ARGS__ )</span>
<span class="cp">#define debugf1( ... ) edac_debug_printk(1, __VA_ARGS__ )</span>
<span class="cp">#define debugf2( ... ) edac_debug_printk(2, __VA_ARGS__ )</span>
<span class="cp">#define debugf3( ... ) edac_debug_printk(3, __VA_ARGS__ )</span>
<span class="cp">#define debugf4( ... ) edac_debug_printk(4, __VA_ARGS__ )</span>

<span class="cp">#else				</span><span class="cm">/* !CONFIG_EDAC_DEBUG */</span><span class="cp"></span>

<span class="cp">#define debugf0( ... )</span>
<span class="cp">#define debugf1( ... )</span>
<span class="cp">#define debugf2( ... )</span>
<span class="cp">#define debugf3( ... )</span>
<span class="cp">#define debugf4( ... )</span>

<span class="cp">#endif				</span><span class="cm">/* !CONFIG_EDAC_DEBUG */</span><span class="cp"></span>

<span class="cp">#define PCI_VEND_DEV(vend, dev) PCI_VENDOR_ID_ ## vend, \</span>
<span class="cp">	PCI_DEVICE_ID_ ## vend ## _ ## dev</span>

<span class="cp">#define edac_dev_name(dev) (dev)-&gt;dev_name</span>

<span class="cm">/*</span>
<span class="cm"> * The following are the structures to provide for a generic</span>
<span class="cm"> * or abstract &#39;edac_device&#39;. This set of structures and the</span>
<span class="cm"> * code that implements the APIs for the same, provide for</span>
<span class="cm"> * registering EDAC type devices which are NOT standard memory.</span>
<span class="cm"> *</span>
<span class="cm"> * CPU caches (L1 and L2)</span>
<span class="cm"> * DMA engines</span>
<span class="cm"> * Core CPU switches</span>
<span class="cm"> * Fabric switch units</span>
<span class="cm"> * PCIe interface controllers</span>
<span class="cm"> * other EDAC/ECC type devices that can be monitored for</span>
<span class="cm"> * errors, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * It allows for a 2 level set of hierarchy. For example:</span>
<span class="cm"> *</span>
<span class="cm"> * cache could be composed of L1, L2 and L3 levels of cache.</span>
<span class="cm"> * Each CPU core would have its own L1 cache, while sharing</span>
<span class="cm"> * L2 and maybe L3 caches.</span>
<span class="cm"> *</span>
<span class="cm"> * View them arranged, via the sysfs presentation:</span>
<span class="cm"> * /sys/devices/system/edac/..</span>
<span class="cm"> *</span>
<span class="cm"> *	mc/		&lt;existing memory device directory&gt;</span>
<span class="cm"> *	cpu/cpu0/..	&lt;L1 and L2 block directory&gt;</span>
<span class="cm"> *		/L1-cache/ce_count</span>
<span class="cm"> *			 /ue_count</span>
<span class="cm"> *		/L2-cache/ce_count</span>
<span class="cm"> *			 /ue_count</span>
<span class="cm"> *	cpu/cpu1/..	&lt;L1 and L2 block directory&gt;</span>
<span class="cm"> *		/L1-cache/ce_count</span>
<span class="cm"> *			 /ue_count</span>
<span class="cm"> *		/L2-cache/ce_count</span>
<span class="cm"> *			 /ue_count</span>
<span class="cm"> *	...</span>
<span class="cm"> *</span>
<span class="cm"> *	the L1 and L2 directories would be &quot;edac_device_block&#39;s&quot;</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">edac_device_counter</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">ue_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ce_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* forward reference */</span>
<span class="k">struct</span> <span class="n">edac_device_ctl_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">edac_device_block</span><span class="p">;</span>

<span class="cm">/* edac_dev_sysfs_attribute structure</span>
<span class="cm"> *	used for driver sysfs attributes in mem_ctl_info</span>
<span class="cm"> *	for extra controls and attributes:</span>
<span class="cm"> *		like high level error Injection controls</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">edac_dev_sysfs_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* edac_dev_sysfs_block_attribute structure</span>
<span class="cm"> *</span>
<span class="cm"> *	used in leaf &#39;block&#39; nodes for adding controls/attributes</span>
<span class="cm"> *</span>
<span class="cm"> *	each block in each instance of the containing control structure</span>
<span class="cm"> *	can have an array of the following. The show and store functions</span>
<span class="cm"> *	will be filled in with the show/store function in the</span>
<span class="cm"> *	low level driver.</span>
<span class="cm"> *</span>
<span class="cm"> *	The &#39;value&#39; field will be the actual value field used for</span>
<span class="cm"> *	counting</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">edac_dev_sysfs_block_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">edac_device_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* device block control structure */</span>
<span class="k">struct</span> <span class="n">edac_device_block</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>	<span class="cm">/* Up Pointer */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EDAC_DEVICE_NAME_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">edac_device_counter</span> <span class="n">counters</span><span class="p">;</span>	<span class="cm">/* basic UE and CE counters */</span>

	<span class="kt">int</span> <span class="n">nr_attribs</span><span class="p">;</span>		<span class="cm">/* how many attributes */</span>

	<span class="cm">/* this block&#39;s attributes, could be NULL */</span>
	<span class="k">struct</span> <span class="n">edac_dev_sysfs_block_attribute</span> <span class="o">*</span><span class="n">block_attributes</span><span class="p">;</span>

	<span class="cm">/* edac sysfs device control */</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* device instance control structure */</span>
<span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">ctl</span><span class="p">;</span>	<span class="cm">/* Up pointer */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EDAC_DEVICE_NAME_LEN</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">edac_device_counter</span> <span class="n">counters</span><span class="p">;</span>	<span class="cm">/* instance counters */</span>

	<span class="n">u32</span> <span class="n">nr_blocks</span><span class="p">;</span>		<span class="cm">/* how many blocks */</span>
	<span class="k">struct</span> <span class="n">edac_device_block</span> <span class="o">*</span><span class="n">blocks</span><span class="p">;</span>	<span class="cm">/* block array */</span>

	<span class="cm">/* edac sysfs device control */</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Abstract edac_device control info structure</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="p">{</span>
	<span class="cm">/* for global list of edac_device_ctl_info structs */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>	<span class="cm">/* Module owner of this control struct */</span>

	<span class="kt">int</span> <span class="n">dev_idx</span><span class="p">;</span>

	<span class="cm">/* Per instance controls for this edac_device */</span>
	<span class="kt">int</span> <span class="n">log_ue</span><span class="p">;</span>		<span class="cm">/* boolean for logging UEs */</span>
	<span class="kt">int</span> <span class="n">log_ce</span><span class="p">;</span>		<span class="cm">/* boolean for logging CEs */</span>
	<span class="kt">int</span> <span class="n">panic_on_ue</span><span class="p">;</span>	<span class="cm">/* boolean for panic&#39;ing on an UE */</span>
	<span class="kt">unsigned</span> <span class="n">poll_msec</span><span class="p">;</span>	<span class="cm">/* number of milliseconds to poll interval */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">;</span>	<span class="cm">/* number of jiffies for poll_msec */</span>

	<span class="cm">/* Additional top controller level attributes, but specified</span>
<span class="cm">	 * by the low level driver.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set by the low level driver to provide attributes at the</span>
<span class="cm">	 * controller level, same level as &#39;ue_count&#39; and &#39;ce_count&#39; above.</span>
<span class="cm">	 * An array of structures, NULL terminated</span>
<span class="cm">	 *</span>
<span class="cm">	 * If attributes are desired, then set to array of attributes</span>
<span class="cm">	 * If no attributes are desired, leave NULL</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">edac_dev_sysfs_attribute</span> <span class="o">*</span><span class="n">sysfs_attributes</span><span class="p">;</span>

	<span class="cm">/* pointer to main &#39;edac&#39; subsys in sysfs */</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">edac_subsys</span><span class="p">;</span>

	<span class="cm">/* the internal state of this controller instance */</span>
	<span class="kt">int</span> <span class="n">op_state</span><span class="p">;</span>
	<span class="cm">/* work struct for this instance */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">work</span><span class="p">;</span>

	<span class="cm">/* pointer to edac polling checking routine:</span>
<span class="cm">	 *      If NOT NULL: points to polling check routine</span>
<span class="cm">	 *      If NULL: Then assumes INTERRUPT operation, where</span>
<span class="cm">	 *              MC driver will receive events</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">edac_check</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span> <span class="n">edac_dev</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>	<span class="cm">/* pointer to device structure */</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">;</span>	<span class="cm">/* module name */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctl_name</span><span class="p">;</span>	<span class="cm">/* edac controller  name */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>	<span class="cm">/* pci/platform/etc... name */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">pvt_info</span><span class="p">;</span>		<span class="cm">/* pointer to &#39;private driver&#39; info */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span><span class="p">;</span>	<span class="cm">/* edac_device load start time (jiffies) */</span>

	<span class="k">struct</span> <span class="n">completion</span> <span class="n">removal_complete</span><span class="p">;</span>

	<span class="cm">/* sysfs top name under &#39;edac&#39; directory</span>
<span class="cm">	 * and instance name:</span>
<span class="cm">	 *      cpu/cpu0/...</span>
<span class="cm">	 *      cpu/cpu1/...</span>
<span class="cm">	 *      cpu/cpu2/...</span>
<span class="cm">	 *      ...</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EDAC_DEVICE_NAME_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Number of instances supported on this control structure</span>
<span class="cm">	 * and the array of those instances</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">nr_instances</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="n">instances</span><span class="p">;</span>

	<span class="cm">/* Event counters for the this whole EDAC Device */</span>
	<span class="k">struct</span> <span class="n">edac_device_counter</span> <span class="n">counters</span><span class="p">;</span>

	<span class="cm">/* edac sysfs device control for the &#39;name&#39;</span>
<span class="cm">	 * device this structure controls</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* To get from the instance&#39;s wq to the beginning of the ctl structure */</span>
<span class="cp">#define to_edac_mem_ctl_work(w) \</span>
<span class="cp">		container_of(w, struct mem_ctl_info, work)</span>

<span class="cp">#define to_edac_device_ctl_work(w) \</span>
<span class="cp">		container_of(w,struct edac_device_ctl_info,work)</span>

<span class="cm">/*</span>
<span class="cm"> * The alloc() and free() functions for the &#39;edac_device&#39; control info</span>
<span class="cm"> * structure. A MC driver will allocate one of these for each edac_device</span>
<span class="cm"> * it is going to control/register with the EDAC CORE.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_device_alloc_ctl_info</span><span class="p">(</span>
		<span class="kt">unsigned</span> <span class="n">sizeof_private</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">edac_device_name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_instances</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">edac_block_name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_blocks</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">offset_value</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">edac_dev_sysfs_block_attribute</span> <span class="o">*</span><span class="n">block_attributes</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">nr_attribs</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">device_index</span><span class="p">);</span>

<span class="cm">/* The offset value can be:</span>
<span class="cm"> *	-1 indicating no offset value</span>
<span class="cm"> *	0 for zero-based block numbers</span>
<span class="cm"> *	1 for 1-based block number</span>
<span class="cm"> *	other for other-based block number</span>
<span class="cm"> */</span>
<span class="cp">#define	BLOCK_OFFSET_VALUE_OFF	((unsigned) -1)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">edac_device_free_ctl_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">ctl_info</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>

<span class="k">struct</span> <span class="n">edac_pci_counter</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">pe_count</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">npe_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Abstract edac_pci control info structure</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="p">{</span>
	<span class="cm">/* for global list of edac_pci_ctl_info structs */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">pci_idx</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">edac_subsys</span><span class="p">;</span>	<span class="cm">/* pointer to subsystem */</span>

	<span class="cm">/* the internal state of this controller instance */</span>
	<span class="kt">int</span> <span class="n">op_state</span><span class="p">;</span>
	<span class="cm">/* work struct for this instance */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">work</span><span class="p">;</span>

	<span class="cm">/* pointer to edac polling checking routine:</span>
<span class="cm">	 *      If NOT NULL: points to polling check routine</span>
<span class="cm">	 *      If NULL: Then assumes INTERRUPT operation, where</span>
<span class="cm">	 *              MC driver will receive events</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">edac_check</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span> <span class="n">edac_dev</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>	<span class="cm">/* pointer to device structure */</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">;</span>	<span class="cm">/* module name */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctl_name</span><span class="p">;</span>	<span class="cm">/* edac controller  name */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>	<span class="cm">/* pci/platform/etc... name */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">pvt_info</span><span class="p">;</span>		<span class="cm">/* pointer to &#39;private driver&#39; info */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span><span class="p">;</span>	<span class="cm">/* edac_pci load start time (jiffies) */</span>

	<span class="k">struct</span> <span class="n">completion</span> <span class="n">complete</span><span class="p">;</span>

	<span class="cm">/* sysfs top name under &#39;edac&#39; directory</span>
<span class="cm">	 * and instance name:</span>
<span class="cm">	 *      cpu/cpu0/...</span>
<span class="cm">	 *      cpu/cpu1/...</span>
<span class="cm">	 *      cpu/cpu2/...</span>
<span class="cm">	 *      ...</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EDAC_DEVICE_NAME_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Event counters for the this whole EDAC Device */</span>
	<span class="k">struct</span> <span class="n">edac_pci_counter</span> <span class="n">counters</span><span class="p">;</span>

	<span class="cm">/* edac sysfs device control for the &#39;name&#39;</span>
<span class="cm">	 * device this structure controls</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">kobj_complete</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define to_edac_pci_ctl_work(w) \</span>
<span class="cp">		container_of(w, struct edac_pci_ctl_info,work)</span>

<span class="cm">/* write all or some bits in a byte-register*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_write_bits8</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">buf</span><span class="p">;</span>

		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* write all or some bits in a word-register*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_write_bits16</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				    <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">buf</span><span class="p">;</span>

		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pci_write_bits32</span>
<span class="cm"> *</span>
<span class="cm"> * edac local routine to do pci_write_config_dword, but adds</span>
<span class="cm"> * a mask parameter. If mask is all ones, ignore the mask.</span>
<span class="cm"> * Otherwise utilize the mask to isolate specified bits</span>
<span class="cm"> *</span>
<span class="cm"> * write all or some bits in a dword-register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_write_bits32</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">value</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">buf</span><span class="p">;</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif				</span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">edac_mc_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">mc_num</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">n_layers</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="o">*</span><span class="n">layers</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">sz_pvt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_mc_add_mc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">edac_mc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">edac_mc_find</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">find_mci_by_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">edac_mc_del_mc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_mc_find_csrow_by_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="k">const</span> <span class="k">enum</span> <span class="n">hw_event_mc_err_type</span> <span class="n">type</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_frame_number</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset_in_page</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">syndrome</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">int</span> <span class="n">layer0</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">int</span> <span class="n">layer1</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">int</span> <span class="n">layer2</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">other_detail</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mcelog</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device APIs</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_device_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_device_del_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">edac_device_handle_ue</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">inst_nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block_nr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">edac_device_handle_ce</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">inst_nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block_nr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_device_alloc_index</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">edac_layer_name</span><span class="p">[];</span>

<span class="cm">/*</span>
<span class="cm"> * edac_pci APIs</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">edac_pci_alloc_ctl_info</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz_pvt</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">edac_pci_name</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">edac_pci_free_ctl_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">edac_pci_reset_delay_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_pci_alloc_index</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_pci_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">edac_idx</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">edac_pci_del_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">edac_pci_create_generic_ctl</span><span class="p">(</span>
				<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">edac_pci_release_generic_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_pci_create_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">edac_pci_remove_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">pci</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * edac misc APIs</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">edac_op_state_to_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">op_state</span><span class="p">);</span>

<span class="cp">#endif				</span><span class="cm">/* _EDAC_CORE_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
