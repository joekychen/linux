<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › edac › sb_edac.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sb_edac.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Intel Sandy Bridge -EN/-EP/-EX Memory Controller kernel module</span>
<span class="cm"> *</span>
<span class="cm"> * This driver supports the memory controllers found on the Intel</span>
<span class="cm"> * processor family Sandy Bridge.</span>
<span class="cm"> *</span>
<span class="cm"> * This file may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License version 2 only.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2011 by:</span>
<span class="cm"> *	 Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pci_ids.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/edac.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/mce.h&gt;</span>

<span class="cp">#include &quot;edac_core.h&quot;</span>

<span class="cm">/* Static vars */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">sbridge_edac_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">sbridge_edac_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">probed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Alter this version for the module when modifications are made</span>
<span class="cm"> */</span>
<span class="cp">#define SBRIDGE_REVISION    &quot; Ver: 1.0.0 &quot;</span>
<span class="cp">#define EDAC_MOD_STR      &quot;sbridge_edac&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Debug macros</span>
<span class="cm"> */</span>
<span class="cp">#define sbridge_printk(level, fmt, arg...)			\</span>
<span class="cp">	edac_printk(level, &quot;sbridge&quot;, fmt, ##arg)</span>

<span class="cp">#define sbridge_mc_printk(mci, level, fmt, arg...)		\</span>
<span class="cp">	edac_mc_chipset_printk(mci, level, &quot;sbridge&quot;, fmt, ##arg)</span>

<span class="cm">/*</span>
<span class="cm"> * Get a bit field at register value &lt;v&gt;, from bit &lt;lo&gt; to bit &lt;hi&gt;</span>
<span class="cm"> */</span>
<span class="cp">#define GET_BITFIELD(v, lo, hi)	\</span>
<span class="cp">	(((v) &amp; ((1ULL &lt;&lt; ((hi) - (lo) + 1)) - 1) &lt;&lt; (lo)) &gt;&gt; (lo))</span>

<span class="cm">/*</span>
<span class="cm"> * sbridge Memory Controller Registers</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME: For now, let&#39;s order by device function, as it makes</span>
<span class="cm"> * easier for driver&#39;s development process. This table should be</span>
<span class="cm"> * moved to pci_id.h when submitted upstream</span>
<span class="cm"> */</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_SAD0	0x3cf4	</span><span class="cm">/* 12.6 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_SAD1	0x3cf6	</span><span class="cm">/* 12.7 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_BR		0x3cf5	</span><span class="cm">/* 13.6 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_HA0	0x3ca0	</span><span class="cm">/* 14.0 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TA	0x3ca8	</span><span class="cm">/* 15.0 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_RAS	0x3c71	</span><span class="cm">/* 15.1 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD0	0x3caa	</span><span class="cm">/* 15.2 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD1	0x3cab	</span><span class="cm">/* 15.3 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD2	0x3cac	</span><span class="cm">/* 15.4 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD3	0x3cad	</span><span class="cm">/* 15.5 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_DDRIO	0x3cb8	</span><span class="cm">/* 17.0 */</span><span class="cp"></span>

	<span class="cm">/*</span>
<span class="cm">	 * Currently, unused, but will be needed in the future</span>
<span class="cm">	 * implementations, as they hold the error counters</span>
<span class="cm">	 */</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_ERR0	0x3c72	</span><span class="cm">/* 16.2 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_ERR1	0x3c73	</span><span class="cm">/* 16.3 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_ERR2	0x3c76	</span><span class="cm">/* 16.6 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_ERR3	0x3c77	</span><span class="cm">/* 16.7 */</span><span class="cp"></span>

<span class="cm">/* Devices 12 Function 6, Offsets 0x80 to 0xcc */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">dram_rule</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0xa0</span><span class="p">,</span>
	<span class="mh">0xa8</span><span class="p">,</span> <span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0xb8</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span> <span class="mh">0xc8</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define MAX_SAD		ARRAY_SIZE(dram_rule)</span>

<span class="cp">#define SAD_LIMIT(reg)		((GET_BITFIELD(reg, 6, 25) &lt;&lt; 26) | 0x3ffffff)</span>
<span class="cp">#define DRAM_ATTR(reg)		GET_BITFIELD(reg, 2,  3)</span>
<span class="cp">#define INTERLEAVE_MODE(reg)	GET_BITFIELD(reg, 1,  1)</span>
<span class="cp">#define DRAM_RULE_ENABLE(reg)	GET_BITFIELD(reg, 0,  0)</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_dram_attr</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">DRAM_ATTR</span><span class="p">(</span><span class="n">reg</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">return</span> <span class="s">&quot;DRAM&quot;</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="k">return</span> <span class="s">&quot;MMCFG&quot;</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">return</span> <span class="s">&quot;NXM&quot;</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">interleave_list</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x84</span><span class="p">,</span> <span class="mh">0x8c</span><span class="p">,</span> <span class="mh">0x94</span><span class="p">,</span> <span class="mh">0x9c</span><span class="p">,</span> <span class="mh">0xa4</span><span class="p">,</span>
	<span class="mh">0xac</span><span class="p">,</span> <span class="mh">0xb4</span><span class="p">,</span> <span class="mh">0xbc</span><span class="p">,</span> <span class="mh">0xc4</span><span class="p">,</span> <span class="mh">0xcc</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define MAX_INTERLEAVE	ARRAY_SIZE(interleave_list)</span>

<span class="cp">#define SAD_PKG0(reg)		GET_BITFIELD(reg, 0, 2)</span>
<span class="cp">#define SAD_PKG1(reg)		GET_BITFIELD(reg, 3, 5)</span>
<span class="cp">#define SAD_PKG2(reg)		GET_BITFIELD(reg, 8, 10)</span>
<span class="cp">#define SAD_PKG3(reg)		GET_BITFIELD(reg, 11, 13)</span>
<span class="cp">#define SAD_PKG4(reg)		GET_BITFIELD(reg, 16, 18)</span>
<span class="cp">#define SAD_PKG5(reg)		GET_BITFIELD(reg, 19, 21)</span>
<span class="cp">#define SAD_PKG6(reg)		GET_BITFIELD(reg, 24, 26)</span>
<span class="cp">#define SAD_PKG7(reg)		GET_BITFIELD(reg, 27, 29)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sad_pkg</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interleave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">interleave</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">return</span> <span class="n">SAD_PKG0</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">return</span> <span class="n">SAD_PKG1</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">return</span> <span class="n">SAD_PKG2</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="k">return</span> <span class="n">SAD_PKG3</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="k">return</span> <span class="n">SAD_PKG4</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="k">return</span> <span class="n">SAD_PKG5</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="k">return</span> <span class="n">SAD_PKG6</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">7</span>:
		<span class="k">return</span> <span class="n">SAD_PKG7</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Devices 12 Function 7 */</span>

<span class="cp">#define TOLM		0x80</span>
<span class="cp">#define	TOHM		0x84</span>

<span class="cp">#define GET_TOLM(reg)		((GET_BITFIELD(reg, 0,  3) &lt;&lt; 28) | 0x3ffffff)</span>
<span class="cp">#define GET_TOHM(reg)		((GET_BITFIELD(reg, 0, 20) &lt;&lt; 25) | 0x3ffffff)</span>

<span class="cm">/* Device 13 Function 6 */</span>

<span class="cp">#define SAD_TARGET	0xf0</span>

<span class="cp">#define SOURCE_ID(reg)		GET_BITFIELD(reg, 9, 11)</span>

<span class="cp">#define SAD_CONTROL	0xf4</span>

<span class="cp">#define NODE_ID(reg)		GET_BITFIELD(reg, 0, 2)</span>

<span class="cm">/* Device 14 function 0 */</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">tad_dram_rule</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x4c</span><span class="p">,</span>
	<span class="mh">0x50</span><span class="p">,</span> <span class="mh">0x54</span><span class="p">,</span> <span class="mh">0x58</span><span class="p">,</span> <span class="mh">0x5c</span><span class="p">,</span>
	<span class="mh">0x60</span><span class="p">,</span> <span class="mh">0x64</span><span class="p">,</span> <span class="mh">0x68</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define MAX_TAD	ARRAY_SIZE(tad_dram_rule)</span>

<span class="cp">#define TAD_LIMIT(reg)		((GET_BITFIELD(reg, 12, 31) &lt;&lt; 26) | 0x3ffffff)</span>
<span class="cp">#define TAD_SOCK(reg)		GET_BITFIELD(reg, 10, 11)</span>
<span class="cp">#define TAD_CH(reg)		GET_BITFIELD(reg,  8,  9)</span>
<span class="cp">#define TAD_TGT3(reg)		GET_BITFIELD(reg,  6,  7)</span>
<span class="cp">#define TAD_TGT2(reg)		GET_BITFIELD(reg,  4,  5)</span>
<span class="cp">#define TAD_TGT1(reg)		GET_BITFIELD(reg,  2,  3)</span>
<span class="cp">#define TAD_TGT0(reg)		GET_BITFIELD(reg,  0,  1)</span>

<span class="cm">/* Device 15, function 0 */</span>

<span class="cp">#define MCMTR			0x7c</span>

<span class="cp">#define IS_ECC_ENABLED(mcmtr)		GET_BITFIELD(mcmtr, 2, 2)</span>
<span class="cp">#define IS_LOCKSTEP_ENABLED(mcmtr)	GET_BITFIELD(mcmtr, 1, 1)</span>
<span class="cp">#define IS_CLOSE_PG(mcmtr)		GET_BITFIELD(mcmtr, 0, 0)</span>

<span class="cm">/* Device 15, function 1 */</span>

<span class="cp">#define RASENABLES		0xac</span>
<span class="cp">#define IS_MIRROR_ENABLED(reg)		GET_BITFIELD(reg, 0, 0)</span>

<span class="cm">/* Device 15, functions 2-5 */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">mtr_regs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define RANK_DISABLE(mtr)		GET_BITFIELD(mtr, 16, 19)</span>
<span class="cp">#define IS_DIMM_PRESENT(mtr)		GET_BITFIELD(mtr, 14, 14)</span>
<span class="cp">#define RANK_CNT_BITS(mtr)		GET_BITFIELD(mtr, 12, 13)</span>
<span class="cp">#define RANK_WIDTH_BITS(mtr)		GET_BITFIELD(mtr, 2, 4)</span>
<span class="cp">#define COL_WIDTH_BITS(mtr)		GET_BITFIELD(mtr, 0, 1)</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">tad_ch_nilv_offset</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x90</span><span class="p">,</span> <span class="mh">0x94</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0x9c</span><span class="p">,</span>
	<span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0xa4</span><span class="p">,</span> <span class="mh">0xa8</span><span class="p">,</span> <span class="mh">0xac</span><span class="p">,</span>
	<span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0xb4</span><span class="p">,</span> <span class="mh">0xb8</span><span class="p">,</span> <span class="mh">0xbc</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define CHN_IDX_OFFSET(reg)		GET_BITFIELD(reg, 28, 29)</span>
<span class="cp">#define TAD_OFFSET(reg)			(GET_BITFIELD(reg,  6, 25) &lt;&lt; 26)</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">rir_way_limit</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x108</span><span class="p">,</span> <span class="mh">0x10c</span><span class="p">,</span> <span class="mh">0x110</span><span class="p">,</span> <span class="mh">0x114</span><span class="p">,</span> <span class="mh">0x118</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define MAX_RIR_RANGES ARRAY_SIZE(rir_way_limit)</span>

<span class="cp">#define IS_RIR_VALID(reg)	GET_BITFIELD(reg, 31, 31)</span>
<span class="cp">#define RIR_WAY(reg)		GET_BITFIELD(reg, 28, 29)</span>
<span class="cp">#define RIR_LIMIT(reg)		((GET_BITFIELD(reg,  1, 10) &lt;&lt; 29)| 0x1fffffff)</span>

<span class="cp">#define MAX_RIR_WAY	8</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">rir_offset</span><span class="p">[</span><span class="n">MAX_RIR_RANGES</span><span class="p">][</span><span class="n">MAX_RIR_WAY</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x120</span><span class="p">,</span> <span class="mh">0x124</span><span class="p">,</span> <span class="mh">0x128</span><span class="p">,</span> <span class="mh">0x12c</span><span class="p">,</span> <span class="mh">0x130</span><span class="p">,</span> <span class="mh">0x134</span><span class="p">,</span> <span class="mh">0x138</span><span class="p">,</span> <span class="mh">0x13c</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x140</span><span class="p">,</span> <span class="mh">0x144</span><span class="p">,</span> <span class="mh">0x148</span><span class="p">,</span> <span class="mh">0x14c</span><span class="p">,</span> <span class="mh">0x150</span><span class="p">,</span> <span class="mh">0x154</span><span class="p">,</span> <span class="mh">0x158</span><span class="p">,</span> <span class="mh">0x15c</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x160</span><span class="p">,</span> <span class="mh">0x164</span><span class="p">,</span> <span class="mh">0x168</span><span class="p">,</span> <span class="mh">0x16c</span><span class="p">,</span> <span class="mh">0x170</span><span class="p">,</span> <span class="mh">0x174</span><span class="p">,</span> <span class="mh">0x178</span><span class="p">,</span> <span class="mh">0x17c</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x180</span><span class="p">,</span> <span class="mh">0x184</span><span class="p">,</span> <span class="mh">0x188</span><span class="p">,</span> <span class="mh">0x18c</span><span class="p">,</span> <span class="mh">0x190</span><span class="p">,</span> <span class="mh">0x194</span><span class="p">,</span> <span class="mh">0x198</span><span class="p">,</span> <span class="mh">0x19c</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x1a0</span><span class="p">,</span> <span class="mh">0x1a4</span><span class="p">,</span> <span class="mh">0x1a8</span><span class="p">,</span> <span class="mh">0x1ac</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">,</span> <span class="mh">0x1b4</span><span class="p">,</span> <span class="mh">0x1b8</span><span class="p">,</span> <span class="mh">0x1bc</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cp">#define RIR_RNK_TGT(reg)		GET_BITFIELD(reg, 16, 19)</span>
<span class="cp">#define RIR_OFFSET(reg)		GET_BITFIELD(reg,  2, 14)</span>

<span class="cm">/* Device 16, functions 2-7 */</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME: Implement the error count reads directly</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">correrrcnt</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x104</span><span class="p">,</span> <span class="mh">0x108</span><span class="p">,</span> <span class="mh">0x10c</span><span class="p">,</span> <span class="mh">0x110</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define RANK_ODD_OV(reg)		GET_BITFIELD(reg, 31, 31)</span>
<span class="cp">#define RANK_ODD_ERR_CNT(reg)		GET_BITFIELD(reg, 16, 30)</span>
<span class="cp">#define RANK_EVEN_OV(reg)		GET_BITFIELD(reg, 15, 15)</span>
<span class="cp">#define RANK_EVEN_ERR_CNT(reg)		GET_BITFIELD(reg,  0, 14)</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">correrrthrsld</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x11c</span><span class="p">,</span> <span class="mh">0x120</span><span class="p">,</span> <span class="mh">0x124</span><span class="p">,</span> <span class="mh">0x128</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define RANK_ODD_ERR_THRSLD(reg)	GET_BITFIELD(reg, 16, 30)</span>
<span class="cp">#define RANK_EVEN_ERR_THRSLD(reg)	GET_BITFIELD(reg,  0, 14)</span>


<span class="cm">/* Device 17, function 0 */</span>

<span class="cp">#define RANK_CFG_A		0x0328</span>

<span class="cp">#define IS_RDIMM_ENABLED(reg)		GET_BITFIELD(reg, 11, 11)</span>

<span class="cm">/*</span>
<span class="cm"> * sbridge structs</span>
<span class="cm"> */</span>

<span class="cp">#define NUM_CHANNELS	4</span>
<span class="cp">#define MAX_DIMMS	3		</span><span class="cm">/* Max DIMMS per channel */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">sbridge_info</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">mcmtr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sbridge_channel</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">ranks</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">dimms</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pci_id_descr</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">func</span><span class="p">;</span>
	<span class="kt">int</span> 			<span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">optional</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pci_id_table</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_id_descr</span>	<span class="o">*</span><span class="n">descr</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">n_devs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">bus</span><span class="p">,</span> <span class="n">mc</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">node_id</span><span class="p">,</span> <span class="n">source_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">**</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">n_devs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span>	<span class="o">*</span><span class="n">mci</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sbridge_pvt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pci_ta</span><span class="p">,</span> <span class="o">*</span><span class="n">pci_ddrio</span><span class="p">,</span> <span class="o">*</span><span class="n">pci_ras</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pci_sad0</span><span class="p">,</span> <span class="o">*</span><span class="n">pci_sad1</span><span class="p">,</span> <span class="o">*</span><span class="n">pci_ha0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pci_br</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pci_tad</span><span class="p">[</span><span class="n">NUM_CHANNELS</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">sbridge_dev</span>	<span class="o">*</span><span class="n">sbridge_dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sbridge_info</span>	<span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbridge_channel</span>	<span class="n">channel</span><span class="p">[</span><span class="n">NUM_CHANNELS</span><span class="p">];</span>

	<span class="cm">/* Memory type detection */</span>
	<span class="n">bool</span>			<span class="n">is_mirrored</span><span class="p">,</span> <span class="n">is_lockstep</span><span class="p">,</span> <span class="n">is_close_pg</span><span class="p">;</span>

	<span class="cm">/* Fifo double buffers */</span>
	<span class="k">struct</span> <span class="n">mce</span>		<span class="n">mce_entry</span><span class="p">[</span><span class="n">MCE_LOG_LEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">mce</span>		<span class="n">mce_outentry</span><span class="p">[</span><span class="n">MCE_LOG_LEN</span><span class="p">];</span>

	<span class="cm">/* Fifo in/out counters */</span>
	<span class="kt">unsigned</span>		<span class="n">mce_in</span><span class="p">,</span> <span class="n">mce_out</span><span class="p">;</span>

	<span class="cm">/* Count indicator to show errors not got */</span>
	<span class="kt">unsigned</span>		<span class="n">mce_overrun</span><span class="p">;</span>

	<span class="cm">/* Memory description */</span>
	<span class="n">u64</span>			<span class="n">tolm</span><span class="p">,</span> <span class="n">tohm</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define PCI_DESCR(device, function, device_id)	\</span>
<span class="cp">	.dev = (device),			\</span>
<span class="cp">	.func = (function),			\</span>
<span class="cp">	.dev_id = (device_id)</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_id_descr</span> <span class="n">pci_dev_descr_sbridge</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* Processor Home Agent */</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_HA0</span><span class="p">)</span>		<span class="p">},</span>

		<span class="cm">/* Memory controller */</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TA</span><span class="p">)</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_RAS</span><span class="p">)</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD0</span><span class="p">)</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD1</span><span class="p">)</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD2</span><span class="p">)</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD3</span><span class="p">)</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_DDRIO</span><span class="p">)</span>	<span class="p">},</span>

		<span class="cm">/* System Address Decoder */</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_SAD0</span><span class="p">)</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_SAD1</span><span class="p">)</span>		<span class="p">},</span>

		<span class="cm">/* Broadcast Registers */</span>
	<span class="p">{</span> <span class="n">PCI_DESCR</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_BR</span><span class="p">)</span>		<span class="p">},</span>
<span class="p">};</span>

<span class="cp">#define PCI_ID_TABLE_ENTRY(A) { .descr=A, .n_devs = ARRAY_SIZE(A) }</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_id_table</span> <span class="n">pci_dev_descr_sbridge_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">PCI_ID_TABLE_ENTRY</span><span class="p">(</span><span class="n">pci_dev_descr_sbridge</span><span class="p">),</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,}</span>			<span class="cm">/* 0 terminated list. */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	pci_device_id	table for which devices we are looking for</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">sbridge_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TA</span><span class="p">)},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,}</span>			<span class="cm">/* 0 terminated list. */</span>
<span class="p">};</span>


<span class="cm">/****************************************************************************</span>
<span class="cm">			Ancillary status routines</span>
<span class="cm"> ****************************************************************************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">numrank</span><span class="p">(</span><span class="n">u32</span> <span class="n">mtr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ranks</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RANK_CNT_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ranks</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Invalid number of ranks: %d (max = 4) raw value = %x (%04x)&quot;</span><span class="p">,</span>
			<span class="n">ranks</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">RANK_CNT_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">),</span> <span class="n">mtr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ranks</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">numrow</span><span class="p">(</span><span class="n">u32</span> <span class="n">mtr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">RANK_WIDTH_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rows</span> <span class="o">&lt;</span> <span class="mi">13</span> <span class="o">||</span> <span class="n">rows</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Invalid number of rows: %d (should be between 14 and 17) raw value = %x (%04x)&quot;</span><span class="p">,</span>
			<span class="n">rows</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">RANK_WIDTH_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">),</span> <span class="n">mtr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">rows</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">numcol</span><span class="p">(</span><span class="n">u32</span> <span class="n">mtr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">(</span><span class="n">COL_WIDTH_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cols</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Invalid number of cols: %d (max = 4) raw value = %x (%04x)&quot;</span><span class="p">,</span>
			<span class="n">cols</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">COL_WIDTH_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">),</span> <span class="n">mtr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cols</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="nf">get_sbridge_dev</span><span class="p">(</span><span class="n">u8</span> <span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbridge_edac_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="n">bus</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sbridge_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="nf">alloc_sbridge_dev</span><span class="p">(</span><span class="n">u8</span> <span class="n">bus</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_id_table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">;</span>

	<span class="n">sbridge_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sbridge_dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbridge_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)</span> <span class="o">*</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">n_devs</span><span class="p">,</span>
				   <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
	<span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">n_devs</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">n_devs</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbridge_edac_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sbridge_dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_sbridge_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">			Memory check routines</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="nf">get_pdev_slot_func</span><span class="p">(</span><span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span> <span class="o">=</span> <span class="n">get_sbridge_dev</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbridge_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">n_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">==</span> <span class="n">slot</span> <span class="o">&amp;&amp;</span>
		    <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">==</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;Associated %02x.%02x.%d with %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bus</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">return</span> <span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * check_if_ecc_is_active() - Checks if ECC is active</span>
<span class="cm"> * bus:		Device bus</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_if_ecc_is_active</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcmtr</span><span class="p">;</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="n">get_pdev_slot_func</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t find PCI device &quot;</span>
					<span class="s">&quot;%2x.%02d.%d!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bus</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">MCMTR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcmtr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ECC_ENABLED</span><span class="p">(</span><span class="n">mcmtr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;ECC is disabled. Aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_dimm_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">banks</span><span class="p">,</span> <span class="n">ranks</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">npages</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">edac_type</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mem_type</span> <span class="n">mtype</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_br</span><span class="p">,</span> <span class="n">SAD_TARGET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">source_id</span> <span class="o">=</span> <span class="n">SOURCE_ID</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_br</span><span class="p">,</span> <span class="n">SAD_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">NODE_ID</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;mc#%d: Node ID: %d, source ID: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">source_id</span><span class="p">);</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ras</span><span class="p">,</span> <span class="n">RASENABLES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_MIRROR_ENABLED</span><span class="p">(</span><span class="n">reg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Memory mirror is enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">is_mirrored</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Memory mirror is disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">is_mirrored</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ta</span><span class="p">,</span> <span class="n">MCMTR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">mcmtr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_LOCKSTEP_ENABLED</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">mcmtr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Lockstep is enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">EDAC_S8ECD8ED</span><span class="p">;</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">is_lockstep</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Lockstep is disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">EDAC_S4ECD4ED</span><span class="p">;</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">is_lockstep</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_CLOSE_PG</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">mcmtr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;address map is on closed page mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">is_close_pg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;address map is on open page mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">is_close_pg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ddrio</span><span class="p">,</span> <span class="n">RANK_CFG_A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_RDIMM_ENABLED</span><span class="p">(</span><span class="n">reg</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* FIXME: Can also be LRDIMM */</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Memory is registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mtype</span> <span class="o">=</span> <span class="n">MEM_RDDR3</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Memory is unregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mtype</span> <span class="o">=</span> <span class="n">MEM_DDR3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* On all supported DDR3 DIMM types, there are 8 banks available */</span>
	<span class="n">banks</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">mtr</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mtr_regs</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dimm</span> <span class="o">=</span> <span class="n">EDAC_DIMM_PTR</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">dimms</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span><span class="p">,</span>
				       <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_tad</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					      <span class="n">mtr_regs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
			<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;Channel #%d  MTR%d = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mtr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_DIMM_PRESENT</span><span class="p">(</span><span class="n">mtr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dimms</span><span class="o">++</span><span class="p">;</span>

				<span class="n">ranks</span> <span class="o">=</span> <span class="n">numrank</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>
				<span class="n">rows</span> <span class="o">=</span> <span class="n">numrow</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>
				<span class="n">cols</span> <span class="o">=</span> <span class="n">numcol</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>

				<span class="cm">/* DDR3 has 8 I/O banks */</span>
				<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">*</span> <span class="n">banks</span> <span class="o">*</span> <span class="n">ranks</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
				<span class="n">npages</span> <span class="o">=</span> <span class="n">MiB_TO_PAGES</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

				<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;mc#%d: channel %d, dimm %d, %d Mb (%d pages) bank: %d, rank: %d, row: %#x, col: %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
					<span class="n">size</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span>
					<span class="n">banks</span><span class="p">,</span> <span class="n">ranks</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

				<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
				<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">grain</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
				<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">dtype</span> <span class="o">=</span> <span class="p">(</span><span class="n">banks</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="o">?</span> <span class="n">DEV_X8</span> <span class="o">:</span> <span class="n">DEV_X4</span><span class="p">;</span>
				<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">mtype</span> <span class="o">=</span> <span class="n">mtype</span><span class="p">;</span>
				<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">edac_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
				<span class="n">snprintf</span><span class="p">(</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">),</span>
					 <span class="s">&quot;CPU_SrcID#%u_Channel#%u_DIMM#%u&quot;</span><span class="p">,</span>
					 <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">source_id</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_memory_layout</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n_sads</span><span class="p">,</span> <span class="n">n_tads</span><span class="p">,</span> <span class="n">sad_interl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">limit</span><span class="p">,</span> <span class="n">prv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tmp_mb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mb</span><span class="p">,</span> <span class="n">kb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rir_way</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Step 1) Get TOLM/TOHM ranges</span>
<span class="cm">	 */</span>

	<span class="cm">/* Address range is 32:28 */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_sad1</span><span class="p">,</span> <span class="n">TOLM</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span> <span class="o">=</span> <span class="n">GET_TOLM</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">tmp_mb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span>

	<span class="n">mb</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">(</span><span class="n">tmp_mb</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kb</span><span class="p">);</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;TOLM: %u.%03u GB (0x%016Lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">mb</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span><span class="p">);</span>

	<span class="cm">/* Address range is already 45:25 */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_sad1</span><span class="p">,</span> <span class="n">TOHM</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tohm</span> <span class="o">=</span> <span class="n">GET_TOHM</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">tmp_mb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tohm</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span>

	<span class="n">mb</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">(</span><span class="n">tmp_mb</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kb</span><span class="p">);</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;TOHM: %u.%03u GB (0x%016Lx)&quot;</span><span class="p">,</span>
		<span class="n">mb</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tohm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Step 2) Get SAD range and SAD Interleave list</span>
<span class="cm">	 * TAD registers contain the interleave wayness. However, it</span>
<span class="cm">	 * seems simpler to just discover it indirectly, with the</span>
<span class="cm">	 * algorithm bellow.</span>
<span class="cm">	 */</span>
	<span class="n">prv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n_sads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n_sads</span> <span class="o">&lt;</span> <span class="n">MAX_SAD</span><span class="p">;</span> <span class="n">n_sads</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* SAD_LIMIT Address range is 45:26 */</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_sad0</span><span class="p">,</span> <span class="n">dram_rule</span><span class="p">[</span><span class="n">n_sads</span><span class="p">],</span>
				      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">SAD_LIMIT</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DRAM_RULE_ENABLE</span><span class="p">(</span><span class="n">reg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;=</span> <span class="n">prv</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">tmp_mb</span> <span class="o">=</span> <span class="p">(</span><span class="n">limit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span>
		<span class="n">mb</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">(</span><span class="n">tmp_mb</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kb</span><span class="p">);</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;SAD#%d %s up to %u.%03u GB (0x%016Lx) %s reg=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">n_sads</span><span class="p">,</span>
			<span class="n">get_dram_attr</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
			<span class="n">mb</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span>
			<span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp_mb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">20L</span><span class="p">,</span>
			<span class="n">INTERLEAVE_MODE</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Interleave: 8:6&quot;</span> <span class="o">:</span> <span class="s">&quot;Interleave: [8:6]XOR[18:16]&quot;</span><span class="p">,</span>
			<span class="n">reg</span><span class="p">);</span>
		<span class="n">prv</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_sad0</span><span class="p">,</span> <span class="n">interleave_list</span><span class="p">[</span><span class="n">n_sads</span><span class="p">],</span>
				      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">sad_interl</span> <span class="o">=</span> <span class="n">sad_pkg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sad_interl</span> <span class="o">==</span> <span class="n">sad_pkg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;SAD#%d, interleave #%d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">n_sads</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sad_pkg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Step 3) Get TAD range</span>
<span class="cm">	 */</span>
	<span class="n">prv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n_tads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n_tads</span> <span class="o">&lt;</span> <span class="n">MAX_TAD</span><span class="p">;</span> <span class="n">n_tads</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ha0</span><span class="p">,</span> <span class="n">tad_dram_rule</span><span class="p">[</span><span class="n">n_tads</span><span class="p">],</span>
				      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">TAD_LIMIT</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;=</span> <span class="n">prv</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">tmp_mb</span> <span class="o">=</span> <span class="p">(</span><span class="n">limit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span>

		<span class="n">mb</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">(</span><span class="n">tmp_mb</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kb</span><span class="p">);</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;TAD#%d: up to %u.%03u GB (0x%016Lx), socket interleave %d, memory interleave %d, TGT: %d, %d, %d, %d, reg=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">n_tads</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span>
			<span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp_mb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">20L</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">TAD_SOCK</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">TAD_CH</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">TAD_TGT0</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">TAD_TGT1</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">TAD_TGT2</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">TAD_TGT3</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
			<span class="n">reg</span><span class="p">);</span>
		<span class="n">prv</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Step 4) Get TAD offsets, per each channel</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dimms</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_tads</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_tad</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					      <span class="n">tad_ch_nilv_offset</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
					      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
			<span class="n">tmp_mb</span> <span class="o">=</span> <span class="n">TAD_OFFSET</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span>
			<span class="n">mb</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">(</span><span class="n">tmp_mb</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kb</span><span class="p">);</span>
			<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;TAD CH#%d, offset #%d: %u.%03u GB (0x%016Lx), reg=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
				<span class="n">mb</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span>
				<span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp_mb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">20L</span><span class="p">,</span>
				<span class="n">reg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Step 6) Get RIR Wayness/Limit, per each channel</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dimms</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MAX_RIR_RANGES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_tad</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					      <span class="n">rir_way_limit</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
					      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_RIR_VALID</span><span class="p">(</span><span class="n">reg</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">tmp_mb</span> <span class="o">=</span> <span class="n">RIR_LIMIT</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span>
			<span class="n">rir_way</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RIR_WAY</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
			<span class="n">mb</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">(</span><span class="n">tmp_mb</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kb</span><span class="p">);</span>
			<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;CH#%d RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d, reg=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
				<span class="n">mb</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span>
				<span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp_mb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">20L</span><span class="p">,</span>
				<span class="n">rir_way</span><span class="p">,</span>
				<span class="n">reg</span><span class="p">);</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">rir_way</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_tad</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						      <span class="n">rir_offset</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>
						      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
				<span class="n">tmp_mb</span> <span class="o">=</span> <span class="n">RIR_OFFSET</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>

				<span class="n">mb</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">(</span><span class="n">tmp_mb</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kb</span><span class="p">);</span>
				<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;CH#%d RIR#%d INTL#%d, offset %u.%03u GB (0x%016Lx), tgt: %d, reg=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span>
					<span class="n">mb</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span>
					<span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp_mb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">20L</span><span class="p">,</span>
					<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">RIR_RNK_TGT</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
					<span class="n">reg</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="nf">get_mci_for_node_id</span><span class="p">(</span><span class="n">u8</span> <span class="n">node_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbridge_edac_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">node_id</span> <span class="o">==</span> <span class="n">node_id</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mci</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_memory_error_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="o">*</span><span class="n">socket</span><span class="p">,</span>
				 <span class="kt">long</span> <span class="o">*</span><span class="n">channel_mask</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="o">*</span><span class="n">rank</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">**</span><span class="n">area_type</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span>	<span class="o">*</span><span class="n">new_mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbridge_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="kt">int</span> 			<span class="n">n_rir</span><span class="p">,</span> <span class="n">n_sads</span><span class="p">,</span> <span class="n">n_tads</span><span class="p">,</span> <span class="n">sad_way</span><span class="p">,</span> <span class="n">sck_xch</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sad_interl</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">base_ch</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">interleave_mode</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">sad_interleave</span><span class="p">[</span><span class="n">MAX_INTERLEAVE</span><span class="p">];</span>
	<span class="n">u32</span>			<span class="n">reg</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ch_way</span><span class="p">,</span><span class="n">sck_way</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">tad_offset</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">rir_way</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">mb</span><span class="p">,</span> <span class="n">kb</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">ch_addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">prv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * Step 0) Check if the address is at special memory ranges</span>
<span class="cm">	 * The check bellow is probably enough to fill all cases where</span>
<span class="cm">	 * the error is not inside a memory, except for the legacy</span>
<span class="cm">	 * range (e. g. VGA addresses). It is unlikely, however, that the</span>
<span class="cm">	 * memory controller would generate an error on that range.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Error at TOLM area, on addr 0x%08Lx&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tohm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Error at MMIOH area, on addr 0x%016Lx&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Step 1) Get socket</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n_sads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n_sads</span> <span class="o">&lt;</span> <span class="n">MAX_SAD</span><span class="p">;</span> <span class="n">n_sads</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_sad0</span><span class="p">,</span> <span class="n">dram_rule</span><span class="p">[</span><span class="n">n_sads</span><span class="p">],</span>
				      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DRAM_RULE_ENABLE</span><span class="p">(</span><span class="n">reg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">limit</span> <span class="o">=</span> <span class="n">SAD_LIMIT</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;=</span> <span class="n">prv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Can&#39;t discover the memory socket&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span>  <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">prv</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_sads</span> <span class="o">==</span> <span class="n">MAX_SAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Can&#39;t discover the memory socket&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">area_type</span> <span class="o">=</span> <span class="n">get_dram_attr</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">interleave_mode</span> <span class="o">=</span> <span class="n">INTERLEAVE_MODE</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_sad0</span><span class="p">,</span> <span class="n">interleave_list</span><span class="p">[</span><span class="n">n_sads</span><span class="p">],</span>
			      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">sad_interl</span> <span class="o">=</span> <span class="n">sad_pkg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sad_way</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sad_way</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">sad_way</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sad_way</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sad_interl</span> <span class="o">==</span> <span class="n">sad_pkg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">sad_way</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sad_interleave</span><span class="p">[</span><span class="n">sad_way</span><span class="p">]</span> <span class="o">=</span> <span class="n">sad_pkg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">sad_way</span><span class="p">);</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;SAD interleave #%d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sad_way</span><span class="p">,</span> <span class="n">sad_interleave</span><span class="p">[</span><span class="n">sad_way</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;mc#%d: Error detected on SAD#%d: address 0x%016Lx &lt; 0x%016Lx, Interleave [%d:6]%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">,</span>
		<span class="n">n_sads</span><span class="p">,</span>
		<span class="n">addr</span><span class="p">,</span>
		<span class="n">limit</span><span class="p">,</span>
		<span class="n">sad_way</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span>
		<span class="n">interleave_mode</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;XOR[18:16]&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interleave_mode</span><span class="p">)</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sad_way</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Can&#39;t discover socket interleave&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="n">sad_interleave</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;SAD interleave index: %d (wayness %d) = CPU socket %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">idx</span><span class="p">,</span> <span class="n">sad_way</span><span class="p">,</span> <span class="o">*</span><span class="n">socket</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Move to the proper node structure, in order to access the</span>
<span class="cm">	 * right PCI registers</span>
<span class="cm">	 */</span>
	<span class="n">new_mci</span> <span class="o">=</span> <span class="n">get_mci_for_node_id</span><span class="p">(</span><span class="o">*</span><span class="n">socket</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_mci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Struct for socket #%u wasn&#39;t initialized&quot;</span><span class="p">,</span>
			<span class="o">*</span><span class="n">socket</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">new_mci</span><span class="p">;</span>
	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Step 2) Get memory channel</span>
<span class="cm">	 */</span>
	<span class="n">prv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n_tads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n_tads</span> <span class="o">&lt;</span> <span class="n">MAX_TAD</span><span class="p">;</span> <span class="n">n_tads</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ha0</span><span class="p">,</span> <span class="n">tad_dram_rule</span><span class="p">[</span><span class="n">n_tads</span><span class="p">],</span>
				      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">TAD_LIMIT</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;=</span> <span class="n">prv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Can&#39;t discover the memory channel&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span>  <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">prv</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ch_way</span> <span class="o">=</span> <span class="n">TAD_CH</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sck_way</span> <span class="o">=</span> <span class="n">TAD_SOCK</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: Is it right to always use channel 0 for offsets?</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_tad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">tad_ch_nilv_offset</span><span class="p">[</span><span class="n">n_tads</span><span class="p">],</span>
				<span class="o">&amp;</span><span class="n">tad_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch_way</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="n">sck_way</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">%</span> <span class="n">ch_way</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: Shouldn&#39;t we use CHN_IDX_OFFSET() here, when ch_way == 3 ???</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">base_ch</span> <span class="o">=</span> <span class="n">TAD_TGT0</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">base_ch</span> <span class="o">=</span> <span class="n">TAD_TGT1</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">base_ch</span> <span class="o">=</span> <span class="n">TAD_TGT2</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">base_ch</span> <span class="o">=</span> <span class="n">TAD_TGT3</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Can&#39;t discover the TAD target&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">channel_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">base_ch</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">is_mirrored</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">channel_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">base_ch</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">ch_way</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="n">sck_xch</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sck_way</span> <span class="o">*</span> <span class="p">(</span><span class="n">ch_way</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Invalid mirror set. Can&#39;t decode addr&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sck_xch</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sck_way</span><span class="p">)</span> <span class="o">*</span> <span class="n">ch_way</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">is_lockstep</span><span class="p">)</span>
		<span class="o">*</span><span class="n">channel_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">base_ch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">TAD_OFFSET</span><span class="p">(</span><span class="n">tad_offset</span><span class="p">);</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;TAD#%d: address 0x%016Lx &lt; 0x%016Lx, socket interleave %d, channel interleave %d (offset 0x%08Lx), index %d, base ch: %d, ch mask: 0x%02lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">n_tads</span><span class="p">,</span>
		<span class="n">addr</span><span class="p">,</span>
		<span class="n">limit</span><span class="p">,</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">TAD_SOCK</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
		<span class="n">ch_way</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span>
		<span class="n">idx</span><span class="p">,</span>
		<span class="n">base_ch</span><span class="p">,</span>
		<span class="o">*</span><span class="n">channel_mask</span><span class="p">);</span>

	<span class="cm">/* Calculate channel address */</span>
	<span class="cm">/* Remove the TAD offset */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Can&#39;t calculate ch addr: TAD offset 0x%08Lx is too high for addr 0x%08Lx!&quot;</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">addr</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="cm">/* Store the low bits [0:6] of the addr */</span>
	<span class="n">ch_addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="cm">/* Remove socket wayness and remove 6 bits */</span>
	<span class="n">addr</span> <span class="o">&gt;&gt;=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">sck_xch</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* Divide by channel way */</span>
<span class="c">	addr = addr / ch_way;</span>
<span class="cp">#endif</span>
	<span class="cm">/* Recover the last 6 bits */</span>
	<span class="n">ch_addr</span> <span class="o">|=</span> <span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Step 3) Decode rank</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n_rir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n_rir</span> <span class="o">&lt;</span> <span class="n">MAX_RIR_RANGES</span><span class="p">;</span> <span class="n">n_rir</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_tad</span><span class="p">[</span><span class="n">base_ch</span><span class="p">],</span>
				      <span class="n">rir_way_limit</span><span class="p">[</span><span class="n">n_rir</span><span class="p">],</span>
				      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_RIR_VALID</span><span class="p">(</span><span class="n">reg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">limit</span> <span class="o">=</span> <span class="n">RIR_LIMIT</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">mb</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">(</span><span class="n">limit</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kb</span><span class="p">);</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">n_rir</span><span class="p">,</span>
			<span class="n">mb</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span>
			<span class="n">limit</span><span class="p">,</span>
			<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RIR_WAY</span><span class="p">(</span><span class="n">reg</span><span class="p">));</span>
		<span class="k">if</span>  <span class="p">(</span><span class="n">ch_addr</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_rir</span> <span class="o">==</span> <span class="n">MAX_RIR_RANGES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Can&#39;t discover the memory rank for ch addr 0x%08Lx&quot;</span><span class="p">,</span>
			<span class="n">ch_addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rir_way</span> <span class="o">=</span> <span class="n">RIR_WAY</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">is_close_pg</span><span class="p">)</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">);</span>	<span class="cm">/* FIXME: Datasheet says to shift by 15 */</span>
	<span class="n">idx</span> <span class="o">%=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">rir_way</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_tad</span><span class="p">[</span><span class="n">base_ch</span><span class="p">],</span>
			      <span class="n">rir_offset</span><span class="p">[</span><span class="n">n_rir</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
			      <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="o">*</span><span class="n">rank</span> <span class="o">=</span> <span class="n">RIR_RNK_TGT</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;RIR#%d: channel address 0x%08Lx &lt; 0x%08Lx, RIR interleave %d, index %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">n_rir</span><span class="p">,</span>
		<span class="n">ch_addr</span><span class="p">,</span>
		<span class="n">limit</span><span class="p">,</span>
		<span class="n">rir_way</span><span class="p">,</span>
		<span class="n">idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">	Device initialization routines: put/get, init/exit</span>
<span class="cm"> ****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> *	sbridge_put_all_devices	&#39;put&#39; all the devices that we have</span>
<span class="cm"> *				reserved via &#39;get&#39;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbridge_put_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="n">__FILE__</span> <span class="s">&quot;: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">n_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Removing dev %02x:%02x.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
			<span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">));</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbridge_put_all_devices</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbridge_edac_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sbridge_put_devices</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">);</span>
		<span class="n">free_sbridge_dev</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	sbridge_get_all_devices	Find and perform &#39;get&#39; operation on the MCH&#39;s</span>
<span class="cm"> *			device/functions we want to reference for this driver</span>
<span class="cm"> *</span>
<span class="cm"> *			Need to &#39;get&#39; device 16 func 1 and func 2</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbridge_get_onedevice</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">**</span><span class="n">prev</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="o">*</span><span class="n">num_mc</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_id_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">devno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_id_descr</span> <span class="o">*</span><span class="n">dev_descr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">[</span><span class="n">devno</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span>
		<span class="s">&quot;Seeking for: dev %02x.%d PCI ID %04x:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
			      <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">optional</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span>
			<span class="s">&quot;Device not found: dev %02x.%d PCI ID %04x:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">,</span>
			<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>

		<span class="cm">/* End of list, leave */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bus</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>

	<span class="n">sbridge_dev</span> <span class="o">=</span> <span class="n">get_sbridge_dev</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbridge_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sbridge_dev</span> <span class="o">=</span> <span class="n">alloc_sbridge_dev</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbridge_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="o">*</span><span class="n">num_mc</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="n">devno</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="s">&quot;Duplicated device for &quot;</span>
			<span class="s">&quot;dev %02x:%d.%d PCI ID %04x:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bus</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">,</span>
			<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="n">devno</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* Sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span>
			<span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="s">&quot;Device PCI ID %04x:%04x &quot;</span>
			<span class="s">&quot;has dev %02x:%d.%d instead of dev %02x:%02x.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">,</span>
			<span class="n">bus</span><span class="p">,</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span>
			<span class="n">bus</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Be sure that the device is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="s">&quot;Couldn&#39;t enable &quot;</span>
			<span class="s">&quot;dev %02x:%d.%d PCI ID %04x:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bus</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">,</span>
			<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Detected dev %02x:%d.%d PCI ID %04x:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bus</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">dev_descr</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * As stated on drivers/pci/search.c, the reference count for</span>
<span class="cm">	 * @from is always decremented if it is not %NULL. So, as we need</span>
<span class="cm">	 * to get all devices up to null, we need to do a get for the device</span>
<span class="cm">	 */</span>
	<span class="n">pci_dev_get</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbridge_get_all_devices</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">num_mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_id_table</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="n">pci_dev_descr_sbridge_table</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">table</span> <span class="o">&amp;&amp;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">n_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">sbridge_get_onedevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">num_mc</span><span class="p">,</span>
							   <span class="n">table</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">i</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">n_devs</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">sbridge_put_all_devices</span><span class="p">();</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">table</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mci_bind_devs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">slot</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">n_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
		<span class="n">func</span> <span class="o">=</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">12</span>:
			<span class="k">switch</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">6</span>:
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_sad0</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">7</span>:
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_sad1</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">13</span>:
			<span class="k">switch</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">6</span>:
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_br</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">14</span>:
			<span class="k">switch</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ha0</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">15</span>:
			<span class="k">switch</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ta</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ras</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">case</span> <span class="mi">3</span>:
			<span class="k">case</span> <span class="mi">4</span>:
			<span class="k">case</span> <span class="mi">5</span>:
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_tad</span><span class="p">[</span><span class="n">func</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">17</span>:
			<span class="k">switch</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ddrio</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Associated PCI %02x.%02d.%d with dev = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
			<span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span>
			<span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check if everything were registered */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_sad0</span> <span class="o">||</span> <span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_sad1</span> <span class="o">||</span> <span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ha0</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span> <span class="n">pci_tad</span> <span class="o">||</span> <span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ras</span>  <span class="o">||</span> <span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ta</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_ddrio</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">enodev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_tad</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">enodev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">enodev:</span>
	<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Some needed devices are missing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Device %d, function %d &quot;</span>
		      <span class="s">&quot;is out of the expected range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">slot</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">			Error check routines</span>
<span class="cm"> ****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * While Sandy Bridge has error count registers, SMI BIOS read values from</span>
<span class="cm"> * and resets the counters. So, they are not reliable for the OS to read</span>
<span class="cm"> * from them. So, we have no option but to just trust on whatever MCE is</span>
<span class="cm"> * telling us about the errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbridge_mce_output_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">new_mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbridge_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">hw_event_mc_err_type</span> <span class="n">tp_event</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="o">*</span><span class="n">optype</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">ripv</span> <span class="o">=</span> <span class="n">GET_BITFIELD</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mcgstatus</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">overflow</span> <span class="o">=</span> <span class="n">GET_BITFIELD</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">62</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">uncorrected_error</span> <span class="o">=</span> <span class="n">GET_BITFIELD</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">recoverable</span> <span class="o">=</span> <span class="n">GET_BITFIELD</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">core_err_cnt</span> <span class="o">=</span> <span class="n">GET_BITFIELD</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">52</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">mscod</span> <span class="o">=</span> <span class="n">GET_BITFIELD</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">errcode</span> <span class="o">=</span> <span class="n">GET_BITFIELD</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">GET_BITFIELD</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">optypenum</span> <span class="o">=</span> <span class="n">GET_BITFIELD</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">channel_mask</span><span class="p">,</span> <span class="n">first_channel</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">rank</span><span class="p">,</span> <span class="n">socket</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">dimm</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">area_type</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uncorrected_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ripv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;FATAL&quot;</span><span class="p">;</span>
			<span class="n">tp_event</span> <span class="o">=</span> <span class="n">HW_EVENT_ERR_FATAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;NON_FATAL&quot;</span><span class="p">;</span>
			<span class="n">tp_event</span> <span class="o">=</span> <span class="n">HW_EVENT_ERR_UNCORRECTED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;CORRECTED&quot;</span><span class="p">;</span>
		<span class="n">tp_event</span> <span class="o">=</span> <span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * According with Table 15-9 of the Intel Architecture spec vol 3A,</span>
<span class="cm">	 * memory errors should fit in this mask:</span>
<span class="cm">	 *	000f 0000 1mmm cccc (binary)</span>
<span class="cm">	 * where:</span>
<span class="cm">	 *	f = Correction Report Filtering Bit. If 1, subsequent errors</span>
<span class="cm">	 *	    won&#39;t be shown</span>
<span class="cm">	 *	mmm = error type</span>
<span class="cm">	 *	cccc = channel</span>
<span class="cm">	 * If the mask doesn&#39;t match, report an error to the parsing logic</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">((</span><span class="n">errcode</span> <span class="o">&amp;</span> <span class="mh">0xef80</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">optype</span> <span class="o">=</span> <span class="s">&quot;Can&#39;t parse: it is not a mem&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">optypenum</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">optype</span> <span class="o">=</span> <span class="s">&quot;generic undef request error&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">optype</span> <span class="o">=</span> <span class="s">&quot;memory read error&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">optype</span> <span class="o">=</span> <span class="s">&quot;memory write error&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">optype</span> <span class="o">=</span> <span class="s">&quot;addr/cmd error&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="n">optype</span> <span class="o">=</span> <span class="s">&quot;memory scrubbing error&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">optype</span> <span class="o">=</span> <span class="s">&quot;reserved&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">get_memory_error_data</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">socket</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">channel_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rank</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">area_type</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_parsing</span><span class="p">;</span>
	<span class="n">new_mci</span> <span class="o">=</span> <span class="n">get_mci_for_node_id</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_mci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;Error: socket got corrupted!&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_parsing</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">new_mci</span><span class="p">;</span>
	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">first_channel</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel_mask</span><span class="p">,</span> <span class="n">NUM_CHANNELS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">dimm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">dimm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dimm</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * FIXME: On some memory configurations (mirror, lockstep), the</span>
<span class="cm">	 * Memory Controller can&#39;t point the error to a single DIMM. The</span>
<span class="cm">	 * EDAC core should be handling the channel mask, in order to point</span>
<span class="cm">	 * to the group of dimm&#39;s where the error may be happening.</span>
<span class="cm">	 */</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span>
		 <span class="s">&quot;count:%d%s%s area:%s err_code:%04x:%04x socket:%d channel_mask:%ld rank:%d&quot;</span><span class="p">,</span>
		 <span class="n">core_err_cnt</span><span class="p">,</span>
		 <span class="n">overflow</span> <span class="o">?</span> <span class="s">&quot; OVERFLOW&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">uncorrected_error</span> <span class="o">&amp;&amp;</span> <span class="n">recoverable</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; recoverable&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		 <span class="n">area_type</span><span class="p">,</span>
		 <span class="n">mscod</span><span class="p">,</span> <span class="n">errcode</span><span class="p">,</span>
		 <span class="n">socket</span><span class="p">,</span>
		 <span class="n">channel_mask</span><span class="p">,</span>
		 <span class="n">rank</span><span class="p">);</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* FIXME: need support for channel mask */</span>

	<span class="cm">/* Call the helper to output message */</span>
	<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">tp_event</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
			     <span class="n">m</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">channel</span><span class="p">,</span> <span class="n">dimm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
			     <span class="n">optype</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">err_parsing:</span>
	<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">tp_event</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
			     <span class="n">msg</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	sbridge_check_error	Retrieve and process errors reported by the</span>
<span class="cm"> *				hardware. Called by the Core module.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbridge_check_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * MCE first step: Copy all mce errors into a temporary buffer</span>
<span class="cm">	 * We use a double buffering here, to reduce the risk of</span>
<span class="cm">	 * loosing an error.</span>
<span class="cm">	 */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_out</span> <span class="o">+</span> <span class="n">MCE_LOG_LEN</span> <span class="o">-</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_in</span><span class="p">)</span>
		<span class="o">%</span> <span class="n">MCE_LOG_LEN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_outentry</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_in</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">MCE_LOG_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">l</span> <span class="o">=</span> <span class="n">MCE_LOG_LEN</span> <span class="o">-</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_in</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_entry</span><span class="p">[</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_in</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">l</span><span class="p">);</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
		<span class="n">m</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_entry</span><span class="p">[</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_in</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_in</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_overrun</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Lost %d memory errors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_overrun</span><span class="p">);</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_overrun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * MCE second step: parse errors and display</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sbridge_mce_output_error</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_outentry</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sbridge_mce_check_error	Replicates mcelog routine to get errors</span>
<span class="cm"> *				This routine simply queues mcelog errors, and</span>
<span class="cm"> *				return. The error itself should be handled later</span>
<span class="cm"> *				by sbridge_check_error.</span>
<span class="cm"> * WARNING: As this routine should be called at NMI time, extra care should</span>
<span class="cm"> * be taken to avoid deadlocks, and to be as fast as possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbridge_mce_check_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">mce</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbridge_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>

	<span class="n">mci</span> <span class="o">=</span> <span class="n">get_mci_for_node_id</span><span class="p">(</span><span class="n">mce</span><span class="o">-&gt;</span><span class="n">socketid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mci</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_BAD</span><span class="p">;</span>
	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just let mcelog handle it if the error is</span>
<span class="cm">	 * outside the memory controller. A memory error</span>
<span class="cm">	 * is indicated by bit 7 = 1 and bits = 8-11,13-15 = 0.</span>
<span class="cm">	 * bit 12 has an special meaning.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mce</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xefff</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sbridge: HANDLING MCE MEMORY ERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU %d: Machine Check Exception: %Lx Bank %d: %016Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">mce</span><span class="o">-&gt;</span><span class="n">extcpu</span><span class="p">,</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">mcgstatus</span><span class="p">,</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">,</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TSC %llx &quot;</span><span class="p">,</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">tsc</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ADDR %llx &quot;</span><span class="p">,</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;MISC %llx &quot;</span><span class="p">,</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;PROCESSOR %u:%x TIME %llu SOCKET %u APIC %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">mce</span><span class="o">-&gt;</span><span class="n">cpuvendor</span><span class="p">,</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">,</span>
		<span class="n">mce</span><span class="o">-&gt;</span><span class="n">socketid</span><span class="p">,</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">apicid</span><span class="p">);</span>

	<span class="cm">/* Only handle if it is the right mc controller */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">mce</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">).</span><span class="n">phys_proc_id</span> <span class="o">!=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MCE_LOG_LEN</span> <span class="o">==</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_in</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_overrun</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy memory error at the ringbuffer */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_entry</span><span class="p">[</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_out</span><span class="p">],</span> <span class="n">mce</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mce</span><span class="p">));</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mce_out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MCE_LOG_LEN</span><span class="p">;</span>

	<span class="cm">/* Handle fatal errors immediately */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mce</span><span class="o">-&gt;</span><span class="n">mcgstatus</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">sbridge_check_error</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="cm">/* Advice mcelog that the error were handled */</span>
	<span class="k">return</span> <span class="n">NOTIFY_STOP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">sbridge_mce_dec</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>      <span class="o">=</span> <span class="n">sbridge_mce_check_error</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">			EDAC register/unregister logic</span>
<span class="cm"> ****************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbridge_unregister_mci</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span> <span class="o">=</span> <span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbridge_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mci</span> <span class="o">||</span> <span class="o">!</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span> <span class="s">&quot;: %s(): dev = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t find mci handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span> <span class="s">&quot;: %s(): mci = %p, dev = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Remove MC sysfs nodes */</span>
	<span class="n">edac_mc_del_mc</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s: free mci struct</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">);</span>
	<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mci</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbridge_register_mci</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="n">layers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sbridge_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Check the number of active and not disabled channels */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">check_if_ecc_is_active</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* allocate a new MC control structure */</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_CHANNEL</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">NUM_CHANNELS</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_SLOT</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">MAX_DIMMS</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">edac_mc_alloc</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">layers</span><span class="p">),</span> <span class="n">layers</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pvt</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mci</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span> <span class="s">&quot;: %s(): mci = %p, dev = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pvt</span><span class="p">));</span>

	<span class="cm">/* Associate sbridge_dev and mci for future usage */</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">sbridge_dev</span> <span class="o">=</span> <span class="n">sbridge_dev</span><span class="p">;</span>
	<span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mci</span> <span class="o">=</span> <span class="n">mci</span><span class="p">;</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mtype_cap</span> <span class="o">=</span> <span class="n">MEM_FLAG_DDR3</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_ctl_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_name</span> <span class="o">=</span> <span class="s">&quot;sbridge_edac.c&quot;</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_ver</span> <span class="o">=</span> <span class="n">SBRIDGE_REVISION</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span> <span class="o">=</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;Sandy Bridge Socket#%d&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">);</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev_name</span> <span class="o">=</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_page_to_phys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Set the function pointer to an actual operation function */</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_check</span> <span class="o">=</span> <span class="n">sbridge_check_error</span><span class="p">;</span>

	<span class="cm">/* Store pci devices at mci for faster access */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mci_bind_devs</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">sbridge_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>

	<span class="cm">/* Get dimm basic config and the memory layout */</span>
	<span class="n">get_dimm_config</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="n">get_memory_layout</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="cm">/* record ptr to the generic device */</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* add this new MC control structure to EDAC&#39;s list of MCs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">edac_mc_add_mc</span><span class="p">(</span><span class="n">mci</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span>
			<span class="s">&quot;: %s(): failed edac_mc_add_mc()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail0:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">);</span>
	<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mci</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	sbridge_probe	Probe for ONE instance of device to see if it is</span>
<span class="cm"> *			present.</span>
<span class="cm"> *	return:</span>
<span class="cm"> *		0 for FOUND a device</span>
<span class="cm"> *		&lt; 0 for error code</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sbridge_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mc</span><span class="p">,</span> <span class="n">num_mc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">;</span>

	<span class="cm">/* get the pci devices we want to reserve for our use */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_edac_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * All memory controllers are allocated at the first pass.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">probed</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_edac_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">probed</span><span class="o">++</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sbridge_get_all_devices</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_mc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>
	<span class="n">mc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbridge_edac_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Registering MC#%d (%d of %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mc</span><span class="p">,</span> <span class="n">mc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_mc</span><span class="p">);</span>
		<span class="n">sbridge_dev</span><span class="o">-&gt;</span><span class="n">mc</span> <span class="o">=</span> <span class="n">mc</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sbridge_register_mci</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;Driver loaded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_edac_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail1:</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbridge_edac_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">sbridge_unregister_mci</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">);</span>

	<span class="n">sbridge_put_all_devices</span><span class="p">();</span>
<span class="nl">fail0:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_edac_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	sbridge_remove	destructor for one instance of device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">sbridge_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbridge_dev</span> <span class="o">*</span><span class="n">sbridge_dev</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="n">__FILE__</span> <span class="s">&quot;: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we have a trouble here: pdev value for removal will be wrong, since</span>
<span class="cm">	 * it will point to the X58 register used to detect that the machine</span>
<span class="cm">	 * is a Nehalem or upper design. However, due to the way several PCI</span>
<span class="cm">	 * devices are grouped together to provide MC functionality, we need</span>
<span class="cm">	 * to use a different method for releasing the devices</span>
<span class="cm">	 */</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_edac_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">probed</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_edac_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbridge_edac_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">sbridge_unregister_mci</span><span class="p">(</span><span class="n">sbridge_dev</span><span class="p">);</span>

	<span class="cm">/* Release PCI resources */</span>
	<span class="n">sbridge_put_all_devices</span><span class="p">();</span>

	<span class="n">probed</span><span class="o">--</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_edac_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">sbridge_pci_tbl</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	sbridge_driver	pci_driver structure for this module</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">sbridge_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>     <span class="o">=</span> <span class="s">&quot;sbridge_edac&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>    <span class="o">=</span> <span class="n">sbridge_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>   <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">sbridge_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">sbridge_pci_tbl</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	sbridge_init		Module entry function</span>
<span class="cm"> *			Try to initialize this module for its devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sbridge_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pci_rc</span><span class="p">;</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span> <span class="s">&quot;: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Ensure that the OPSTATE is set correctly for POLL or NMI */</span>
	<span class="n">opstate_init</span><span class="p">();</span>

	<span class="n">pci_rc</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_rc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mce_register_decode_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_mce_dec</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sbridge_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Failed to register device with error %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">pci_rc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pci_rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	sbridge_exit()	Module exit function</span>
<span class="cm"> *			Unregister the driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">sbridge_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span> <span class="s">&quot;: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_driver</span><span class="p">);</span>
	<span class="n">mce_unregister_decode_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbridge_mce_dec</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">sbridge_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">sbridge_exit</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">edac_op_state</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edac_op_state</span><span class="p">,</span> <span class="s">&quot;EDAC Error Reporting state: 0=Poll,1=NMI&quot;</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Red Hat Inc. (http://www.redhat.com)&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MC Driver for Intel Sandy Bridge memory controllers - &quot;</span>
		   <span class="n">SBRIDGE_REVISION</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
