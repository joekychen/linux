<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › edac › ppc4xx_edac.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ppc4xx_edac.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2008 Nuovation System Designs, LLC</span>
<span class="cm"> *   Grant Erickson &lt;gerickson@nuovations.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation; version 2 of the</span>
<span class="cm"> * License.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/edac.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/of_device.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &lt;asm/dcr.h&gt;</span>

<span class="cp">#include &quot;edac_core.h&quot;</span>
<span class="cp">#include &quot;ppc4xx_edac.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements a driver for monitoring and handling events</span>
<span class="cm"> * associated with the IMB DDR2 ECC controller found in the AMCC/IBM</span>
<span class="cm"> * 405EX[r], 440SP, 440SPe, 460EX, 460GT and 460SX.</span>
<span class="cm"> *</span>
<span class="cm"> * As realized in the 405EX[r], this controller features:</span>
<span class="cm"> *</span>
<span class="cm"> *   - Support for registered- and non-registered DDR1 and DDR2 memory.</span>
<span class="cm"> *   - 32-bit or 16-bit memory interface with optional ECC.</span>
<span class="cm"> *</span>
<span class="cm"> *     o ECC support includes:</span>
<span class="cm"> *</span>
<span class="cm"> *       - 4-bit SEC/DED</span>
<span class="cm"> *       - Aligned-nibble error detect</span>
<span class="cm"> *       - Bypass mode</span>
<span class="cm"> *</span>
<span class="cm"> *   - Two (2) memory banks/ranks.</span>
<span class="cm"> *   - Up to 1 GiB per bank/rank in 32-bit mode and up to 512 MiB per</span>
<span class="cm"> *     bank/rank in 16-bit mode.</span>
<span class="cm"> *</span>
<span class="cm"> * As realized in the 440SP and 440SPe, this controller changes/adds:</span>
<span class="cm"> *</span>
<span class="cm"> *   - 64-bit or 32-bit memory interface with optional ECC.</span>
<span class="cm"> *</span>
<span class="cm"> *     o ECC support includes:</span>
<span class="cm"> *</span>
<span class="cm"> *       - 8-bit SEC/DED</span>
<span class="cm"> *       - Aligned-nibble error detect</span>
<span class="cm"> *       - Bypass mode</span>
<span class="cm"> *</span>
<span class="cm"> *   - Up to 4 GiB per bank/rank in 64-bit mode and up to 2 GiB</span>
<span class="cm"> *     per bank/rank in 32-bit mode.</span>
<span class="cm"> *</span>
<span class="cm"> * As realized in the 460EX and 460GT, this controller changes/adds:</span>
<span class="cm"> *</span>
<span class="cm"> *   - 64-bit or 32-bit memory interface with optional ECC.</span>
<span class="cm"> *</span>
<span class="cm"> *     o ECC support includes:</span>
<span class="cm"> *</span>
<span class="cm"> *       - 8-bit SEC/DED</span>
<span class="cm"> *       - Aligned-nibble error detect</span>
<span class="cm"> *       - Bypass mode</span>
<span class="cm"> *</span>
<span class="cm"> *   - Four (4) memory banks/ranks.</span>
<span class="cm"> *   - Up to 16 GiB per bank/rank in 64-bit mode and up to 8 GiB</span>
<span class="cm"> *     per bank/rank in 32-bit mode.</span>
<span class="cm"> *</span>
<span class="cm"> * At present, this driver has ONLY been tested against the controller</span>
<span class="cm"> * realization in the 405EX[r] on the AMCC Kilauea and Haleakala</span>
<span class="cm"> * boards (256 MiB w/o ECC memory soldered onto the board) and a</span>
<span class="cm"> * proprietary board based on those designs (128 MiB ECC memory, also</span>
<span class="cm"> * soldered onto the board).</span>
<span class="cm"> *</span>
<span class="cm"> * Dynamic feature detection and handling needs to be added for the</span>
<span class="cm"> * other realizations of this controller listed above.</span>
<span class="cm"> *</span>
<span class="cm"> * Eventually, this driver will likely be adapted to the above variant</span>
<span class="cm"> * realizations of this controller as well as broken apart to handle</span>
<span class="cm"> * the other known ECC-capable controllers prevalent in other 4xx</span>
<span class="cm"> * processors:</span>
<span class="cm"> *</span>
<span class="cm"> *   - IBM SDRAM (405GP, 405CR and 405EP) &quot;ibm,sdram-4xx&quot;</span>
<span class="cm"> *   - IBM DDR1 (440GP, 440GX, 440EP and 440GR) &quot;ibm,sdram-4xx-ddr&quot;</span>
<span class="cm"> *   - Denali DDR1/DDR2 (440EPX and 440GRX) &quot;denali,sdram-4xx-ddr2&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * For this controller, unfortunately, correctable errors report</span>
<span class="cm"> * nothing more than the beat/cycle and byte/lane the correction</span>
<span class="cm"> * occurred on and the check bit group that covered the error.</span>
<span class="cm"> *</span>
<span class="cm"> * In contrast, uncorrectable errors also report the failing address,</span>
<span class="cm"> * the bus master and the transaction direction (i.e. read or write)</span>
<span class="cm"> *</span>
<span class="cm"> * Regardless of whether the error is a CE or a UE, we report the</span>
<span class="cm"> * following pieces of information in the driver-unique message to the</span>
<span class="cm"> * EDAC subsystem:</span>
<span class="cm"> *</span>
<span class="cm"> *   - Device tree path</span>
<span class="cm"> *   - Bank(s)</span>
<span class="cm"> *   - Check bit error group</span>
<span class="cm"> *   - Beat(s)/lane(s)</span>
<span class="cm"> */</span>

<span class="cm">/* Preprocessor Definitions */</span>

<span class="cp">#define EDAC_OPSTATE_INT_STR		&quot;interrupt&quot;</span>
<span class="cp">#define EDAC_OPSTATE_POLL_STR		&quot;polled&quot;</span>
<span class="cp">#define EDAC_OPSTATE_UNKNOWN_STR	&quot;unknown&quot;</span>

<span class="cp">#define PPC4XX_EDAC_MODULE_NAME		&quot;ppc4xx_edac&quot;</span>
<span class="cp">#define PPC4XX_EDAC_MODULE_REVISION	&quot;v1.0.0&quot;</span>

<span class="cp">#define PPC4XX_EDAC_MESSAGE_SIZE	256</span>

<span class="cm">/*</span>
<span class="cm"> * Kernel logging without an EDAC instance</span>
<span class="cm"> */</span>
<span class="cp">#define ppc4xx_edac_printk(level, fmt, arg...) \</span>
<span class="cp">	edac_printk(level, &quot;PPC4xx MC&quot;, fmt, ##arg)</span>

<span class="cm">/*</span>
<span class="cm"> * Kernel logging with an EDAC instance</span>
<span class="cm"> */</span>
<span class="cp">#define ppc4xx_edac_mc_printk(level, mci, fmt, arg...) \</span>
<span class="cp">	edac_mc_chipset_printk(mci, level, &quot;PPC4xx&quot;, fmt, ##arg)</span>

<span class="cm">/*</span>
<span class="cm"> * Macros to convert bank configuration size enumerations into MiB and</span>
<span class="cm"> * page values.</span>
<span class="cm"> */</span>
<span class="cp">#define SDRAM_MBCF_SZ_MiB_MIN		4</span>
<span class="cp">#define SDRAM_MBCF_SZ_TO_MiB(n)		(SDRAM_MBCF_SZ_MiB_MIN \</span>
<span class="cp">					 &lt;&lt; (SDRAM_MBCF_SZ_DECODE(n)))</span>
<span class="cp">#define SDRAM_MBCF_SZ_TO_PAGES(n)	(SDRAM_MBCF_SZ_MiB_MIN \</span>
<span class="cp">					 &lt;&lt; (20 - PAGE_SHIFT + \</span>
<span class="cp">					     SDRAM_MBCF_SZ_DECODE(n)))</span>

<span class="cm">/*</span>
<span class="cm"> * The ibm,sdram-4xx-ddr2 Device Control Registers (DCRs) are</span>
<span class="cm"> * indirectly accessed and have a base and length defined by the</span>
<span class="cm"> * device tree. The base can be anything; however, we expect the</span>
<span class="cm"> * length to be precisely two registers, the first for the address</span>
<span class="cm"> * window and the second for the data window.</span>
<span class="cm"> */</span>
<span class="cp">#define SDRAM_DCR_RESOURCE_LEN		2</span>
<span class="cp">#define SDRAM_DCR_ADDR_OFFSET		0</span>
<span class="cp">#define SDRAM_DCR_DATA_OFFSET		1</span>

<span class="cm">/*</span>
<span class="cm"> * Device tree interrupt indices</span>
<span class="cm"> */</span>
<span class="cp">#define INTMAP_ECCDED_INDEX		0	</span><span class="cm">/* Double-bit Error Detect */</span><span class="cp"></span>
<span class="cp">#define INTMAP_ECCSEC_INDEX		1	</span><span class="cm">/* Single-bit Error Correct */</span><span class="cp"></span>

<span class="cm">/* Type Definitions */</span>

<span class="cm">/*</span>
<span class="cm"> * PPC4xx SDRAM memory controller private instance data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ppc4xx_edac_pdata</span> <span class="p">{</span>
	<span class="n">dcr_host_t</span> <span class="n">dcr_host</span><span class="p">;</span>	<span class="cm">/* Indirect DCR address/data window mapping */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sec</span><span class="p">;</span>	<span class="cm">/* Single-bit correctable error IRQ assigned */</span>
		<span class="kt">int</span> <span class="n">ded</span><span class="p">;</span>	<span class="cm">/* Double-bit detectable error IRQ assigned */</span>
	<span class="p">}</span> <span class="n">irqs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Various status data gathered and manipulated when checking and</span>
<span class="cm"> * reporting ECC status.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">ecces</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">besr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bearh</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bearl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wmirq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Function Prototypes */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ppc4xx_edac_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ppc4xx_edac_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>

<span class="cm">/* Global Variables */</span>

<span class="cm">/*</span>
<span class="cm"> * Device tree node type and compatible tuples this driver can match</span>
<span class="cm"> * on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">ppc4xx_edac_match</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">compatible</span>	<span class="o">=</span> <span class="s">&quot;ibm,sdram-4xx-ddr2&quot;</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">ppc4xx_edac_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>			<span class="o">=</span> <span class="n">ppc4xx_edac_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>			<span class="o">=</span> <span class="n">ppc4xx_edac_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">PPC4XX_EDAC_MODULE_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">ppc4xx_edac_match</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * TODO: The row and channel parameters likely need to be dynamically</span>
<span class="cm"> * set based on the aforementioned variant controller realizations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ppc4xx_edac_nr_csrows</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ppc4xx_edac_nr_chans</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Strings associated with PLB master IDs capable of being posted in</span>
<span class="cm"> * SDRAM_BESR or SDRAM_WMIRQ on uncorrectable ECC errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">ppc4xx_plb_masters</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">SDRAM_PLB_M0ID_ICU</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;ICU&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SDRAM_PLB_M0ID_PCIE0</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;PCI-E 0&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SDRAM_PLB_M0ID_PCIE1</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;PCI-E 1&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SDRAM_PLB_M0ID_DMA</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;DMA&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SDRAM_PLB_M0ID_DCU</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;DCU&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SDRAM_PLB_M0ID_OPB</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;OPB&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SDRAM_PLB_M0ID_MAL</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;MAL&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SDRAM_PLB_M0ID_SEC</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;SEC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SDRAM_PLB_M0ID_AHB</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;AHB&quot;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * mfsdram - read and return controller register data</span>
<span class="cm"> * @dcr_host: A pointer to the DCR mapping.</span>
<span class="cm"> * @idcr_n: The indirect DCR register to read.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine reads and returns the data associated with the</span>
<span class="cm"> * controller&#39;s specified indirect DCR register.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the read data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">mfsdram</span><span class="p">(</span><span class="k">const</span> <span class="n">dcr_host_t</span> <span class="o">*</span><span class="n">dcr_host</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idcr_n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__mfdcri</span><span class="p">(</span><span class="n">dcr_host</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">SDRAM_DCR_ADDR_OFFSET</span><span class="p">,</span>
			<span class="n">dcr_host</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">SDRAM_DCR_DATA_OFFSET</span><span class="p">,</span>
			<span class="n">idcr_n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mtsdram - write controller register data</span>
<span class="cm"> * @dcr_host: A pointer to the DCR mapping.</span>
<span class="cm"> * @idcr_n: The indirect DCR register to write.</span>
<span class="cm"> * @value: The data to write.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine writes the provided data to the controller&#39;s specified</span>
<span class="cm"> * indirect DCR register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mtsdram</span><span class="p">(</span><span class="k">const</span> <span class="n">dcr_host_t</span> <span class="o">*</span><span class="n">dcr_host</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idcr_n</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__mtdcri</span><span class="p">(</span><span class="n">dcr_host</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">SDRAM_DCR_ADDR_OFFSET</span><span class="p">,</span>
			<span class="n">dcr_host</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">SDRAM_DCR_DATA_OFFSET</span><span class="p">,</span>
			<span class="n">idcr_n</span><span class="p">,</span>
			<span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_check_bank_error - check a bank for an ECC bank error</span>
<span class="cm"> * @status: A pointer to the ECC status structure to check for an</span>
<span class="cm"> *          ECC bank error.</span>
<span class="cm"> * @bank: The bank to check for an ECC error.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine determines whether the specified bank has an ECC</span>
<span class="cm"> * error.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if the specified bank has an ECC error; otherwise,</span>
<span class="cm"> * false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">ppc4xx_edac_check_bank_error</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bank</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bank</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">return</span> <span class="n">status</span><span class="o">-&gt;</span><span class="n">ecces</span> <span class="o">&amp;</span> <span class="n">SDRAM_ECCES_BK0ER</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">return</span> <span class="n">status</span><span class="o">-&gt;</span><span class="n">ecces</span> <span class="o">&amp;</span> <span class="n">SDRAM_ECCES_BK1ER</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_generate_bank_message - generate interpretted bank status message</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance associated</span>
<span class="cm"> *       with the bank message being generated.</span>
<span class="cm"> * @status: A pointer to the ECC status structure to generate the</span>
<span class="cm"> *          message from.</span>
<span class="cm"> * @buffer: A pointer to the buffer in which to generate the</span>
<span class="cm"> *          message.</span>
<span class="cm"> * @size: The size, in bytes, of space available in buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine generates to the provided buffer the portion of the</span>
<span class="cm"> * driver-unique report message associated with the ECCESS[BKNER]</span>
<span class="cm"> * field of the specified ECC status.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of characters generated on success; otherwise, &lt;</span>
<span class="cm"> * 0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppc4xx_edac_generate_bank_message</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">rows</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s: Banks: &quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">rows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppc4xx_edac_check_bank_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s%u&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">rows</span><span class="o">++</span> <span class="o">?</span> <span class="s">&quot;, &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">),</span> <span class="n">row</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

			<span class="n">buffer</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s; &quot;</span><span class="p">,</span> <span class="n">rows</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;None&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_generate_checkbit_message - generate interpretted checkbit message</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance associated</span>
<span class="cm"> *       with the checkbit message being generated.</span>
<span class="cm"> * @status: A pointer to the ECC status structure to generate the</span>
<span class="cm"> *          message from.</span>
<span class="cm"> * @buffer: A pointer to the buffer in which to generate the</span>
<span class="cm"> *          message.</span>
<span class="cm"> * @size: The size, in bytes, of space available in buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine generates to the provided buffer the portion of the</span>
<span class="cm"> * driver-unique report message associated with the ECCESS[CKBER]</span>
<span class="cm"> * field of the specified ECC status.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of characters generated on success; otherwise, &lt;</span>
<span class="cm"> * 0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppc4xx_edac_generate_checkbit_message</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				      <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_edac_pdata</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ckber</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">ecces</span> <span class="o">&amp;</span> <span class="n">SDRAM_ECCES_CKBER_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SDRAM_ECCES_CKBER_NONE</span>:
		<span class="n">ckber</span> <span class="o">=</span> <span class="s">&quot;None&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SDRAM_ECCES_CKBER_32_ECC_0_3</span>:
		<span class="n">ckber</span> <span class="o">=</span> <span class="s">&quot;ECC0:3&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SDRAM_ECCES_CKBER_32_ECC_4_8</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">mfsdram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_MCOPT1</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">SDRAM_MCOPT1_WDTH_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDRAM_MCOPT1_WDTH_16</span>:
			<span class="n">ckber</span> <span class="o">=</span> <span class="s">&quot;ECC0:3&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SDRAM_MCOPT1_WDTH_32</span>:
			<span class="n">ckber</span> <span class="o">=</span> <span class="s">&quot;ECC4:8&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ckber</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SDRAM_ECCES_CKBER_32_ECC_0_8</span>:
		<span class="n">ckber</span> <span class="o">=</span> <span class="s">&quot;ECC0:8&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ckber</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;Checkbit Error: %s&quot;</span><span class="p">,</span> <span class="n">ckber</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_generate_lane_message - generate interpretted byte lane message</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance associated</span>
<span class="cm"> *       with the byte lane message being generated.</span>
<span class="cm"> * @status: A pointer to the ECC status structure to generate the</span>
<span class="cm"> *          message from.</span>
<span class="cm"> * @buffer: A pointer to the buffer in which to generate the</span>
<span class="cm"> *          message.</span>
<span class="cm"> * @size: The size, in bytes, of space available in buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine generates to the provided buffer the portion of the</span>
<span class="cm"> * driver-unique report message associated with the ECCESS[BNCE]</span>
<span class="cm"> * field of the specified ECC status.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of characters generated on success; otherwise, &lt;</span>
<span class="cm"> * 0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppc4xx_edac_generate_lane_message</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lane</span><span class="p">,</span> <span class="n">lanes</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_lane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lane_count</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;; Byte Lane Errors: &quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">lanes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lane</span> <span class="o">=</span> <span class="n">first_lane</span><span class="p">;</span> <span class="n">lane</span> <span class="o">&lt;</span> <span class="n">lane_count</span><span class="p">;</span> <span class="n">lane</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">ecces</span> <span class="o">&amp;</span> <span class="n">SDRAM_ECCES_BNCE_ENCODE</span><span class="p">(</span><span class="n">lane</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				     <span class="s">&quot;%s%u&quot;</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">lanes</span><span class="o">++</span> <span class="o">?</span> <span class="s">&quot;, &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">),</span> <span class="n">lane</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

			<span class="n">buffer</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s; &quot;</span><span class="p">,</span> <span class="n">lanes</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;None&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_generate_ecc_message - generate interpretted ECC status message</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance associated</span>
<span class="cm"> *       with the ECCES message being generated.</span>
<span class="cm"> * @status: A pointer to the ECC status structure to generate the</span>
<span class="cm"> *          message from.</span>
<span class="cm"> * @buffer: A pointer to the buffer in which to generate the</span>
<span class="cm"> *          message.</span>
<span class="cm"> * @size: The size, in bytes, of space available in buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine generates to the provided buffer the portion of the</span>
<span class="cm"> * driver-unique report message associated with the ECCESS register of</span>
<span class="cm"> * the specified ECC status.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of characters generated on success; otherwise, &lt;</span>
<span class="cm"> * 0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppc4xx_edac_generate_ecc_message</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">ppc4xx_edac_generate_bank_message</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">ppc4xx_edac_generate_checkbit_message</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">ppc4xx_edac_generate_lane_message</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_generate_plb_message - generate interpretted PLB status message</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance associated</span>
<span class="cm"> *       with the PLB message being generated.</span>
<span class="cm"> * @status: A pointer to the ECC status structure to generate the</span>
<span class="cm"> *          message from.</span>
<span class="cm"> * @buffer: A pointer to the buffer in which to generate the</span>
<span class="cm"> *          message.</span>
<span class="cm"> * @size: The size, in bytes, of space available in buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine generates to the provided buffer the portion of the</span>
<span class="cm"> * driver-unique report message associated with the PLB-related BESR</span>
<span class="cm"> * and/or WMIRQ registers of the specified ECC status.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of characters generated on success; otherwise, &lt;</span>
<span class="cm"> * 0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppc4xx_edac_generate_plb_message</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">master</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">read</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">besr</span> <span class="o">&amp;</span> <span class="n">SDRAM_BESR_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">besr</span> <span class="o">&amp;</span> <span class="n">SDRAM_BESR_M0ET_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SDRAM_BESR_M0ET_NONE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read</span> <span class="o">=</span> <span class="p">((</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">besr</span> <span class="o">&amp;</span> <span class="n">SDRAM_BESR_M0RW_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SDRAM_BESR_M0RW_READ</span><span class="p">);</span>

	<span class="n">master</span> <span class="o">=</span> <span class="n">SDRAM_BESR_M0ID_DECODE</span><span class="p">(</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">besr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="s">&quot;%s error w/ PLB master %u </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">; &quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">read</span> <span class="o">?</span> <span class="s">&quot;Read&quot;</span> <span class="o">:</span> <span class="s">&quot;Write&quot;</span><span class="p">),</span>
			<span class="n">master</span><span class="p">,</span>
			<span class="p">(((</span><span class="n">master</span> <span class="o">&gt;=</span> <span class="n">SDRAM_PLB_M0ID_FIRST</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			  <span class="p">(</span><span class="n">master</span> <span class="o">&lt;=</span> <span class="n">SDRAM_PLB_M0ID_LAST</span><span class="p">))</span> <span class="o">?</span>
			 <span class="n">ppc4xx_plb_masters</span><span class="p">[</span><span class="n">master</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_generate_message - generate interpretted status message</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance associated</span>
<span class="cm"> *       with the driver-unique message being generated.</span>
<span class="cm"> * @status: A pointer to the ECC status structure to generate the</span>
<span class="cm"> *          message from.</span>
<span class="cm"> * @buffer: A pointer to the buffer in which to generate the</span>
<span class="cm"> *          message.</span>
<span class="cm"> * @size: The size, in bytes, of space available in buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine generates to the provided buffer the driver-unique</span>
<span class="cm"> * EDAC report message from the specified ECC status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppc4xx_edac_generate_message</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">ppc4xx_edac_generate_ecc_message</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">ppc4xx_edac_generate_plb_message</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cm">/**</span>
<span class="cm"> * ppc4xx_ecc_dump_status - dump controller ECC status registers</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance</span>
<span class="cm"> *       associated with the status being dumped.</span>
<span class="cm"> * @status: A pointer to the ECC status structure to generate the</span>
<span class="cm"> *          dump from.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine dumps to the kernel log buffer the raw and</span>
<span class="cm"> * interpretted specified ECC status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppc4xx_ecc_dump_status</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">PPC4XX_EDAC_MESSAGE_SIZE</span><span class="p">];</span>

	<span class="n">ppc4xx_edac_generate_message</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>

	<span class="n">ppc4xx_edac_mc_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
			      <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;</span><span class="se">\t</span><span class="s">ECCES: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;</span><span class="se">\t</span><span class="s">WMIRQ: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;</span><span class="se">\t</span><span class="s">BESR:  0x%08x</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;</span><span class="se">\t</span><span class="s">BEAR:  0x%08x%08x</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;</span><span class="se">\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">status</span><span class="o">-&gt;</span><span class="n">ecces</span><span class="p">,</span>
			      <span class="n">status</span><span class="o">-&gt;</span><span class="n">wmirq</span><span class="p">,</span>
			      <span class="n">status</span><span class="o">-&gt;</span><span class="n">besr</span><span class="p">,</span>
			      <span class="n">status</span><span class="o">-&gt;</span><span class="n">bearh</span><span class="p">,</span>
			      <span class="n">status</span><span class="o">-&gt;</span><span class="n">bearl</span><span class="p">,</span>
			      <span class="n">message</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_ecc_get_status - get controller ECC status</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance</span>
<span class="cm"> *       associated with the status being retrieved.</span>
<span class="cm"> * @status: A pointer to the ECC status structure to populate the</span>
<span class="cm"> *          ECC status with.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine reads and masks, as appropriate, all the relevant</span>
<span class="cm"> * status registers that deal with ibm,sdram-4xx-ddr2 ECC errors.</span>
<span class="cm"> * While we read all of them, for correctable errors, we only expect</span>
<span class="cm"> * to deal with ECCES. For uncorrectable errors, we expect to deal</span>
<span class="cm"> * with all of them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppc4xx_ecc_get_status</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_edac_pdata</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">dcr_host_t</span> <span class="o">*</span><span class="n">dcr_host</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dcr_host</span><span class="p">;</span>

	<span class="n">status</span><span class="o">-&gt;</span><span class="n">ecces</span> <span class="o">=</span> <span class="n">mfsdram</span><span class="p">(</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_ECCES</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SDRAM_ECCES_MASK</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">wmirq</span> <span class="o">=</span> <span class="n">mfsdram</span><span class="p">(</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_WMIRQ</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SDRAM_WMIRQ_MASK</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">besr</span>  <span class="o">=</span> <span class="n">mfsdram</span><span class="p">(</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_BESR</span><span class="p">)</span>  <span class="o">&amp;</span> <span class="n">SDRAM_BESR_MASK</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">bearl</span> <span class="o">=</span> <span class="n">mfsdram</span><span class="p">(</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_BEARL</span><span class="p">);</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">bearh</span> <span class="o">=</span> <span class="n">mfsdram</span><span class="p">(</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_BEARH</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_ecc_clear_status - clear controller ECC status</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance</span>
<span class="cm"> *       associated with the status being cleared.</span>
<span class="cm"> * @status: A pointer to the ECC status structure containing the</span>
<span class="cm"> *          values to write to clear the ECC status.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine clears--by writing the masked (as appropriate) status</span>
<span class="cm"> * values back to--the status registers that deal with</span>
<span class="cm"> * ibm,sdram-4xx-ddr2 ECC errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppc4xx_ecc_clear_status</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_edac_pdata</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">dcr_host_t</span> <span class="o">*</span><span class="n">dcr_host</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dcr_host</span><span class="p">;</span>

	<span class="n">mtsdram</span><span class="p">(</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_ECCES</span><span class="p">,</span>	<span class="n">status</span><span class="o">-&gt;</span><span class="n">ecces</span> <span class="o">&amp;</span> <span class="n">SDRAM_ECCES_MASK</span><span class="p">);</span>
	<span class="n">mtsdram</span><span class="p">(</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_WMIRQ</span><span class="p">,</span>	<span class="n">status</span><span class="o">-&gt;</span><span class="n">wmirq</span> <span class="o">&amp;</span> <span class="n">SDRAM_WMIRQ_MASK</span><span class="p">);</span>
	<span class="n">mtsdram</span><span class="p">(</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_BESR</span><span class="p">,</span>	<span class="n">status</span><span class="o">-&gt;</span><span class="n">besr</span> <span class="o">&amp;</span> <span class="n">SDRAM_BESR_MASK</span><span class="p">);</span>
	<span class="n">mtsdram</span><span class="p">(</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_BEARL</span><span class="p">,</span>	<span class="mi">0</span><span class="p">);</span>
	<span class="n">mtsdram</span><span class="p">(</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_BEARH</span><span class="p">,</span>	<span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_handle_ce - handle controller correctable ECC error (CE)</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance</span>
<span class="cm"> *       associated with the correctable error being handled and reported.</span>
<span class="cm"> * @status: A pointer to the ECC status structure associated with</span>
<span class="cm"> *          the correctable error being handled and reported.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine handles an ibm,sdram-4xx-ddr2 controller ECC</span>
<span class="cm"> * correctable error. Per the aforementioned discussion, there&#39;s not</span>
<span class="cm"> * enough status available to use the full EDAC correctable error</span>
<span class="cm"> * interface, so we just pass driver-unique message to the &quot;no info&quot;</span>
<span class="cm"> * interface.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppc4xx_edac_handle_ce</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">row</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">PPC4XX_EDAC_MESSAGE_SIZE</span><span class="p">];</span>

	<span class="n">ppc4xx_edac_generate_message</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppc4xx_edac_check_bank_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span>
			<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
					     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					     <span class="n">message</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_handle_ue - handle controller uncorrectable ECC error (UE)</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance</span>
<span class="cm"> *       associated with the uncorrectable error being handled and</span>
<span class="cm"> *       reported.</span>
<span class="cm"> * @status: A pointer to the ECC status structure associated with</span>
<span class="cm"> *          the uncorrectable error being handled and reported.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine handles an ibm,sdram-4xx-ddr2 controller ECC</span>
<span class="cm"> * uncorrectable error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppc4xx_edac_handle_ue</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u64</span> <span class="n">bear</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">bearh</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span> <span class="o">|</span> <span class="n">status</span><span class="o">-&gt;</span><span class="n">bearl</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span> <span class="o">=</span> <span class="n">bear</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">bear</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">row</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">PPC4XX_EDAC_MESSAGE_SIZE</span><span class="p">];</span>

	<span class="n">ppc4xx_edac_generate_message</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppc4xx_edac_check_bank_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span>
			<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_UNCORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
					     <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					     <span class="n">message</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_check - check controller for ECC errors</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance</span>
<span class="cm"> *       associated with the ibm,sdram-4xx-ddr2 controller being</span>
<span class="cm"> *       checked.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to check and post ECC errors and is called by</span>
<span class="cm"> * both the EDAC polling thread and this driver&#39;s CE and UE interrupt</span>
<span class="cm"> * handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppc4xx_edac_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">ppc4xx_ecc_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">ppc4xx_ecc_get_status</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="o">++</span> <span class="o">%</span> <span class="mi">30</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ppc4xx_ecc_dump_status</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ecces</span> <span class="o">&amp;</span> <span class="n">SDRAM_ECCES_UE</span><span class="p">)</span>
		<span class="n">ppc4xx_edac_handle_ue</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ecces</span> <span class="o">&amp;</span> <span class="n">SDRAM_ECCES_CE</span><span class="p">)</span>
		<span class="n">ppc4xx_edac_handle_ce</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>

	<span class="n">ppc4xx_ecc_clear_status</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_isr - SEC (CE) and DED (UE) interrupt service routine</span>
<span class="cm"> * @irq:    The virtual interrupt number being serviced.</span>
<span class="cm"> * @dev_id: A pointer to the EDAC memory controller instance</span>
<span class="cm"> *          associated with the interrupt being handled.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine implements the interrupt handler for both correctable</span>
<span class="cm"> * (CE) and uncorrectable (UE) ECC errors for the ibm,sdram-4xx-ddr2</span>
<span class="cm"> * controller. It simply calls through to the same routine used during</span>
<span class="cm"> * polling to check, report and clear the ECC status.</span>
<span class="cm"> *</span>
<span class="cm"> * Unconditionally returns IRQ_HANDLED.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">ppc4xx_edac_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="n">ppc4xx_edac_check</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_get_dtype - return the controller memory width</span>
<span class="cm"> * @mcopt1: The 32-bit Memory Controller Option 1 register value</span>
<span class="cm"> *          currently set for the controller, from which the width</span>
<span class="cm"> *          is derived.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine returns the EDAC device type width appropriate for the</span>
<span class="cm"> * current controller configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: This needs to be conditioned dynamically through feature</span>
<span class="cm"> * flags or some such when other controller variants are supported as</span>
<span class="cm"> * the 405EX[r] is 16-/32-bit and the others are 32-/64-bit with the</span>
<span class="cm"> * 16- and 64-bit field definition/value/enumeration (b1) overloaded</span>
<span class="cm"> * among them.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a device type width enumeration.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">dev_type</span> <span class="n">__devinit</span>
<span class="nf">ppc4xx_edac_get_dtype</span><span class="p">(</span><span class="n">u32</span> <span class="n">mcopt1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mcopt1</span> <span class="o">&amp;</span> <span class="n">SDRAM_MCOPT1_WDTH_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SDRAM_MCOPT1_WDTH_16</span>:
		<span class="k">return</span> <span class="n">DEV_X2</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SDRAM_MCOPT1_WDTH_32</span>:
		<span class="k">return</span> <span class="n">DEV_X4</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">DEV_UNKNOWN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_get_mtype - return controller memory type</span>
<span class="cm"> * @mcopt1: The 32-bit Memory Controller Option 1 register value</span>
<span class="cm"> *          currently set for the controller, from which the memory type</span>
<span class="cm"> *          is derived.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine returns the EDAC memory type appropriate for the</span>
<span class="cm"> * current controller configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a memory type enumeration.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">mem_type</span> <span class="n">__devinit</span>
<span class="nf">ppc4xx_edac_get_mtype</span><span class="p">(</span><span class="n">u32</span> <span class="n">mcopt1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">rden</span> <span class="o">=</span> <span class="p">((</span><span class="n">mcopt1</span> <span class="o">&amp;</span> <span class="n">SDRAM_MCOPT1_RDEN_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SDRAM_MCOPT1_RDEN</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mcopt1</span> <span class="o">&amp;</span> <span class="n">SDRAM_MCOPT1_DDR_TYPE_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SDRAM_MCOPT1_DDR2_TYPE</span>:
		<span class="k">return</span> <span class="n">rden</span> <span class="o">?</span> <span class="n">MEM_RDDR2</span> <span class="o">:</span> <span class="n">MEM_DDR2</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SDRAM_MCOPT1_DDR1_TYPE</span>:
		<span class="k">return</span> <span class="n">rden</span> <span class="o">?</span> <span class="n">MEM_RDDR</span> <span class="o">:</span> <span class="n">MEM_DDR</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">MEM_UNKNOWN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_init_csrows - initialize driver instance rows</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance</span>
<span class="cm"> *       associated with the ibm,sdram-4xx-ddr2 controller for which</span>
<span class="cm"> *       the csrows (i.e. banks/ranks) are being initialized.</span>
<span class="cm"> * @mcopt1: The 32-bit Memory Controller Option 1 register value</span>
<span class="cm"> *          currently set for the controller, from which bank width</span>
<span class="cm"> *          and memory typ information is derived.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine initializes the virtual &quot;chip select rows&quot; associated</span>
<span class="cm"> * with the EDAC memory controller instance. An ibm,sdram-4xx-ddr2</span>
<span class="cm"> * controller bank/rank is mapped to a row.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if OK; otherwise, -EINVAL if the memory bank size</span>
<span class="cm"> * configuration cannot be determined.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">ppc4xx_edac_init_csrows</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mcopt1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ppc4xx_edac_pdata</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mem_type</span> <span class="n">mtype</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dev_type</span> <span class="n">dtype</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">edac_type</span> <span class="n">edac_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mbxcf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="cm">/* Establish the memory type and width */</span>

	<span class="n">mtype</span> <span class="o">=</span> <span class="n">ppc4xx_edac_get_mtype</span><span class="p">(</span><span class="n">mcopt1</span><span class="p">);</span>
	<span class="n">dtype</span> <span class="o">=</span> <span class="n">ppc4xx_edac_get_dtype</span><span class="p">(</span><span class="n">mcopt1</span><span class="p">);</span>

	<span class="cm">/* Establish EDAC mode */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span> <span class="o">&amp;</span> <span class="n">EDAC_FLAG_SECDED</span><span class="p">)</span>
		<span class="n">edac_mode</span> <span class="o">=</span> <span class="n">EDAC_SECDED</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span> <span class="o">&amp;</span> <span class="n">EDAC_FLAG_EC</span><span class="p">)</span>
		<span class="n">edac_mode</span> <span class="o">=</span> <span class="n">EDAC_EC</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">edac_mode</span> <span class="o">=</span> <span class="n">EDAC_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize each chip select row structure which correspond</span>
<span class="cm">	 * 1:1 with a controller bank/rank.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get the configuration settings for this</span>
<span class="cm">		 * row/bank/rank and skip disabled banks.</span>
<span class="cm">		 */</span>

		<span class="n">mbxcf</span> <span class="o">=</span> <span class="n">mfsdram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_MBXCF</span><span class="p">(</span><span class="n">row</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mbxcf</span> <span class="o">&amp;</span> <span class="n">SDRAM_MBCF_BE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SDRAM_MBCF_BE_ENABLE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Map the bank configuration size setting to pages. */</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">mbxcf</span> <span class="o">&amp;</span> <span class="n">SDRAM_MBCF_SZ_MASK</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_4MB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_8MB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_16MB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_32MB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_64MB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_128MB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_256MB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_512MB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_1GB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_2GB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_4GB</span>:
		<span class="k">case</span> <span class="n">SDRAM_MBCF_SZ_8GB</span>:
			<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">SDRAM_MBCF_SZ_TO_PAGES</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ppc4xx_edac_mc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
					      <span class="s">&quot;Unrecognized memory bank %d &quot;</span>
					      <span class="s">&quot;size 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					      <span class="n">row</span><span class="p">,</span> <span class="n">SDRAM_MBCF_SZ_DECODE</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s unclear exactly what grain should be set to</span>
<span class="cm">		 * here. The SDRAM_ECCES register allows resolution of</span>
<span class="cm">		 * an error down to a nibble which would potentially</span>
<span class="cm">		 * argue for a grain of &#39;1&#39; byte, even though we only</span>
<span class="cm">		 * know the associated address for uncorrectable</span>
<span class="cm">		 * errors. This value is not used at present for</span>
<span class="cm">		 * anything other than error reporting so getting it</span>
<span class="cm">		 * wrong should be of little consequence. Other</span>
<span class="cm">		 * possible values would be the PLB width (16), the</span>
<span class="cm">		 * page size (PAGE_SIZE) or the memory width (2 or 4).</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">csi</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span> <span class="o">=</span> <span class="n">csi</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dimm</span><span class="p">;</span>

			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span>  <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">/</span> <span class="n">csi</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">;</span>
			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">grain</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">mtype</span>	<span class="o">=</span> <span class="n">mtype</span><span class="p">;</span>
			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">dtype</span>	<span class="o">=</span> <span class="n">dtype</span><span class="p">;</span>

			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">edac_mode</span>	<span class="o">=</span> <span class="n">edac_mode</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">done:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_mc_init - initialize driver instance</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance being</span>
<span class="cm"> *       initialized.</span>
<span class="cm"> * @op: A pointer to the OpenFirmware device tree node associated</span>
<span class="cm"> *      with the controller this EDAC instance is bound to.</span>
<span class="cm"> * @dcr_host: A pointer to the DCR data containing the DCR mapping</span>
<span class="cm"> *            for this controller instance.</span>
<span class="cm"> * @mcopt1: The 32-bit Memory Controller Option 1 register value</span>
<span class="cm"> *          currently set for the controller, from which ECC capabilities</span>
<span class="cm"> *          and scrub mode are derived.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine performs initialization of the EDAC memory controller</span>
<span class="cm"> * instance and related driver-private data associated with the</span>
<span class="cm"> * ibm,sdram-4xx-ddr2 memory controller the instance is bound to.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if OK; otherwise, &lt; 0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">ppc4xx_edac_mc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
		    <span class="k">const</span> <span class="n">dcr_host_t</span> <span class="o">*</span><span class="n">dcr_host</span><span class="p">,</span>
		    <span class="n">u32</span> <span class="n">mcopt1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">memcheck</span> <span class="o">=</span> <span class="p">(</span><span class="n">mcopt1</span> <span class="o">&amp;</span> <span class="n">SDRAM_MCOPT1_MCHK_MASK</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ppc4xx_edac_pdata</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">of_match_device</span><span class="p">(</span><span class="n">ppc4xx_edac_match</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Initial driver pointers and private data */</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mci</span><span class="p">);</span>

	<span class="n">pdata</span>			<span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dcr_host</span>		<span class="o">=</span> <span class="o">*</span><span class="n">dcr_host</span><span class="p">;</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">.</span><span class="n">sec</span>		<span class="o">=</span> <span class="n">NO_IRQ</span><span class="p">;</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">.</span><span class="n">ded</span>		<span class="o">=</span> <span class="n">NO_IRQ</span><span class="p">;</span>

	<span class="cm">/* Initialize controller capabilities and configuration */</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mtype_cap</span>		<span class="o">=</span> <span class="p">(</span><span class="n">MEM_FLAG_DDR</span> <span class="o">|</span> <span class="n">MEM_FLAG_RDDR</span> <span class="o">|</span>
				   <span class="n">MEM_FLAG_DDR2</span> <span class="o">|</span> <span class="n">MEM_FLAG_RDDR2</span><span class="p">);</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_ctl_cap</span>	<span class="o">=</span> <span class="p">(</span><span class="n">EDAC_FLAG_NONE</span> <span class="o">|</span>
				   <span class="n">EDAC_FLAG_EC</span> <span class="o">|</span>
				   <span class="n">EDAC_FLAG_SECDED</span><span class="p">);</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">scrub_cap</span>		<span class="o">=</span> <span class="n">SCRUB_NONE</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">scrub_mode</span>		<span class="o">=</span> <span class="n">SCRUB_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the actual capabilites based on the MCOPT1[MCHK]</span>
<span class="cm">	 * settings. Scrubbing is only useful if reporting is enabled.</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">memcheck</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SDRAM_MCOPT1_MCHK_CHK</span>:
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span>	<span class="o">=</span> <span class="n">EDAC_FLAG_EC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SDRAM_MCOPT1_MCHK_CHK_REP</span>:
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span>	<span class="o">=</span> <span class="p">(</span><span class="n">EDAC_FLAG_EC</span> <span class="o">|</span> <span class="n">EDAC_FLAG_SECDED</span><span class="p">);</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">scrub_mode</span>	<span class="o">=</span> <span class="n">SCRUB_SW_SRC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span>	<span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize strings */</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_name</span>		<span class="o">=</span> <span class="n">PPC4XX_EDAC_MODULE_NAME</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_ver</span>		<span class="o">=</span> <span class="n">PPC4XX_EDAC_MODULE_REVISION</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span>		<span class="o">=</span> <span class="n">ppc4xx_edac_match</span><span class="o">-&gt;</span><span class="n">compatible</span><span class="p">,</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev_name</span>		<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">;</span>

	<span class="cm">/* Initialize callbacks */</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_check</span>		<span class="o">=</span> <span class="n">ppc4xx_edac_check</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_page_to_phys</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Initialize chip select rows */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ppc4xx_edac_init_csrows</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">mcopt1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">ppc4xx_edac_mc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				      <span class="s">&quot;Failed to initialize rows!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_register_irq - setup and register controller interrupts</span>
<span class="cm"> * @op: A pointer to the OpenFirmware device tree node associated</span>
<span class="cm"> *      with the controller this EDAC instance is bound to.</span>
<span class="cm"> * @mci: A pointer to the EDAC memory controller instance</span>
<span class="cm"> *       associated with the ibm,sdram-4xx-ddr2 controller for which</span>
<span class="cm"> *       interrupts are being registered.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine parses the correctable (CE) and uncorrectable error (UE)</span>
<span class="cm"> * interrupts from the device tree node and maps and assigns them to</span>
<span class="cm"> * the associated EDAC memory controller instance.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if OK; otherwise, -ENODEV if the interrupts could not be</span>
<span class="cm"> * mapped and assigned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">ppc4xx_edac_register_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ded_irq</span><span class="p">,</span> <span class="n">sec_irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ppc4xx_edac_pdata</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>

	<span class="n">ded_irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">INTMAP_ECCDED_INDEX</span><span class="p">);</span>
	<span class="n">sec_irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">INTMAP_ECCSEC_INDEX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ded_irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span> <span class="o">||</span> <span class="n">sec_irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_mc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				      <span class="s">&quot;Unable to map interrupts.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">ded_irq</span><span class="p">,</span>
			     <span class="n">ppc4xx_edac_isr</span><span class="p">,</span>
			     <span class="n">IRQF_DISABLED</span><span class="p">,</span>
			     <span class="s">&quot;[EDAC] MC ECCDED&quot;</span><span class="p">,</span>
			     <span class="n">mci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_mc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				      <span class="s">&quot;Unable to request irq %d for ECC DED&quot;</span><span class="p">,</span>
				      <span class="n">ded_irq</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">sec_irq</span><span class="p">,</span>
			     <span class="n">ppc4xx_edac_isr</span><span class="p">,</span>
			     <span class="n">IRQF_DISABLED</span><span class="p">,</span>
			     <span class="s">&quot;[EDAC] MC ECCSEC&quot;</span><span class="p">,</span>
			     <span class="n">mci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_mc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				      <span class="s">&quot;Unable to request irq %d for ECC SEC&quot;</span><span class="p">,</span>
				      <span class="n">sec_irq</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ppc4xx_edac_mc_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="s">&quot;ECCDED irq is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ded_irq</span><span class="p">);</span>
	<span class="n">ppc4xx_edac_mc_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="s">&quot;ECCSEC irq is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sec_irq</span><span class="p">);</span>

	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">.</span><span class="n">ded</span> <span class="o">=</span> <span class="n">ded_irq</span><span class="p">;</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">.</span><span class="n">sec</span> <span class="o">=</span> <span class="n">sec_irq</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail2:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">sec_irq</span><span class="p">,</span> <span class="n">mci</span><span class="p">);</span>

 <span class="nl">fail1:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">ded_irq</span><span class="p">,</span> <span class="n">mci</span><span class="p">);</span>

 <span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_map_dcrs - locate and map controller registers</span>
<span class="cm"> * @np: A pointer to the device tree node containing the DCR</span>
<span class="cm"> *      resources to map.</span>
<span class="cm"> * @dcr_host: A pointer to the DCR data to populate with the</span>
<span class="cm"> *            DCR mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine attempts to locate in the device tree and map the DCR</span>
<span class="cm"> * register resources associated with the controller&#39;s indirect DCR</span>
<span class="cm"> * address and data windows.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the DCRs were successfully mapped; otherwise, &lt; 0 on</span>
<span class="cm"> * error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">ppc4xx_edac_map_dcrs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">dcr_host_t</span> <span class="o">*</span><span class="n">dcr_host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dcr_base</span><span class="p">,</span> <span class="n">dcr_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">dcr_host</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Get the DCR resource extent and sanity check the values. */</span>

	<span class="n">dcr_base</span> <span class="o">=</span> <span class="n">dcr_resource_start</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dcr_len</span> <span class="o">=</span> <span class="n">dcr_resource_len</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dcr_base</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">dcr_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
				   <span class="s">&quot;Failed to obtain DCR property.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dcr_len</span> <span class="o">!=</span> <span class="n">SDRAM_DCR_RESOURCE_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
				   <span class="s">&quot;Unexpected DCR length %d, expected %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dcr_len</span><span class="p">,</span> <span class="n">SDRAM_DCR_RESOURCE_LEN</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  Attempt to map the DCR extent. */</span>

	<span class="o">*</span><span class="n">dcr_host</span> <span class="o">=</span> <span class="n">dcr_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dcr_base</span><span class="p">,</span> <span class="n">dcr_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DCR_MAP_OK</span><span class="p">(</span><span class="o">*</span><span class="n">dcr_host</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;Failed to map DCRs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		    <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_probe - check controller and bind driver</span>
<span class="cm"> * @op: A pointer to the OpenFirmware device tree node associated</span>
<span class="cm"> *      with the controller being probed for driver binding.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine probes a specific ibm,sdram-4xx-ddr2 controller</span>
<span class="cm"> * instance for binding with the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the controller instance was successfully bound to the</span>
<span class="cm"> * driver; otherwise, &lt; 0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ppc4xx_edac_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcopt1</span><span class="p">,</span> <span class="n">memcheck</span><span class="p">;</span>
	<span class="n">dcr_host_t</span> <span class="n">dcr_host</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="n">layers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">ppc4xx_edac_instance</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, we only support the controller realized on</span>
<span class="cm">	 * the AMCC PPC 405EX[r]. Reject anything else.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;ibm,sdram-405ex&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;ibm,sdram-405exr&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span>
				   <span class="s">&quot;Only the PPC405EX[r] is supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Next, get the DCR property and attempt to map it so that we</span>
<span class="cm">	 * can probe the controller.</span>
<span class="cm">	 */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ppc4xx_edac_map_dcrs</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dcr_host</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First determine whether ECC is enabled at all. If not,</span>
<span class="cm">	 * there is no useful checking or monitoring that can be done</span>
<span class="cm">	 * for this controller.</span>
<span class="cm">	 */</span>

	<span class="n">mcopt1</span> <span class="o">=</span> <span class="n">mfsdram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_MCOPT1</span><span class="p">);</span>
	<span class="n">memcheck</span> <span class="o">=</span> <span class="p">(</span><span class="n">mcopt1</span> <span class="o">&amp;</span> <span class="n">SDRAM_MCOPT1_MCHK_MASK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcheck</span> <span class="o">==</span> <span class="n">SDRAM_MCOPT1_MCHK_NON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;%s: No ECC memory detected or &quot;</span>
				   <span class="s">&quot;ECC is disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, we know ECC is enabled, allocate an EDAC</span>
<span class="cm">	 * controller instance and perform the appropriate</span>
<span class="cm">	 * initialization.</span>
<span class="cm">	 */</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_CHIP_SELECT</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">ppc4xx_edac_nr_csrows</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_CHANNEL</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">ppc4xx_edac_nr_chans</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">edac_mc_alloc</span><span class="p">(</span><span class="n">ppc4xx_edac_instance</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">layers</span><span class="p">),</span> <span class="n">layers</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ppc4xx_edac_pdata</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;%s: &quot;</span>
				   <span class="s">&quot;Failed to allocate EDAC MC instance!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ppc4xx_edac_mc_init</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">mcopt1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_mc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				      <span class="s">&quot;Failed to initialize instance!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have a valid, initialized EDAC instance bound to the</span>
<span class="cm">	 * controller. Attempt to register it with the EDAC subsystem</span>
<span class="cm">	 * and, if necessary, register interrupts.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_mc_add_mc</span><span class="p">(</span><span class="n">mci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ppc4xx_edac_mc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span>
				      <span class="s">&quot;Failed to add instance!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_op_state</span> <span class="o">==</span> <span class="n">EDAC_OPSTATE_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ppc4xx_edac_register_irq</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">mci</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ppc4xx_edac_instance</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail1:</span>
	<span class="n">edac_mc_del_mc</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

 <span class="nl">fail:</span>
	<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

 <span class="nl">done:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_remove - unbind driver from controller</span>
<span class="cm"> * @op: A pointer to the OpenFirmware device tree node associated</span>
<span class="cm"> *      with the controller this EDAC instance is to be unbound/removed</span>
<span class="cm"> *      from.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine unbinds the EDAC memory controller instance associated</span>
<span class="cm"> * with the specified ibm,sdram-4xx-ddr2 controller described by the</span>
<span class="cm"> * OpenFirmware device tree node passed as a parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * Unconditionally returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppc4xx_edac_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ppc4xx_edac_pdata</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edac_op_state</span> <span class="o">==</span> <span class="n">EDAC_OPSTATE_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">.</span><span class="n">sec</span><span class="p">,</span> <span class="n">mci</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">.</span><span class="n">ded</span><span class="p">,</span> <span class="n">mci</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dcr_unmap</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dcr_host</span><span class="p">,</span> <span class="n">SDRAM_DCR_RESOURCE_LEN</span><span class="p">);</span>

	<span class="n">edac_mc_del_mc</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_opstate_init - initialize EDAC reporting method</span>
<span class="cm"> *</span>
<span class="cm"> * This routine ensures that the EDAC memory controller reporting</span>
<span class="cm"> * method is mapped to a sane value as the EDAC core defines the value</span>
<span class="cm"> * to EDAC_OPSTATE_INVAL by default. We don&#39;t call the global</span>
<span class="cm"> * opstate_init as that defaults to polling and we want interrupt as</span>
<span class="cm"> * the default.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ppc4xx_edac_opstate_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">edac_op_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EDAC_OPSTATE_POLL</span>:
	<span class="k">case</span> <span class="n">EDAC_OPSTATE_INT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">edac_op_state</span> <span class="o">=</span> <span class="n">EDAC_OPSTATE_INT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ppc4xx_edac_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;Reporting type: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="p">((</span><span class="n">edac_op_state</span> <span class="o">==</span> <span class="n">EDAC_OPSTATE_POLL</span><span class="p">)</span> <span class="o">?</span>
			    <span class="n">EDAC_OPSTATE_POLL_STR</span> <span class="o">:</span>
			    <span class="p">((</span><span class="n">edac_op_state</span> <span class="o">==</span> <span class="n">EDAC_OPSTATE_INT</span><span class="p">)</span> <span class="o">?</span>
			     <span class="n">EDAC_OPSTATE_INT_STR</span> <span class="o">:</span>
			     <span class="n">EDAC_OPSTATE_UNKNOWN_STR</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_init - driver/module insertion entry point</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the driver/module insertion entry point. It</span>
<span class="cm"> * initializes the EDAC memory controller reporting state and</span>
<span class="cm"> * registers the driver as an OpenFirmware device tree platform</span>
<span class="cm"> * driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">ppc4xx_edac_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ppc4xx_edac_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">PPC4XX_EDAC_MODULE_REVISION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ppc4xx_edac_opstate_init</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppc4xx_edac_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ppc4xx_edac_exit - driver/module removal entry point</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the driver/module removal entry point. It</span>
<span class="cm"> * unregisters the driver as an OpenFirmware device tree platform</span>
<span class="cm"> * driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span>
<span class="nf">ppc4xx_edac_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppc4xx_edac_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ppc4xx_edac_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ppc4xx_edac_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Grant Erickson &lt;gerickson@nuovations.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;EDAC MC Driver for the PPC4xx IBM DDR2 Memory Controller&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">edac_op_state</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edac_op_state</span><span class="p">,</span> <span class="s">&quot;EDAC Error Reporting State: &quot;</span>
		 <span class="s">&quot;0=&quot;</span> <span class="n">EDAC_OPSTATE_POLL_STR</span> <span class="s">&quot;, 2=&quot;</span> <span class="n">EDAC_OPSTATE_INT_STR</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
