<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › edac › edac_mc_sysfs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>edac_mc_sysfs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * edac_mc kernel module</span>
<span class="cm"> * (C) 2005-2007 Linux Networx (http://lnxi.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This file may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License.</span>
<span class="cm"> *</span>
<span class="cm"> * Written Doug Thompson &lt;norsk5@xmission.com&gt; www.softwarebitmaker.com</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/edac.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>

<span class="cp">#include &quot;edac_core.h&quot;</span>
<span class="cp">#include &quot;edac_module.h&quot;</span>


<span class="cm">/* MC EDAC Controls, setable by module parameter, and sysfs */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">edac_mc_log_ue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">edac_mc_log_ce</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">edac_mc_panic_on_ue</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">edac_mc_poll_msec</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

<span class="cm">/* Getter functions for above */</span>
<span class="kt">int</span> <span class="nf">edac_mc_get_log_ue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edac_mc_log_ue</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">edac_mc_get_log_ce</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edac_mc_log_ce</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">edac_mc_get_panic_on_ue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edac_mc_panic_on_ue</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* this is temporary */</span>
<span class="kt">int</span> <span class="nf">edac_mc_get_poll_msec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edac_mc_poll_msec</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_set_poll_msec</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">l</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">strict_strtol</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">||</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">l</span> <span class="o">!=</span> <span class="n">l</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">)</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>

	<span class="cm">/* notify edac_mc engine to reset the poll period */</span>
	<span class="n">edac_mc_reset_delay_period</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Parameter declarations for above */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">edac_mc_panic_on_ue</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edac_mc_panic_on_ue</span><span class="p">,</span> <span class="s">&quot;Panic on uncorrected error: 0=off 1=on&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">edac_mc_log_ue</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edac_mc_log_ue</span><span class="p">,</span>
		 <span class="s">&quot;Log uncorrectable error to console: 0=off 1=on&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">edac_mc_log_ce</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edac_mc_log_ce</span><span class="p">,</span>
		 <span class="s">&quot;Log correctable error to console: 0=off 1=on&quot;</span><span class="p">);</span>
<span class="n">module_param_call</span><span class="p">(</span><span class="n">edac_mc_poll_msec</span><span class="p">,</span> <span class="n">edac_set_poll_msec</span><span class="p">,</span> <span class="n">param_get_int</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">edac_mc_poll_msec</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edac_mc_poll_msec</span><span class="p">,</span> <span class="s">&quot;Polling period in milliseconds&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * various constants for Memory Controllers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">MEM_EMPTY</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Empty&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_RESERVED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Reserved&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_UNKNOWN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_FPM</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FPM&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_EDO</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;EDO&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_BEDO</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;BEDO&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_SDR</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Unbuffered-SDR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_RDR</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Registered-SDR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_DDR</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Unbuffered-DDR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_RDDR</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Registered-DDR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_RMBS</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;RMBS&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_DDR2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Unbuffered-DDR2&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_FB_DDR2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FullyBuffered-DDR2&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_RDDR2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Registered-DDR2&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_XDR</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;XDR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_DDR3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Unbuffered-DDR3&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MEM_RDDR3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Registered-DDR3&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">DEV_UNKNOWN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DEV_X1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;x1&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DEV_X2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;x2&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DEV_X4</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;x4&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DEV_X8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;x8&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DEV_X16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;x16&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DEV_X32</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;x32&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DEV_X64</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;x64&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">edac_caps</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">EDAC_UNKNOWN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_NONE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;None&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_RESERVED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Reserved&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_PARITY</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PARITY&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_EC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;EC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_SECDED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;SECDED&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_S2ECD2ED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;S2ECD2ED&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_S4ECD4ED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;S4ECD4ED&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_S8ECD8ED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;S8ECD8ED&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EDAC_S16ECD16ED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;S16ECD16ED&quot;</span>
<span class="p">};</span>

<span class="cm">/* EDAC sysfs CSROW data structures and methods</span>
<span class="cm"> */</span>

<span class="cm">/* Set of more default csrow&lt;id&gt; attribute show/store functions */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">csrow_ue_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">ue_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">csrow_ce_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">ce_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">csrow_size_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PAGES_TO_MiB</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">csrow_mem_type_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_types</span><span class="p">[</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">mtype</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">csrow_dev_type_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_types</span><span class="p">[</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">dtype</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">csrow_edac_mode_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">edac_caps</span><span class="p">[</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">edac_mode</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* show/store functions for DIMM Label attributes */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">channel_dimm_label_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* if field has not been initialized, there is nothing to send */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">EDAC_MC_LABEL_LEN</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">channel_dimm_label_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">max_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">ssize_t</span><span class="p">)</span> <span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span> <span class="n">EDAC_MC_LABEL_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
	<span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">[</span><span class="n">max_size</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">max_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* show function for dynamic chX_ce_count attribute */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">channel_ce_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">ce_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* csrow specific attribute structure */</span>
<span class="k">struct</span> <span class="n">csrowdev_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	 <span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	 <span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">private</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define to_csrow(k) container_of(k, struct csrow_info, kobj)</span>
<span class="cp">#define to_csrowdev_attr(a) container_of(a, struct csrowdev_attribute, attr)</span>

<span class="cm">/* Set of show/store higher level functions for default csrow attributes */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">csrowdev_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span> <span class="o">=</span> <span class="n">to_csrow</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">csrowdev_attribute</span> <span class="o">*</span><span class="n">csrowdev_attr</span> <span class="o">=</span> <span class="n">to_csrowdev_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">csrowdev_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">csrowdev_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">csrow</span><span class="p">,</span>
					<span class="n">buffer</span><span class="p">,</span> <span class="n">csrowdev_attr</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">csrowdev_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span> <span class="o">=</span> <span class="n">to_csrow</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">csrowdev_attribute</span> <span class="o">*</span><span class="n">csrowdev_attr</span> <span class="o">=</span> <span class="n">to_csrowdev_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">csrowdev_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">csrowdev_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">csrow</span><span class="p">,</span>
					<span class="n">buffer</span><span class="p">,</span>
					<span class="n">count</span><span class="p">,</span> <span class="n">csrowdev_attr</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">csrowfs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">csrowdev_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">csrowdev_store</span>
<span class="p">};</span>

<span class="cp">#define CSROWDEV_ATTR(_name,_mode,_show,_store,_private)	\</span>
<span class="cp">static struct csrowdev_attribute attr_##_name = {			\</span>
<span class="cp">	.attr = {.name = __stringify(_name), .mode = _mode },	\</span>
<span class="cp">	.show   = _show,					\</span>
<span class="cp">	.store  = _store,					\</span>
<span class="cp">	.private = _private,					\</span>
<span class="cp">};</span>

<span class="cm">/* default cwrow&lt;id&gt;/attribute files */</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">size_mb</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">csrow_size_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">dev_type</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">csrow_dev_type_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">mem_type</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">csrow_mem_type_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">edac_mode</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">csrow_edac_mode_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ue_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">csrow_ue_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ce_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">csrow_ce_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* default attributes of the CSROW&lt;id&gt; object */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">csrowdev_attribute</span> <span class="o">*</span><span class="n">default_csrow_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">attr_dev_type</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_mem_type</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_edac_mode</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_size_mb</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ue_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ce_count</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* possible dynamic channel DIMM Label attribute files */</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch0_dimm_label</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">channel_dimm_label_show</span><span class="p">,</span> <span class="n">channel_dimm_label_store</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch1_dimm_label</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">channel_dimm_label_show</span><span class="p">,</span> <span class="n">channel_dimm_label_store</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch2_dimm_label</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">channel_dimm_label_show</span><span class="p">,</span> <span class="n">channel_dimm_label_store</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch3_dimm_label</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">channel_dimm_label_show</span><span class="p">,</span> <span class="n">channel_dimm_label_store</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch4_dimm_label</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">channel_dimm_label_show</span><span class="p">,</span> <span class="n">channel_dimm_label_store</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch5_dimm_label</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">channel_dimm_label_show</span><span class="p">,</span> <span class="n">channel_dimm_label_store</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

<span class="cm">/* Total possible dynamic DIMM Label attribute file table */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">csrowdev_attribute</span> <span class="o">*</span><span class="n">dynamic_csrow_dimm_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">attr_ch0_dimm_label</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ch1_dimm_label</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ch2_dimm_label</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ch3_dimm_label</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ch4_dimm_label</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ch5_dimm_label</span>
<span class="p">};</span>

<span class="cm">/* possible dynamic channel ce_count attribute files */</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch0_ce_count</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">channel_ce_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch1_ce_count</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">channel_ce_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch2_ce_count</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">channel_ce_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch3_ce_count</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">channel_ce_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch4_ce_count</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">channel_ce_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">CSROWDEV_ATTR</span><span class="p">(</span><span class="n">ch5_ce_count</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">channel_ce_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

<span class="cm">/* Total possible dynamic ce_count attribute file table */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">csrowdev_attribute</span> <span class="o">*</span><span class="n">dynamic_csrow_ce_count_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">attr_ch0_ce_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ch1_ce_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ch2_ce_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ch3_ce_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ch4_ce_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ch5_ce_count</span>
<span class="p">};</span>

<span class="cp">#define EDAC_NR_CHANNELS	6</span>

<span class="cm">/* Create dynamic CHANNEL files, indexed by &#39;chan&#39;,  under specifed CSROW */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_create_channel_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&gt;=</span> <span class="n">EDAC_NR_CHANNELS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* create the DIMM label attribute file */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">dynamic_csrow_dimm_attr</span><span class="p">[</span><span class="n">chan</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* create the CE Count attribute file */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="p">)</span>
					<span class="n">dynamic_csrow_ce_count_attr</span><span class="p">[</span><span class="n">chan</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()  dimm labels and ce_count files created&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* No memory to release for this kobj */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_csrow_instance_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">cs</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">csrow_info</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mci</span><span class="p">;</span>

	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* the kobj_type instance for a CSROW */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">ktype_csrow</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">edac_csrow_instance_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">csrowfs_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">default_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">**</span><span class="p">)</span><span class="n">default_csrow_attr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Create a CSROW object under specifed edac_mc_device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_create_csrow_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj_mci</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* generate ..../edac/mc/mc&lt;id&gt;/csrow&lt;index&gt;   */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">));</span>
	<span class="n">csrow</span><span class="o">-&gt;</span><span class="n">mci</span> <span class="o">=</span> <span class="n">mci</span><span class="p">;</span>	<span class="cm">/* include container up link */</span>

	<span class="cm">/* bump the mci instance&#39;s kobject&#39;s ref count */</span>
	<span class="n">kobj</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Instanstiate the csrow object */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktype_csrow</span><span class="p">,</span> <span class="n">kobj_mci</span><span class="p">,</span>
				   <span class="s">&quot;csrow%d&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_release_top_kobj</span><span class="p">;</span>

	<span class="cm">/* At this point, to release a csrow kobj, one must</span>
<span class="cm">	 * call the kobject_put and allow that tear down</span>
<span class="cm">	 * to work the releasing</span>
<span class="cm">	 */</span>

	<span class="cm">/* Create the dyanmic attribute files on this csrow,</span>
<span class="cm">	 * namely, the DIMM labels and the channel ce_count</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">;</span> <span class="n">chan</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">edac_create_channel_files</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* special case the unregister here */</span>
			<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csrow</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* error unwind stack */</span>
<span class="nl">err_release_top_kobj:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">);</span>

<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* default sysfs methods and data structures for the main MCI kobject */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mci_reset_counters_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">chan</span><span class="p">;</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ue_noinfo_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ce_noinfo_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ue_mc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ce_mc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">ri</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>

		<span class="n">ri</span><span class="o">-&gt;</span><span class="n">ue_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ri</span><span class="o">-&gt;</span><span class="n">ce_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">ri</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">;</span> <span class="n">chan</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ri</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">].</span><span class="n">ce_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Memory scrubbing interface:</span>
<span class="cm"> *</span>
<span class="cm"> * A MC driver can limit the scrubbing bandwidth based on the CPU type.</span>
<span class="cm"> * Therefore, -&gt;set_sdram_scrub_rate should be made to return the actual</span>
<span class="cm"> * bandwidth that is accepted or 0 when scrubbing is to be disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Negative value still means that an error has occurred while setting</span>
<span class="cm"> * the scrub rate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mci_sdram_scrub_rate_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bandwidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_bw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">set_sdram_scrub_rate</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtoul</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bandwidth</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">new_bw</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">set_sdram_scrub_rate</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_bw</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">EDAC_MC</span><span class="p">,</span>
			    <span class="s">&quot;Error setting scrub rate to: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * -&gt;get_sdram_scrub_rate() return value semantics same as above.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mci_sdram_scrub_rate_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bandwidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">get_sdram_scrub_rate</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">bandwidth</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">get_sdram_scrub_rate</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bandwidth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edac_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">EDAC_MC</span><span class="p">,</span> <span class="s">&quot;Error reading scrub rate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">bandwidth</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* default attribute files for the MCI object */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mci_ue_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">ue_mc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mci_ce_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">ce_mc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mci_ce_noinfo_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">ce_noinfo_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mci_ue_noinfo_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">ue_noinfo_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mci_seconds_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mci_ctl_name_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mci_size_mb_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">total_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">csrow_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">csrow_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">csrow_idx</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">;</span> <span class="n">csrow_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">csrow_idx</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span> <span class="o">=</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dimm</span><span class="p">;</span>

			<span class="n">total_pages</span> <span class="o">+=</span> <span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PAGES_TO_MiB</span><span class="p">(</span><span class="n">total_pages</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define to_mci(k) container_of(k, struct mem_ctl_info, edac_mci_kobj)</span>
<span class="cp">#define to_mcidev_attr(a) container_of(a,struct mcidev_sysfs_attribute,attr)</span>

<span class="cm">/* MCI show/store functions for top most object */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mcidev_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mem_ctl_info</span> <span class="o">=</span> <span class="n">to_mci</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="o">*</span><span class="n">mcidev_attr</span> <span class="o">=</span> <span class="n">to_mcidev_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() mem_ctl_info %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">mem_ctl_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcidev_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mcidev_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">mem_ctl_info</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mcidev_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mem_ctl_info</span> <span class="o">=</span> <span class="n">to_mci</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="o">*</span><span class="n">mcidev_attr</span> <span class="o">=</span> <span class="n">to_mcidev_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() mem_ctl_info %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">mem_ctl_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcidev_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mcidev_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">mem_ctl_info</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Intermediate show/store table */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">mci_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">mcidev_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">mcidev_store</span>
<span class="p">};</span>

<span class="cp">#define MCIDEV_ATTR(_name,_mode,_show,_store)			\</span>
<span class="cp">static struct mcidev_sysfs_attribute mci_attr_##_name = {			\</span>
<span class="cp">	.attr = {.name = __stringify(_name), .mode = _mode },	\</span>
<span class="cp">	.show   = _show,					\</span>
<span class="cp">	.store  = _store,					\</span>
<span class="cp">};</span>

<span class="cm">/* default Control file */</span>
<span class="n">MCIDEV_ATTR</span><span class="p">(</span><span class="n">reset_counters</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mci_reset_counters_store</span><span class="p">);</span>

<span class="cm">/* default Attribute files */</span>
<span class="n">MCIDEV_ATTR</span><span class="p">(</span><span class="n">mc_name</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">mci_ctl_name_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">MCIDEV_ATTR</span><span class="p">(</span><span class="n">size_mb</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">mci_size_mb_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">MCIDEV_ATTR</span><span class="p">(</span><span class="n">seconds_since_reset</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">mci_seconds_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">MCIDEV_ATTR</span><span class="p">(</span><span class="n">ue_noinfo_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">mci_ue_noinfo_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">MCIDEV_ATTR</span><span class="p">(</span><span class="n">ce_noinfo_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">mci_ce_noinfo_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">MCIDEV_ATTR</span><span class="p">(</span><span class="n">ue_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">mci_ue_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">MCIDEV_ATTR</span><span class="p">(</span><span class="n">ce_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">mci_ce_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* memory scrubber attribute file */</span>
<span class="n">MCIDEV_ATTR</span><span class="p">(</span><span class="n">sdram_scrub_rate</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">mci_sdram_scrub_rate_show</span><span class="p">,</span>
	<span class="n">mci_sdram_scrub_rate_store</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="o">*</span><span class="n">mci_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">mci_attr_reset_counters</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">mci_attr_mc_name</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">mci_attr_size_mb</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">mci_attr_seconds_since_reset</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">mci_attr_ue_noinfo_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">mci_attr_ce_noinfo_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">mci_attr_ue_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">mci_attr_ce_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">mci_attr_sdram_scrub_rate</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Release of a MC controlling instance</span>
<span class="cm"> *</span>
<span class="cm"> *	each MC control instance has the following resources upon entry:</span>
<span class="cm"> *		a) a ref count on the top memctl kobj</span>
<span class="cm"> *		b) a ref count on this module</span>
<span class="cm"> *</span>
<span class="cm"> *	this function must decrement those ref counts and then</span>
<span class="cm"> *	issue a free on the instance&#39;s memory</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_mci_control_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>

	<span class="n">mci</span> <span class="o">=</span> <span class="n">to_mci</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() mci instance idx=%d releasing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">);</span>

	<span class="cm">/* decrement the module ref count */</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">ktype_mci</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">edac_mci_control_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">default_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">**</span><span class="p">)</span><span class="n">mci_attr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* EDAC memory controller sysfs kset:</span>
<span class="cm"> *	/sys/devices/system/edac/mc</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">mc_kset</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * edac_mc_register_sysfs_main_kobj</span>
<span class="cm"> *</span>
<span class="cm"> *	setups and registers the main kobject for each mci</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edac_mc_register_sysfs_main_kobj</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj_mci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">kobj_mci</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">;</span>

	<span class="cm">/* Init the mci&#39;s kobject */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">kobj_mci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">kobj_mci</span><span class="p">));</span>

	<span class="cm">/* Record which module &#39;owns&#39; this control structure</span>
<span class="cm">	 * and bump the ref count of the module</span>
<span class="cm">	 */</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

	<span class="cm">/* bump ref count on this module */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this instance become part of the mc_kset */</span>
	<span class="n">kobj_mci</span><span class="o">-&gt;</span><span class="n">kset</span> <span class="o">=</span> <span class="n">mc_kset</span><span class="p">;</span>

	<span class="cm">/* register the mc&lt;id&gt; kobject to the mc_kset */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="n">kobj_mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktype_mci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				   <span class="s">&quot;mc%d&quot;</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()Failed to register &#39;.../edac/mc%d&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">kobj_reg_fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="n">kobj_mci</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>

	<span class="cm">/* At this point, to &#39;free&#39; the control struct,</span>
<span class="cm">	 * edac_mc_unregister_sysfs_main_kobj() must be used</span>
<span class="cm">	 */</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() Registered &#39;.../edac/mc%d&#39; kobject</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Error exit stack */</span>

<span class="nl">kobj_reg_fail:</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>

<span class="nl">fail_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_mc_register_sysfs_main_kobj</span>
<span class="cm"> *</span>
<span class="cm"> *	tears down and the main mci kobject from the mc_kset</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_mc_unregister_sysfs_main_kobj</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* delete the kobj from the mc_kset */</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define EDAC_DEVICE_SYMLINK	&quot;device&quot;</span>

<span class="cp">#define grp_to_mci(k) (container_of(k, struct mcidev_sysfs_group_kobj, kobj)-&gt;mci)</span>

<span class="cm">/* MCI show/store functions for top most object */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">inst_grp_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mem_ctl_info</span> <span class="o">=</span> <span class="n">grp_to_mci</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="o">*</span><span class="n">mcidev_attr</span> <span class="o">=</span> <span class="n">to_mcidev_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() mem_ctl_info %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">mem_ctl_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcidev_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mcidev_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">mem_ctl_info</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">inst_grp_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mem_ctl_info</span> <span class="o">=</span> <span class="n">grp_to_mci</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="o">*</span><span class="n">mcidev_attr</span> <span class="o">=</span> <span class="n">to_mcidev_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() mem_ctl_info %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">mem_ctl_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcidev_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mcidev_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">mem_ctl_info</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* No memory to release for this kobj */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_inst_grp_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcidev_sysfs_group_kobj</span> <span class="o">*</span><span class="n">grp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">grp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcidev_sysfs_group_kobj</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">mci</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Intermediate show/store table */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">inst_grp_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">inst_grp_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">inst_grp_store</span>
<span class="p">};</span>

<span class="cm">/* the kobj_type instance for a instance group */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">ktype_inst_grp</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">edac_inst_grp_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inst_grp_ops</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * edac_create_mci_instance_attributes</span>
<span class="cm"> *	create MC driver specific attributes bellow an specified kobj</span>
<span class="cm"> * This routine calls itself recursively, in order to create an entire</span>
<span class="cm"> * object tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_create_mci_instance_attributes</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="o">*</span><span class="n">sysfs_attrib</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sysfs_attrib</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() sysfs_attrib = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__func__</span><span class="p">,</span> <span class="n">sysfs_attrib</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">mcidev_sysfs_group_kobj</span> <span class="o">*</span><span class="n">grp_kobj</span><span class="p">;</span>

			<span class="n">grp_kobj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">grp_kobj</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grp_kobj</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">grp</span> <span class="o">=</span> <span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">;</span>
			<span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">mci</span> <span class="o">=</span> <span class="n">mci</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">grp_kobj_list</span><span class="p">);</span>

			<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() grp %s, mci %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mci</span><span class="p">);</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">ktype_inst_grp</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">,</span>
						<span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kobject_init_and_add failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">edac_create_mci_instance_attributes</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span>
					<span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">mcidev_attr</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sysfs_create_file failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">sysfs_attrib</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_remove_mci_instance_attributes</span>
<span class="cm"> *	remove MC driver specific attributes at the topmost level</span>
<span class="cm"> *	directory of this mci instance.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_remove_mci_instance_attributes</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="o">*</span><span class="n">sysfs_attrib</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcidev_sysfs_group_kobj</span> <span class="o">*</span><span class="n">grp_kobj</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * loop if there are attributes and until we hit a NULL entry</span>
<span class="cm">	 * Remove first all the attributes</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sysfs_attrib</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() sysfs_attrib = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__func__</span><span class="p">,</span> <span class="n">sysfs_attrib</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() seeking for group %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">grp_kobj</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">grp_kobj_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() grp_kobj-&gt;grp = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__func__</span><span class="p">,</span> <span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">grp</span> <span class="o">==</span> <span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">edac_remove_mci_instance_attributes</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span>
						    <span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">mcidev_attr</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
					<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() group %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
						<span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
					<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() end of seeking for group %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
			<span class="n">sysfs_remove_file</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sysfs_attrib</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remove the group objects */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">grp_kobj</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">grp_kobj_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp_kobj</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">grp_kobj</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Create a new Memory Controller kobject instance,</span>
<span class="cm"> *	mc&lt;id&gt; under the &#39;mc&#39; directory</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *	0	Success</span>
<span class="cm"> *	!0	Failure</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edac_create_sysfs_mci_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj_mci</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() idx=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">grp_kobj_list</span><span class="p">);</span>

	<span class="cm">/* create a symlink for the device */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="n">kobj_mci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
				<span class="n">EDAC_DEVICE_SYMLINK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() failure to create symlink</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the low level driver desires some attributes,</span>
<span class="cm">	 * then create them now for the driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_driver_sysfs_attributes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">edac_create_mci_instance_attributes</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span>
					<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_driver_sysfs_attributes</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() failure to create mci attributes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Make directories for each CSROW object under the mc&lt;id&gt; kobject</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">csrow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">edac_create_csrow_object</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">csrow</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() failure: create csrow %d obj</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail1:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">csrow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">kobj</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* remove the mci instance&#39;s attributes, if any */</span>
	<span class="n">edac_remove_mci_instance_attributes</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_driver_sysfs_attributes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* remove the symlink */</span>
	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="n">kobj_mci</span><span class="p">,</span> <span class="n">EDAC_DEVICE_SYMLINK</span><span class="p">);</span>

<span class="nl">fail0:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * remove a Memory Controller instance</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_remove_sysfs_mci_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* remove all csrow kobjects */</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s()  unregister this mci kobj</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">nr_csrows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">csrow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">nr_channels</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">csrow</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()  unreg csrow-%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">csrows</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">kobj</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* remove this mci instance&#39;s attribtes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_driver_sysfs_attributes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s()  unregister mci private attributes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">edac_remove_mci_instance_attributes</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span>
						<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_driver_sysfs_attributes</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* remove the symlink */</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s()  remove_link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">,</span> <span class="n">EDAC_DEVICE_SYMLINK</span><span class="p">);</span>

	<span class="cm">/* unregister this instance&#39;s kobject */</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s()  remove_mci_instance</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_mci_kobj</span><span class="p">);</span>
<span class="p">}</span>




<span class="cm">/*</span>
<span class="cm"> * edac_setup_sysfs_mc_kset(void)</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the mc_kset for the &#39;mc&#39; entry</span>
<span class="cm"> *	This requires creating the top &#39;mc&#39; directory with a kset</span>
<span class="cm"> *	and its controls/attributes.</span>
<span class="cm"> *</span>
<span class="cm"> *	To this &#39;mc&#39; kset, instance &#39;mci&#39; will be grouped as children.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:  0 SUCCESS</span>
<span class="cm"> *         !0 FAILURE error code</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edac_sysfs_setup_mc_kset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">edac_subsys</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* get the /sys/devices/system/edac subsys reference */</span>
	<span class="n">edac_subsys</span> <span class="o">=</span> <span class="n">edac_get_sysfs_subsys</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edac_subsys</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() no edac_subsys error=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Init the MC&#39;s kobject */</span>
	<span class="n">mc_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">&quot;mc&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edac_subsys</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mc_kset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() Failed to register &#39;.../edac/mc&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_kset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() Registered &#39;.../edac/mc&#39; kobject</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_kset:</span>
	<span class="n">edac_put_sysfs_subsys</span><span class="p">();</span>

<span class="nl">fail_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_sysfs_teardown_mc_kset</span>
<span class="cm"> *</span>
<span class="cm"> *	deconstruct the mc_ket for memory controllers</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_sysfs_teardown_mc_kset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kset_unregister</span><span class="p">(</span><span class="n">mc_kset</span><span class="p">);</span>
	<span class="n">edac_put_sysfs_subsys</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
