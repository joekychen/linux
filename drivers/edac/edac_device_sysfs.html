<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › edac › edac_device_sysfs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>edac_device_sysfs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * file for managing the edac_device subsystem of devices for EDAC</span>
<span class="cm"> *</span>
<span class="cm"> * (C) 2007 SoftwareBitMaker </span>
<span class="cm"> *</span>
<span class="cm"> * This file may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License.</span>
<span class="cm"> *</span>
<span class="cm"> * Written Doug Thompson &lt;norsk5@xmission.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/edac.h&gt;</span>

<span class="cp">#include &quot;edac_core.h&quot;</span>
<span class="cp">#include &quot;edac_module.h&quot;</span>

<span class="cp">#define EDAC_DEVICE_SYMLINK	&quot;device&quot;</span>

<span class="cp">#define to_edacdev(k) container_of(k, struct edac_device_ctl_info, kobj)</span>
<span class="cp">#define to_edacdev_attr(a) container_of(a, struct edacdev_attribute, attr)</span>


<span class="cm">/*</span>
<span class="cm"> * Set of edac_device_ctl_info attribute store/show functions</span>
<span class="cm"> */</span>

<span class="cm">/* &#39;log_ue&#39; */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_device_ctl_log_ue_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span>
					<span class="o">*</span><span class="n">ctl_info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctl_info</span><span class="o">-&gt;</span><span class="n">log_ue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_device_ctl_log_ue_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span>
					<span class="o">*</span><span class="n">ctl_info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* if parameter is zero, turn off flag, if non-zero turn on flag */</span>
	<span class="n">ctl_info</span><span class="o">-&gt;</span><span class="n">log_ue</span> <span class="o">=</span> <span class="p">(</span><span class="n">simple_strtoul</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* &#39;log_ce&#39; */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_device_ctl_log_ce_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span>
					<span class="o">*</span><span class="n">ctl_info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctl_info</span><span class="o">-&gt;</span><span class="n">log_ce</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_device_ctl_log_ce_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span>
					<span class="o">*</span><span class="n">ctl_info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* if parameter is zero, turn off flag, if non-zero turn on flag */</span>
	<span class="n">ctl_info</span><span class="o">-&gt;</span><span class="n">log_ce</span> <span class="o">=</span> <span class="p">(</span><span class="n">simple_strtoul</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* &#39;panic_on_ue&#39; */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_device_ctl_panic_on_ue_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span>
						<span class="o">*</span><span class="n">ctl_info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctl_info</span><span class="o">-&gt;</span><span class="n">panic_on_ue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_device_ctl_panic_on_ue_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span>
						 <span class="o">*</span><span class="n">ctl_info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
						 <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* if parameter is zero, turn off flag, if non-zero turn on flag */</span>
	<span class="n">ctl_info</span><span class="o">-&gt;</span><span class="n">panic_on_ue</span> <span class="o">=</span> <span class="p">(</span><span class="n">simple_strtoul</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* &#39;poll_msec&#39; show and store functions*/</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_device_ctl_poll_msec_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span>
					<span class="o">*</span><span class="n">ctl_info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctl_info</span><span class="o">-&gt;</span><span class="n">poll_msec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_device_ctl_poll_msec_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span>
					<span class="o">*</span><span class="n">ctl_info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>

	<span class="cm">/* get the value and enforce that it is non-zero, must be at least</span>
<span class="cm">	 * one millisecond for the delay period, between scans</span>
<span class="cm">	 * Then cancel last outstanding delay for the work request</span>
<span class="cm">	 * and set a new one.</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">edac_device_reset_delay_period</span><span class="p">(</span><span class="n">ctl_info</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* edac_device_ctl_info specific attribute structure */</span>
<span class="k">struct</span> <span class="n">ctl_info_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define to_ctl_info(k) container_of(k, struct edac_device_ctl_info, kobj)</span>
<span class="cp">#define to_ctl_info_attr(a) container_of(a,struct ctl_info_attribute,attr)</span>

<span class="cm">/* Function to &#39;show&#39; fields from the edac_dev &#39;ctl_info&#39; structure */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_dev_ctl_info_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span> <span class="o">=</span> <span class="n">to_ctl_info</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ctl_info_attribute</span> <span class="o">*</span><span class="n">ctl_info_attr</span> <span class="o">=</span> <span class="n">to_ctl_info_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctl_info_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ctl_info_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function to &#39;store&#39; fields into the edac_dev &#39;ctl_info&#39; structure */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_dev_ctl_info_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span> <span class="o">=</span> <span class="n">to_ctl_info</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ctl_info_attribute</span> <span class="o">*</span><span class="n">ctl_info_attr</span> <span class="o">=</span> <span class="n">to_ctl_info_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctl_info_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ctl_info_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* edac_dev file operations for an &#39;ctl_info&#39; */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">device_ctl_info_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">edac_dev_ctl_info_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">edac_dev_ctl_info_store</span>
<span class="p">};</span>

<span class="cp">#define CTL_INFO_ATTR(_name,_mode,_show,_store)        \</span>
<span class="cp">static struct ctl_info_attribute attr_ctl_info_##_name = {      \</span>
<span class="cp">	.attr = {.name = __stringify(_name), .mode = _mode },   \</span>
<span class="cp">	.show   = _show,                                        \</span>
<span class="cp">	.store  = _store,                                       \</span>
<span class="cp">};</span>

<span class="cm">/* Declare the various ctl_info attributes here and their respective ops */</span>
<span class="n">CTL_INFO_ATTR</span><span class="p">(</span><span class="n">log_ue</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">edac_device_ctl_log_ue_show</span><span class="p">,</span> <span class="n">edac_device_ctl_log_ue_store</span><span class="p">);</span>
<span class="n">CTL_INFO_ATTR</span><span class="p">(</span><span class="n">log_ce</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">edac_device_ctl_log_ce_show</span><span class="p">,</span> <span class="n">edac_device_ctl_log_ce_store</span><span class="p">);</span>
<span class="n">CTL_INFO_ATTR</span><span class="p">(</span><span class="n">panic_on_ue</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">edac_device_ctl_panic_on_ue_show</span><span class="p">,</span>
	<span class="n">edac_device_ctl_panic_on_ue_store</span><span class="p">);</span>
<span class="n">CTL_INFO_ATTR</span><span class="p">(</span><span class="n">poll_msec</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">edac_device_ctl_poll_msec_show</span><span class="p">,</span> <span class="n">edac_device_ctl_poll_msec_store</span><span class="p">);</span>

<span class="cm">/* Base Attributes of the EDAC_DEVICE ECC object */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_info_attribute</span> <span class="o">*</span><span class="n">device_ctrl_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">attr_ctl_info_panic_on_ue</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ctl_info_log_ue</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ctl_info_log_ce</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_ctl_info_poll_msec</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_ctrl_master_release</span>
<span class="cm"> *</span>
<span class="cm"> *	called when the reference count for the &#39;main&#39; kobj</span>
<span class="cm"> *	for a edac_device control struct reaches zero</span>
<span class="cm"> *</span>
<span class="cm"> *	Reference count model:</span>
<span class="cm"> *		One &#39;main&#39; kobject for each control structure allocated.</span>
<span class="cm"> *		That main kobj is initially set to one AND</span>
<span class="cm"> *		the reference count for the EDAC &#39;core&#39; module is</span>
<span class="cm"> *		bumped by one, thus added &#39;keep in memory&#39; dependency.</span>
<span class="cm"> *</span>
<span class="cm"> *		Each new internal kobj (in instances and blocks) then</span>
<span class="cm"> *		bumps the &#39;main&#39; kobject.</span>
<span class="cm"> *</span>
<span class="cm"> *		When they are released their release functions decrement</span>
<span class="cm"> *		the &#39;main&#39; kobj.</span>
<span class="cm"> *</span>
<span class="cm"> *		When the main kobj reaches zero (0) then THIS function</span>
<span class="cm"> *		is called which then decrements the EDAC &#39;core&#39; module.</span>
<span class="cm"> *		When the module reference count reaches zero then the</span>
<span class="cm"> *		module no longer has dependency on keeping the release</span>
<span class="cm"> *		function code in memory and module can be unloaded.</span>
<span class="cm"> *</span>
<span class="cm"> *		This will support several control objects as well, each</span>
<span class="cm"> *		with its own &#39;main&#39; kobj.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_device_ctrl_master_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span> <span class="o">=</span> <span class="n">to_edacdev</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() control index=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">dev_idx</span><span class="p">);</span>

	<span class="cm">/* decrement the EDAC CORE module ref count */</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>

	<span class="cm">/* free the control struct containing the &#39;main&#39; kobj</span>
<span class="cm">	 * passed in to this routine</span>
<span class="cm">	 */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ktype for the main (master) kobject */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">ktype_device_ctrl</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">edac_device_ctrl_master_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">device_ctl_info_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">default_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">**</span><span class="p">)</span><span class="n">device_ctrl_attr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_register_sysfs_main_kobj</span>
<span class="cm"> *</span>
<span class="cm"> *	perform the high level setup for the new edac_device instance</span>
<span class="cm"> *</span>
<span class="cm"> * Return:  0 SUCCESS</span>
<span class="cm"> *         !0 FAILURE</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edac_device_register_sysfs_main_kobj</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">edac_subsys</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* get the /sys/devices/system/edac reference */</span>
	<span class="n">edac_subsys</span> <span class="o">=</span> <span class="n">edac_get_sysfs_subsys</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edac_subsys</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() no edac_subsys error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Point to the &#39;edac_subsys&#39; this instance &#39;reports&#39; to */</span>
	<span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">edac_subsys</span> <span class="o">=</span> <span class="n">edac_subsys</span><span class="p">;</span>

	<span class="cm">/* Init the devices&#39;s kobject */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span><span class="p">));</span>

	<span class="cm">/* Record which module &#39;owns&#39; this control structure</span>
<span class="cm">	 * and bump the ref count of the module</span>
<span class="cm">	 */</span>
	<span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_mod_get</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* register */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktype_device_ctrl</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">edac_subsys</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
				   <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()Failed to register &#39;.../edac/%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_kobj_reg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>

	<span class="cm">/* At this point, to &#39;free&#39; the control struct,</span>
<span class="cm">	 * edac_device_unregister_sysfs_main_kobj() must be used</span>
<span class="cm">	 */</span>

	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() Registered &#39;.../edac/%s&#39; kobject</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Error exit stack */</span>
<span class="nl">err_kobj_reg:</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>

<span class="nl">err_mod_get:</span>
	<span class="n">edac_put_sysfs_subsys</span><span class="p">();</span>

<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_unregister_sysfs_main_kobj:</span>
<span class="cm"> *	the &#39;..../edac/&lt;name&gt;&#39; kobject</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_device_unregister_sysfs_main_kobj</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() name of kobject is: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">kobject_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unregister the edac device&#39;s kobject and</span>
<span class="cm">	 * allow for reference count to reach 0 at which point</span>
<span class="cm">	 * the callback will be called to:</span>
<span class="cm">	 *   a) module_put() this module</span>
<span class="cm">	 *   b) &#39;kfree&#39; the memory</span>
<span class="cm">	 */</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">edac_put_sysfs_subsys</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* edac_dev -&gt; instance information */</span>

<span class="cm">/*</span>
<span class="cm"> * Set of low-level instance attribute show functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">instance_ue_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">.</span><span class="n">ue_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">instance_ce_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">.</span><span class="n">ce_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define to_instance(k) container_of(k, struct edac_device_instance, kobj)</span>
<span class="cp">#define to_instance_attr(a) container_of(a,struct instance_attribute,attr)</span>

<span class="cm">/* DEVICE instance kobject release() function */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_device_ctrl_instance_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* map from this kobj to the main control struct</span>
<span class="cm">	 * and then dec the main kobj count</span>
<span class="cm">	 */</span>
	<span class="n">instance</span> <span class="o">=</span> <span class="n">to_instance</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* instance specific attribute structure */</span>
<span class="k">struct</span> <span class="n">instance_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* Function to &#39;show&#39; fields from the edac_dev &#39;instance&#39; structure */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_dev_instance_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">to_instance</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">instance_attribute</span> <span class="o">*</span><span class="n">instance_attr</span> <span class="o">=</span> <span class="n">to_instance_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">instance_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function to &#39;store&#39; fields into the edac_dev &#39;instance&#39; structure */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_dev_instance_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">to_instance</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">instance_attribute</span> <span class="o">*</span><span class="n">instance_attr</span> <span class="o">=</span> <span class="n">to_instance_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">instance_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* edac_dev file operations for an &#39;instance&#39; */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">device_instance_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">edac_dev_instance_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">edac_dev_instance_store</span>
<span class="p">};</span>

<span class="cp">#define INSTANCE_ATTR(_name,_mode,_show,_store)        \</span>
<span class="cp">static struct instance_attribute attr_instance_##_name = {      \</span>
<span class="cp">	.attr = {.name = __stringify(_name), .mode = _mode },   \</span>
<span class="cp">	.show   = _show,                                        \</span>
<span class="cp">	.store  = _store,                                       \</span>
<span class="cp">};</span>

<span class="cm">/*</span>
<span class="cm"> * Define attributes visible for the edac_device instance object</span>
<span class="cm"> *	Each contains a pointer to a show and an optional set</span>
<span class="cm"> *	function pointer that does the low level output/input</span>
<span class="cm"> */</span>
<span class="n">INSTANCE_ATTR</span><span class="p">(</span><span class="n">ce_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">instance_ce_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">INSTANCE_ATTR</span><span class="p">(</span><span class="n">ue_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">instance_ue_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* list of edac_dev &#39;instance&#39; attributes */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">instance_attribute</span> <span class="o">*</span><span class="n">device_instance_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">attr_instance_ce_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_instance_ue_count</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* The &#39;ktype&#39; for each edac_dev &#39;instance&#39; */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">ktype_instance_ctrl</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">edac_device_ctrl_instance_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">device_instance_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">default_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">**</span><span class="p">)</span><span class="n">device_instance_attr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* edac_dev -&gt; instance -&gt; block information */</span>

<span class="cp">#define to_block(k) container_of(k, struct edac_device_block, kobj)</span>
<span class="cp">#define to_block_attr(a) \</span>
<span class="cp">	container_of(a, struct edac_dev_sysfs_block_attribute, attr)</span>

<span class="cm">/*</span>
<span class="cm"> * Set of low-level block attribute show functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">block_ue_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_block</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">to_block</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">.</span><span class="n">ue_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">block_ce_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_block</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">to_block</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">.</span><span class="n">ce_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DEVICE block kobject release() function */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_device_ctrl_block_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* get the container of the kobj */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">to_block</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="cm">/* map from &#39;block kobj&#39; to &#39;block-&gt;instance-&gt;controller-&gt;main_kobj&#39;</span>
<span class="cm">	 * now &#39;release&#39; the block kobject</span>
<span class="cm">	 */</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Function to &#39;show&#39; fields from the edac_dev &#39;block&#39; structure */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_dev_block_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_dev_sysfs_block_attribute</span> <span class="o">*</span><span class="n">block_attr</span> <span class="o">=</span>
						<span class="n">to_block_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">block_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function to &#39;store&#39; fields into the edac_dev &#39;block&#39; structure */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edac_dev_block_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_dev_sysfs_block_attribute</span> <span class="o">*</span><span class="n">block_attr</span><span class="p">;</span>

	<span class="n">block_attr</span> <span class="o">=</span> <span class="n">to_block_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">block_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* edac_dev file operations for a &#39;block&#39; */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">device_block_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">edac_dev_block_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">edac_dev_block_store</span>
<span class="p">};</span>

<span class="cp">#define BLOCK_ATTR(_name,_mode,_show,_store)        \</span>
<span class="cp">static struct edac_dev_sysfs_block_attribute attr_block_##_name = {	\</span>
<span class="cp">	.attr = {.name = __stringify(_name), .mode = _mode },   \</span>
<span class="cp">	.show   = _show,                                        \</span>
<span class="cp">	.store  = _store,                                       \</span>
<span class="cp">};</span>

<span class="n">BLOCK_ATTR</span><span class="p">(</span><span class="n">ce_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">block_ce_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">BLOCK_ATTR</span><span class="p">(</span><span class="n">ue_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">block_ue_count_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* list of edac_dev &#39;block&#39; attributes */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">edac_dev_sysfs_block_attribute</span> <span class="o">*</span><span class="n">device_block_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">attr_block_ce_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">attr_block_ue_count</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* The &#39;ktype&#39; for each edac_dev &#39;block&#39; */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">ktype_block_ctrl</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">edac_device_ctrl_block_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">device_block_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">default_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">**</span><span class="p">)</span><span class="n">device_block_attr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* block ctor/dtor  code */</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_create_block</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_device_create_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">edac_device_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edac_dev_sysfs_block_attribute</span> <span class="o">*</span><span class="n">sysfs_attrib</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">main_kobj</span><span class="p">;</span>

	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() Instance &#39;%s&#39; inst_p=%p  block &#39;%s&#39;  block_p=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() block kobj=%p  block kobj-&gt;parent=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>

	<span class="cm">/* init this block&#39;s kobject */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span><span class="p">));</span>

	<span class="cm">/* bump the main kobject&#39;s reference count for this controller</span>
<span class="cm">	 * and this instance is dependent on the main</span>
<span class="cm">	 */</span>
	<span class="n">main_kobj</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">main_kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Add this block&#39;s kobject */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktype_block_ctrl</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
				   <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;%s() Failed to register instance &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">main_kobj</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If there are driver level block attributes, then added them</span>
<span class="cm">	 * to the block kobject</span>
<span class="cm">	 */</span>
	<span class="n">sysfs_attrib</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">block_attributes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_attrib</span> <span class="o">&amp;&amp;</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">nr_attribs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">nr_attribs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sysfs_attrib</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() creating block attrib=&#39;%s&#39; &quot;</span>
				<span class="s">&quot;attrib-&gt;%p to kobj=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span>
				<span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				<span class="n">sysfs_attrib</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>

			<span class="cm">/* Create each block_attribute file */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_on_attrib</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Error unwind stack */</span>
<span class="nl">err_on_attrib:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>

<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_delete_block(edac_dev,block);</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_device_delete_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">edac_device_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_dev_sysfs_block_attribute</span> <span class="o">*</span><span class="n">sysfs_attrib</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* if this block has &#39;attributes&#39; then we need to iterate over the list</span>
<span class="cm">	 * and &#39;remove&#39; the attributes on this block</span>
<span class="cm">	 */</span>
	<span class="n">sysfs_attrib</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">block_attributes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_attrib</span> <span class="o">&amp;&amp;</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">nr_attribs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">nr_attribs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sysfs_attrib</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* remove each block_attrib file */</span>
			<span class="n">sysfs_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="p">)</span> <span class="n">sysfs_attrib</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* unregister this block&#39;s kobject, SEE:</span>
<span class="cm">	 *	edac_device_ctrl_block_release() callback operation</span>
<span class="cm">	 */</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* instance ctor/dtor code */</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_create_instance</span>
<span class="cm"> *	create just one instance of an edac_device &#39;instance&#39;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_device_create_instance</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">main_kobj</span><span class="p">;</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">instances</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="cm">/* Init the instance&#39;s kobject */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span><span class="p">));</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">=</span> <span class="n">edac_dev</span><span class="p">;</span>

	<span class="cm">/* bump the main kobject&#39;s reference count for this controller</span>
<span class="cm">	 * and this instance is dependent on the main</span>
<span class="cm">	 */</span>
	<span class="n">main_kobj</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">main_kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Formally register this instance&#39;s kobject under the edac_device */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktype_instance_ctrl</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s() Failed to register instance &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">main_kobj</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() now register &#39;%d&#39; blocks for instance %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">nr_blocks</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="cm">/* register all blocks of this instance */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">nr_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">edac_device_create_block</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If any fail, remove all previous ones */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">edac_device_delete_block</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
			<span class="k">goto</span> <span class="n">err_release_instance_kobj</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>

	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() Registered instance %d &#39;%s&#39; kobject</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* error unwind stack */</span>
<span class="nl">err_release_instance_kobj:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>

<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_remove_instance</span>
<span class="cm"> *	remove an edac_device instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_device_delete_instance</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_device_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">instances</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="cm">/* unregister all blocks in this instance */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">nr_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">edac_device_delete_block</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* unregister this instance&#39;s kobject, SEE:</span>
<span class="cm">	 *	edac_device_ctrl_instance_release() for callback operation</span>
<span class="cm">	 */</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_create_instances</span>
<span class="cm"> *	create the first level of &#39;instances&#39; for this device</span>
<span class="cm"> *	(ie  &#39;cache&#39; might have &#39;cache0&#39;, &#39;cache1&#39;, &#39;cache2&#39;, etc</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_device_create_instances</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* iterate over creation of the instances */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">nr_instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">edac_device_create_instance</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* unwind previous instances on error */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">edac_device_delete_instance</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_delete_instances(edac_dev);</span>
<span class="cm"> *	unregister all the kobjects of the instances</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_device_delete_instances</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* iterate over creation of the instances */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">nr_instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">edac_device_delete_instance</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* edac_dev sysfs ctor/dtor  code */</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_add_main_sysfs_attributes</span>
<span class="cm"> *	add some attributes to this instance&#39;s main kobject</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">edac_device_add_main_sysfs_attributes</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_dev_sysfs_attribute</span> <span class="o">*</span><span class="n">sysfs_attrib</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sysfs_attrib</span> <span class="o">=</span> <span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">sysfs_attributes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_attrib</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* iterate over the array and create an attribute for each</span>
<span class="cm">		 * entry in the list</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span><span class="o">*</span><span class="p">)</span> <span class="n">sysfs_attrib</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

			<span class="n">sysfs_attrib</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_remove_main_sysfs_attributes</span>
<span class="cm"> *	remove any attributes to this instance&#39;s main kobject</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edac_device_remove_main_sysfs_attributes</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edac_dev_sysfs_attribute</span> <span class="o">*</span><span class="n">sysfs_attrib</span><span class="p">;</span>

	<span class="cm">/* if there are main attributes, defined, remove them. First,</span>
<span class="cm">	 * point to the start of the array and iterate over it</span>
<span class="cm">	 * removing each attribute listed from this device&#39;s instance&#39;s kobject</span>
<span class="cm">	 */</span>
	<span class="n">sysfs_attrib</span> <span class="o">=</span> <span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">sysfs_attributes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_attrib</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">sysfs_attrib</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sysfs_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="p">)</span> <span class="n">sysfs_attrib</span><span class="p">);</span>
			<span class="n">sysfs_attrib</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_create_sysfs() Constructor</span>
<span class="cm"> *</span>
<span class="cm"> * accept a created edac_device control structure</span>
<span class="cm"> * and &#39;export&#39; it to sysfs. The &#39;main&#39; kobj should already have been</span>
<span class="cm"> * created. &#39;instance&#39; and &#39;block&#39; kobjects should be registered</span>
<span class="cm"> * along with any &#39;block&#39; attributes from the low driver. In addition,</span>
<span class="cm"> * the main attributes (if any) are connected to the main kobject of</span>
<span class="cm"> * the control structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *	0	Success</span>
<span class="cm"> *	!0	Failure</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edac_device_create_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">edac_kobj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() idx=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">dev_idx</span><span class="p">);</span>

	<span class="cm">/*  go create any main attributes callers wants */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">edac_device_add_main_sysfs_attributes</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() failed to add sysfs attribs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* create a symlink from the edac device</span>
<span class="cm">	 * to the platform &#39;device&#39; being used for this</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="n">edac_kobj</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">EDAC_DEVICE_SYMLINK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() sysfs_create_link() returned err= %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_remove_main_attribs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create the first level instance directories</span>
<span class="cm">	 * In turn, the nested blocks beneath the instances will</span>
<span class="cm">	 * be registered as well</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">edac_device_create_instances</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s() edac_device_create_instances() &quot;</span>
			<span class="s">&quot;returned err= %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_remove_link</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">debugf4</span><span class="p">(</span><span class="s">&quot;%s() create-instances done, idx=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">dev_idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Error unwind stack */</span>
<span class="nl">err_remove_link:</span>
	<span class="cm">/* remove the sym link */</span>
	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">EDAC_DEVICE_SYMLINK</span><span class="p">);</span>

<span class="nl">err_remove_main_attribs:</span>
	<span class="n">edac_device_remove_main_sysfs_attributes</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">);</span>

<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * edac_device_remove_sysfs() destructor</span>
<span class="cm"> *</span>
<span class="cm"> * given an edac_device struct, tear down the kobject resources</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edac_device_remove_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">edac_device_ctl_info</span> <span class="o">*</span><span class="n">edac_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* remove any main attributes for this device */</span>
	<span class="n">edac_device_remove_main_sysfs_attributes</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">);</span>

	<span class="cm">/* remove the device sym link */</span>
	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edac_dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">EDAC_DEVICE_SYMLINK</span><span class="p">);</span>

	<span class="cm">/* walk the instance/block kobject tree, deconstructing it */</span>
	<span class="n">edac_device_delete_instances</span><span class="p">(</span><span class="n">edac_dev</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
