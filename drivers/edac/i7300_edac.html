<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › edac › i7300_edac.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>i7300_edac.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Intel 7300 class Memory Controllers kernel module (Clarksboro)</span>
<span class="cm"> *</span>
<span class="cm"> * This file may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License version 2 only.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2010 by:</span>
<span class="cm"> *	 Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Red Hat Inc. http://www.redhat.com</span>
<span class="cm"> *</span>
<span class="cm"> * Intel 7300 Chipset Memory Controller Hub (MCH) - Datasheet</span>
<span class="cm"> *	http://www.intel.com/Assets/PDF/datasheet/318082.pdf</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: The chipset allow checking for PCI Express errors also. Currently,</span>
<span class="cm"> *	 the driver covers only memory error errors</span>
<span class="cm"> *</span>
<span class="cm"> * This driver uses &quot;csrows&quot; EDAC attribute to represent DIMM slot#</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pci_ids.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/edac.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>

<span class="cp">#include &quot;edac_core.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Alter this version for the I7300 module when modifications are made</span>
<span class="cm"> */</span>
<span class="cp">#define I7300_REVISION    &quot; Ver: 1.0.0&quot;</span>

<span class="cp">#define EDAC_MOD_STR      &quot;i7300_edac&quot;</span>

<span class="cp">#define i7300_printk(level, fmt, arg...) \</span>
<span class="cp">	edac_printk(level, &quot;i7300&quot;, fmt, ##arg)</span>

<span class="cp">#define i7300_mc_printk(mci, level, fmt, arg...) \</span>
<span class="cp">	edac_mc_chipset_printk(mci, level, &quot;i7300&quot;, fmt, ##arg)</span>

<span class="cm">/***********************************************</span>
<span class="cm"> * i7300 Limit constants Structs and static vars</span>
<span class="cm"> ***********************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Memory topology is organized as:</span>
<span class="cm"> *	Branch 0 - 2 channels: channels 0 and 1 (FDB0 PCI dev 21.0)</span>
<span class="cm"> *	Branch 1 - 2 channels: channels 2 and 3 (FDB1 PCI dev 22.0)</span>
<span class="cm"> * Each channel can have to 8 DIMM sets (called as SLOTS)</span>
<span class="cm"> * Slots should generally be filled in pairs</span>
<span class="cm"> *	Except on Single Channel mode of operation</span>
<span class="cm"> *		just slot 0/channel0 filled on this mode</span>
<span class="cm"> *	On normal operation mode, the two channels on a branch should be</span>
<span class="cm"> *		filled together for the same SLOT#</span>
<span class="cm"> * When in mirrored mode, Branch 1 replicate memory at Branch 0, so, the four</span>
<span class="cm"> *		channels on both branches should be filled</span>
<span class="cm"> */</span>

<span class="cm">/* Limits for i7300 */</span>
<span class="cp">#define MAX_SLOTS		8</span>
<span class="cp">#define MAX_BRANCHES		2</span>
<span class="cp">#define MAX_CH_PER_BRANCH	2</span>
<span class="cp">#define MAX_CHANNELS		(MAX_CH_PER_BRANCH * MAX_BRANCHES)</span>
<span class="cp">#define MAX_MIR			3</span>

<span class="cp">#define to_channel(ch, branch)	((((branch)) &lt;&lt; 1) | (ch))</span>

<span class="cp">#define to_csrow(slot, ch, branch)					\</span>
<span class="cp">		(to_channel(ch, branch) | ((slot) &lt;&lt; 2))</span>

<span class="cm">/* Device name and register DID (Device ID) */</span>
<span class="k">struct</span> <span class="n">i7300_dev_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctl_name</span><span class="p">;</span>	<span class="cm">/* name for this device */</span>
	<span class="n">u16</span> <span class="n">fsb_mapping_errors</span><span class="p">;</span>	<span class="cm">/* DID for the branchmap,control */</span>
<span class="p">};</span>

<span class="cm">/* Table of devices attributes supported by this driver */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i7300_dev_info</span> <span class="n">i7300_devs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">ctl_name</span> <span class="o">=</span> <span class="s">&quot;I7300&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fsb_mapping_errors</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_INTEL_I7300_MCH_ERR</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">i7300_dimm_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">megabytes</span><span class="p">;</span>		<span class="cm">/* size, 0 means not present  */</span>
<span class="p">};</span>

<span class="cm">/* driver private data structure */</span>
<span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev_16_0_fsb_ctlr</span><span class="p">;</span>		<span class="cm">/* 16.0 */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">;</span>	<span class="cm">/* 16.1 */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">;</span>	<span class="cm">/* 16.2 */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev_2x_0_fbd_branch</span><span class="p">[</span><span class="n">MAX_BRANCHES</span><span class="p">];</span>	<span class="cm">/* 21.0  and 22.0 */</span>

	<span class="n">u16</span> <span class="n">tolm</span><span class="p">;</span>				<span class="cm">/* top of low memory */</span>
	<span class="n">u64</span> <span class="n">ambase</span><span class="p">;</span>				<span class="cm">/* AMB BAR */</span>

	<span class="n">u32</span> <span class="n">mc_settings</span><span class="p">;</span>			<span class="cm">/* Report several settings */</span>
	<span class="n">u32</span> <span class="n">mc_settings_a</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">mir</span><span class="p">[</span><span class="n">MAX_MIR</span><span class="p">];</span>			<span class="cm">/* Memory Interleave Reg*/</span>

	<span class="n">u16</span> <span class="n">mtr</span><span class="p">[</span><span class="n">MAX_SLOTS</span><span class="p">][</span><span class="n">MAX_BRANCHES</span><span class="p">];</span>	<span class="cm">/* Memory Technlogy Reg */</span>
	<span class="n">u16</span> <span class="n">ambpresent</span><span class="p">[</span><span class="n">MAX_CHANNELS</span><span class="p">];</span>		<span class="cm">/* AMB present regs */</span>

	<span class="cm">/* DIMM information matrix, allocating architecture maximums */</span>
	<span class="k">struct</span> <span class="n">i7300_dimm_info</span> <span class="n">dimm_info</span><span class="p">[</span><span class="n">MAX_SLOTS</span><span class="p">][</span><span class="n">MAX_CHANNELS</span><span class="p">];</span>

	<span class="cm">/* Temporary buffer for use when preparing error messages */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp_prt_buffer</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* FIXME: Why do we need to have this static? */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">edac_pci_ctl_info</span> <span class="o">*</span><span class="n">i7300_pci</span><span class="p">;</span>

<span class="cm">/***************************************************</span>
<span class="cm"> * i7300 Register definitions for memory enumeration</span>
<span class="cm"> ***************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Device 16,</span>
<span class="cm"> * Function 0: System Address (not documented)</span>
<span class="cm"> * Function 1: Memory Branch Map, Control, Errors Register</span>
<span class="cm"> */</span>

	<span class="cm">/* OFFSETS for Function 0 */</span>
<span class="cp">#define AMBASE			0x48 </span><span class="cm">/* AMB Mem Mapped Reg Region Base */</span><span class="cp"></span>
<span class="cp">#define MAXCH			0x56 </span><span class="cm">/* Max Channel Number */</span><span class="cp"></span>
<span class="cp">#define MAXDIMMPERCH		0x57 </span><span class="cm">/* Max DIMM PER Channel Number */</span><span class="cp"></span>

	<span class="cm">/* OFFSETS for Function 1 */</span>
<span class="cp">#define MC_SETTINGS		0x40</span>
  <span class="cp">#define IS_MIRRORED(mc)		((mc) &amp; (1 &lt;&lt; 16))</span>
  <span class="cp">#define IS_ECC_ENABLED(mc)		((mc) &amp; (1 &lt;&lt; 5))</span>
  <span class="cp">#define IS_RETRY_ENABLED(mc)		((mc) &amp; (1 &lt;&lt; 31))</span>
  <span class="cp">#define IS_SCRBALGO_ENHANCED(mc)	((mc) &amp; (1 &lt;&lt; 8))</span>

<span class="cp">#define MC_SETTINGS_A		0x58</span>
  <span class="cp">#define IS_SINGLE_MODE(mca)		((mca) &amp; (1 &lt;&lt; 14))</span>

<span class="cp">#define TOLM			0x6C</span>

<span class="cp">#define MIR0			0x80</span>
<span class="cp">#define MIR1			0x84</span>
<span class="cp">#define MIR2			0x88</span>

<span class="cm">/*</span>
<span class="cm"> * Note: Other Intel EDAC drivers use AMBPRESENT to identify if the available</span>
<span class="cm"> * memory. From datasheet item 7.3.1 (FB-DIMM technology &amp; organization), it</span>
<span class="cm"> * seems that we cannot use this information directly for the same usage.</span>
<span class="cm"> * Each memory slot may have up to 2 AMB interfaces, one for income and another</span>
<span class="cm"> * for outcome interface to the next slot.</span>
<span class="cm"> * For now, the driver just stores the AMB present registers, but rely only at</span>
<span class="cm"> * the MTR info to detect memory.</span>
<span class="cm"> * Datasheet is also not clear about how to map each AMBPRESENT registers to</span>
<span class="cm"> * one of the 4 available channels.</span>
<span class="cm"> */</span>
<span class="cp">#define AMBPRESENT_0	0x64</span>
<span class="cp">#define AMBPRESENT_1	0x66</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">mtr_regs</span><span class="p">[</span><span class="n">MAX_SLOTS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x8c</span><span class="p">,</span>
	<span class="mh">0x82</span><span class="p">,</span> <span class="mh">0x86</span><span class="p">,</span> <span class="mh">0x8a</span><span class="p">,</span> <span class="mh">0x8e</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Defines to extract the vaious fields from the</span>
<span class="cm"> *	MTRx - Memory Technology Registers</span>
<span class="cm"> */</span>
<span class="cp">#define MTR_DIMMS_PRESENT(mtr)		((mtr) &amp; (1 &lt;&lt; 8))</span>
<span class="cp">#define MTR_DIMMS_ETHROTTLE(mtr)	((mtr) &amp; (1 &lt;&lt; 7))</span>
<span class="cp">#define MTR_DRAM_WIDTH(mtr)		(((mtr) &amp; (1 &lt;&lt; 6)) ? 8 : 4)</span>
<span class="cp">#define MTR_DRAM_BANKS(mtr)		(((mtr) &amp; (1 &lt;&lt; 5)) ? 8 : 4)</span>
<span class="cp">#define MTR_DIMM_RANKS(mtr)		(((mtr) &amp; (1 &lt;&lt; 4)) ? 1 : 0)</span>
<span class="cp">#define MTR_DIMM_ROWS(mtr)		(((mtr) &gt;&gt; 2) &amp; 0x3)</span>
<span class="cp">#define MTR_DRAM_BANKS_ADDR_BITS	2</span>
<span class="cp">#define MTR_DIMM_ROWS_ADDR_BITS(mtr)	(MTR_DIMM_ROWS(mtr) + 13)</span>
<span class="cp">#define MTR_DIMM_COLS(mtr)		((mtr) &amp; 0x3)</span>
<span class="cp">#define MTR_DIMM_COLS_ADDR_BITS(mtr)	(MTR_DIMM_COLS(mtr) + 10)</span>

<span class="cp">#ifdef CONFIG_EDAC_DEBUG</span>
<span class="cm">/* MTR NUMROW */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">numrow_toString</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;8,192 - 13 rows&quot;</span><span class="p">,</span>
	<span class="s">&quot;16,384 - 14 rows&quot;</span><span class="p">,</span>
	<span class="s">&quot;32,768 - 15 rows&quot;</span><span class="p">,</span>
	<span class="s">&quot;65,536 - 16 rows&quot;</span>
<span class="p">};</span>

<span class="cm">/* MTR NUMCOL */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">numcol_toString</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;1,024 - 10 columns&quot;</span><span class="p">,</span>
	<span class="s">&quot;2,048 - 11 columns&quot;</span><span class="p">,</span>
	<span class="s">&quot;4,096 - 12 columns&quot;</span><span class="p">,</span>
	<span class="s">&quot;reserved&quot;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/************************************************</span>
<span class="cm"> * i7300 Register definitions for error detection</span>
<span class="cm"> ************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Device 16.1: FBD Error Registers</span>
<span class="cm"> */</span>
<span class="cp">#define FERR_FAT_FBD	0x98</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ferr_fat_fbd_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Non-Redundant Fast Reset Timeout&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;&gt;Tmid Thermal event with intelligent throttling disabled&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Memory or FBD configuration CRC read error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Memory Write error on non-redundant retry or &quot;</span>
	       <span class="s">&quot;FBD configuration Write error on retry&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define GET_FBD_FAT_IDX(fbderr)	(fbderr &amp; (3 &lt;&lt; 28))</span>
<span class="cp">#define FERR_FAT_FBD_ERR_MASK ((1 &lt;&lt; 0) | (1 &lt;&lt; 1) | (1 &lt;&lt; 2) | (1 &lt;&lt; 3))</span>

<span class="cp">#define FERR_NF_FBD	0xa0</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ferr_nf_fbd_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;DIMM-Spare Copy Completed&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;DIMM-Spare Copy Initiated&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Redundant Fast Reset Timeout&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Memory Write error on redundant retry&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;SPD protocol Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FBD Northbound parity error on FBD Sync Status&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Correctable Patrol Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Correctable Resilver- or Spare-Copy Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Correctable Mirrored Demand Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Correctable Non-Mirrored Demand Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Memory or FBD configuration CRC read error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FBD Configuration Write error on first attempt&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">9</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Memory Write error on first attempt&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Non-Aliased Uncorrectable Patrol Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">7</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Non-Aliased Uncorrectable Resilver- or Spare-Copy Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Non-Aliased Uncorrectable Mirrored Demand Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Non-Aliased Uncorrectable Non-Mirrored Demand Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Aliased Uncorrectable Patrol Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Aliased Uncorrectable Resilver- or Spare-Copy Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Aliased Uncorrectable Mirrored Demand Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Aliased Uncorrectable Non-Mirrored Demand Data ECC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;Uncorrectable Data ECC on Replay&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define GET_FBD_NF_IDX(fbderr)	(fbderr &amp; (3 &lt;&lt; 28))</span>
<span class="cp">#define FERR_NF_FBD_ERR_MASK ((1 &lt;&lt; 24) | (1 &lt;&lt; 23) | (1 &lt;&lt; 22) | (1 &lt;&lt; 21) |\</span>
<span class="cp">			      (1 &lt;&lt; 18) | (1 &lt;&lt; 17) | (1 &lt;&lt; 16) | (1 &lt;&lt; 15) |\</span>
<span class="cp">			      (1 &lt;&lt; 14) | (1 &lt;&lt; 13) | (1 &lt;&lt; 11) | (1 &lt;&lt; 10) |\</span>
<span class="cp">			      (1 &lt;&lt; 9)  | (1 &lt;&lt; 8)  | (1 &lt;&lt; 7)  | (1 &lt;&lt; 6)  |\</span>
<span class="cp">			      (1 &lt;&lt; 5)  | (1 &lt;&lt; 4)  | (1 &lt;&lt; 3)  | (1 &lt;&lt; 2)  |\</span>
<span class="cp">			      (1 &lt;&lt; 1)  | (1 &lt;&lt; 0))</span>

<span class="cp">#define EMASK_FBD	0xa8</span>
<span class="cp">#define EMASK_FBD_ERR_MASK ((1 &lt;&lt; 27) | (1 &lt;&lt; 26) | (1 &lt;&lt; 25) | (1 &lt;&lt; 24) |\</span>
<span class="cp">			    (1 &lt;&lt; 22) | (1 &lt;&lt; 21) | (1 &lt;&lt; 20) | (1 &lt;&lt; 19) |\</span>
<span class="cp">			    (1 &lt;&lt; 18) | (1 &lt;&lt; 17) | (1 &lt;&lt; 16) | (1 &lt;&lt; 14) |\</span>
<span class="cp">			    (1 &lt;&lt; 13) | (1 &lt;&lt; 12) | (1 &lt;&lt; 11) | (1 &lt;&lt; 10) |\</span>
<span class="cp">			    (1 &lt;&lt; 9)  | (1 &lt;&lt; 8)  | (1 &lt;&lt; 7)  | (1 &lt;&lt; 6)  |\</span>
<span class="cp">			    (1 &lt;&lt; 5)  | (1 &lt;&lt; 4)  | (1 &lt;&lt; 3)  | (1 &lt;&lt; 2)  |\</span>
<span class="cp">			    (1 &lt;&lt; 1)  | (1 &lt;&lt; 0))</span>

<span class="cm">/*</span>
<span class="cm"> * Device 16.2: Global Error Registers</span>
<span class="cm"> */</span>

<span class="cp">#define FERR_GLOBAL_HI	0x48</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ferr_global_hi_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FSB 3 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FSB 2 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FSB 1 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FSB 0 Fatal Error&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define ferr_global_hi_is_fatal(errno)	1</span>

<span class="cp">#define FERR_GLOBAL_LO	0x40</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ferr_global_lo_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Internal MCH Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Intel QuickData Technology Device Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FSB1 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">28</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FSB0 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">27</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FBD Channel 3 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FBD Channel 2 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">25</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FBD Channel 1 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FBD Channel 0 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PCI Express Device 7Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PCI Express Device 6 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PCI Express Device 5 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PCI Express Device 4 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PCI Express Device 3 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PCI Express Device 2 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PCI Express Device 1 Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ESI Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Internal MCH Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Intel QuickData Technology Device Non Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FSB1 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FSB 0 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FBD Channel 3 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FBD Channel 2 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">9</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;FBD Channel 1 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;FBD Channel 0 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">7</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;PCI Express Device 7 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;PCI Express Device 6 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;PCI Express Device 5 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;PCI Express Device 4 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;PCI Express Device 3 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;PCI Express Device 2 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;PCI Express Device 1 Non-Fatal Error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;ESI Non-Fatal Error&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define ferr_global_lo_is_fatal(errno)	((errno &lt; 16) ? 0 : 1)</span>

<span class="cp">#define NRECMEMA	0xbe</span>
  <span class="cp">#define NRECMEMA_BANK(v)	(((v) &gt;&gt; 12) &amp; 7)</span>
  <span class="cp">#define NRECMEMA_RANK(v)	(((v) &gt;&gt; 8) &amp; 15)</span>

<span class="cp">#define NRECMEMB	0xc0</span>
  <span class="cp">#define NRECMEMB_IS_WR(v)	((v) &amp; (1 &lt;&lt; 31))</span>
  <span class="cp">#define NRECMEMB_CAS(v)	(((v) &gt;&gt; 16) &amp; 0x1fff)</span>
  <span class="cp">#define NRECMEMB_RAS(v)	((v) &amp; 0xffff)</span>

<span class="cp">#define REDMEMA		0xdc</span>

<span class="cp">#define REDMEMB		0x7c</span>
  <span class="cp">#define IS_SECOND_CH(v)	((v) * (1 &lt;&lt; 17))</span>

<span class="cp">#define RECMEMA		0xe0</span>
  <span class="cp">#define RECMEMA_BANK(v)	(((v) &gt;&gt; 12) &amp; 7)</span>
  <span class="cp">#define RECMEMA_RANK(v)	(((v) &gt;&gt; 8) &amp; 15)</span>

<span class="cp">#define RECMEMB		0xe4</span>
  <span class="cp">#define RECMEMB_IS_WR(v)	((v) &amp; (1 &lt;&lt; 31))</span>
  <span class="cp">#define RECMEMB_CAS(v)	(((v) &gt;&gt; 16) &amp; 0x1fff)</span>
  <span class="cp">#define RECMEMB_RAS(v)	((v) &amp; 0xffff)</span>

<span class="cm">/********************************************</span>
<span class="cm"> * i7300 Functions related to error detection</span>
<span class="cm"> ********************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * get_err_from_table() - Gets the error message from a table</span>
<span class="cm"> * @table:	table name (array of char *)</span>
<span class="cm"> * @size:	number of elements at the table</span>
<span class="cm"> * @pos:	position of the element to be returned</span>
<span class="cm"> *</span>
<span class="cm"> * This is a small routine that gets the pos-th element of a table. If the</span>
<span class="cm"> * element doesn&#39;t exist (or it is empty), it returns &quot;reserved&quot;.</span>
<span class="cm"> * Instead of calling it directly, the better is to call via the macro</span>
<span class="cm"> * GET_ERR_FROM_TABLE(), that automatically checks the table size via</span>
<span class="cm"> * ARRAY_SIZE() macro</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_err_from_table</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">table</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="s">&quot;Reserved&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">]))</span>
		<span class="k">return</span> <span class="s">&quot;Reserved&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">table</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#define GET_ERR_FROM_TABLE(table, pos)				\</span>
<span class="cp">	get_err_from_table(table, ARRAY_SIZE(table), pos)</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_process_error_global() - Retrieve the hardware error information from</span>
<span class="cm"> *				  the hardware global error registers and</span>
<span class="cm"> *				  sends it to dmesg</span>
<span class="cm"> * @mci: struct mem_ctl_info pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i7300_process_error_global</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">errnum</span><span class="p">,</span> <span class="n">error_reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">errors</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">specific</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_fatal</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/* read in the 1st FATAL error register */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">,</span>
			      <span class="n">FERR_GLOBAL_HI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error_reg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">errors</span> <span class="o">=</span> <span class="n">error_reg</span><span class="p">;</span>
		<span class="n">errnum</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">errors</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ferr_global_hi_name</span><span class="p">));</span>
		<span class="n">specific</span> <span class="o">=</span> <span class="n">GET_ERR_FROM_TABLE</span><span class="p">(</span><span class="n">ferr_global_hi_name</span><span class="p">,</span> <span class="n">errnum</span><span class="p">);</span>
		<span class="n">is_fatal</span> <span class="o">=</span> <span class="n">ferr_global_hi_is_fatal</span><span class="p">(</span><span class="n">errnum</span><span class="p">);</span>

		<span class="cm">/* Clear the error bit */</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">,</span>
				       <span class="n">FERR_GLOBAL_HI</span><span class="p">,</span> <span class="n">error_reg</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">error_global</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">,</span>
			      <span class="n">FERR_GLOBAL_LO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error_reg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">errors</span> <span class="o">=</span> <span class="n">error_reg</span><span class="p">;</span>
		<span class="n">errnum</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">errors</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ferr_global_lo_name</span><span class="p">));</span>
		<span class="n">specific</span> <span class="o">=</span> <span class="n">GET_ERR_FROM_TABLE</span><span class="p">(</span><span class="n">ferr_global_lo_name</span><span class="p">,</span> <span class="n">errnum</span><span class="p">);</span>
		<span class="n">is_fatal</span> <span class="o">=</span> <span class="n">ferr_global_lo_is_fatal</span><span class="p">(</span><span class="n">errnum</span><span class="p">);</span>

		<span class="cm">/* Clear the error bit */</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">,</span>
				       <span class="n">FERR_GLOBAL_LO</span><span class="p">,</span> <span class="n">error_reg</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">error_global</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">error_global:</span>
	<span class="n">i7300_mc_printk</span><span class="p">(</span><span class="n">mci</span><span class="p">,</span> <span class="n">KERN_EMERG</span><span class="p">,</span> <span class="s">&quot;%s misc error: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">is_fatal</span> <span class="o">?</span> <span class="s">&quot;Fatal&quot;</span> <span class="o">:</span> <span class="s">&quot;NOT fatal&quot;</span><span class="p">,</span> <span class="n">specific</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_process_fbd_error() - Retrieve the hardware error information from</span>
<span class="cm"> *			       the FBD error registers and sends it via</span>
<span class="cm"> *			       EDAC error API calls</span>
<span class="cm"> * @mci: struct mem_ctl_info pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i7300_process_fbd_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">errnum</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">error_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val16</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">branch</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">cas</span><span class="p">,</span> <span class="n">ras</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">syndrome</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">errors</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">specific</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_wr</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/* read in the 1st FATAL error register */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
			      <span class="n">FERR_FAT_FBD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error_reg</span> <span class="o">&amp;</span> <span class="n">FERR_FAT_FBD_ERR_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">errors</span> <span class="o">=</span> <span class="n">error_reg</span> <span class="o">&amp;</span> <span class="n">FERR_FAT_FBD_ERR_MASK</span> <span class="p">;</span>
		<span class="n">errnum</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">errors</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ferr_fat_fbd_name</span><span class="p">));</span>
		<span class="n">specific</span> <span class="o">=</span> <span class="n">GET_ERR_FROM_TABLE</span><span class="p">(</span><span class="n">ferr_fat_fbd_name</span><span class="p">,</span> <span class="n">errnum</span><span class="p">);</span>
		<span class="n">branch</span> <span class="o">=</span> <span class="p">(</span><span class="n">GET_FBD_FAT_IDX</span><span class="p">(</span><span class="n">error_reg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
				     <span class="n">NRECMEMA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val16</span><span class="p">);</span>
		<span class="n">bank</span> <span class="o">=</span> <span class="n">NRECMEMA_BANK</span><span class="p">(</span><span class="n">val16</span><span class="p">);</span>
		<span class="n">rank</span> <span class="o">=</span> <span class="n">NRECMEMA_RANK</span><span class="p">(</span><span class="n">val16</span><span class="p">);</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
				<span class="n">NRECMEMB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
		<span class="n">is_wr</span> <span class="o">=</span> <span class="n">NRECMEMB_IS_WR</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
		<span class="n">cas</span> <span class="o">=</span> <span class="n">NRECMEMB_CAS</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
		<span class="n">ras</span> <span class="o">=</span> <span class="n">NRECMEMB_RAS</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

		<span class="cm">/* Clean the error register */</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
				<span class="n">FERR_FAT_FBD</span><span class="p">,</span> <span class="n">error_reg</span><span class="p">);</span>

		<span class="n">snprintf</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			 <span class="s">&quot;Bank=%d RAS=%d CAS=%d Err=0x%lx (%s))&quot;</span><span class="p">,</span>
			 <span class="n">bank</span><span class="p">,</span> <span class="n">ras</span><span class="p">,</span> <span class="n">cas</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">specific</span><span class="p">);</span>

		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_FATAL</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">branch</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span>
				     <span class="n">is_wr</span> <span class="o">?</span> <span class="s">&quot;Write error&quot;</span> <span class="o">:</span> <span class="s">&quot;Read error&quot;</span><span class="p">,</span>
				     <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="cm">/* read in the 1st NON-FATAL error register */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
			      <span class="n">FERR_NF_FBD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error_reg</span> <span class="o">&amp;</span> <span class="n">FERR_NF_FBD_ERR_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">errors</span> <span class="o">=</span> <span class="n">error_reg</span> <span class="o">&amp;</span> <span class="n">FERR_NF_FBD_ERR_MASK</span><span class="p">;</span>
		<span class="n">errnum</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">errors</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ferr_nf_fbd_name</span><span class="p">));</span>
		<span class="n">specific</span> <span class="o">=</span> <span class="n">GET_ERR_FROM_TABLE</span><span class="p">(</span><span class="n">ferr_nf_fbd_name</span><span class="p">,</span> <span class="n">errnum</span><span class="p">);</span>
		<span class="n">branch</span> <span class="o">=</span> <span class="p">(</span><span class="n">GET_FBD_FAT_IDX</span><span class="p">(</span><span class="n">error_reg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
			<span class="n">REDMEMA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">syndrome</span><span class="p">);</span>

		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
				     <span class="n">RECMEMA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val16</span><span class="p">);</span>
		<span class="n">bank</span> <span class="o">=</span> <span class="n">RECMEMA_BANK</span><span class="p">(</span><span class="n">val16</span><span class="p">);</span>
		<span class="n">rank</span> <span class="o">=</span> <span class="n">RECMEMA_RANK</span><span class="p">(</span><span class="n">val16</span><span class="p">);</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
				<span class="n">RECMEMB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
		<span class="n">is_wr</span> <span class="o">=</span> <span class="n">RECMEMB_IS_WR</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
		<span class="n">cas</span> <span class="o">=</span> <span class="n">RECMEMB_CAS</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
		<span class="n">ras</span> <span class="o">=</span> <span class="n">RECMEMB_RAS</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
				     <span class="n">REDMEMB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">branch</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_SECOND_CH</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
			<span class="n">channel</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Clear the error bit */</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
				<span class="n">FERR_NF_FBD</span><span class="p">,</span> <span class="n">error_reg</span><span class="p">);</span>

		<span class="cm">/* Form out message */</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			 <span class="s">&quot;DRAM-Bank=%d RAS=%d CAS=%d, Err=0x%lx (%s))&quot;</span><span class="p">,</span>
			 <span class="n">bank</span><span class="p">,</span> <span class="n">ras</span><span class="p">,</span> <span class="n">cas</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">specific</span><span class="p">);</span>

		<span class="n">edac_mc_handle_error</span><span class="p">(</span><span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span> <span class="n">mci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">syndrome</span><span class="p">,</span>
				     <span class="n">branch</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">channel</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span>
				     <span class="n">is_wr</span> <span class="o">?</span> <span class="s">&quot;Write error&quot;</span> <span class="o">:</span> <span class="s">&quot;Read error&quot;</span><span class="p">,</span>
				     <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_check_error() - Calls the error checking subroutines</span>
<span class="cm"> * @mci: struct mem_ctl_info pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i7300_check_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i7300_process_error_global</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="n">i7300_process_fbd_error</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_clear_error() - Clears the error registers</span>
<span class="cm"> * @mci: struct mem_ctl_info pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i7300_clear_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * All error values are RWC - we need to read and write 1 to the</span>
<span class="cm">	 * bit that we want to cleanup</span>
<span class="cm">	 */</span>

	<span class="cm">/* Clear global error registers */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">,</span>
			      <span class="n">FERR_GLOBAL_HI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">,</span>
			      <span class="n">FERR_GLOBAL_HI</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">,</span>
			      <span class="n">FERR_GLOBAL_LO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">,</span>
			      <span class="n">FERR_GLOBAL_LO</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="cm">/* Clear FBD error registers */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
			      <span class="n">FERR_FAT_FBD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
			      <span class="n">FERR_FAT_FBD</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
			      <span class="n">FERR_NF_FBD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
			      <span class="n">FERR_NF_FBD</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_enable_error_reporting() - Enable the memory reporting logic at the</span>
<span class="cm"> *				    hardware</span>
<span class="cm"> * @mci: struct mem_ctl_info pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i7300_enable_error_reporting</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fbd_error_mask</span><span class="p">;</span>

	<span class="cm">/* Read the FBD Error Mask Register */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
			      <span class="n">EMASK_FBD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbd_error_mask</span><span class="p">);</span>

	<span class="cm">/* Enable with a &#39;0&#39; */</span>
	<span class="n">fbd_error_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">EMASK_FBD_ERR_MASK</span><span class="p">);</span>

	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span>
			       <span class="n">EMASK_FBD</span><span class="p">,</span> <span class="n">fbd_error_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/************************************************</span>
<span class="cm"> * i7300 Functions related to memory enumberation</span>
<span class="cm"> ************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * decode_mtr() - Decodes the MTR descriptor, filling the edac structs</span>
<span class="cm"> * @pvt: pointer to the private data struct used by i7300 driver</span>
<span class="cm"> * @slot: DIMM slot (0 to 7)</span>
<span class="cm"> * @ch: Channel number within the branch (0 or 1)</span>
<span class="cm"> * @branch: Branch number (0 or 1)</span>
<span class="cm"> * @dinfo: Pointer to DIMM info where dimm size is stored</span>
<span class="cm"> * @p_csrow: Pointer to the struct csrow_info that corresponds to that element</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_mtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">branch</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">i7300_dimm_info</span> <span class="o">*</span><span class="n">dinfo</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mtr</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">addrBits</span><span class="p">,</span> <span class="n">channel</span><span class="p">;</span>

	<span class="n">channel</span> <span class="o">=</span> <span class="n">to_channel</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">branch</span><span class="p">);</span>

	<span class="n">mtr</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mtr</span><span class="p">[</span><span class="n">slot</span><span class="p">][</span><span class="n">branch</span><span class="p">];</span>
	<span class="n">ans</span> <span class="o">=</span> <span class="n">MTR_DIMMS_PRESENT</span><span class="p">(</span><span class="n">mtr</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">MTR%d CH%d: DIMMs are %s (mtr)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">slot</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
		<span class="n">ans</span> <span class="o">?</span> <span class="s">&quot;Present&quot;</span> <span class="o">:</span> <span class="s">&quot;NOT Present&quot;</span><span class="p">);</span>

	<span class="cm">/* Determine if there is a DIMM present in this DIMM slot */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ans</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Start with the number of bits for a Bank</span>
<span class="cm">	* on the DRAM */</span>
	<span class="n">addrBits</span> <span class="o">=</span> <span class="n">MTR_DRAM_BANKS_ADDR_BITS</span><span class="p">;</span>
	<span class="cm">/* Add thenumber of ROW bits */</span>
	<span class="n">addrBits</span> <span class="o">+=</span> <span class="n">MTR_DIMM_ROWS_ADDR_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>
	<span class="cm">/* add the number of COLUMN bits */</span>
	<span class="n">addrBits</span> <span class="o">+=</span> <span class="n">MTR_DIMM_COLS_ADDR_BITS</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>
	<span class="cm">/* add the number of RANK bits */</span>
	<span class="n">addrBits</span> <span class="o">+=</span> <span class="n">MTR_DIMM_RANKS</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>

	<span class="n">addrBits</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>	<span class="cm">/* add 64 bits per DIMM */</span>
	<span class="n">addrBits</span> <span class="o">-=</span> <span class="mi">20</span><span class="p">;</span>	<span class="cm">/* divide by 2^^20 */</span>
	<span class="n">addrBits</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* 8 bits per bytes */</span>

	<span class="n">dinfo</span><span class="o">-&gt;</span><span class="n">megabytes</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">addrBits</span><span class="p">;</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">WIDTH: x%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MTR_DRAM_WIDTH</span><span class="p">(</span><span class="n">mtr</span><span class="p">));</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">ELECTRICAL THROTTLING is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">MTR_DIMMS_ETHROTTLE</span><span class="p">(</span><span class="n">mtr</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">);</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">NUMBANK: %d bank(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MTR_DRAM_BANKS</span><span class="p">(</span><span class="n">mtr</span><span class="p">));</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">NUMRANK: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MTR_DIMM_RANKS</span><span class="p">(</span><span class="n">mtr</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;double&quot;</span> <span class="o">:</span> <span class="s">&quot;single&quot;</span><span class="p">);</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">NUMROW: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">numrow_toString</span><span class="p">[</span><span class="n">MTR_DIMM_ROWS</span><span class="p">(</span><span class="n">mtr</span><span class="p">)]);</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">NUMCOL: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">numcol_toString</span><span class="p">[</span><span class="n">MTR_DIMM_COLS</span><span class="p">(</span><span class="n">mtr</span><span class="p">)]);</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">SIZE: %d MB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dinfo</span><span class="o">-&gt;</span><span class="n">megabytes</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The type of error detection actually depends of the</span>
<span class="cm">	 * mode of operation. When it is just one single memory chip, at</span>
<span class="cm">	 * socket 0, channel 0, it uses 8-byte-over-32-byte SECDED+ code.</span>
<span class="cm">	 * In normal or mirrored mode, it uses Lockstep mode,</span>
<span class="cm">	 * with the possibility of using an extended algorithm for x8 memories</span>
<span class="cm">	 * See datasheet Sections 7.3.6 to 7.3.8</span>
<span class="cm">	 */</span>

	<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">MiB_TO_PAGES</span><span class="p">(</span><span class="n">dinfo</span><span class="o">-&gt;</span><span class="n">megabytes</span><span class="p">);</span>
	<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">grain</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">mtype</span> <span class="o">=</span> <span class="n">MEM_FB_DDR2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SINGLE_MODE</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_settings_a</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">edac_mode</span> <span class="o">=</span> <span class="n">EDAC_SECDED</span><span class="p">;</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">ECC code is 8-byte-over-32-byte SECDED+ code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">ECC code is on Lockstep mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">MTR_DRAM_WIDTH</span><span class="p">(</span><span class="n">mtr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">edac_mode</span> <span class="o">=</span> <span class="n">EDAC_S8ECD8ED</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">edac_mode</span> <span class="o">=</span> <span class="n">EDAC_S4ECD4ED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ask what device type on this row */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MTR_DRAM_WIDTH</span><span class="p">(</span><span class="n">mtr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Scrub algorithm for x8 is on %s mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">IS_SCRBALGO_ENHANCED</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_settings</span><span class="p">)</span> <span class="o">?</span>
					    <span class="s">&quot;enhanced&quot;</span> <span class="o">:</span> <span class="s">&quot;normal&quot;</span><span class="p">);</span>

		<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">DEV_X8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dimm</span><span class="o">-&gt;</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">DEV_X4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mtr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * print_dimm_size() - Prints dump of the memory organization</span>
<span class="cm"> * @pvt: pointer to the private data struct used by i7300 driver</span>
<span class="cm"> *</span>
<span class="cm"> * Useful for debug. If debug is disabled, this routine do nothing</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_dimm_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_EDAC_DEBUG</span>
	<span class="k">struct</span> <span class="n">i7300_dimm_info</span> <span class="o">*</span><span class="n">dinfo</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">space</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="n">slot</span><span class="p">;</span>

	<span class="n">space</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;              &quot;</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">channel</span> <span class="o">&lt;</span> <span class="n">MAX_CHANNELS</span><span class="p">;</span> <span class="n">channel</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;channel %d | &quot;</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;-------------------------------&quot;</span>
			       <span class="s">&quot;------------------------------&quot;</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="n">MAX_SLOTS</span><span class="p">;</span> <span class="n">slot</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;csrow/SLOT %d  &quot;</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">channel</span> <span class="o">&lt;</span> <span class="n">MAX_CHANNELS</span><span class="p">;</span> <span class="n">channel</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dimm_info</span><span class="p">[</span><span class="n">slot</span><span class="p">][</span><span class="n">channel</span><span class="p">];</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;%4d MB   | &quot;</span><span class="p">,</span> <span class="n">dinfo</span><span class="o">-&gt;</span><span class="n">megabytes</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="s">&quot;-------------------------------&quot;</span>
			       <span class="s">&quot;------------------------------&quot;</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_init_csrows() - Initialize the &#39;csrows&#39; table within</span>
<span class="cm"> *			 the mci control structure with the</span>
<span class="cm"> *			 addressing of memory.</span>
<span class="cm"> * @mci: struct mem_ctl_info pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i7300_init_csrows</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i7300_dimm_info</span> <span class="o">*</span><span class="n">dinfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="n">branch</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;Memory Technology Registers:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Get the AMB present registers for the four channels */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">branch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">branch</span> <span class="o">&lt;</span> <span class="n">MAX_BRANCHES</span><span class="p">;</span> <span class="n">branch</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read and dump branch 0&#39;s MTRs */</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">to_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">branch</span><span class="p">);</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_2x_0_fbd_branch</span><span class="p">[</span><span class="n">branch</span><span class="p">],</span>
				     <span class="n">AMBPRESENT_0</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ambpresent</span><span class="p">[</span><span class="n">channel</span><span class="p">]);</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">AMB-present CH%d = 0x%x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">channel</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ambpresent</span><span class="p">[</span><span class="n">channel</span><span class="p">]);</span>

		<span class="n">channel</span> <span class="o">=</span> <span class="n">to_channel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">branch</span><span class="p">);</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_2x_0_fbd_branch</span><span class="p">[</span><span class="n">branch</span><span class="p">],</span>
				     <span class="n">AMBPRESENT_1</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ambpresent</span><span class="p">[</span><span class="n">channel</span><span class="p">]);</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">AMB-present CH%d = 0x%x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">channel</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ambpresent</span><span class="p">[</span><span class="n">channel</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* Get the set of MTR[0-7] regs by each branch */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="n">MAX_SLOTS</span><span class="p">;</span> <span class="n">slot</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">where</span> <span class="o">=</span> <span class="n">mtr_regs</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">branch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">branch</span> <span class="o">&lt;</span> <span class="n">MAX_BRANCHES</span><span class="p">;</span> <span class="n">branch</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_2x_0_fbd_branch</span><span class="p">[</span><span class="n">branch</span><span class="p">],</span>
					<span class="n">where</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mtr</span><span class="p">[</span><span class="n">slot</span><span class="p">][</span><span class="n">branch</span><span class="p">]);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ch</span> <span class="o">&lt;</span> <span class="n">MAX_CH_PER_BRANCH</span><span class="p">;</span> <span class="n">ch</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">to_channel</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">branch</span><span class="p">);</span>

				<span class="n">dimm</span> <span class="o">=</span> <span class="n">EDAC_DIMM_PTR</span><span class="p">(</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">,</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">dimms</span><span class="p">,</span>
					       <span class="n">mci</span><span class="o">-&gt;</span><span class="n">n_layers</span><span class="p">,</span> <span class="n">branch</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

				<span class="n">dinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">dimm_info</span><span class="p">[</span><span class="n">slot</span><span class="p">][</span><span class="n">channel</span><span class="p">];</span>

				<span class="n">mtr</span> <span class="o">=</span> <span class="n">decode_mtr</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">branch</span><span class="p">,</span>
						 <span class="n">dinfo</span><span class="p">,</span> <span class="n">dimm</span><span class="p">);</span>

				<span class="cm">/* if no DIMMS on this row, continue */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MTR_DIMMS_PRESENT</span><span class="p">(</span><span class="n">mtr</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * decode_mir() - Decodes Memory Interleave Register (MIR) info</span>
<span class="cm"> * @int mir_no: number of the MIR register to decode</span>
<span class="cm"> * @mir: array with the MIR data cached on the driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_mir</span><span class="p">(</span><span class="kt">int</span> <span class="n">mir_no</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mir</span><span class="p">[</span><span class="n">MAX_MIR</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mir</span><span class="p">[</span><span class="n">mir_no</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MIR%d: limit= 0x%x Branch(es) that participate:&quot;</span>
			<span class="s">&quot; %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mir_no</span><span class="p">,</span>
			<span class="p">(</span><span class="n">mir</span><span class="p">[</span><span class="n">mir_no</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">,</span>
			<span class="p">(</span><span class="n">mir</span><span class="p">[</span><span class="n">mir_no</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;B0&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">mir</span><span class="p">[</span><span class="n">mir_no</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;B1&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_get_mc_regs() - Get the contents of the MC enumeration registers</span>
<span class="cm"> * @mci: struct mem_ctl_info pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Data read is cached internally for its usage when needed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i7300_get_mc_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">actual_tolm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_0_fsb_ctlr</span><span class="p">,</span> <span class="n">AMBASE</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ambase</span><span class="p">);</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;AMBASE= 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">ambase</span><span class="p">);</span>

	<span class="cm">/* Get the Branch Map regs */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span> <span class="n">TOLM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span><span class="p">);</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span> <span class="o">&gt;&gt;=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;TOLM (number of 256M regions) =%u (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span><span class="p">);</span>

	<span class="n">actual_tolm</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="mi">1000l</span> <span class="o">*</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="mi">28</span><span class="p">));</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;Actual TOLM byte addr=%u.%03u GB (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">actual_tolm</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="n">actual_tolm</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tolm</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>

	<span class="cm">/* Get memory controller settings */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span> <span class="n">MC_SETTINGS</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_settings</span><span class="p">);</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span> <span class="n">MC_SETTINGS_A</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_settings_a</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SINGLE_MODE</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_settings_a</span><span class="p">))</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Memory controller operating on single mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Memory controller operating on %s mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">IS_MIRRORED</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_settings</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;mirrored&quot;</span> <span class="o">:</span> <span class="s">&quot;non-mirrored&quot;</span><span class="p">);</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Error detection is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">IS_ECC_ENABLED</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_settings</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">);</span>
	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;Retry is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">IS_RETRY_ENABLED</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mc_settings</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">);</span>

	<span class="cm">/* Get Memory Interleave Range registers */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span> <span class="n">MIR0</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span> <span class="n">MIR1</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">,</span> <span class="n">MIR2</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="cm">/* Decode the MIR regs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_MIR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">decode_mir</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">mir</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">i7300_init_csrows</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Go and determine the size of each DIMM and place in an</span>
<span class="cm">	 * orderly matrix */</span>
	<span class="n">print_dimm_size</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*************************************************</span>
<span class="cm"> * i7300 Functions related to device probe/release</span>
<span class="cm"> *************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_put_devices() - Release the PCI devices</span>
<span class="cm"> * @mci: struct mem_ctl_info pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i7300_put_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">branch</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/* Decrement usage count for devices */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">branch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">branch</span> <span class="o">&lt;</span> <span class="n">MAX_CH_PER_BRANCH</span><span class="p">;</span> <span class="n">branch</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_2x_0_fbd_branch</span><span class="p">[</span><span class="n">branch</span><span class="p">]);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_get_devices() - Find and perform &#39;get&#39; operation on the MCH&#39;s</span>
<span class="cm"> *			 device/functions we want to reference for this driver</span>
<span class="cm"> * @mci: struct mem_ctl_info pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Access and prepare the several devices for usage:</span>
<span class="cm"> * I7300 devices used by this driver:</span>
<span class="cm"> *    Device 16, functions 0,1 and 2:	PCI_DEVICE_ID_INTEL_I7300_MCH_ERR</span>
<span class="cm"> *    Device 21 function 0:		PCI_DEVICE_ID_INTEL_I7300_MCH_FB0</span>
<span class="cm"> *    Device 22 function 0:		PCI_DEVICE_ID_INTEL_I7300_MCH_FB1</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">i7300_get_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>

	<span class="cm">/* Attempt to &#39;get&#39; the MCH register we want */</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
				      <span class="n">PCI_DEVICE_ID_INTEL_I7300_MCH_ERR</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* End of list, leave */</span>
			<span class="n">i7300_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
				<span class="s">&quot;&#39;system address,Process Bus&#39; &quot;</span>
				<span class="s">&quot;device not found:&quot;</span>
				<span class="s">&quot;vendor 0x%x device 0x%x ERR funcs &quot;</span>
				<span class="s">&quot;(broken BIOS?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
				<span class="n">PCI_DEVICE_ID_INTEL_I7300_MCH_ERR</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Store device 16 funcs 1 and 2 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;System Address, processor bus- PCI Bus ID: %s  %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pci_name</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_0_fsb_ctlr</span><span class="p">),</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_0_fsb_ctlr</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_0_fsb_ctlr</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;Branchmap, control and errors - PCI Bus ID: %s  %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pci_name</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="p">),</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_1_fsb_addr_map</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;FSB Error Regs - PCI Bus ID: %s  %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pci_name</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="p">),</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_2_fsb_err_regs</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_2x_0_fbd_branch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
					    <span class="n">PCI_DEVICE_ID_INTEL_I7300_MCH_FB0</span><span class="p">,</span>
					    <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_2x_0_fbd_branch</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">i7300_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="s">&quot;MC: &#39;BRANCH 0&#39; device not found:&quot;</span>
			<span class="s">&quot;vendor 0x%x device 0x%x Func 0 (broken BIOS?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_I7300_MCH_FB0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_2x_0_fbd_branch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
					    <span class="n">PCI_DEVICE_ID_INTEL_I7300_MCH_FB1</span><span class="p">,</span>
					    <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_2x_0_fbd_branch</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">i7300_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="s">&quot;MC: &#39;BRANCH 1&#39; device not found:&quot;</span>
			<span class="s">&quot;vendor 0x%x device 0x%x Func 0 &quot;</span>
			<span class="s">&quot;(broken BIOS?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_INTEL_I7300_MCH_FB1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">i7300_put_devices</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_init_one() - Probe for one instance of the device</span>
<span class="cm"> * @pdev: struct pci_dev pointer</span>
<span class="cm"> * @id: struct pci_device_id pointer - currently unused</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">i7300_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="n">layers</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* wake up device */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span> <span class="s">&quot;: %s(), pdev bus %u dev=0x%x fn=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
		<span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">));</span>

	<span class="cm">/* We only are looking for func 0 of the set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* allocate a new MC control structure */</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_BRANCH</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">MAX_BRANCHES</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_CHANNEL</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">MAX_CH_PER_BRANCH</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">EDAC_MC_LAYER_SLOT</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">MAX_SLOTS</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">is_virt_csrow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">mci</span> <span class="o">=</span> <span class="n">edac_mc_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">layers</span><span class="p">),</span> <span class="n">layers</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pvt</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span> <span class="s">&quot;: %s(): mci = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">mci</span><span class="p">);</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>	<span class="cm">/* record ptr  to the generic device */</span>

	<span class="n">pvt</span> <span class="o">=</span> <span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">pci_dev_16_0_fsb_ctlr</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>	<span class="cm">/* Record this device in our private */</span>

	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* &#39;get&#39; the pci devices we want to reserve for our use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i7300_get_devices</span><span class="p">(</span><span class="n">mci</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>

	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mc_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mtype_cap</span> <span class="o">=</span> <span class="n">MEM_FLAG_FB_DDR2</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_ctl_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_name</span> <span class="o">=</span> <span class="s">&quot;i7300_edac.c&quot;</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">mod_ver</span> <span class="o">=</span> <span class="n">I7300_REVISION</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_name</span> <span class="o">=</span> <span class="n">i7300_devs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ctl_name</span><span class="p">;</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">dev_name</span> <span class="o">=</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">ctl_page_to_phys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Set the function pointer to an actual operation function */</span>
	<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_check</span> <span class="o">=</span> <span class="n">i7300_check_error</span><span class="p">;</span>

	<span class="cm">/* initialize the MC control structure &#39;csrows&#39; table</span>
<span class="cm">	 * with the mapping and control information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i7300_get_mc_regs</span><span class="p">(</span><span class="n">mci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: Setting mci-&gt;edac_cap to EDAC_FLAG_NONE</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;    because i7300_init_csrows() returned nonzero &quot;</span>
			<span class="s">&quot;value</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mci</span><span class="o">-&gt;</span><span class="n">edac_cap</span> <span class="o">=</span> <span class="n">EDAC_FLAG_NONE</span><span class="p">;</span>	<span class="cm">/* no csrows found */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">debugf1</span><span class="p">(</span><span class="s">&quot;MC: Enable error reporting now</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">i7300_enable_error_reporting</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* add this new MC control structure to EDAC&#39;s list of MCs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edac_mc_add_mc</span><span class="p">(</span><span class="n">mci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debugf0</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span>
			<span class="s">&quot;: %s(): failed edac_mc_add_mc()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* FIXME: perhaps some code should go here that disables error</span>
<span class="cm">		 * reporting if we just enabled it</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i7300_clear_error</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="cm">/* allocating generic PCI control info */</span>
	<span class="n">i7300_pci</span> <span class="o">=</span> <span class="n">edac_pci_create_generic_ctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">EDAC_MOD_STR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i7300_pci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;%s(): Unable to create PCI control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;%s(): PCI error report via EDAC not setup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Error exit unwinding stack */</span>
<span class="nl">fail1:</span>

	<span class="n">i7300_put_devices</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

<span class="nl">fail0:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">);</span>
	<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_remove_one() - Remove the driver</span>
<span class="cm"> * @pdev: struct pci_dev pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">i7300_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">debugf0</span><span class="p">(</span><span class="n">__FILE__</span> <span class="s">&quot;: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i7300_pci</span><span class="p">)</span>
		<span class="n">edac_pci_release_generic_ctl</span><span class="p">(</span><span class="n">i7300_pci</span><span class="p">);</span>

	<span class="n">mci</span> <span class="o">=</span> <span class="n">edac_mc_del_mc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mci</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">i7300_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">mci</span><span class="o">-&gt;</span><span class="n">pvt_info</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tmp_prt_buffer</span><span class="p">;</span>

	<span class="cm">/* retrieve references to resources, and free those resources */</span>
	<span class="n">i7300_put_devices</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">edac_mc_free</span><span class="p">(</span><span class="n">mci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pci_device_id: table for which devices we are looking for</span>
<span class="cm"> *</span>
<span class="cm"> * Has only 8086:360c PCI ID</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">i7300_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_I7300_MCH_ERR</span><span class="p">)},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,}</span>			<span class="cm">/* 0 terminated list. */</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">i7300_pci_tbl</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * i7300_driver: pci_driver structure for this module</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">i7300_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;i7300_edac&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">i7300_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">i7300_remove_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">i7300_pci_tbl</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_init() - Registers the driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">i7300_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pci_rc</span><span class="p">;</span>

	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span> <span class="s">&quot;: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Ensure that the OPSTATE is set correctly for POLL or NMI */</span>
	<span class="n">opstate_init</span><span class="p">();</span>

	<span class="n">pci_rc</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i7300_driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">pci_rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">pci_rc</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i7300_init() - Unregisters the driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">i7300_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugf2</span><span class="p">(</span><span class="s">&quot;MC: &quot;</span> <span class="n">__FILE__</span> <span class="s">&quot;: %s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i7300_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">i7300_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">i7300_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Red Hat Inc. (http://www.redhat.com)&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MC Driver for Intel I7300 memory controllers - &quot;</span>
		   <span class="n">I7300_REVISION</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">edac_op_state</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edac_op_state</span><span class="p">,</span> <span class="s">&quot;EDAC Error Reporting state: 0=Poll,1=NMI&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
