<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › w1 › masters › ds2490.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ds2490.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	dscore.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004 Evgeniy Polyakov &lt;zbr@ioremap.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;../w1_int.h&quot;</span>
<span class="cp">#include &quot;../w1.h&quot;</span>

<span class="cm">/* COMMAND TYPE CODES */</span>
<span class="cp">#define CONTROL_CMD			0x00</span>
<span class="cp">#define COMM_CMD			0x01</span>
<span class="cp">#define MODE_CMD			0x02</span>

<span class="cm">/* CONTROL COMMAND CODES */</span>
<span class="cp">#define CTL_RESET_DEVICE		0x0000</span>
<span class="cp">#define CTL_START_EXE			0x0001</span>
<span class="cp">#define CTL_RESUME_EXE			0x0002</span>
<span class="cp">#define CTL_HALT_EXE_IDLE		0x0003</span>
<span class="cp">#define CTL_HALT_EXE_DONE		0x0004</span>
<span class="cp">#define CTL_FLUSH_COMM_CMDS		0x0007</span>
<span class="cp">#define CTL_FLUSH_RCV_BUFFER		0x0008</span>
<span class="cp">#define CTL_FLUSH_XMT_BUFFER		0x0009</span>
<span class="cp">#define CTL_GET_COMM_CMDS		0x000A</span>

<span class="cm">/* MODE COMMAND CODES */</span>
<span class="cp">#define MOD_PULSE_EN			0x0000</span>
<span class="cp">#define MOD_SPEED_CHANGE_EN		0x0001</span>
<span class="cp">#define MOD_1WIRE_SPEED			0x0002</span>
<span class="cp">#define MOD_STRONG_PU_DURATION		0x0003</span>
<span class="cp">#define MOD_PULLDOWN_SLEWRATE		0x0004</span>
<span class="cp">#define MOD_PROG_PULSE_DURATION		0x0005</span>
<span class="cp">#define MOD_WRITE1_LOWTIME		0x0006</span>
<span class="cp">#define MOD_DSOW0_TREC			0x0007</span>

<span class="cm">/* COMMUNICATION COMMAND CODES */</span>
<span class="cp">#define COMM_ERROR_ESCAPE		0x0601</span>
<span class="cp">#define COMM_SET_DURATION		0x0012</span>
<span class="cp">#define COMM_BIT_IO			0x0020</span>
<span class="cp">#define COMM_PULSE			0x0030</span>
<span class="cp">#define COMM_1_WIRE_RESET		0x0042</span>
<span class="cp">#define COMM_BYTE_IO			0x0052</span>
<span class="cp">#define COMM_MATCH_ACCESS		0x0064</span>
<span class="cp">#define COMM_BLOCK_IO			0x0074</span>
<span class="cp">#define COMM_READ_STRAIGHT		0x0080</span>
<span class="cp">#define COMM_DO_RELEASE			0x6092</span>
<span class="cp">#define COMM_SET_PATH			0x00A2</span>
<span class="cp">#define COMM_WRITE_SRAM_PAGE		0x00B2</span>
<span class="cp">#define COMM_WRITE_EPROM		0x00C4</span>
<span class="cp">#define COMM_READ_CRC_PROT_PAGE		0x00D4</span>
<span class="cp">#define COMM_READ_REDIRECT_PAGE_CRC	0x21E4</span>
<span class="cp">#define COMM_SEARCH_ACCESS		0x00F4</span>

<span class="cm">/* Communication command bits */</span>
<span class="cp">#define COMM_TYPE			0x0008</span>
<span class="cp">#define COMM_SE				0x0008</span>
<span class="cp">#define COMM_D				0x0008</span>
<span class="cp">#define COMM_Z				0x0008</span>
<span class="cp">#define COMM_CH				0x0008</span>
<span class="cp">#define COMM_SM				0x0008</span>
<span class="cp">#define COMM_R				0x0008</span>
<span class="cp">#define COMM_IM				0x0001</span>

<span class="cp">#define COMM_PS				0x4000</span>
<span class="cp">#define COMM_PST			0x4000</span>
<span class="cp">#define COMM_CIB			0x4000</span>
<span class="cp">#define COMM_RTS			0x4000</span>
<span class="cp">#define COMM_DT				0x2000</span>
<span class="cp">#define COMM_SPU			0x1000</span>
<span class="cp">#define COMM_F				0x0800</span>
<span class="cp">#define COMM_NTF			0x0400</span>
<span class="cp">#define COMM_ICP			0x0200</span>
<span class="cp">#define COMM_RST			0x0100</span>

<span class="cp">#define PULSE_PROG			0x01</span>
<span class="cp">#define PULSE_SPUE			0x02</span>

<span class="cp">#define BRANCH_MAIN			0xCC</span>
<span class="cp">#define BRANCH_AUX			0x33</span>

<span class="cm">/* Status flags */</span>
<span class="cp">#define ST_SPUA				0x01  </span><span class="cm">/* Strong Pull-up is active */</span><span class="cp"></span>
<span class="cp">#define ST_PRGA				0x02  </span><span class="cm">/* 12V programming pulse is being generated */</span><span class="cp"></span>
<span class="cp">#define ST_12VP				0x04  </span><span class="cm">/* external 12V programming voltage is present */</span><span class="cp"></span>
<span class="cp">#define ST_PMOD				0x08  </span><span class="cm">/* DS2490 powered from USB and external sources */</span><span class="cp"></span>
<span class="cp">#define ST_HALT				0x10  </span><span class="cm">/* DS2490 is currently halted */</span><span class="cp"></span>
<span class="cp">#define ST_IDLE				0x20  </span><span class="cm">/* DS2490 is currently idle */</span><span class="cp"></span>
<span class="cp">#define ST_EPOF				0x80</span>

<span class="cm">/* Result Register flags */</span>
<span class="cp">#define RR_DETECT			0xA5 </span><span class="cm">/* New device detected */</span><span class="cp"></span>
<span class="cp">#define RR_NRS				0x01 </span><span class="cm">/* Reset no presence or ... */</span><span class="cp"></span>
<span class="cp">#define RR_SH				0x02 </span><span class="cm">/* short on reset or set path */</span><span class="cp"></span>
<span class="cp">#define RR_APP				0x04 </span><span class="cm">/* alarming presence on reset */</span><span class="cp"></span>
<span class="cp">#define RR_VPP				0x08 </span><span class="cm">/* 12V expected not seen */</span><span class="cp"></span>
<span class="cp">#define RR_CMP				0x10 </span><span class="cm">/* compare error */</span><span class="cp"></span>
<span class="cp">#define RR_CRC				0x20 </span><span class="cm">/* CRC error detected */</span><span class="cp"></span>
<span class="cp">#define RR_RDP				0x40 </span><span class="cm">/* redirected page */</span><span class="cp"></span>
<span class="cp">#define RR_EOS				0x80 </span><span class="cm">/* end of search error */</span><span class="cp"></span>

<span class="cp">#define SPEED_NORMAL			0x00</span>
<span class="cp">#define SPEED_FLEXIBLE			0x01</span>
<span class="cp">#define SPEED_OVERDRIVE			0x02</span>

<span class="cp">#define NUM_EP				4</span>
<span class="cp">#define EP_CONTROL			0</span>
<span class="cp">#define EP_STATUS			1</span>
<span class="cp">#define EP_DATA_OUT			2</span>
<span class="cp">#define EP_DATA_IN			3</span>

<span class="k">struct</span> <span class="n">ds_device</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ds_entry</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">intf</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">ep</span><span class="p">[</span><span class="n">NUM_EP</span><span class="p">];</span>

	<span class="cm">/* Strong PullUp</span>
<span class="cm">	 * 0: pullup not active, else duration in milliseconds</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">spu_sleep</span><span class="p">;</span>
	<span class="cm">/* spu_bit contains COMM_SPU or 0 depending on if the strong pullup</span>
<span class="cm">	 * should be active or not for writes.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span>			<span class="n">spu_bit</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">w1_bus_master</span>	<span class="n">master</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ds_status</span>
<span class="p">{</span>
	<span class="n">u8</span>			<span class="n">enable</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">speed</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">pullup_dur</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ppuls_dur</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">pulldown_slew</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">write1_time</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">write0_time</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">reserved0</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">command0</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">command1</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">command_buffer_status</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">data_out_buffer_status</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">data_in_buffer_status</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">reserved1</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">reserved2</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">ds_id_table</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x04fa</span><span class="p">,</span> <span class="mh">0x2490</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">ds_id_table</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ds_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ds_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ds_send_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ds_send_control_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ds_devices</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ds_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">ds_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;DS9490R&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">ds_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">ds_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">ds_id_table</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_send_control_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_CONTROL</span><span class="p">]),</span>
			<span class="n">CONTROL_CMD</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to send command control message %x.%x: err=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_send_control_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_CONTROL</span><span class="p">]),</span>
			<span class="n">MODE_CMD</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to send mode control message %x.%x: err=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_send_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_CONTROL</span><span class="p">]),</span>
			<span class="n">COMM_CMD</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to send control message %x.%x: err=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_recv_status_nodump</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ds_status</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">st</span><span class="p">));</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_bulk_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_STATUS</span><span class="p">]),</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to read 1-wire data from 0x%x: err=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_STATUS</span><span class="p">],</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">st</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">st</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ds_print_msg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%45s: %8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ds_dump_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;0x%x: count=%d, status: &quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_STATUS</span><span class="p">],</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;enable flag&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;1-wire speed&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;strong pullup duration&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;programming pulse duration&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;pulldown slew rate control&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;write-1 low time&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;data sample offset/write-0 recovery time&quot;</span><span class="p">,</span>
			<span class="mi">6</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;reserved (test register)&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;device status flags&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;communication command byte 1&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;communication command byte 2&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;communication command buffer status&quot;</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;1-wire data output buffer status&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;1-wire data input buffer status&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;reserved&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;reserved&quot;</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">RR_DETECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;new device detect&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ds_print_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;Result Register Value: &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RR_NRS</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NRS: Reset no presence or ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RR_SH</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SH: short on reset or set path</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RR_APP</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;APP: alarming presence on reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RR_VPP</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;VPP: 12V expected not seen</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RR_CMP</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CMP: compare error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RR_CRC</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CRC: CRC error detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RR_RDP</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;RDP: redirected page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RR_EOS</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;EOS: end of search error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ds_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ds_send_control_cmd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CTL_RESET_DEVICE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Always allow strong pullup which allow individual writes to use</span>
<span class="cm">	 * the strong pullup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ds_send_control_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MOD_PULSE_EN</span><span class="p">,</span> <span class="n">PULSE_SPUE</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ds_reset_device: &quot;</span>
			<span class="s">&quot;Error allowing strong pullup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Chip strong pullup time was cleared. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_sleep</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* lower 4 bits are 0, see ds_set_pullup */</span>
		<span class="n">u8</span> <span class="n">del</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_sleep</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ds_send_control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">COMM_SET_DURATION</span> <span class="o">|</span> <span class="n">COMM_IM</span><span class="p">,</span> <span class="n">del</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ds_reset_device: &quot;</span>
				<span class="s">&quot;Error setting duration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_recv_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ds_status</span> <span class="n">st</span><span class="p">;</span>

	<span class="cm">/* Careful on size.  If size is less than what is available in</span>
<span class="cm">	 * the input buffer, the device fails the bulk transfer and</span>
<span class="cm">	 * clears the input buffer.  It could read the maximum size of</span>
<span class="cm">	 * the data buffer, but then do you return the first, last, or</span>
<span class="cm">	 * some set of the middle size bytes?  As long as the rest of</span>
<span class="cm">	 * the code is correct there will be size bytes waiting.  A</span>
<span class="cm">	 * call to ds_wait_status will wait until the device is idle</span>
<span class="cm">	 * and any data to be received would have been available.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_bulk_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_DATA_IN</span><span class="p">]),</span>
				<span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x20</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Clearing ep0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_DATA_IN</span><span class="p">]);</span>
		<span class="n">usb_clear_halt</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_DATA_IN</span><span class="p">]));</span>

		<span class="n">count</span> <span class="o">=</span> <span class="n">ds_recv_status_nodump</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
		<span class="n">ds_dump_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	{</span>
<span class="c">		int i;</span>

<span class="c">		printk(&quot;%s: count=%d: &quot;, __func__, count);</span>
<span class="c">		for (i=0; i&lt;count; ++i)</span>
<span class="c">			printk(&quot;%02x &quot;, buf[i]);</span>
<span class="c">		printk(&quot;\n&quot;);</span>
<span class="c">	}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_send_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_bulk_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_DATA_OUT</span><span class="p">]),</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to write 1-wire data to ep0x%x: &quot;</span>
			<span class="s">&quot;err=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">EP_DATA_OUT</span><span class="p">],</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>

<span class="c">int ds_stop_pulse(struct ds_device *dev, int limit)</span>
<span class="c">{</span>
<span class="c">	struct ds_status st;</span>
<span class="c">	int count = 0, err = 0;</span>
<span class="c">	u8 buf[0x20];</span>

<span class="c">	do {</span>
<span class="c">		err = ds_send_control(dev, CTL_HALT_EXE_IDLE, 0);</span>
<span class="c">		if (err)</span>
<span class="c">			break;</span>
<span class="c">		err = ds_send_control(dev, CTL_RESUME_EXE, 0);</span>
<span class="c">		if (err)</span>
<span class="c">			break;</span>
<span class="c">		err = ds_recv_status_nodump(dev, &amp;st, buf, sizeof(buf));</span>
<span class="c">		if (err)</span>
<span class="c">			break;</span>

<span class="c">		if ((st.status &amp; ST_SPUA) == 0) {</span>
<span class="c">			err = ds_send_control_mode(dev, MOD_PULSE_EN, 0);</span>
<span class="c">			if (err)</span>
<span class="c">				break;</span>
<span class="c">		}</span>
<span class="c">	} while(++count &lt; limit);</span>

<span class="c">	return err;</span>
<span class="c">}</span>

<span class="c">int ds_detect(struct ds_device *dev, struct ds_status *st)</span>
<span class="c">{</span>
<span class="c">	int err;</span>

<span class="c">	err = ds_send_control_cmd(dev, CTL_RESET_DEVICE, 0);</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	err = ds_send_control(dev, COMM_SET_DURATION | COMM_IM, 0);</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	err = ds_send_control(dev, COMM_SET_DURATION | COMM_IM | COMM_TYPE, 0x40);</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	err = ds_send_control_mode(dev, MOD_PULSE_EN, PULSE_PROG);</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	err = ds_dump_status(dev, st);</span>

<span class="c">	return err;</span>
<span class="c">}</span>

<span class="cp">#endif  /*  0  */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_wait_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ds_status</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x20</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ds_recv_status_nodump</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		if (err &gt;= 0) {</span>
<span class="c">			int i;</span>
<span class="c">			printk(&quot;0x%x: count=%d, status: &quot;, dev-&gt;ep[EP_STATUS], err);</span>
<span class="c">			for (i=0; i&lt;err; ++i)</span>
<span class="c">				printk(&quot;%02x &quot;, buf[i]);</span>
<span class="c">			printk(&quot;\n&quot;);</span>
<span class="c">		}</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mh">0x08</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ST_IDLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">16</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ST_EPOF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Resetting device after ST_EPOF.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ds_reset_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="cm">/* Always dump the device status. */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">101</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Dump the status for errors or if there is extended return data.</span>
<span class="cm">	 * The extended status includes new device detection (maybe someone</span>
<span class="cm">	 * can do something with it).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">16</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="o">||</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ds_dump_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="cm">/* Extended data isn&#39;t an error.  Well, a short is, but the dump</span>
<span class="cm">	 * would have already told the user that and we can&#39;t do anything</span>
<span class="cm">	 * about it in software anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="o">||</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Other potentionally interesting flags for reset.</span>
<span class="cm">	 *</span>
<span class="cm">	 * COMM_NTF: Return result register feedback.  This could be used to</span>
<span class="cm">	 * detect some conditions such as short, alarming presence, or</span>
<span class="cm">	 * detect if a new device was detected.</span>
<span class="cm">	 *</span>
<span class="cm">	 * COMM_SE which allows SPEED_NORMAL, SPEED_FLEXIBLE, SPEED_OVERDRIVE:</span>
<span class="cm">	 * Select the data transfer rate.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_send_control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">COMM_1_WIRE_RESET</span> <span class="o">|</span> <span class="n">COMM_IM</span><span class="p">,</span> <span class="n">SPEED_NORMAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static int ds_set_speed(struct ds_device *dev, int speed)</span>
<span class="c">{</span>
<span class="c">	int err;</span>

<span class="c">	if (speed != SPEED_NORMAL &amp;&amp; speed != SPEED_FLEXIBLE &amp;&amp; speed != SPEED_OVERDRIVE)</span>
<span class="c">		return -EINVAL;</span>

<span class="c">	if (speed != SPEED_OVERDRIVE)</span>
<span class="c">		speed = SPEED_FLEXIBLE;</span>

<span class="c">	speed &amp;= 0xff;</span>

<span class="c">	err = ds_send_control_mode(dev, MOD_1WIRE_SPEED, speed);</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	return err;</span>
<span class="c">}</span>
<span class="cp">#endif  /*  0  */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_set_pullup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">del</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">delay</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/* Just storing delay would not get the trunication and roundup. */</span>
	<span class="kt">int</span> <span class="n">ms</span> <span class="o">=</span> <span class="n">del</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Enable spu_bit if a delay is set. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_bit</span> <span class="o">=</span> <span class="n">delay</span> <span class="o">?</span> <span class="n">COMM_SPU</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* If delay is zero, it has already been disabled, if the time is</span>
<span class="cm">	 * the same as the hardware was last programmed to, there is also</span>
<span class="cm">	 * nothing more to do.  Compare with the recalculated value ms</span>
<span class="cm">	 * rather than del or delay which can have a different value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ms</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_sleep</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_send_control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">COMM_SET_DURATION</span> <span class="o">|</span> <span class="n">COMM_IM</span><span class="p">,</span> <span class="n">del</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_sleep</span> <span class="o">=</span> <span class="n">ms</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_touch_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bit</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">tbit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ds_status</span> <span class="n">st</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_send_control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">COMM_BIT_IO</span> <span class="o">|</span> <span class="n">COMM_IM</span> <span class="o">|</span> <span class="p">(</span><span class="n">bit</span> <span class="o">?</span> <span class="n">COMM_D</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ds_wait_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_recv_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tbit</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tbit</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static int ds_write_bit(struct ds_device *dev, u8 bit)</span>
<span class="c">{</span>
<span class="c">	int err;</span>
<span class="c">	struct ds_status st;</span>

<span class="c">	/* Set COMM_ICP to write without a readback.  Note, this will</span>
<span class="c">	 * produce one time slot, a down followed by an up with COMM_D</span>
<span class="c">	 * only determing the timing.</span>
<span class="c">	 */</span>
<span class="c">	err = ds_send_control(dev, COMM_BIT_IO | COMM_IM | COMM_ICP |</span>
<span class="c">		(bit ? COMM_D : 0), 0);</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	ds_wait_status(dev, &amp;st);</span>

<span class="c">	return 0;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_write_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ds_status</span> <span class="n">st</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rbyte</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_send_control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">COMM_BYTE_IO</span> <span class="o">|</span> <span class="n">COMM_IM</span> <span class="o">|</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_bit</span><span class="p">,</span> <span class="n">byte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_bit</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_sleep</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_wait_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_recv_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbyte</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rbyte</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">byte</span> <span class="o">==</span> <span class="n">rbyte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_read_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ds_status</span> <span class="n">st</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_send_control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">COMM_BYTE_IO</span> <span class="o">|</span> <span class="n">COMM_IM</span> <span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ds_wait_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_recv_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">byte</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_read_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ds_status</span> <span class="n">st</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_send_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_send_control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">COMM_BLOCK_IO</span> <span class="o">|</span> <span class="n">COMM_IM</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ds_wait_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_recv_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_write_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ds_status</span> <span class="n">st</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_send_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_send_control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">COMM_BLOCK_IO</span> <span class="o">|</span> <span class="n">COMM_IM</span> <span class="o">|</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_bit</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_bit</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_sleep</span><span class="p">);</span>

	<span class="n">ds_wait_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_recv_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>

<span class="c">static int ds_search(struct ds_device *dev, u64 init, u64 *buf, u8 id_number, int conditional_search)</span>
<span class="c">{</span>
<span class="c">	int err;</span>
<span class="c">	u16 value, index;</span>
<span class="c">	struct ds_status st;</span>

<span class="c">	memset(buf, 0, sizeof(buf));</span>

<span class="c">	err = ds_send_data(ds_dev, (unsigned char *)&amp;init, 8);</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	ds_wait_status(ds_dev, &amp;st);</span>

<span class="c">	value = COMM_SEARCH_ACCESS | COMM_IM | COMM_SM | COMM_F | COMM_RTS;</span>
<span class="c">	index = (conditional_search ? 0xEC : 0xF0) | (id_number &lt;&lt; 8);</span>
<span class="c">	err = ds_send_control(ds_dev, value, index);</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	ds_wait_status(ds_dev, &amp;st);</span>

<span class="c">	err = ds_recv_data(ds_dev, (unsigned char *)buf, 8*id_number);</span>
<span class="c">	if (err &lt; 0)</span>
<span class="c">		return err;</span>

<span class="c">	return err/8;</span>
<span class="c">}</span>

<span class="c">static int ds_match_access(struct ds_device *dev, u64 init)</span>
<span class="c">{</span>
<span class="c">	int err;</span>
<span class="c">	struct ds_status st;</span>

<span class="c">	err = ds_send_data(dev, (unsigned char *)&amp;init, sizeof(init));</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	ds_wait_status(dev, &amp;st);</span>

<span class="c">	err = ds_send_control(dev, COMM_MATCH_ACCESS | COMM_IM | COMM_RST, 0x0055);</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	ds_wait_status(dev, &amp;st);</span>

<span class="c">	return 0;</span>
<span class="c">}</span>

<span class="c">static int ds_set_path(struct ds_device *dev, u64 init)</span>
<span class="c">{</span>
<span class="c">	int err;</span>
<span class="c">	struct ds_status st;</span>
<span class="c">	u8 buf[9];</span>

<span class="c">	memcpy(buf, &amp;init, 8);</span>
<span class="c">	buf[8] = BRANCH_MAIN;</span>

<span class="c">	err = ds_send_data(dev, buf, sizeof(buf));</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	ds_wait_status(dev, &amp;st);</span>

<span class="c">	err = ds_send_control(dev, COMM_SET_PATH | COMM_IM | COMM_RST, 0);</span>
<span class="c">	if (err)</span>
<span class="c">		return err;</span>

<span class="c">	ds_wait_status(dev, &amp;st);</span>

<span class="c">	return 0;</span>
<span class="c">}</span>

<span class="cp">#endif  /*  0  */</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">ds9490r_touch_bit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ds_touch_bit</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static void ds9490r_write_bit(void *data, u8 bit)</span>
<span class="c">{</span>
<span class="c">	struct ds_device *dev = data;</span>

<span class="c">	ds_write_bit(dev, bit);</span>
<span class="c">}</span>

<span class="c">static u8 ds9490r_read_bit(void *data)</span>
<span class="c">{</span>
<span class="c">	struct ds_device *dev = data;</span>
<span class="c">	int err;</span>
<span class="c">	u8 bit = 0;</span>

<span class="c">	err = ds_touch_bit(dev, 1, &amp;bit);</span>
<span class="c">	if (err)</span>
<span class="c">		return 0;</span>

<span class="c">	return bit &amp; 1;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ds9490r_write_byte</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u8</span> <span class="n">byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ds_write_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">byte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">ds9490r_read_byte</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">byte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_read_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">byte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">byte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ds9490r_write_block</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ds_write_block</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">ds9490r_read_block</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_read_block</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">ds9490r_reset</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">ds9490r_set_pullup</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ds_set_pullup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">delay</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_w1_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">w1_bus_master</span><span class="p">));</span>

	<span class="cm">/* Reset the device as it can be in a bad state.</span>
<span class="cm">	 * This is necessary because a block write will wait for data</span>
<span class="cm">	 * to be placed in the output buffer and block any later</span>
<span class="cm">	 * commands which will keep accumulating and the device will</span>
<span class="cm">	 * not be idle.  Another case is removing the ds2490 module</span>
<span class="cm">	 * while a bus search is in progress, somehow a few commands</span>
<span class="cm">	 * get through, but the input transfers fail leaving data in</span>
<span class="cm">	 * the input buffer.  This will cause the next read to fail</span>
<span class="cm">	 * see the note in ds_recv_data.</span>
<span class="cm">	 */</span>
	<span class="n">ds_reset_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">.</span><span class="n">data</span>	<span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">.</span><span class="n">touch_bit</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ds9490r_touch_bit</span><span class="p">;</span>
	<span class="cm">/* read_bit and write_bit in w1_bus_master are expected to set and</span>
<span class="cm">	 * sample the line level.  For write_bit that means it is expected to</span>
<span class="cm">	 * set it to that value and leave it there.  ds2490 only supports an</span>
<span class="cm">	 * individual time slot at the lowest level.  The requirement from</span>
<span class="cm">	 * pulling the bus state down to reading the state is 15us, something</span>
<span class="cm">	 * that isn&#39;t realistic on the USB bus anyway.</span>
<span class="cm">	dev-&gt;master.read_bit	= &amp;ds9490r_read_bit;</span>
<span class="cm">	dev-&gt;master.write_bit	= &amp;ds9490r_write_bit;</span>
<span class="cm">	*/</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">.</span><span class="n">read_byte</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ds9490r_read_byte</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">.</span><span class="n">write_byte</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ds9490r_write_byte</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">.</span><span class="n">read_block</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ds9490r_read_block</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">.</span><span class="n">write_block</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ds9490r_write_block</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">.</span><span class="n">reset_bus</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ds9490r_reset</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">.</span><span class="n">set_pullup</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ds9490r_set_pullup</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">w1_add_master_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ds_w1_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">w1_remove_master_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
		    <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">udev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">endpoint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">iface_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ds_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Failed to allocate new DS9490R structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">spu_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usb_get_dev</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">));</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to set alternative setting 3 for %d interface: err=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_clear</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_reset_configuration</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to reset configuration: err=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_clear</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iface_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface_desc</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span> <span class="o">!=</span> <span class="n">NUM_EP</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Num endpoints=%d. It is not DS9490R.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iface_desc</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_clear</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This loop doesn&#39;d show control 0 endpoint,</span>
<span class="cm">	 * so we will fill only 1-3 endpoints entry.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iface_desc</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">endpoint</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface_desc</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		printk(&quot;%d: addr=%x, size=%d, dir=%s, type=%x\n&quot;,</span>
<span class="c">			i, endpoint-&gt;bEndpointAddress, le16_to_cpu(endpoint-&gt;wMaxPacketSize),</span>
<span class="c">			(endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN)?&quot;IN&quot;:&quot;OUT&quot;,</span>
<span class="c">			endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ds_w1_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_clear</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds_mutex</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ds_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ds_devices</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_clear:</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
<span class="nl">err_out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ds_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ds_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds_mutex</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ds_entry</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds_mutex</span><span class="p">);</span>

	<span class="n">ds_w1_fini</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">ds_driver</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Evgeniy Polyakov &lt;zbr@ioremap.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;DS2490 USB &lt;-&gt; W1 bus master driver (DS9490*)&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
