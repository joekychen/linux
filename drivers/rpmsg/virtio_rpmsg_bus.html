<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › rpmsg › virtio_rpmsg_bus.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>virtio_rpmsg_bus.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Virtio-based remote processor messaging bus</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Texas Instruments, Inc.</span>
<span class="cm"> * Copyright (C) 2011 Google, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Ohad Ben-Cohen &lt;ohad@wizery.com&gt;</span>
<span class="cm"> * Brian Swetland &lt;swetland@google.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This software is licensed under the terms of the GNU General Public</span>
<span class="cm"> * License version 2, as published by the Free Software Foundation, and</span>
<span class="cm"> * may be copied, distributed, and modified under those terms.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) &quot;%s: &quot; fmt, __func__</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/virtio.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_ids.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_config.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/rpmsg.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * struct virtproc_info - virtual remote processor state</span>
<span class="cm"> * @vdev:	the virtio device</span>
<span class="cm"> * @rvq:	rx virtqueue</span>
<span class="cm"> * @svq:	tx virtqueue</span>
<span class="cm"> * @rbufs:	kernel address of rx buffers</span>
<span class="cm"> * @sbufs:	kernel address of tx buffers</span>
<span class="cm"> * @last_sbuf:	index of last tx buffer used</span>
<span class="cm"> * @bufs_dma:	dma base addr of the buffers</span>
<span class="cm"> * @tx_lock:	protects svq, sbufs and sleepers, to allow concurrent senders.</span>
<span class="cm"> *		sending a message might require waking up a dozing remote</span>
<span class="cm"> *		processor, which involves sleeping, hence the mutex.</span>
<span class="cm"> * @endpoints:	idr of local endpoints, allows fast retrieval</span>
<span class="cm"> * @endpoints_lock: lock of the endpoints set</span>
<span class="cm"> * @sendq:	wait queue of sending contexts waiting for a tx buffers</span>
<span class="cm"> * @sleepers:	number of senders that are waiting for a tx buffer</span>
<span class="cm"> * @ns_ept:	the bus&#39;s name service endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * This structure stores the rpmsg state of a given virtio remote processor</span>
<span class="cm"> * device (there might be several virtio proc devices for each physical</span>
<span class="cm"> * remote processor).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">virtproc_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">rvq</span><span class="p">,</span> <span class="o">*</span><span class="n">svq</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rbufs</span><span class="p">,</span> <span class="o">*</span><span class="n">sbufs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_sbuf</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bufs_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">tx_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr</span> <span class="n">endpoints</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">endpoints_lock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">sendq</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">sleepers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="n">ns_ept</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct rpmsg_channel_info - internal channel info representation</span>
<span class="cm"> * @name: name of service</span>
<span class="cm"> * @src: local address</span>
<span class="cm"> * @dst: destination address</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpmsg_channel_info</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">RPMSG_NAME_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define to_rpmsg_channel(d) container_of(d, struct rpmsg_channel, dev)</span>
<span class="cp">#define to_rpmsg_driver(d) container_of(d, struct rpmsg_driver, drv)</span>

<span class="cm">/*</span>
<span class="cm"> * We&#39;re allocating 512 buffers of 512 bytes for communications, and then</span>
<span class="cm"> * using the first 256 buffers for RX, and the last 256 buffers for TX.</span>
<span class="cm"> *</span>
<span class="cm"> * Each buffer will have 16 bytes for the msg header and 496 bytes for</span>
<span class="cm"> * the payload.</span>
<span class="cm"> *</span>
<span class="cm"> * This will require a total space of 256KB for the buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * We might also want to add support for user-provided buffers in time.</span>
<span class="cm"> * This will allow bigger buffer size flexibility, and can also be used</span>
<span class="cm"> * to achieve zero-copy messaging.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that these numbers are purely a decision of this driver - we</span>
<span class="cm"> * can change this without changing anything in the firmware of the remote</span>
<span class="cm"> * processor.</span>
<span class="cm"> */</span>
<span class="cp">#define RPMSG_NUM_BUFS		(512)</span>
<span class="cp">#define RPMSG_BUF_SIZE		(512)</span>
<span class="cp">#define RPMSG_TOTAL_BUF_SPACE	(RPMSG_NUM_BUFS * RPMSG_BUF_SIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * Local addresses are dynamically allocated on-demand.</span>
<span class="cm"> * We do not dynamically assign addresses from the low 1024 range,</span>
<span class="cm"> * in order to reserve that address range for predefined services.</span>
<span class="cm"> */</span>
<span class="cp">#define RPMSG_RESERVED_ADDRESSES	(1024)</span>

<span class="cm">/* Address 53 is reserved for advertising remote services */</span>
<span class="cp">#define RPMSG_NS_ADDR			(53)</span>

<span class="cm">/* sysfs show configuration fields */</span>
<span class="cp">#define rpmsg_show_attr(field, path, format_string)			\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">field##_show(struct device *dev,					\</span>
<span class="cp">			struct device_attribute *attr, char *buf)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct rpmsg_channel *rpdev = to_rpmsg_channel(dev);		\</span>
<span class="cp">									\</span>
<span class="cp">	return sprintf(buf, format_string, rpdev-&gt;path);		\</span>
<span class="cp">}</span>

<span class="cm">/* for more info, see Documentation/ABI/testing/sysfs-bus-rpmsg */</span>
<span class="n">rpmsg_show_attr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">rpmsg_show_attr</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">rpmsg_show_attr</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">rpmsg_show_attr</span><span class="p">(</span><span class="n">announce</span><span class="p">,</span> <span class="n">announce</span> <span class="o">?</span> <span class="s">&quot;true&quot;</span> <span class="o">:</span> <span class="s">&quot;false&quot;</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Unique (and free running) index for rpmsg devices.</span>
<span class="cm"> *</span>
<span class="cm"> * Yeah, we&#39;re not recycling those numbers (yet?). will be easy</span>
<span class="cm"> * to change if/when we want to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rpmsg_dev_index</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">modalias_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span> <span class="o">=</span> <span class="n">to_rpmsg_channel</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">RPMSG_DEVICE_MODALIAS_FMT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">rpmsg_dev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">modalias</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">src</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">announce</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span>
<span class="p">};</span>

<span class="cm">/* rpmsg devices and drivers are matched using the service name */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rpmsg_id_match</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">rpmsg_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">RPMSG_NAME_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* match rpmsg channel and rpmsg driver */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpmsg_dev_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span> <span class="o">=</span> <span class="n">to_rpmsg_channel</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rpmsg_driver</span> <span class="o">*</span><span class="n">rpdrv</span> <span class="o">=</span> <span class="n">to_rpmsg_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rpmsg_device_id</span> <span class="o">*</span><span class="n">ids</span> <span class="o">=</span> <span class="n">rpdrv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rpmsg_id_match</span><span class="p">(</span><span class="n">rpdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpmsg_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span> <span class="o">=</span> <span class="n">to_rpmsg_channel</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;MODALIAS=&quot;</span> <span class="n">RPMSG_DEVICE_MODALIAS_FMT</span><span class="p">,</span>
					<span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* for more info, see below documentation of rpmsg_create_ept() */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="nf">__rpmsg_create_ept</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">rpmsg_rx_cb_t</span> <span class="n">cb</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">tmpaddr</span><span class="p">,</span> <span class="n">request</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="n">ept</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rpdev</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ept</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ept</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to kzalloc a new ept</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ept</span><span class="o">-&gt;</span><span class="n">rpdev</span> <span class="o">=</span> <span class="n">rpdev</span><span class="p">;</span>
	<span class="n">ept</span><span class="o">-&gt;</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
	<span class="n">ept</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="cm">/* do we need to allocate a local address ? */</span>
	<span class="n">request</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">==</span> <span class="n">RPMSG_ADDR_ANY</span> <span class="o">?</span> <span class="n">RPMSG_RESERVED_ADDRESSES</span> <span class="o">:</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints_lock</span><span class="p">);</span>

	<span class="cm">/* bind the endpoint to an rpmsg address (and allocate one if needed) */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">,</span> <span class="n">ept</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;idr_get_new_above failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_ept</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make sure the user&#39;s address request is fulfilled, if relevant */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">RPMSG_ADDR_ANY</span> <span class="o">&amp;&amp;</span> <span class="n">tmpaddr</span> <span class="o">!=</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;address 0x%x already in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rem_idr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ept</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">tmpaddr</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ept</span><span class="p">;</span>

<span class="nl">rem_idr:</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
<span class="nl">free_ept:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ept</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_create_ept() - create a new rpmsg_endpoint</span>
<span class="cm"> * @rpdev: rpmsg channel device</span>
<span class="cm"> * @cb: rx callback handler</span>
<span class="cm"> * @priv: private data for the driver&#39;s use</span>
<span class="cm"> * @addr: local rpmsg address to bind with @cb</span>
<span class="cm"> *</span>
<span class="cm"> * Every rpmsg address in the system is bound to an rx callback (so when</span>
<span class="cm"> * inbound messages arrive, they are dispatched by the rpmsg bus using the</span>
<span class="cm"> * appropriate callback handler) by means of an rpmsg_endpoint struct.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allows drivers to create such an endpoint, and by that,</span>
<span class="cm"> * bind a callback, and possibly some private data too, to an rpmsg address</span>
<span class="cm"> * (either one that is known in advance, or one that will be dynamically</span>
<span class="cm"> * assigned for them).</span>
<span class="cm"> *</span>
<span class="cm"> * Simple rpmsg drivers need not call rpmsg_create_ept, because an endpoint</span>
<span class="cm"> * is already created for them when they are probed by the rpmsg bus</span>
<span class="cm"> * (using the rx callback provided when they registered to the rpmsg bus).</span>
<span class="cm"> *</span>
<span class="cm"> * So things should just work for simple drivers: they already have an</span>
<span class="cm"> * endpoint, their rx callback is bound to their rpmsg address, and when</span>
<span class="cm"> * relevant inbound messages arrive (i.e. messages which their dst address</span>
<span class="cm"> * equals to the src address of their rpmsg channel), the driver&#39;s handler</span>
<span class="cm"> * is invoked to process it.</span>
<span class="cm"> *</span>
<span class="cm"> * That said, more complicated drivers might do need to allocate</span>
<span class="cm"> * additional rpmsg addresses, and bind them to different rx callbacks.</span>
<span class="cm"> * To accomplish that, those drivers need to call this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers should provide their @rpdev channel (so the new endpoint would belong</span>
<span class="cm"> * to the same remote processor their channel belongs to), an rx callback</span>
<span class="cm"> * function, an optional private data (which is provided back when the</span>
<span class="cm"> * rx callback is invoked), and an address they want to bind with the</span>
<span class="cm"> * callback. If @addr is RPMSG_ADDR_ANY, then rpmsg_create_ept will</span>
<span class="cm"> * dynamically assign them an available rpmsg address (drivers should have</span>
<span class="cm"> * a very good reason why not to always use RPMSG_ADDR_ANY here).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the endpoint on success, or NULL on error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="nf">rpmsg_create_ept</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span>
				<span class="n">rpmsg_rx_cb_t</span> <span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__rpmsg_create_ept</span><span class="p">(</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">vrp</span><span class="p">,</span> <span class="n">rpdev</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rpmsg_create_ept</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __rpmsg_destroy_ept() - destroy an existing rpmsg endpoint</span>
<span class="cm"> * @vrp: virtproc which owns this ept</span>
<span class="cm"> * @ept: endpoing to destroy</span>
<span class="cm"> *</span>
<span class="cm"> * An internal function which destroy an ept without assuming it is</span>
<span class="cm"> * bound to an rpmsg channel. This is needed for handling the internal</span>
<span class="cm"> * name service endpoint, which isn&#39;t bound to an rpmsg channel.</span>
<span class="cm"> * See also __rpmsg_create_ept().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__rpmsg_destroy_ept</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="n">ept</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints_lock</span><span class="p">);</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">,</span> <span class="n">ept</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints_lock</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ept</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_destroy_ept() - destroy an existing rpmsg endpoint</span>
<span class="cm"> * @ept: endpoing to destroy</span>
<span class="cm"> *</span>
<span class="cm"> * Should be used by drivers to destroy an rpmsg endpoint previously</span>
<span class="cm"> * created with rpmsg_create_ept().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rpmsg_destroy_ept</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="n">ept</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__rpmsg_destroy_ept</span><span class="p">(</span><span class="n">ept</span><span class="o">-&gt;</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">vrp</span><span class="p">,</span> <span class="n">ept</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rpmsg_destroy_ept</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * when an rpmsg driver is probed with a channel, we seamlessly create</span>
<span class="cm"> * it an endpoint, binding its rx callback to a unique local rpmsg</span>
<span class="cm"> * address.</span>
<span class="cm"> *</span>
<span class="cm"> * if we need to, we also announce about this channel to the remote</span>
<span class="cm"> * processor (needed in case the driver is exposing an rpmsg service).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpmsg_dev_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span> <span class="o">=</span> <span class="n">to_rpmsg_channel</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rpmsg_driver</span> <span class="o">*</span><span class="n">rpdrv</span> <span class="o">=</span> <span class="n">to_rpmsg_driver</span><span class="p">(</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">vrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="n">ept</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ept</span> <span class="o">=</span> <span class="n">rpmsg_create_ept</span><span class="p">(</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">rpdrv</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to create endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">ept</span> <span class="o">=</span> <span class="n">ept</span><span class="p">;</span>
	<span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span> <span class="o">=</span> <span class="n">ept</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">rpdrv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">rpdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">rpmsg_destroy_ept</span><span class="p">(</span><span class="n">ept</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* need to tell remote processor&#39;s name service about this channel ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">announce</span> <span class="o">&amp;&amp;</span>
			<span class="n">virtio_has_feature</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">VIRTIO_RPMSG_F_NS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rpmsg_ns_msg</span> <span class="n">nsm</span><span class="p">;</span>

		<span class="n">strncpy</span><span class="p">(</span><span class="n">nsm</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">RPMSG_NAME_SIZE</span><span class="p">);</span>
		<span class="n">nsm</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
		<span class="n">nsm</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">RPMSG_NS_CREATE</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">rpmsg_sendto</span><span class="p">(</span><span class="n">rpdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nsm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nsm</span><span class="p">),</span> <span class="n">RPMSG_NS_ADDR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to announce service %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpmsg_dev_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span> <span class="o">=</span> <span class="n">to_rpmsg_channel</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rpmsg_driver</span> <span class="o">*</span><span class="n">rpdrv</span> <span class="o">=</span> <span class="n">to_rpmsg_driver</span><span class="p">(</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">vrp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* tell remote processor&#39;s name service we&#39;re removing this channel */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">announce</span> <span class="o">&amp;&amp;</span>
			<span class="n">virtio_has_feature</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">VIRTIO_RPMSG_F_NS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rpmsg_ns_msg</span> <span class="n">nsm</span><span class="p">;</span>

		<span class="n">strncpy</span><span class="p">(</span><span class="n">nsm</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">RPMSG_NAME_SIZE</span><span class="p">);</span>
		<span class="n">nsm</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
		<span class="n">nsm</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">RPMSG_NS_DESTROY</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">rpmsg_sendto</span><span class="p">(</span><span class="n">rpdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nsm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nsm</span><span class="p">),</span> <span class="n">RPMSG_NS_ADDR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to announce service %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rpdrv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">rpdev</span><span class="p">);</span>

	<span class="n">rpmsg_destroy_ept</span><span class="p">(</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">ept</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">rpmsg_bus</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rpmsg&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span>		<span class="o">=</span> <span class="n">rpmsg_dev_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_attrs</span>	<span class="o">=</span> <span class="n">rpmsg_dev_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uevent</span>		<span class="o">=</span> <span class="n">rpmsg_uevent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">rpmsg_dev_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">rpmsg_dev_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * register_rpmsg_driver() - register an rpmsg driver with the rpmsg bus</span>
<span class="cm"> * @rpdrv: pointer to a struct rpmsg_driver</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, and an appropriate error value on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_rpmsg_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_driver</span> <span class="o">*</span><span class="n">rpdrv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rpdrv</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rpmsg_bus</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpdrv</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_rpmsg_driver</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * unregister_rpmsg_driver() - unregister an rpmsg driver from the rpmsg bus</span>
<span class="cm"> * @rpdrv: pointer to a struct rpmsg_driver</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, and an appropriate error value on failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unregister_rpmsg_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_driver</span> <span class="o">*</span><span class="n">rpdrv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpdrv</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_rpmsg_driver</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpmsg_release_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span> <span class="o">=</span> <span class="n">to_rpmsg_channel</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rpdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * match an rpmsg channel with a channel info struct.</span>
<span class="cm"> * this is used to make sure we&#39;re not creating rpmsg devices for channels</span>
<span class="cm"> * that already exist.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpmsg_channel_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel_info</span> <span class="o">*</span><span class="n">chinfo</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span> <span class="o">=</span> <span class="n">to_rpmsg_channel</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">src</span> <span class="o">!=</span> <span class="n">RPMSG_ADDR_ANY</span> <span class="o">&amp;&amp;</span> <span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">src</span> <span class="o">!=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">!=</span> <span class="n">RPMSG_ADDR_ANY</span> <span class="o">&amp;&amp;</span> <span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">!=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">RPMSG_NAME_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* found a match ! */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * create an rpmsg channel using its name and address info.</span>
<span class="cm"> * this function will be used to create both static and dynamic</span>
<span class="cm"> * channels.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="nf">rpmsg_create_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rpmsg_channel_info</span> <span class="o">*</span><span class="n">chinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* make sure a similar channel doesn&#39;t already exist */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">device_find_child</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">chinfo</span><span class="p">,</span> <span class="n">rpmsg_channel_match</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* decrement the matched device&#39;s refcount back */</span>
		<span class="n">put_device</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;channel %s:%x:%x already exist</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rpdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rpdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kzalloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">vrp</span> <span class="o">=</span> <span class="n">vrp</span><span class="p">;</span>
	<span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
	<span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * rpmsg server channels has predefined local address (for now),</span>
<span class="cm">	 * and their existence needs to be announced remotely</span>
<span class="cm">	 */</span>
	<span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">announce</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span> <span class="o">!=</span> <span class="n">RPMSG_ADDR_ANY</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">chinfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">RPMSG_NAME_SIZE</span><span class="p">);</span>

	<span class="cm">/* very simple device indexing plumbing which is enough for now */</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rpmsg%d&quot;</span><span class="p">,</span> <span class="n">rpmsg_dev_index</span><span class="o">++</span><span class="p">);</span>

	<span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rpmsg_bus</span><span class="p">;</span>
	<span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">rpmsg_release_device</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device_register failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rpdev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find an existing channel using its name + address properties,</span>
<span class="cm"> * and destroy it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpmsg_destroy_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">rpmsg_channel_info</span> <span class="o">*</span><span class="n">chinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">vrp</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">device_find_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">chinfo</span><span class="p">,</span> <span class="n">rpmsg_channel_match</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* super simple buffer &quot;allocator&quot; that is just enough for now */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">get_a_tx_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* support multiple concurrent senders */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * either pick the next unused tx buffer</span>
<span class="cm">	 * (half of our buffers are used for sending messages)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">last_sbuf</span> <span class="o">&lt;</span> <span class="n">RPMSG_NUM_BUFS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vrp</span><span class="o">-&gt;</span><span class="n">sbufs</span> <span class="o">+</span> <span class="n">RPMSG_BUF_SIZE</span> <span class="o">*</span> <span class="n">vrp</span><span class="o">-&gt;</span><span class="n">last_sbuf</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* or recycle a used one */</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">virtqueue_get_buf</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">svq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_upref_sleepers() - enable &quot;tx-complete&quot; interrupts, if needed</span>
<span class="cm"> * @vrp: virtual remote processor state</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called before a sender is blocked, waiting for</span>
<span class="cm"> * a tx buffer to become available.</span>
<span class="cm"> *</span>
<span class="cm"> * If we already have blocking senders, this function merely increases</span>
<span class="cm"> * the &quot;sleepers&quot; reference count, and exits.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, if this is the first sender to block, we also enable</span>
<span class="cm"> * virtio&#39;s tx callbacks, so we&#39;d be immediately notified when a tx</span>
<span class="cm"> * buffer is consumed (we rely on virtio&#39;s tx callback in order</span>
<span class="cm"> * to wake up sleeping senders as soon as a tx buffer is used by the</span>
<span class="cm"> * remote processor).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpmsg_upref_sleepers</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* support multiple concurrent senders */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>

	<span class="cm">/* are we the first sleeping context waiting for tx buffers ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">sleepers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* enable &quot;tx-complete&quot; interrupts before dozing off */</span>
		<span class="n">virtqueue_enable_cb</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">svq</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_downref_sleepers() - disable &quot;tx-complete&quot; interrupts, if needed</span>
<span class="cm"> * @vrp: virtual remote processor state</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called after a sender, that waited for a tx buffer</span>
<span class="cm"> * to become available, is unblocked.</span>
<span class="cm"> *</span>
<span class="cm"> * If we still have blocking senders, this function merely decreases</span>
<span class="cm"> * the &quot;sleepers&quot; reference count, and exits.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, if there are no more blocking senders, we also disable</span>
<span class="cm"> * virtio&#39;s tx callbacks, to avoid the overhead incurred with handling</span>
<span class="cm"> * those (now redundant) interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpmsg_downref_sleepers</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* support multiple concurrent senders */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>

	<span class="cm">/* are we the last sleeping context waiting for tx buffers ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">sleepers</span><span class="p">))</span>
		<span class="cm">/* disable &quot;tx-complete&quot; interrupts */</span>
		<span class="n">virtqueue_disable_cb</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">svq</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_send_offchannel_raw() - send a message across to the remote processor</span>
<span class="cm"> * @rpdev: the rpmsg channel</span>
<span class="cm"> * @src: source address</span>
<span class="cm"> * @dst: destination address</span>
<span class="cm"> * @data: payload of message</span>
<span class="cm"> * @len: length of payload</span>
<span class="cm"> * @wait: indicates whether caller should block in case no TX buffers available</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the base implementation for all of the rpmsg sending API.</span>
<span class="cm"> *</span>
<span class="cm"> * It will send @data of length @len to @dst, and say it&#39;s from @src. The</span>
<span class="cm"> * message will be sent to the remote processor which the @rpdev channel</span>
<span class="cm"> * belongs to.</span>
<span class="cm"> *</span>
<span class="cm"> * The message is sent using one of the TX buffers that are available for</span>
<span class="cm"> * communication with this remote processor.</span>
<span class="cm"> *</span>
<span class="cm"> * If @wait is true, the caller will be blocked until either a TX buffer is</span>
<span class="cm"> * available, or 15 seconds elapses (we don&#39;t want callers to</span>
<span class="cm"> * sleep indefinitely due to misbehaving remote processors), and in that</span>
<span class="cm"> * case -ERESTARTSYS is returned. The number &#39;15&#39; itself was picked</span>
<span class="cm"> * arbitrarily; there&#39;s little point in asking drivers to provide a timeout</span>
<span class="cm"> * value themselves.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, if @wait is false, and there are no TX buffers available,</span>
<span class="cm"> * the function will immediately fail, and -ENOMEM will be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Normally drivers shouldn&#39;t use this function directly; instead, drivers</span>
<span class="cm"> * should use the appropriate rpmsg_{try}send{to, _offchannel} API</span>
<span class="cm"> * (see include/linux/rpmsg.h).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and an appropriate error value on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rpmsg_send_offchannel_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">src</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dst</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">bool</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">vrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpmsg_hdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* bcasting isn&#39;t allowed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">src</span> <span class="o">==</span> <span class="n">RPMSG_ADDR_ANY</span> <span class="o">||</span> <span class="n">dst</span> <span class="o">==</span> <span class="n">RPMSG_ADDR_ANY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid addr (src 0x%x, dst 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We currently use fixed-sized buffers, and therefore the payload</span>
<span class="cm">	 * length is limited.</span>
<span class="cm">	 *</span>
<span class="cm">	 * One of the possible improvements here is either to support</span>
<span class="cm">	 * user-provided buffers (and then we can also support zero-copy</span>
<span class="cm">	 * messaging), or to improve the buffer allocator, to support</span>
<span class="cm">	 * variable-length buffer sizes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">RPMSG_BUF_SIZE</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;message is too big (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* grab a buffer */</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">get_a_tx_buf</span><span class="p">(</span><span class="n">vrp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wait</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* no free buffer ? wait for one (but bail after 15 seconds) */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enable &quot;tx-complete&quot; interrupts, if not already enabled */</span>
		<span class="n">rpmsg_upref_sleepers</span><span class="p">(</span><span class="n">vrp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * sleep until a free buffer is available or 15 secs elapse.</span>
<span class="cm">		 * the timeout period is not configurable because there&#39;s</span>
<span class="cm">		 * little point in asking drivers to specify that.</span>
<span class="cm">		 * if later this happens to be required, it&#39;d be easy to add.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">sendq</span><span class="p">,</span>
					<span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="n">get_a_tx_buf</span><span class="p">(</span><span class="n">vrp</span><span class="p">)),</span>
					<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">15000</span><span class="p">));</span>

		<span class="cm">/* disable &quot;tx-complete&quot; interrupts if we&#39;re the last sleeper */</span>
		<span class="n">rpmsg_downref_sleepers</span><span class="p">(</span><span class="n">vrp</span><span class="p">);</span>

		<span class="cm">/* timeout ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;timeout waiting for a tx buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">src</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX From 0x%x, To 0x%x, Len %d, Flags %d, Reserved %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">msg</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					<span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>
	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;rpmsg_virtio TX: &quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_NONE</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					<span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">)</span> <span class="o">+</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>

	<span class="cm">/* add message to the remote processor&#39;s virtqueue */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">virtqueue_add_buf</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">svq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * need to reclaim the buffer here, otherwise it&#39;s lost</span>
<span class="cm">		 * (memory won&#39;t leak, but rpmsg won&#39;t use it again for TX).</span>
<span class="cm">		 * this will wait for a buffer management overhaul.</span>
<span class="cm">		 */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;virtqueue_add_buf failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* tell the remote processor it has a pending message to read */</span>
	<span class="n">virtqueue_kick</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">svq</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rpmsg_send_offchannel_raw</span><span class="p">);</span>

<span class="cm">/* called when an rx buffer is used, and it&#39;s time to digest a message */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpmsg_recv_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">rvq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_hdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="n">ept</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span> <span class="o">=</span> <span class="n">rvq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rvq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">virtqueue_get_buf</span><span class="p">(</span><span class="n">rvq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;uhm, incoming signal, but no used buffer ?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;From: 0x%x, To: 0x%x, Len: %d, Flags: %d, Reserved: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">msg</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					<span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>
	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;rpmsg_virtio RX: &quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_NONE</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					<span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">)</span> <span class="o">+</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We currently use fixed-sized buffers, so trivially sanitize</span>
<span class="cm">	 * the reported payload length.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">RPMSG_BUF_SIZE</span> <span class="o">||</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_hdr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;inbound msg too big: (%d, %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* use the dst addr to fetch the callback of the appropriate user */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints_lock</span><span class="p">);</span>
	<span class="n">ept</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ept</span> <span class="o">&amp;&amp;</span> <span class="n">ept</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">)</span>
		<span class="n">ept</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">(</span><span class="n">ept</span><span class="o">-&gt;</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">ept</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;msg received with no recepient</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* publish the real size of the buffer */</span>
	<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">RPMSG_BUF_SIZE</span><span class="p">);</span>

	<span class="cm">/* add the buffer back to the remote processor&#39;s virtqueue */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">virtqueue_add_buf</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">rvq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to add a virtqueue buffer: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* tell the remote processor we added another available rx buffer */</span>
	<span class="n">virtqueue_kick</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">rvq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is invoked whenever the remote processor completed processing</span>
<span class="cm"> * a TX msg we just sent it, and the buffer is put back to the used ring.</span>
<span class="cm"> *</span>
<span class="cm"> * Normally, though, we suppress this &quot;tx complete&quot; interrupt in order to</span>
<span class="cm"> * avoid the incurred overhead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpmsg_xmit_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">svq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span> <span class="o">=</span> <span class="n">svq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* wake up potential senders that are waiting for a tx buffer */</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">sendq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* invoked when a name service announcement arrives */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpmsg_ns_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
							<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_ns_msg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">newch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel_info</span> <span class="n">chinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;NS announcement: &quot;</span><span class="p">,</span>
			<span class="n">DUMP_PREFIX_NONE</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;malformed ns msg (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * the name service ept does _not_ belong to a real rpmsg channel,</span>
<span class="cm">	 * and is handled by the rpmsg bus itself.</span>
<span class="cm">	 * for sanity reasons, make sure a valid rpdev has _not_ sneaked</span>
<span class="cm">	 * in somehow.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;anomaly: ns ept has an rpdev handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* don&#39;t trust the remote processor for null terminating the name */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">RPMSG_NAME_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%sing channel %s addr 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RPMSG_NS_DESTROY</span> <span class="o">?</span> <span class="s">&quot;destroy&quot;</span> <span class="o">:</span> <span class="s">&quot;creat&quot;</span><span class="p">,</span>
			<span class="n">msg</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">chinfo</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chinfo</span><span class="p">.</span><span class="n">name</span><span class="p">));</span>
	<span class="n">chinfo</span><span class="p">.</span><span class="n">src</span> <span class="o">=</span> <span class="n">RPMSG_ADDR_ANY</span><span class="p">;</span>
	<span class="n">chinfo</span><span class="p">.</span><span class="n">dst</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RPMSG_NS_DESTROY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rpmsg_destroy_channel</span><span class="p">(</span><span class="n">vrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chinfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rpmsg_destroy_channel failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">newch</span> <span class="o">=</span> <span class="n">rpmsg_create_channel</span><span class="p">(</span><span class="n">vrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chinfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newch</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rpmsg_create_channel failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpmsg_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vq_callback_t</span> <span class="o">*</span><span class="n">vq_cbs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">rpmsg_recv_done</span><span class="p">,</span> <span class="n">rpmsg_xmit_done</span> <span class="p">};</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;input&quot;</span><span class="p">,</span> <span class="s">&quot;output&quot;</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vqs</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bufs_va</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">vrp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vrp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vrp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">vrp</span><span class="o">-&gt;</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">vdev</span><span class="p">;</span>

	<span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">sendq</span><span class="p">);</span>

	<span class="cm">/* We expect two virtqueues, rx and tx (and in this order) */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">find_vqs</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">vqs</span><span class="p">,</span> <span class="n">vq_cbs</span><span class="p">,</span> <span class="n">names</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_vrp</span><span class="p">;</span>

	<span class="n">vrp</span><span class="o">-&gt;</span><span class="n">rvq</span> <span class="o">=</span> <span class="n">vqs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">vrp</span><span class="o">-&gt;</span><span class="n">svq</span> <span class="o">=</span> <span class="n">vqs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* allocate coherent memory for the buffers */</span>
	<span class="n">bufs_va</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">RPMSG_TOTAL_BUF_SPACE</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">bufs_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bufs_va</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">vqs_del</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;buffers: va %p, dma 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bufs_va</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">bufs_dma</span><span class="p">);</span>

	<span class="cm">/* half of the buffers is dedicated for RX */</span>
	<span class="n">vrp</span><span class="o">-&gt;</span><span class="n">rbufs</span> <span class="o">=</span> <span class="n">bufs_va</span><span class="p">;</span>

	<span class="cm">/* and half is dedicated for TX */</span>
	<span class="n">vrp</span><span class="o">-&gt;</span><span class="n">sbufs</span> <span class="o">=</span> <span class="n">bufs_va</span> <span class="o">+</span> <span class="n">RPMSG_TOTAL_BUF_SPACE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* set up the receive buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RPMSG_NUM_BUFS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span> <span class="o">=</span> <span class="n">vrp</span><span class="o">-&gt;</span><span class="n">rbufs</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">RPMSG_BUF_SIZE</span><span class="p">;</span>

		<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">RPMSG_BUF_SIZE</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">virtqueue_add_buf</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">rvq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">,</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* sanity check; this can&#39;t really happen */</span>
	<span class="p">}</span>

	<span class="cm">/* suppress &quot;tx-complete&quot; interrupts */</span>
	<span class="n">virtqueue_disable_cb</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">svq</span><span class="p">);</span>

	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">vrp</span><span class="p">;</span>

	<span class="cm">/* if supported by the remote processor, enable the name service */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">virtio_has_feature</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="n">VIRTIO_RPMSG_F_NS</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* a dedicated endpoint handles the name service msgs */</span>
		<span class="n">vrp</span><span class="o">-&gt;</span><span class="n">ns_ept</span> <span class="o">=</span> <span class="n">__rpmsg_create_ept</span><span class="p">(</span><span class="n">vrp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">rpmsg_ns_cb</span><span class="p">,</span>
						<span class="n">vrp</span><span class="p">,</span> <span class="n">RPMSG_NS_ADDR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">ns_ept</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to create the ns ept</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_coherent</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* tell the remote processor it can start sending messages */</span>
	<span class="n">virtqueue_kick</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">rvq</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rpmsg host is online</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_coherent:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">RPMSG_TOTAL_BUF_SPACE</span><span class="p">,</span> <span class="n">bufs_va</span><span class="p">,</span>
					<span class="n">vrp</span><span class="o">-&gt;</span><span class="n">bufs_dma</span><span class="p">);</span>
<span class="nl">vqs_del:</span>
	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">del_vqs</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
<span class="nl">free_vrp:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vrp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpmsg_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">rpmsg_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span> <span class="o">=</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">rpmsg_remove_device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t remove rpmsg device: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">ns_ept</span><span class="p">)</span>
		<span class="n">__rpmsg_destroy_ept</span><span class="p">(</span><span class="n">vrp</span><span class="p">,</span> <span class="n">vrp</span><span class="o">-&gt;</span><span class="n">ns_ept</span><span class="p">);</span>

	<span class="n">idr_remove_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">);</span>
	<span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">);</span>

	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">del_vqs</span><span class="p">(</span><span class="n">vrp</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">RPMSG_TOTAL_BUF_SPACE</span><span class="p">,</span>
					<span class="n">vrp</span><span class="o">-&gt;</span><span class="n">rbufs</span><span class="p">,</span> <span class="n">vrp</span><span class="o">-&gt;</span><span class="n">bufs_dma</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">vrp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">virtio_device_id</span> <span class="n">id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">VIRTIO_ID_RPMSG</span><span class="p">,</span> <span class="n">VIRTIO_DEV_ANY_ID</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">features</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">VIRTIO_RPMSG_F_NS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">virtio_driver</span> <span class="n">virtio_ipc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">feature_table</span>	<span class="o">=</span> <span class="n">features</span><span class="p">,</span>
	<span class="p">.</span><span class="n">feature_table_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">features</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">rpmsg_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">rpmsg_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rpmsg_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpmsg_bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed to register rpmsg bus: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_virtio_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virtio_ipc_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed to register virtio driver: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpmsg_bus</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">rpmsg_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">rpmsg_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_virtio_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virtio_ipc_driver</span><span class="p">);</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpmsg_bus</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">rpmsg_fini</span><span class="p">);</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">virtio</span><span class="p">,</span> <span class="n">id_table</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Virtio-based remote processor messaging bus&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
