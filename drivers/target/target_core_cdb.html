<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › target › target_core_cdb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>target_core_cdb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * CDB emulation for non-READ/WRITE commands.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002, 2003, 2004, 2005 PyX Technologies, Inc.</span>
<span class="cm"> * Copyright (c) 2005, 2006, 2007 SBE, Inc.</span>
<span class="cm"> * Copyright (c) 2007-2010 Rising Tide Systems</span>
<span class="cm"> * Copyright (c) 2008-2010 Linux-iSCSI.org</span>
<span class="cm"> *</span>
<span class="cm"> * Nicholas A. Bellinger &lt;nab@kernel.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>

<span class="cp">#include &lt;target/target_core_base.h&gt;</span>
<span class="cp">#include &lt;target/target_core_backend.h&gt;</span>
<span class="cp">#include &lt;target/target_core_fabric.h&gt;</span>

<span class="cp">#include &quot;target_core_internal.h&quot;</span>
<span class="cp">#include &quot;target_core_ua.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">target_fill_alua_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">t10_alua_tg_pt_gp</span> <span class="o">*</span><span class="n">tg_pt_gp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">t10_alua_tg_pt_gp_member</span> <span class="o">*</span><span class="n">tg_pt_gp_mem</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set SCCS for MAINTENANCE_IN + REPORT_TARGET_PORT_GROUPS.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set TPGS field for explict and/or implict ALUA access type</span>
<span class="cm">	 * and opteration.</span>
<span class="cm">	 *</span>
<span class="cm">	 * See spc4r17 section 6.4.2 Table 135</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">tg_pt_gp_mem</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sep_alua_tg_pt_gp_mem</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg_pt_gp_mem</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg_pt_gp_mem</span><span class="o">-&gt;</span><span class="n">tg_pt_gp_mem_lock</span><span class="p">);</span>
	<span class="n">tg_pt_gp</span> <span class="o">=</span> <span class="n">tg_pt_gp_mem</span><span class="o">-&gt;</span><span class="n">tg_pt_gp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tg_pt_gp</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">|=</span> <span class="n">tg_pt_gp</span><span class="o">-&gt;</span><span class="n">tg_pt_gp_alua_access_type</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg_pt_gp_mem</span><span class="o">-&gt;</span><span class="n">tg_pt_gp_mem_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_emulate_inquiry_std</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>

	<span class="cm">/* Set RMB (removable media) for tape devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_TAPE</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_rev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * NORMACA and HISUP = 0, RESPONSE DATA FORMAT = 2</span>
<span class="cm">	 *</span>
<span class="cm">	 * SPC4 says:</span>
<span class="cm">	 *   A RESPONSE DATA FORMAT field set to 2h indicates that the</span>
<span class="cm">	 *   standard INQUIRY data is in the format defined in this</span>
<span class="cm">	 *   standard. Response data format values less than 2h are</span>
<span class="cm">	 *   obsolete. Response data format values greater than 2h are</span>
<span class="cm">	 *   reserved.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable SCCS and TPGS fields for Emulated ALUA</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_alua</span><span class="p">.</span><span class="n">alua_type</span> <span class="o">==</span> <span class="n">SPC3_ALUA_EMULATED</span><span class="p">)</span>
		<span class="n">target_fill_alua_data</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span> <span class="cm">/* CmdQue=1 */</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;LIO-ORG&quot;</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">model</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">revision</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="cm">/* Set additional length to 31 */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* unit serial number */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_emulate_evpd_80</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">su_dev_flags</span> <span class="o">&amp;</span>
			<span class="n">SDF_EMULATED_VPD_UNIT_SERIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">unit_serial_len</span><span class="p">;</span>

		<span class="n">unit_serial_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">unit_serial</span><span class="p">);</span>
		<span class="n">unit_serial_len</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* For NULL Terminator */</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">unit_serial</span><span class="p">);</span>
		<span class="n">len</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Extra Byte for NULL Terminator */</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">target_parse_naa_6h_vendor_specific</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">unit_serial</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate up to 36 bits of VENDOR SPECIFIC IDENTIFIER starting on</span>
<span class="cm">	 * byte 3 bit 3-0 for NAA IEEE Registered Extended DESIGNATOR field</span>
<span class="cm">	 * format, followed by 64 bits of VENDOR SPECIFIC IDENTIFIER EXTENSION</span>
<span class="cm">	 * to complete the payload.  These are based from VPD=0x80 PRODUCT SERIAL</span>
<span class="cm">	 * NUMBER set via vpd_unit_serial in target_core_configfs.c to ensure</span>
<span class="cm">	 * per device uniqeness.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">13</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="n">val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Device identification VPD, for a complete list of</span>
<span class="cm"> * DESIGNATOR TYPEs see spc4r17 Table 459.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_emulate_evpd_83</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_portal_group</span> <span class="o">*</span><span class="n">tpg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">t10_alua_lu_gp_member</span> <span class="o">*</span><span class="n">lu_gp_mem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">t10_alua_tg_pt_gp</span> <span class="o">*</span><span class="n">tg_pt_gp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">t10_alua_tg_pt_gp_member</span> <span class="o">*</span><span class="n">tg_pt_gp_mem</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prod</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">prod_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">unit_serial_len</span><span class="p">,</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">id_len</span><span class="p">;</span>

	<span class="n">off</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NAA IEEE Registered Extended Assigned designator format, see</span>
<span class="cm">	 * spc4r17 section 7.7.3.6.5</span>
<span class="cm">	 *</span>
<span class="cm">	 * We depend upon a target_core_mod/ConfigFS provided</span>
<span class="cm">	 * /sys/kernel/config/target/core/$HBA/$DEV/wwn/vpd_unit_serial</span>
<span class="cm">	 * value in order to return the NAA id.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">su_dev_flags</span> <span class="o">&amp;</span> <span class="n">SDF_EMULATED_VPD_UNIT_SERIAL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">check_t10_vend_desc</span><span class="p">;</span>

	<span class="cm">/* CODE SET == Binary */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>

	<span class="cm">/* Set ASSOCIATION == addressed logical unit: 0)b */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

	<span class="cm">/* Identifier/Designator type == NAA identifier */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="n">off</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Identifier/Designator length */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start NAA IEEE Registered Extended Identifier/Designator</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x6</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use OpenFabrics IEEE Company ID: 00 14 05</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x5</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return ConfigFS Unit Serial Number information for</span>
<span class="cm">	 * VENDOR_SPECIFIC_IDENTIFIER and</span>
<span class="cm">	 * VENDOR_SPECIFIC_IDENTIFIER_EXTENTION</span>
<span class="cm">	 */</span>
	<span class="n">target_parse_naa_6h_vendor_specific</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">off</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

<span class="nl">check_t10_vend_desc:</span>
	<span class="cm">/*</span>
<span class="cm">	 * T10 Vendor Identifier Page, see spc4r17 section 7.7.3.4</span>
<span class="cm">	 */</span>
	<span class="n">id_len</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* For Vendor field */</span>
	<span class="n">prod_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* For VPD Header */</span>
	<span class="n">prod_len</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* For Vendor field */</span>
	<span class="n">prod_len</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">prod</span><span class="p">);</span>
	<span class="n">prod_len</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* For : */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">su_dev_flags</span> <span class="o">&amp;</span>
			<span class="n">SDF_EMULATED_VPD_UNIT_SERIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unit_serial_len</span> <span class="o">=</span>
			<span class="n">strlen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">unit_serial</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">unit_serial_len</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* For NULL Terminator */</span>

		<span class="n">id_len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">+</span><span class="mi">12</span><span class="p">],</span> <span class="s">&quot;%s:%s&quot;</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">unit_serial</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span> <span class="cm">/* ASCII */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span> <span class="cm">/* T10 Vendor ID */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="s">&quot;LIO-ORG&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="cm">/* Extra Byte for NULL Terminator */</span>
	<span class="n">id_len</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* Identifier Length */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_len</span><span class="p">;</span>
	<span class="cm">/* Header size for Designation descriptor */</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">id_len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">off</span> <span class="o">+=</span> <span class="p">(</span><span class="n">id_len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * struct se_port is only set for INQUIRY VPD=1 through $FABRIC_MOD</span>
<span class="cm">	 */</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">t10_alua_lu_gp</span> <span class="o">*</span><span class="n">lu_gp</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">padding</span><span class="p">,</span> <span class="n">scsi_name_len</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">lu_gp_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">tg_pt_gp_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">tpgt</span><span class="p">;</span>

		<span class="n">tpg</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sep_tpg</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Relative target port identifer, see spc4r17</span>
<span class="cm">		 * section 7.7.3.7</span>
<span class="cm">		 *</span>
<span class="cm">		 * Get the PROTOCOL IDENTIFIER as defined by spc4r17</span>
<span class="cm">		 * section 7.5.1 Table 362</span>
<span class="cm">		 */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_proto_ident</span><span class="p">(</span><span class="n">tpg</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span> <span class="cm">/* CODE SET == Binary */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="cm">/* Set PIV=1 */</span>
		<span class="cm">/* Set ASSOCIATION == target port: 01b */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x10</span><span class="p">;</span>
		<span class="cm">/* DESIGNATOR TYPE == Relative target port identifer */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x4</span><span class="p">;</span>
		<span class="n">off</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Skip over Reserved */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* DESIGNATOR LENGTH */</span>
		<span class="cm">/* Skip over Obsolete field in RTPI payload</span>
<span class="cm">		 * in Table 472 */</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sep_rtpi</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sep_rtpi</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* Header size + Designation descriptor */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Target port group identifier, see spc4r17</span>
<span class="cm">		 * section 7.7.3.8</span>
<span class="cm">		 *</span>
<span class="cm">		 * Get the PROTOCOL IDENTIFIER as defined by spc4r17</span>
<span class="cm">		 * section 7.5.1 Table 362</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_alua</span><span class="p">.</span><span class="n">alua_type</span> <span class="o">!=</span>
				<span class="n">SPC3_ALUA_EMULATED</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">check_scsi_name</span><span class="p">;</span>

		<span class="n">tg_pt_gp_mem</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sep_alua_tg_pt_gp_mem</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg_pt_gp_mem</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">check_lu_gp</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg_pt_gp_mem</span><span class="o">-&gt;</span><span class="n">tg_pt_gp_mem_lock</span><span class="p">);</span>
		<span class="n">tg_pt_gp</span> <span class="o">=</span> <span class="n">tg_pt_gp_mem</span><span class="o">-&gt;</span><span class="n">tg_pt_gp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg_pt_gp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg_pt_gp_mem</span><span class="o">-&gt;</span><span class="n">tg_pt_gp_mem_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">check_lu_gp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tg_pt_gp_id</span> <span class="o">=</span> <span class="n">tg_pt_gp</span><span class="o">-&gt;</span><span class="n">tg_pt_gp_id</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg_pt_gp_mem</span><span class="o">-&gt;</span><span class="n">tg_pt_gp_mem_lock</span><span class="p">);</span>

		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_proto_ident</span><span class="p">(</span><span class="n">tpg</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span> <span class="cm">/* CODE SET == Binary */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="cm">/* Set PIV=1 */</span>
		<span class="cm">/* Set ASSOCIATION == target port: 01b */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x10</span><span class="p">;</span>
		<span class="cm">/* DESIGNATOR TYPE == Target port group identifier */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x5</span><span class="p">;</span>
		<span class="n">off</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Skip over Reserved */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* DESIGNATOR LENGTH */</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* Skip over Reserved Field */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">tg_pt_gp_id</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tg_pt_gp_id</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* Header size + Designation descriptor */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Logical Unit Group identifier, see spc4r17</span>
<span class="cm">		 * section 7.7.3.8</span>
<span class="cm">		 */</span>
<span class="nl">check_lu_gp:</span>
		<span class="n">lu_gp_mem</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_alua_lu_gp_mem</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lu_gp_mem</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">check_scsi_name</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lu_gp_mem</span><span class="o">-&gt;</span><span class="n">lu_gp_mem_lock</span><span class="p">);</span>
		<span class="n">lu_gp</span> <span class="o">=</span> <span class="n">lu_gp_mem</span><span class="o">-&gt;</span><span class="n">lu_gp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lu_gp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lu_gp_mem</span><span class="o">-&gt;</span><span class="n">lu_gp_mem_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">check_scsi_name</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lu_gp_id</span> <span class="o">=</span> <span class="n">lu_gp</span><span class="o">-&gt;</span><span class="n">lu_gp_id</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lu_gp_mem</span><span class="o">-&gt;</span><span class="n">lu_gp_mem_lock</span><span class="p">);</span>

		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span> <span class="cm">/* CODE SET == Binary */</span>
		<span class="cm">/* DESIGNATOR TYPE == Logical Unit Group identifier */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x6</span><span class="p">;</span>
		<span class="n">off</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Skip over Reserved */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* DESIGNATOR LENGTH */</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* Skip over Reserved Field */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">lu_gp_id</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lu_gp_id</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* Header size + Designation descriptor */</span>
		<span class="cm">/*</span>
<span class="cm">		 * SCSI name string designator, see spc4r17</span>
<span class="cm">		 * section 7.7.3.11</span>
<span class="cm">		 *</span>
<span class="cm">		 * Get the PROTOCOL IDENTIFIER as defined by spc4r17</span>
<span class="cm">		 * section 7.5.1 Table 362</span>
<span class="cm">		 */</span>
<span class="nl">check_scsi_name:</span>
		<span class="n">scsi_name_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">tpg_get_wwn</span><span class="p">(</span><span class="n">tpg</span><span class="p">));</span>
		<span class="cm">/* UTF-8 &quot;,t,0x&lt;16-bit TPGT&gt;&quot; + NULL Terminator */</span>
		<span class="n">scsi_name_len</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* Check for 4-byte padding */</span>
		<span class="n">padding</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="n">scsi_name_len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">padding</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">scsi_name_len</span> <span class="o">+=</span> <span class="n">padding</span><span class="p">;</span>
		<span class="cm">/* Header size + Designation descriptor */</span>
		<span class="n">scsi_name_len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_proto_ident</span><span class="p">(</span><span class="n">tpg</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x3</span><span class="p">;</span> <span class="cm">/* CODE SET == UTF-8 */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="cm">/* Set PIV=1 */</span>
		<span class="cm">/* Set ASSOCIATION == target port: 01b */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x10</span><span class="p">;</span>
		<span class="cm">/* DESIGNATOR TYPE == SCSI name string */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x8</span><span class="p">;</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* Skip over Reserved and length */</span>
		<span class="cm">/*</span>
<span class="cm">		 * SCSI name string identifer containing, $FABRIC_MOD</span>
<span class="cm">		 * dependent information.  For LIO-Target and iSCSI</span>
<span class="cm">		 * Target Port, this means &quot;&lt;iSCSI name&gt;,t,0x&lt;TPGT&gt; in</span>
<span class="cm">		 * UTF-8 encoding.</span>
<span class="cm">		 */</span>
		<span class="n">tpgt</span> <span class="o">=</span> <span class="n">tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">tpg_get_tag</span><span class="p">(</span><span class="n">tpg</span><span class="p">);</span>
		<span class="n">scsi_name_len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">],</span> <span class="s">&quot;%s,t,0x%04x&quot;</span><span class="p">,</span>
					<span class="n">tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">tpg_get_wwn</span><span class="p">(</span><span class="n">tpg</span><span class="p">),</span> <span class="n">tpgt</span><span class="p">);</span>
		<span class="n">scsi_name_len</span> <span class="o">+=</span> <span class="mi">1</span> <span class="cm">/* Include  NULL terminator */</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The null-terminated, null-padded (see 4.4.2) SCSI</span>
<span class="cm">		 * NAME STRING field contains a UTF-8 format string.</span>
<span class="cm">		 * The number of bytes in the SCSI NAME STRING field</span>
<span class="cm">		 * (i.e., the value in the DESIGNATOR LENGTH field)</span>
<span class="cm">		 * shall be no larger than 256 and shall be a multiple</span>
<span class="cm">		 * of four.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">padding</span><span class="p">)</span>
			<span class="n">scsi_name_len</span> <span class="o">+=</span> <span class="n">padding</span><span class="p">;</span>

		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scsi_name_len</span><span class="p">;</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="n">scsi_name_len</span><span class="p">;</span>
		<span class="cm">/* Header size + Designation descriptor */</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">scsi_name_len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span> <span class="cm">/* Page Length for VPD 0x83 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Extended INQUIRY Data VPD Page */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_emulate_evpd_86</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3c</span><span class="p">;</span>
	<span class="cm">/* Set HEADSUP, ORDSUP, SIMPSUP */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">;</span>

	<span class="cm">/* If WriteCache emulation is enabled, set V_SUP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_write_cache</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Block Limits VPD page */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_emulate_evpd_b0</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_sectors</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">have_tp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Following sbc3r22 section 6.5.3 Block Limits VPD page, when</span>
<span class="cm">	 * emulate_tpu=1 or emulate_tpws=1 we will be expect a</span>
<span class="cm">	 * different page length for Thin Provisioning.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_tpu</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_tpws</span><span class="p">)</span>
		<span class="n">have_tp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">have_tp</span> <span class="o">?</span> <span class="mh">0x3c</span> <span class="o">:</span> <span class="mh">0x10</span><span class="p">;</span>

	<span class="cm">/* Set WSNZ to 1 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set OPTIMAL TRANSFER LENGTH GRANULARITY</span>
<span class="cm">	 */</span>
	<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set MAXIMUM TRANSFER LENGTH</span>
<span class="cm">	 */</span>
	<span class="n">max_sectors</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">fabric_max_sectors</span><span class="p">,</span>
			  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">hw_max_sectors</span><span class="p">);</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">max_sectors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set OPTIMAL TRANSFER LENGTH</span>
<span class="cm">	 */</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">optimal_sectors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Exit now if we don&#39;t support TP.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_tp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set MAXIMUM UNMAP LBA COUNT</span>
<span class="cm">	 */</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">max_unmap_lba_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set MAXIMUM UNMAP BLOCK DESCRIPTOR COUNT</span>
<span class="cm">	 */</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">max_unmap_block_desc_count</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">24</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set OPTIMAL UNMAP GRANULARITY</span>
<span class="cm">	 */</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">unmap_granularity</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">28</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * UNMAP GRANULARITY ALIGNMENT</span>
<span class="cm">	 */</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">unmap_granularity_alignment</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">unmap_granularity_alignment</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="cm">/* Set the UGAVALID bit */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Block Device Characteristics VPD page */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_emulate_evpd_b1</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3c</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">is_nonrot</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Thin Provisioning VPD */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_emulate_evpd_b2</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * From sbc3r22 section 6.5.4 Thin Provisioning VPD page:</span>
<span class="cm">	 *</span>
<span class="cm">	 * The PAGE LENGTH field is defined in SPC-4. If the DP bit is set to</span>
<span class="cm">	 * zero, then the page length shall be set to 0004h.  If the DP bit</span>
<span class="cm">	 * is set to one, then the page length shall be set to the value</span>
<span class="cm">	 * defined in table 162.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set Hardcoded length mentioned above for DP=0</span>
<span class="cm">	 */</span>
	<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="mh">0x0004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The THRESHOLD EXPONENT field indicates the threshold set size in</span>
<span class="cm">	 * LBAs as a power of 2 (i.e., the threshold set size is equal to</span>
<span class="cm">	 * 2(threshold exponent)).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that this is currently set to 0x00 as mkp says it will be</span>
<span class="cm">	 * changing again.  We can enable this once it has settled in T10</span>
<span class="cm">	 * and is actually used by Linux/SCSI ML code.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A TPU bit set to one indicates that the device server supports</span>
<span class="cm">	 * the UNMAP command (see 5.25). A TPU bit set to zero indicates</span>
<span class="cm">	 * that the device server does not support the UNMAP command.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_tpu</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A TPWS bit set to one indicates that the device server supports</span>
<span class="cm">	 * the use of the WRITE SAME (16) command (see 5.42) to unmap LBAs.</span>
<span class="cm">	 * A TPWS bit set to zero indicates that the device server does not</span>
<span class="cm">	 * support the use of the WRITE SAME (16) command to unmap LBAs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_tpws</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x40</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">target_emulate_evpd_00</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">emulate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">evpd_handlers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span> <span class="p">.</span><span class="n">emulate</span> <span class="o">=</span> <span class="n">target_emulate_evpd_00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span> <span class="p">.</span><span class="n">emulate</span> <span class="o">=</span> <span class="n">target_emulate_evpd_80</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="mh">0x83</span><span class="p">,</span> <span class="p">.</span><span class="n">emulate</span> <span class="o">=</span> <span class="n">target_emulate_evpd_83</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="mh">0x86</span><span class="p">,</span> <span class="p">.</span><span class="n">emulate</span> <span class="o">=</span> <span class="n">target_emulate_evpd_86</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="mh">0xb0</span><span class="p">,</span> <span class="p">.</span><span class="n">emulate</span> <span class="o">=</span> <span class="n">target_emulate_evpd_b0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="mh">0xb1</span><span class="p">,</span> <span class="p">.</span><span class="n">emulate</span> <span class="o">=</span> <span class="n">target_emulate_evpd_b1</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="mh">0xb2</span><span class="p">,</span> <span class="p">.</span><span class="n">emulate</span> <span class="o">=</span> <span class="n">target_emulate_evpd_b2</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* supported vital product data pages */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_emulate_evpd_00</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only report the INQUIRY EVPD=1 pages after a valid NAA</span>
<span class="cm">	 * Registered Extended LUN WWN has been set via ConfigFS</span>
<span class="cm">	 * during device creation/restart.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">su_dev_flags</span> <span class="o">&amp;</span>
			<span class="n">SDF_EMULATED_VPD_UNIT_SERIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">evpd_handlers</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">evpd_handlers</span><span class="p">);</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">evpd_handlers</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">target_emulate_inquiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_portal_group</span> <span class="o">*</span><span class="n">tpg</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="o">-&gt;</span><span class="n">sep_tpg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">map_buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">map_buf</span> <span class="o">=</span> <span class="n">transport_kmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC is not set, then we</span>
<span class="cm">	 * know we actually allocated a full page.  Otherwise, if the</span>
<span class="cm">	 * data buffer is too small, allocate a temporary buffer so we</span>
<span class="cm">	 * don&#39;t have to worry about overruns in all our INQUIRY</span>
<span class="cm">	 * emulation handling.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">&lt;</span> <span class="n">SE_INQUIRY_BUF</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">SE_INQUIRY_BUF</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">transport_kunmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">map_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="n">tpg</span><span class="o">-&gt;</span><span class="n">tpg_virt_lun0</span><span class="p">.</span><span class="n">lun_se_dev</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3f</span><span class="p">;</span> <span class="cm">/* Not connected */</span>
	<span class="k">else</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;INQUIRY with EVPD==0 but PAGE CODE=%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_INVALID_CDB_FIELD</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">target_emulate_inquiry_std</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">evpd_handlers</span><span class="p">);</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">evpd_handlers</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">evpd_handlers</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">emulate</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unknown VPD Code: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_INVALID_CDB_FIELD</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="n">map_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">map_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">transport_kunmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">target_complete_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">GOOD</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">target_emulate_readcapacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocks_long</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_blocks</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">blocks</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blocks_long</span> <span class="o">&gt;=</span> <span class="mh">0x00000000ffffffff</span><span class="p">)</span>
		<span class="n">blocks</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">blocks_long</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">transport_kmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">blocks</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">transport_kunmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">target_complete_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">GOOD</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">target_emulate_readcapacity_16</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocks</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_blocks</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">transport_kmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">blocks</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set Thin Provisioning Enable bit following sbc3r22 in section</span>
<span class="cm">	 * READ CAPACITY (16) byte 14 if emulate_tpu or emulate_tpws is enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_tpu</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_tpws</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>

	<span class="n">transport_kunmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">target_complete_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">GOOD</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_modesense_rwrecovery</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0a</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_modesense_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0a</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0a</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * From spc4r23, 7.4.7 Control mode page</span>
<span class="cm">	 *</span>
<span class="cm">	 * The QUEUE ALGORITHM MODIFIER field (see table 368) specifies</span>
<span class="cm">	 * restrictions on the algorithm used for reordering commands</span>
<span class="cm">	 * having the SIMPLE task attribute (see SAM-4).</span>
<span class="cm">	 *</span>
<span class="cm">	 *                    Table 368 -- QUEUE ALGORITHM MODIFIER field</span>
<span class="cm">	 *                         Code      Description</span>
<span class="cm">	 *                          0h       Restricted reordering</span>
<span class="cm">	 *                          1h       Unrestricted reordering allowed</span>
<span class="cm">	 *                          2h to 7h    Reserved</span>
<span class="cm">	 *                          8h to Fh    Vendor specific</span>
<span class="cm">	 *</span>
<span class="cm">	 * A value of zero in the QUEUE ALGORITHM MODIFIER field specifies that</span>
<span class="cm">	 * the device server shall order the processing sequence of commands</span>
<span class="cm">	 * having the SIMPLE task attribute such that data integrity is maintained</span>
<span class="cm">	 * for that I_T nexus (i.e., if the transmission of new SCSI transport protocol</span>
<span class="cm">	 * requests is halted at any time, the final value of all data observable</span>
<span class="cm">	 * on the medium shall be the same as if all the commands had been processed</span>
<span class="cm">	 * with the ORDERED task attribute).</span>
<span class="cm">	 *</span>
<span class="cm">	 * A value of one in the QUEUE ALGORITHM MODIFIER field specifies that the</span>
<span class="cm">	 * device server may reorder the processing sequence of commands having the</span>
<span class="cm">	 * SIMPLE task attribute in any manner. Any data integrity exposures related to</span>
<span class="cm">	 * command sequence order shall be explicitly handled by the application client</span>
<span class="cm">	 * through the selection of appropriate ommands and task attributes.</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_rest_reord</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x00</span> <span class="o">:</span> <span class="mh">0x10</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * From spc4r17, section 7.4.6 Control mode Page</span>
<span class="cm">	 *</span>
<span class="cm">	 * Unit Attention interlocks control (UN_INTLCK_CTRL) to code 00b</span>
<span class="cm">	 *</span>
<span class="cm">	 * 00b: The logical unit shall clear any unit attention condition</span>
<span class="cm">	 * reported in the same I_T_L_Q nexus transaction as a CHECK CONDITION</span>
<span class="cm">	 * status and shall not establish a unit attention condition when a com-</span>
<span class="cm">	 * mand is completed with BUSY, TASK SET FULL, or RESERVATION CONFLICT</span>
<span class="cm">	 * status.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 10b: The logical unit shall not clear any unit attention condition</span>
<span class="cm">	 * reported in the same I_T_L_Q nexus transaction as a CHECK CONDITION</span>
<span class="cm">	 * status and shall not establish a unit attention condition when</span>
<span class="cm">	 * a command is completed with BUSY, TASK SET FULL, or RESERVATION</span>
<span class="cm">	 * CONFLICT status.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 11b a The logical unit shall not clear any unit attention condition</span>
<span class="cm">	 * reported in the same I_T_L_Q nexus transaction as a CHECK CONDITION</span>
<span class="cm">	 * status and shall establish a unit attention condition for the</span>
<span class="cm">	 * initiator port associated with the I_T nexus on which the BUSY,</span>
<span class="cm">	 * TASK SET FULL, or RESERVATION CONFLICT status is being returned.</span>
<span class="cm">	 * Depending on the status, the additional sense code shall be set to</span>
<span class="cm">	 * PREVIOUS BUSY STATUS, PREVIOUS TASK SET FULL STATUS, or PREVIOUS</span>
<span class="cm">	 * RESERVATION CONFLICT STATUS. Until it is cleared by a REQUEST SENSE</span>
<span class="cm">	 * command, a unit attention condition shall be established only once</span>
<span class="cm">	 * for a BUSY, TASK SET FULL, or RESERVATION CONFLICT status regardless</span>
<span class="cm">	 * to the number of commands completed with one of those status codes.</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_ua_intlck_ctrl</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x30</span> <span class="o">:</span>
	       <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_ua_intlck_ctrl</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x20</span> <span class="o">:</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * From spc4r17, section 7.4.6 Control mode Page</span>
<span class="cm">	 *</span>
<span class="cm">	 * Task Aborted Status (TAS) bit set to zero.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A task aborted status (TAS) bit set to zero specifies that aborted</span>
<span class="cm">	 * tasks shall be terminated by the device server without any response</span>
<span class="cm">	 * to the application client. A TAS bit set to one specifies that tasks</span>
<span class="cm">	 * aborted by the actions of an I_T nexus other than the I_T nexus on</span>
<span class="cm">	 * which the command was received shall be completed with TASK ABORTED</span>
<span class="cm">	 * status (see SAM-4).</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_tas</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x40</span> <span class="o">:</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_modesense_caching</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_write_cache</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">;</span> <span class="cm">/* Write Cache Enable */</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span> <span class="cm">/* Disabled Read Ahead */</span>

	<span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">target_modesense_write_protect</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * I believe that the WP bit (bit 7) in the mode header is the same for</span>
<span class="cm">	 * all device types..</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TYPE_DISK</span>:
	<span class="k">case</span> <span class="n">TYPE_TAPE</span>:
	<span class="nl">default:</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="cm">/* WP bit */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">target_modesense_dpofua</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TYPE_DISK</span>:
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x10</span><span class="p">;</span> <span class="cm">/* DPOFUA bit */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">target_emulate_modesense</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ten</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MODE_SENSE_10</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">ten</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">SE_MODE_PAGE_BUF</span><span class="p">];</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SE_MODE_PAGE_BUF</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x01</span>:
		<span class="n">length</span> <span class="o">=</span> <span class="n">target_modesense_rwrecovery</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x08</span>:
		<span class="n">length</span> <span class="o">=</span> <span class="n">target_modesense_caching</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0a</span>:
		<span class="n">length</span> <span class="o">=</span> <span class="n">target_modesense_control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x3f</span>:
		<span class="n">length</span> <span class="o">=</span> <span class="n">target_modesense_rwrecovery</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
		<span class="n">length</span> <span class="o">+=</span> <span class="n">target_modesense_caching</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">length</span><span class="p">]);</span>
		<span class="n">length</span> <span class="o">+=</span> <span class="n">target_modesense_control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">length</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;MODE SENSE: unimplemented page/subpage: 0x%02x/0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_UNKNOWN_MODE_PAGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ten</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_access</span> <span class="o">&amp;</span> <span class="n">TRANSPORT_LUNFLAGS_READ_ONLY</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_deve</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_deve</span><span class="o">-&gt;</span><span class="n">lun_flags</span> <span class="o">&amp;</span> <span class="n">TRANSPORT_LUNFLAGS_READ_ONLY</span><span class="p">)))</span>
			<span class="n">target_modesense_write_protect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">type</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_write_cache</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_fua_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">target_modesense_dpofua</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">type</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">)</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_access</span> <span class="o">&amp;</span> <span class="n">TRANSPORT_LUNFLAGS_READ_ONLY</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_deve</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_deve</span><span class="o">-&gt;</span><span class="n">lun_flags</span> <span class="o">&amp;</span> <span class="n">TRANSPORT_LUNFLAGS_READ_ONLY</span><span class="p">)))</span>
			<span class="n">target_modesense_write_protect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">type</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_write_cache</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_fua_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">target_modesense_dpofua</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">type</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">)</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rbuf</span> <span class="o">=</span> <span class="n">transport_kmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">rbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">transport_kunmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">target_complete_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">GOOD</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">target_emulate_request_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ua_asc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ua_ascq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;REQUEST_SENSE description emulation not&quot;</span>
			<span class="s">&quot; supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_INVALID_CDB_FIELD</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">transport_kmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">core_scsi3_ua_clear_for_request_sense</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ua_asc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ua_ascq</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * CURRENT ERROR, UNIT ATTENTION</span>
<span class="cm">		 */</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNIT_ATTENTION</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">&lt;</span> <span class="mi">18</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The Additional Sense Code (ASC) from the UNIT ATTENTION</span>
<span class="cm">		 */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ua_asc</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">SPC_ASCQ_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ua_ascq</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0A</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * CURRENT ERROR, NO SENSE</span>
<span class="cm">		 */</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">NO_SENSE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">&lt;</span> <span class="mi">18</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * NO ADDITIONAL SENSE INFORMATION</span>
<span class="cm">		 */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0A</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">end:</span>
	<span class="n">transport_kunmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">target_complete_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">GOOD</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used for TCM/IBLOCK and TCM/FILEIO for block/blk-lib.c level discard support.</span>
<span class="cm"> * Note this is not used for TCM/pSCSI passthrough</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">target_emulate_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">sector_t</span> <span class="n">lba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">,</span> <span class="n">range</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">dl</span><span class="p">,</span> <span class="n">bd_dl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">do_discard</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;UNMAP emulation not supported for: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_UNSUPPORTED_SCSI_OPCODE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* First UNMAP block descriptor starts at 8 byte offset */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">dl</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">bd_dl</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">transport_kmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;UNMAP: Sub: %s Using dl: %hu bd_dl: %hu size: %hu&quot;</span>
		<span class="s">&quot; ptr: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">bd_dl</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">range</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;UNMAP: Using lba: %llu and range: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">do_discard</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">lba</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;blkdev_issue_discard() failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">err:</span>
	<span class="n">transport_kunmap_data_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">target_complete_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">GOOD</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used for TCM/IBLOCK and TCM/FILEIO for block/blk-lib.c level discard support.</span>
<span class="cm"> * Note this is not used for TCM/pSCSI passthrough</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">target_emulate_write_same</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">range</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">lba</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_blocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">do_discard</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;WRITE_SAME emulation not supported&quot;</span>
				<span class="s">&quot; for: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_UNSUPPORTED_SCSI_OPCODE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_SAME</span><span class="p">)</span>
		<span class="n">num_blocks</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_SAME_16</span><span class="p">)</span>
		<span class="n">num_blocks</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
	<span class="k">else</span> <span class="cm">/* WRITE_SAME_32 via VARIABLE_LENGTH_CMD */</span>
		<span class="n">num_blocks</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">28</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use the explicit range when non zero is supplied, otherwise calculate</span>
<span class="cm">	 * the remaining range based on -&gt;get_blocks() - starting LBA.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_blocks</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">range</span> <span class="o">=</span> <span class="n">num_blocks</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_blocks</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">-</span> <span class="n">lba</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;WRITE_SAME UNMAP: LBA: %llu Range: %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">range</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">do_discard</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">lba</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;blkdev_issue_discard() failed for WRITE_SAME</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">target_complete_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">GOOD</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">target_emulate_synchronize_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">do_sync_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;SYNCHRONIZE_CACHE emulation not supported&quot;</span>
			<span class="s">&quot; for: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_UNSUPPORTED_SCSI_OPCODE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">do_sync_cache</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">target_emulate_noop</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">target_complete_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">GOOD</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
