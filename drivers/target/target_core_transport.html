<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › target › target_core_transport.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>target_core_transport.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>
<span class="cm"> * Filename:  target_core_transport.c</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains the Generic Target Engine Core.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002, 2003, 2004, 2005 PyX Technologies, Inc.</span>
<span class="cm"> * Copyright (c) 2005, 2006, 2007 SBE, Inc.</span>
<span class="cm"> * Copyright (c) 2007-2010 Rising Tide Systems</span>
<span class="cm"> * Copyright (c) 2008-2010 Linux-iSCSI.org</span>
<span class="cm"> *</span>
<span class="cm"> * Nicholas A. Bellinger &lt;nab@kernel.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/cdrom.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>

<span class="cp">#include &lt;target/target_core_base.h&gt;</span>
<span class="cp">#include &lt;target/target_core_backend.h&gt;</span>
<span class="cp">#include &lt;target/target_core_fabric.h&gt;</span>
<span class="cp">#include &lt;target/target_core_configfs.h&gt;</span>

<span class="cp">#include &quot;target_core_internal.h&quot;</span>
<span class="cp">#include &quot;target_core_alua.h&quot;</span>
<span class="cp">#include &quot;target_core_pr.h&quot;</span>
<span class="cp">#include &quot;target_core_ua.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sub_api_initialized</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">target_completion_wq</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">se_sess_cache</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">se_ua_cache</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">t10_pr_reg_cache</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">t10_alua_lu_gp_cache</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">t10_alua_lu_gp_mem_cache</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">t10_alua_tg_pt_gp_cache</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">t10_alua_tg_pt_gp_mem_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">transport_generic_write_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">transport_processing_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__transport_execute_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">transport_complete_task_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">transport_handle_queue_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">transport_generic_get_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">transport_put_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">transport_remove_cmd_from_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">transport_set_sense_codes</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">asc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ascq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">target_complete_ok_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">init_se_kmem_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">se_sess_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;se_sess_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_session</span><span class="p">),</span> <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_session</span><span class="p">),</span>
			<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se_sess_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kmem_cache_create() for struct se_session&quot;</span>
				<span class="s">&quot; failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">se_ua_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;se_ua_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_ua</span><span class="p">),</span> <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_ua</span><span class="p">),</span>
			<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se_ua_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kmem_cache_create() for struct se_ua failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_sess_cache</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">t10_pr_reg_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;t10_pr_reg_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_pr_registration</span><span class="p">),</span>
			<span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_pr_registration</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t10_pr_reg_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kmem_cache_create() for struct t10_pr_registration&quot;</span>
				<span class="s">&quot; failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_ua_cache</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">t10_alua_lu_gp_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;t10_alua_lu_gp_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_alua_lu_gp</span><span class="p">),</span> <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_alua_lu_gp</span><span class="p">),</span>
			<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t10_alua_lu_gp_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kmem_cache_create() for t10_alua_lu_gp_cache&quot;</span>
				<span class="s">&quot; failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_pr_reg_cache</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">t10_alua_lu_gp_mem_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;t10_alua_lu_gp_mem_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_alua_lu_gp_member</span><span class="p">),</span>
			<span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_alua_lu_gp_member</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t10_alua_lu_gp_mem_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kmem_cache_create() for t10_alua_lu_gp_mem_&quot;</span>
				<span class="s">&quot;cache failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_lu_gp_cache</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">t10_alua_tg_pt_gp_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;t10_alua_tg_pt_gp_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_alua_tg_pt_gp</span><span class="p">),</span>
			<span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_alua_tg_pt_gp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t10_alua_tg_pt_gp_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kmem_cache_create() for t10_alua_tg_pt_gp_&quot;</span>
				<span class="s">&quot;cache failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_lu_gp_mem_cache</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">t10_alua_tg_pt_gp_mem_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span>
			<span class="s">&quot;t10_alua_tg_pt_gp_mem_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_alua_tg_pt_gp_member</span><span class="p">),</span>
			<span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_alua_tg_pt_gp_member</span><span class="p">),</span>
			<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t10_alua_tg_pt_gp_mem_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kmem_cache_create() for t10_alua_tg_pt_gp_&quot;</span>
				<span class="s">&quot;mem_t failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_tg_pt_gp_cache</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">target_completion_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;target_completion&quot;</span><span class="p">,</span>
					       <span class="n">WQ_MEM_RECLAIM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target_completion_wq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_tg_pt_gp_mem_cache</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_tg_pt_gp_mem_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">t10_alua_tg_pt_gp_mem_cache</span><span class="p">);</span>
<span class="nl">out_free_tg_pt_gp_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">t10_alua_tg_pt_gp_cache</span><span class="p">);</span>
<span class="nl">out_free_lu_gp_mem_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">t10_alua_lu_gp_mem_cache</span><span class="p">);</span>
<span class="nl">out_free_lu_gp_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">t10_alua_lu_gp_cache</span><span class="p">);</span>
<span class="nl">out_free_pr_reg_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">t10_pr_reg_cache</span><span class="p">);</span>
<span class="nl">out_free_ua_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">se_ua_cache</span><span class="p">);</span>
<span class="nl">out_free_sess_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">se_sess_cache</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">release_se_kmem_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">target_completion_wq</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">se_sess_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">se_ua_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">t10_pr_reg_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">t10_alua_lu_gp_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">t10_alua_lu_gp_mem_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">t10_alua_tg_pt_gp_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">t10_alua_tg_pt_gp_mem_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This code ensures unique mib indexes are handed out. */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">scsi_mib_index_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">scsi_mib_index</span><span class="p">[</span><span class="n">SCSI_INDEX_TYPE_MAX</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new row index for the entry type specified</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">scsi_get_new_index</span><span class="p">(</span><span class="n">scsi_index_t</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">new_index</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">type</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">SCSI_INDEX_TYPE_MAX</span><span class="p">));</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_mib_index_lock</span><span class="p">);</span>
	<span class="n">new_index</span> <span class="o">=</span> <span class="o">++</span><span class="n">scsi_mib_index</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_mib_index_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">new_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_init_queue_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_queue_obj</span> <span class="o">*</span><span class="n">qobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">queue_cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">qobj_list</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">thread_wq</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">transport_subsystem_check_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sub_api_initialized</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_module</span><span class="p">(</span><span class="s">&quot;target_core_iblock&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to load target_core_iblock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_module</span><span class="p">(</span><span class="s">&quot;target_core_file&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to load target_core_file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_module</span><span class="p">(</span><span class="s">&quot;target_core_pscsi&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to load target_core_pscsi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_module</span><span class="p">(</span><span class="s">&quot;target_core_stgt&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to load target_core_stgt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">sub_api_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="nf">transport_init_session</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">;</span>

	<span class="n">se_sess</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">se_sess_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se_sess</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to allocate struct se_session from&quot;</span>
				<span class="s">&quot; se_sess_cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_acl_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_wait_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">);</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_kref</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">se_sess</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_init_session</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called with spin_lock_irqsave(&amp;struct se_portal_group-&gt;session_lock called.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__transport_register_session</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_portal_group</span> <span class="o">*</span><span class="n">se_tpg</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_node_acl</span> <span class="o">*</span><span class="n">se_nacl</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">fabric_sess_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">PR_REG_ISID_LEN</span><span class="p">];</span>

	<span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_tpg</span> <span class="o">=</span> <span class="n">se_tpg</span><span class="p">;</span>
	<span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">fabric_sess_ptr</span> <span class="o">=</span> <span class="n">fabric_sess_ptr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Used by struct se_node_acl&#39;s under ConfigFS to locate active se_session-t</span>
<span class="cm">	 *</span>
<span class="cm">	 * Only set for struct se_session&#39;s that will actually be moving I/O.</span>
<span class="cm">	 * eg: *NOT* discovery sessions.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se_nacl</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the fabric module supports an ISID based TransportID,</span>
<span class="cm">		 * save this value in binary from the fabric I_T Nexus now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">sess_get_initiator_sid</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PR_REG_ISID_LEN</span><span class="p">);</span>
			<span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">sess_get_initiator_sid</span><span class="p">(</span><span class="n">se_sess</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PR_REG_ISID_LEN</span><span class="p">);</span>
			<span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_bin_isid</span> <span class="o">=</span> <span class="n">get_unaligned_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">acl_kref</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">nacl_sess_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The se_nacl-&gt;nacl_sess pointer will be set to the</span>
<span class="cm">		 * last active I_T Nexus for each struct se_node_acl.</span>
<span class="cm">		 */</span>
		<span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">nacl_sess</span> <span class="o">=</span> <span class="n">se_sess</span><span class="p">;</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_acl_list</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">acl_sess_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">nacl_sess_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">tpg_sess_list</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;TARGET_CORE[%s]: Registered fabric_sess_ptr: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_name</span><span class="p">(),</span> <span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">fabric_sess_ptr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__transport_register_session</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">transport_register_session</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_portal_group</span> <span class="o">*</span><span class="n">se_tpg</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_node_acl</span> <span class="o">*</span><span class="n">se_nacl</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">fabric_sess_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">session_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__transport_register_session</span><span class="p">(</span><span class="n">se_tpg</span><span class="p">,</span> <span class="n">se_nacl</span><span class="p">,</span> <span class="n">se_sess</span><span class="p">,</span> <span class="n">fabric_sess_ptr</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">session_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_register_session</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">target_release_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">se_session</span><span class="p">,</span> <span class="n">sess_kref</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">se_portal_group</span> <span class="o">*</span><span class="n">se_tpg</span> <span class="o">=</span> <span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_tpg</span><span class="p">;</span>

	<span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">close_session</span><span class="p">(</span><span class="n">se_sess</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">target_get_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_kref</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">target_get_session</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">target_put_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_portal_group</span> <span class="o">*</span><span class="n">tpg</span> <span class="o">=</span> <span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_tpg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">put_session</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">put_session</span><span class="p">(</span><span class="n">se_sess</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_kref</span><span class="p">,</span> <span class="n">target_release_session</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">target_put_session</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_complete_nacl</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_node_acl</span> <span class="o">*</span><span class="n">nacl</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">se_node_acl</span><span class="p">,</span> <span class="n">acl_kref</span><span class="p">);</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nacl</span><span class="o">-&gt;</span><span class="n">acl_free_comp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">target_put_nacl</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_node_acl</span> <span class="o">*</span><span class="n">nacl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nacl</span><span class="o">-&gt;</span><span class="n">acl_kref</span><span class="p">,</span> <span class="n">target_complete_nacl</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">transport_deregister_session_configfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_node_acl</span> <span class="o">*</span><span class="n">se_nacl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Used by struct se_node_acl&#39;s under ConfigFS to locate active struct se_session</span>
<span class="cm">	 */</span>
	<span class="n">se_nacl</span> <span class="o">=</span> <span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_node_acl</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se_nacl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">nacl_sess_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">acl_stop</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_acl_list</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the session list is empty, then clear the pointer.</span>
<span class="cm">		 * Otherwise, set the struct se_session pointer from the tail</span>
<span class="cm">		 * element of the per struct se_node_acl active session list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">acl_sess_list</span><span class="p">))</span>
			<span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">nacl_sess</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">nacl_sess</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span>
					<span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">acl_sess_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">se_session</span><span class="p">,</span> <span class="n">sess_acl_list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">nacl_sess_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_deregister_session_configfs</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">transport_free_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">se_sess_cache</span><span class="p">,</span> <span class="n">se_sess</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_free_session</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">transport_deregister_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_portal_group</span> <span class="o">*</span><span class="n">se_tpg</span> <span class="o">=</span> <span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_tpg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">target_core_fabric_ops</span> <span class="o">*</span><span class="n">se_tfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_node_acl</span> <span class="o">*</span><span class="n">se_nacl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">comp_nacl</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se_tpg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport_free_session</span><span class="p">(</span><span class="n">se_sess</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">se_tfo</span> <span class="o">=</span> <span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">session_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_list</span><span class="p">);</span>
	<span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_tpg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">fabric_sess_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">session_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine if we need to do extra work for this initiator node&#39;s</span>
<span class="cm">	 * struct se_node_acl if it had been previously dynamically generated.</span>
<span class="cm">	 */</span>
	<span class="n">se_nacl</span> <span class="o">=</span> <span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_node_acl</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">acl_node_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se_nacl</span> <span class="o">&amp;&amp;</span> <span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">dynamic_node_acl</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">tpg_check_demo_mode_cache</span><span class="p">(</span><span class="n">se_tpg</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_nacl</span><span class="o">-&gt;</span><span class="n">acl_list</span><span class="p">);</span>
			<span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">num_node_acls</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">acl_node_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">core_tpg_wait_for_nacl_pr_ref</span><span class="p">(</span><span class="n">se_nacl</span><span class="p">);</span>
			<span class="n">core_free_device_list_for_node</span><span class="p">(</span><span class="n">se_nacl</span><span class="p">,</span> <span class="n">se_tpg</span><span class="p">);</span>
			<span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">tpg_release_fabric_acl</span><span class="p">(</span><span class="n">se_tpg</span><span class="p">,</span> <span class="n">se_nacl</span><span class="p">);</span>

			<span class="n">comp_nacl</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">acl_node_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">acl_node_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;TARGET_CORE[%s]: Deregistered fabric_sess</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_name</span><span class="p">());</span>
	<span class="cm">/*</span>
<span class="cm">	 * If last kref is dropping now for an explict NodeACL, awake sleeping</span>
<span class="cm">	 * -&gt;acl_free_comp caller to wakeup configfs se_node_acl-&gt;acl_group</span>
<span class="cm">	 * removal context.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se_nacl</span> <span class="o">&amp;&amp;</span> <span class="n">comp_nacl</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
		<span class="n">target_put_nacl</span><span class="p">(</span><span class="n">se_nacl</span><span class="p">);</span>

	<span class="n">transport_free_session</span><span class="p">(</span><span class="n">se_sess</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_deregister_session</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called with cmd-&gt;t_state_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_remove_from_state_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_BUSY</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*	transport_cmd_check_stop():</span>
<span class="cm"> *</span>
<span class="cm"> *	&#39;transport_off = 1&#39; determines if CMD_T_ACTIVE should be cleared.</span>
<span class="cm"> *	&#39;transport_off = 2&#39; determines if task_dev_state should be removed.</span>
<span class="cm"> *</span>
<span class="cm"> *	A non-zero u8 t_state sets cmd-&gt;t_state.</span>
<span class="cm"> *	Returns 1 when command is stopped, else 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_cmd_check_stop</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">transport_off</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">t_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Determine if IOCTL context caller in requesting the stopping of this</span>
<span class="cm">	 * command for LUN shutdown purposes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_LUN_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s:%d CMD_T_LUN_STOP for ITT: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_ACTIVE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport_off</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">target_remove_from_state_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_lun_stop_comp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Determine if frontend context caller is requesting the stopping of</span>
<span class="cm">	 * this command for frontend exceptions.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s:%d CMD_T_STOP for ITT: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">transport_off</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">target_remove_from_state_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear struct se_cmd-&gt;se_lun before the transport_off == 2 handoff</span>
<span class="cm">		 * to FE.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport_off</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_transport_stop_comp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport_off</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_ACTIVE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport_off</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">target_remove_from_state_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Clear struct se_cmd-&gt;se_lun before the transport_off == 2</span>
<span class="cm">			 * handoff to fabric module.</span>
<span class="cm">			 */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Some fabric modules like tcm_loop can release</span>
<span class="cm">			 * their internally allocated I/O reference now and</span>
<span class="cm">			 * struct se_cmd now.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Fabric modules are expected to return &#39;1&#39; here if the</span>
<span class="cm">			 * se_cmd being passed is released at this point,</span>
<span class="cm">			 * or zero if not being released.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">check_stop_free</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

				<span class="k">return</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">check_stop_free</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t_state</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">t_state</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_cmd_check_stop_to_fabric</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">transport_cmd_check_stop</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_lun_remove_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lun</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_DEV_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_DEV_ACTIVE</span><span class="p">;</span>
		<span class="n">target_remove_from_state_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun_node</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun_node</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">transport_cmd_finish_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">remove</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_TMR_CDB</span><span class="p">))</span>
		<span class="n">transport_lun_remove_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport_cmd_check_stop_to_fabric</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remove</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport_remove_cmd_from_queue</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">transport_put_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_add_cmd_to_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t_state</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">at_head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_queue_obj</span> <span class="o">*</span><span class="n">qobj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">t_state</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_ACTIVE</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* If the cmd is already on the list, remove it before we add it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_queue_node</span><span class="p">))</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_queue_node</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">queue_cnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">at_head</span><span class="p">)</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_queue_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">qobj_list</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_queue_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">qobj_list</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_QUEUED</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">thread_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span>
<span class="nf">transport_get_cmd_from_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_queue_obj</span> <span class="o">*</span><span class="n">qobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">qobj_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">qobj_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">se_queue_node</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_QUEUED</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_queue_node</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">queue_cnt</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_remove_cmd_from_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_queue_obj</span> <span class="o">*</span><span class="n">qobj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_QUEUED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_QUEUED</span><span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">queue_cnt</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_queue_node</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_complete_failure_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="n">transport_generic_request_failure</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">target_complete_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">scsi_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="n">scsi_status</span> <span class="o">==</span> <span class="n">GOOD</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="n">scsi_status</span><span class="p">;</span>


	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_BUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transport_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transport_complete</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_TRANSPORT_TASK_SENSE</span><span class="p">;</span>
			<span class="n">success</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if we are waiting to complete for an exception condition.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_REQUEST_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">task_stop_comp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_FAILED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for case where an explict ABORT_TASK has been received</span>
<span class="cm">	 * and transport_wait_for_tasks() will be waiting for completion..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_ABORTED</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_transport_stop_comp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE</span><span class="p">;</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">target_complete_failure_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">target_complete_ok_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">TRANSPORT_COMPLETE</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CMD_T_COMPLETE</span> <span class="o">|</span> <span class="n">CMD_T_ACTIVE</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">queue_work</span><span class="p">(</span><span class="n">target_completion_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">target_complete_cmd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_add_to_state_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__target_add_to_execute_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">head_of_queue</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_task_attr_type</span> <span class="o">==</span> <span class="n">SAM_TASK_ATTR_EMULATED</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">==</span> <span class="n">MSG_HEAD_TAG</span><span class="p">)</span>
		<span class="n">head_of_queue</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">head_of_queue</span><span class="p">)</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_tasks</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_active</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">head_of_queue</span><span class="p">)</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_add_to_execute_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__target_add_to_execute_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__target_remove_from_execute_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">execute_tasks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_remove_from_execute_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__target_remove_from_execute_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle QUEUE_FULL / -EAGAIN and -ENOMEM status</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_qf_do_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_device</span><span class="p">,</span>
					<span class="n">qf_work_queue</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">qf_cmd_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">cmd_tmp</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">qf_cmd_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">qf_cmd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qf_cmd_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">qf_cmd_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd_tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qf_cmd_list</span><span class="p">,</span> <span class="n">se_qf_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_qf_node</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_qf_count</span><span class="p">);</span>
		<span class="n">smp_mb__after_atomic_dec</span><span class="p">();</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Processing %s cmd: %p QUEUE_FULL in work queue&quot;</span>
			<span class="s">&quot; context: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_name</span><span class="p">(),</span> <span class="n">cmd</span><span class="p">,</span>
			<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">TRANSPORT_COMPLETE_QF_OK</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;COMPLETE_OK&quot;</span> <span class="o">:</span>
			<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">TRANSPORT_COMPLETE_QF_WP</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;WRITE_PENDING&quot;</span>
			<span class="o">:</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">);</span>

		<span class="n">transport_add_cmd_to_queue</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">transport_dump_cmd_direction</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_direction</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_NONE</span>:
		<span class="k">return</span> <span class="s">&quot;NONE&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_FROM_DEVICE</span>:
		<span class="k">return</span> <span class="s">&quot;READ&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_TO_DEVICE</span>:
		<span class="k">return</span> <span class="s">&quot;WRITE&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_BIDIRECTIONAL</span>:
		<span class="k">return</span> <span class="s">&quot;BIDI&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">transport_dump_dev_state</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">bl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">bl</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="s">&quot;Status: &quot;</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRANSPORT_DEVICE_ACTIVATED</span>:
		<span class="o">*</span><span class="n">bl</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="s">&quot;ACTIVATED&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRANSPORT_DEVICE_DEACTIVATED</span>:
		<span class="o">*</span><span class="n">bl</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="s">&quot;DEACTIVATED&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRANSPORT_DEVICE_SHUTDOWN</span>:
		<span class="o">*</span><span class="n">bl</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="s">&quot;SHUTDOWN&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRANSPORT_DEVICE_OFFLINE_ACTIVATED</span>:
	<span class="k">case</span> <span class="n">TRANSPORT_DEVICE_OFFLINE_DEACTIVATED</span>:
		<span class="o">*</span><span class="n">bl</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="s">&quot;OFFLINE&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="o">*</span><span class="n">bl</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="s">&quot;UNKNOWN=%d&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">bl</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="s">&quot;  Execute/Max Queue Depth: %d/%d&quot;</span><span class="p">,</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_tasks</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bl</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="s">&quot;  SectorSize: %u  HwMaxSectors: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">hw_max_sectors</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bl</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="s">&quot;        &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">transport_dump_vpd_proto_id</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">t10_vpd</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p_buf</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">p_buf_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">VPD_TMP_BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VPD_TMP_BUF_SIZE</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;T10 VPD Protocol Identifier: &quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">protocol_identifier</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x00</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Fibre Channel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x10</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Parallel SCSI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x20</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;SSA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x30</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;IEEE 1394</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x40</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;SCSI Remote Direct Memory Access&quot;</span>
				<span class="s">&quot; Protocol</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x50</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Internet SCSI (iSCSI)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x60</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;SAS Serial SCSI Protocol</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x70</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Automation/Drive Interface Transport&quot;</span>
				<span class="s">&quot; Protocol</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x80</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;AT Attachment Interface ATA/ATAPI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Unknown 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">protocol_identifier</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_buf</span><span class="p">)</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">p_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">p_buf_len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">transport_set_vpd_proto_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_vpd</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page_83</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if the Protocol Identifier Valid (PIV) bit is set..</span>
<span class="cm">	 *</span>
<span class="cm">	 * from spc3r23.pdf section 7.5.1</span>
<span class="cm">	 */</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">page_83</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">protocol_identifier</span> <span class="o">=</span> <span class="p">(</span><span class="n">page_83</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">);</span>
		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">protocol_identifier_set</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">transport_dump_vpd_proto_id</span><span class="p">(</span><span class="n">vpd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_set_vpd_proto_id</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">transport_dump_vpd_assoc</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">t10_vpd</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p_buf</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">p_buf_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">VPD_TMP_BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VPD_TMP_BUF_SIZE</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;T10 VPD Identifier Association: &quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">association</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x00</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;addressed logical unit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x10</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;target port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x20</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;SCSI target device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Unknown 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">association</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_buf</span><span class="p">)</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">p_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">p_buf_len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">transport_set_vpd_assoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_vpd</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page_83</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The VPD identification association..</span>
<span class="cm">	 *</span>
<span class="cm">	 * from spc3r23.pdf Section 7.6.3.1 Table 297</span>
<span class="cm">	 */</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">association</span> <span class="o">=</span> <span class="p">(</span><span class="n">page_83</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">transport_dump_vpd_assoc</span><span class="p">(</span><span class="n">vpd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_set_vpd_assoc</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">transport_dump_vpd_ident_type</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">t10_vpd</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p_buf</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">p_buf_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">VPD_TMP_BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VPD_TMP_BUF_SIZE</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;T10 VPD Identifier Type: &quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x00</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Vendor specific</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x01</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;T10 Vendor ID based</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x02</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;EUI-64 based</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x03</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;NAA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x04</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Relative target port identifier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x08</span>:
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;SCSI name string</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Unsupported: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier_type</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p_buf_len</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">p_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">p_buf_len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">transport_set_vpd_ident_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_vpd</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page_83</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The VPD identifier type..</span>
<span class="cm">	 *</span>
<span class="cm">	 * from spc3r23.pdf Section 7.6.3.1 Table 298</span>
<span class="cm">	 */</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">page_83</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">transport_dump_vpd_ident_type</span><span class="p">(</span><span class="n">vpd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_set_vpd_ident_type</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">transport_dump_vpd_ident</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">t10_vpd</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p_buf</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">p_buf_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">VPD_TMP_BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VPD_TMP_BUF_SIZE</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier_code_set</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x01</span>: <span class="cm">/* Binary */</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;T10 VPD Binary Device Identifier: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x02</span>: <span class="cm">/* ASCII */</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;T10 VPD ASCII Device Identifier: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x03</span>: <span class="cm">/* UTF-8 */</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;T10 VPD UTF-8 Device Identifier: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;T10 VPD Device Identifier encoding unsupported:&quot;</span>
			<span class="s">&quot; 0x%02x&quot;</span><span class="p">,</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier_code_set</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_buf</span><span class="p">)</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">p_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">p_buf_len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">transport_set_vpd_ident</span><span class="p">(</span><span class="k">struct</span> <span class="n">t10_vpd</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page_83</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">hex_str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;0123456789abcdef&quot;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* offset to start of the identifer */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The VPD Code Set (encoding)</span>
<span class="cm">	 *</span>
<span class="cm">	 * from spc3r23.pdf Section 7.6.3.1 Table 296</span>
<span class="cm">	 */</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier_code_set</span> <span class="o">=</span> <span class="p">(</span><span class="n">page_83</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier_code_set</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x01</span>: <span class="cm">/* Binary */</span>
		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">hex_str</span><span class="p">[</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier_type</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">page_83</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">hex_str</span><span class="p">[(</span><span class="n">page_83</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">];</span>
			<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">hex_str</span><span class="p">[</span><span class="n">page_83</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">];</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x02</span>: <span class="cm">/* ASCII */</span>
	<span class="k">case</span> <span class="mh">0x03</span>: <span class="cm">/* UTF-8 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">page_83</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
			<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">device_identifier</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">page_83</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">transport_dump_vpd_ident</span><span class="p">(</span><span class="n">vpd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_set_vpd_ident</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">core_setup_task_attr_emulation</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this device is from Target_Core_Mod/pSCSI, disable the</span>
<span class="cm">	 * SAM Task Attribute emulation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is currently not available in upsream Linux/SCSI Target</span>
<span class="cm">	 * mode code, and is assumed to be disabled while using TCM/pSCSI.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transport_type</span> <span class="o">==</span> <span class="n">TRANSPORT_PLUGIN_PHBA_PDEV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_task_attr_type</span> <span class="o">=</span> <span class="n">SAM_TASK_ATTR_PASSTHROUGH</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_task_attr_type</span> <span class="o">=</span> <span class="n">SAM_TASK_ATTR_EMULATED</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Using SAM_TASK_ATTR_EMULATED for SPC: 0x%02x&quot;</span>
		<span class="s">&quot; device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_rev</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_dump_inquiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">t10_wwn</span> <span class="o">*</span><span class="n">wwn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">device_type</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Print Linux/SCSI style INQUIRY formatting to the kernel ring buffer</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wwn</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wwn</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  Vendor: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wwn</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wwn</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  Model: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wwn</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wwn</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  Revision: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="n">device_type</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  Type:   %s &quot;</span><span class="p">,</span> <span class="n">scsi_device_type</span><span class="p">(</span><span class="n">device_type</span><span class="p">));</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;                 ANSI SCSI revision: %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_rev</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="nf">transport_add_device_to_core_hba</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_subsystem_api</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_subsystem_dev</span> <span class="o">*</span><span class="n">se_dev</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">device_flags</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">transport_dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_dev_limits</span> <span class="o">*</span><span class="n">dev_limits</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">inquiry_prod</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">inquiry_rev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">force_pt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_device</span>  <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to allocate memory for se_dev_t</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">transport_init_queue_obj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_flags</span>		<span class="o">=</span> <span class="n">device_flags</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_status</span>		<span class="o">|=</span> <span class="n">TRANSPORT_DEVICE_DEACTIVATED</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_ptr</span>		<span class="o">=</span> <span class="n">transport_dev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_hba</span>		<span class="o">=</span> <span class="n">hba</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span>		<span class="o">=</span> <span class="n">se_dev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span>		<span class="o">=</span> <span class="n">transport</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_sep_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_tmr_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delayed_cmd_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">qf_cmd_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delayed_cmd_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_reservation_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_status_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_port_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_tmr_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">qf_cmd_lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_ordered_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">se_dev_set_default_attribs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_limits</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_index</span> <span class="o">=</span> <span class="n">scsi_get_new_index</span><span class="p">(</span><span class="n">SCSI_DEVICE_INDEX</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">creation_time</span> <span class="o">=</span> <span class="n">get_jiffies_64</span><span class="p">();</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">device_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">hba_dev_list</span><span class="p">);</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">device_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Setup the SAM Task Attribute emulation for struct se_device</span>
<span class="cm">	 */</span>
	<span class="n">core_setup_task_attr_emulation</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Force PR and ALUA passthrough emulation with internal object use.</span>
<span class="cm">	 */</span>
	<span class="n">force_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">hba_flags</span> <span class="o">&amp;</span> <span class="n">HBA_FLAGS_INTERNAL_USE</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Setup the Reservations infrastructure for struct se_device</span>
<span class="cm">	 */</span>
	<span class="n">core_setup_reservations</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">force_pt</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Setup the Asymmetric Logical Unit Assignment for struct se_device</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">core_setup_alua</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">force_pt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Startup the struct se_device processing thread</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">process_thread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">transport_processing_thread</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
					  <span class="s">&quot;LIO_%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">process_thread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to create kthread: LIO_%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Setup work_queue for QUEUE_FULL</span>
<span class="cm">	 */</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">qf_work_queue</span><span class="p">,</span> <span class="n">target_qf_do_work</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Preload the initial INQUIRY const values if we are doing</span>
<span class="cm">	 * anything virtual (IBLOCK, FILEIO, RAMDISK), but not for TCM/pSCSI</span>
<span class="cm">	 * passthrough because this is being provided by the backend LLD.</span>
<span class="cm">	 * This is required so that transport_get_inquiry() copies these</span>
<span class="cm">	 * originals once back into DEV_T10_WWN(dev) for the virtual device</span>
<span class="cm">	 * setup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transport_type</span> <span class="o">!=</span> <span class="n">TRANSPORT_PLUGIN_PHBA_PDEV</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inquiry_prod</span> <span class="o">||</span> <span class="o">!</span><span class="n">inquiry_rev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;All non TCM/pSCSI plugins require&quot;</span>
				<span class="s">&quot; INQUIRY consts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">strncpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">vendor</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;LIO-ORG&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inquiry_prod</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">t10_wwn</span><span class="p">.</span><span class="n">revision</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inquiry_rev</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">scsi_dump_inquiry</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">process_thread</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">device_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">);</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">device_lock</span><span class="p">);</span>

	<span class="n">se_release_vpd_for_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_add_device_to_core_hba</span><span class="p">);</span>

<span class="cm">/*	transport_generic_prepare_cdb():</span>
<span class="cm"> *</span>
<span class="cm"> *	Since the Initiator sees iSCSI devices as LUNs,  the SCSI CDB will</span>
<span class="cm"> *	contain the iSCSI LUN in bits 7-5 of byte 1 as per SAM-2.</span>
<span class="cm"> *	The point of this is since we are mapping iSCSI LUNs to</span>
<span class="cm"> *	SCSI Target IDs having a non-zero LUN in the CDB will throw the</span>
<span class="cm"> *	devices and HBAs for a loop.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">transport_generic_prepare_cdb</span><span class="p">(</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">READ_10</span>: <span class="cm">/* SBC - RDProtect */</span>
	<span class="k">case</span> <span class="n">READ_12</span>: <span class="cm">/* SBC - RDProtect */</span>
	<span class="k">case</span> <span class="n">READ_16</span>: <span class="cm">/* SBC - RDProtect */</span>
	<span class="k">case</span> <span class="n">SEND_DIAGNOSTIC</span>: <span class="cm">/* SPC - SELF-TEST Code */</span>
	<span class="k">case</span> <span class="n">VERIFY</span>: <span class="cm">/* SBC - VRProtect */</span>
	<span class="k">case</span> <span class="n">VERIFY_16</span>: <span class="cm">/* SBC - VRProtect */</span>
	<span class="k">case</span> <span class="n">WRITE_VERIFY</span>: <span class="cm">/* SBC - VRProtect */</span>
	<span class="k">case</span> <span class="n">WRITE_VERIFY_12</span>: <span class="cm">/* SBC - VRProtect */</span>
	<span class="k">case</span> <span class="n">MAINTENANCE_IN</span>: <span class="cm">/* SPC - Parameter Data Format for SA RTPG */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0x1f</span><span class="p">;</span> <span class="cm">/* clear logical unit number */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">transport_generic_cmd_sequencer</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Used by fabric modules containing a local struct se_cmd within their</span>
<span class="cm"> * fabric dependent per I/O descriptor.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">transport_init_se_cmd</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">target_core_fabric_ops</span> <span class="o">*</span><span class="n">tfo</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">data_length</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">data_direction</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">task_attr</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sense_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun_node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_delayed_node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_qf_node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_queue_node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_lun_fe_stop_comp</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_lun_stop_comp</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_transport_stop_comp</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_wait_comp</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">task_stop_comp</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">=</span> <span class="n">CMD_T_DEV_ACTIVE</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span> <span class="o">=</span> <span class="n">tfo</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span> <span class="o">=</span> <span class="n">se_sess</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">=</span> <span class="n">data_length</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_direction</span> <span class="o">=</span> <span class="n">data_direction</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">=</span> <span class="n">task_attr</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span> <span class="o">=</span> <span class="n">sense_buffer</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_init_se_cmd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_check_alloc_task_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if SAM Task Attribute emulation is enabled for this</span>
<span class="cm">	 * struct se_device storage object</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_task_attr_type</span> <span class="o">!=</span> <span class="n">SAM_TASK_ATTR_EMULATED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">==</span> <span class="n">MSG_ACA_TAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;SAM Task Attribute ACA&quot;</span>
			<span class="s">&quot; emulation is not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Used to determine when ORDERED commands should go from</span>
<span class="cm">	 * Dormant to Active status.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_ordered_id</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_ordered_id</span><span class="p">);</span>
	<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Allocated se_ordered_id: %u for Task Attr: 0x%02x on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_ordered_id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*	target_setup_cmd_from_cdb():</span>
<span class="cm"> *</span>
<span class="cm"> *	Called from fabric RX Thread.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">target_setup_cmd_from_cdb</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">transport_generic_prepare_cdb</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the received CDB is less than the max (252 + 8) bytes</span>
<span class="cm">	 * for VARIABLE_LENGTH_CMD</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_command_size</span><span class="p">(</span><span class="n">cdb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SCSI_MAX_VARLEN_CDB_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Received SCSI CDB with command_size: %d that&quot;</span>
			<span class="s">&quot; exceeds SCSI_MAX_VARLEN_CDB_SIZE: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">scsi_command_size</span><span class="p">(</span><span class="n">cdb</span><span class="p">),</span> <span class="n">SCSI_MAX_VARLEN_CDB_SIZE</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CDB_EXCEPTION</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_INVALID_CDB_FIELD</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the received CDB is larger than TCM_MAX_COMMAND_SIZE,</span>
<span class="cm">	 * allocate the additional extended CDB buffer now..  Otherwise</span>
<span class="cm">	 * setup the pointer from __t_task_cdb to t_task_cdb.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_command_size</span><span class="p">(</span><span class="n">cdb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">__t_task_cdb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">scsi_command_size</span><span class="p">(</span><span class="n">cdb</span><span class="p">),</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to allocate cmd-&gt;t_task_cdb&quot;</span>
				<span class="s">&quot; %u &gt; sizeof(cmd-&gt;__t_task_cdb): %lu ops</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">scsi_command_size</span><span class="p">(</span><span class="n">cdb</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">__t_task_cdb</span><span class="p">));</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CDB_EXCEPTION</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span>
					<span class="n">TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">__t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy the original CDB into cmd-&gt;</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">scsi_command_size</span><span class="p">(</span><span class="n">cdb</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Setup the received CDB based on SCSI defined opcodes and</span>
<span class="cm">	 * perform unit attention, persistent reservations and ALUA</span>
<span class="cm">	 * checks for virtual device backends.  The cmd-&gt;t_task_cdb</span>
<span class="cm">	 * pointer is expected to be setup before we reach this point.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">transport_generic_cmd_sequencer</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cdb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for SAM Task Attribute Emulation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport_check_alloc_task_attr</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CDB_EXCEPTION</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_INVALID_CDB_FIELD</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="o">-&gt;</span><span class="n">sep_stats</span><span class="p">.</span><span class="n">cmd_pdus</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">target_setup_cmd_from_cdb</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Used by fabric module frontends to queue tasks directly.</span>
<span class="cm"> * Many only be used from process context only</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">transport_handle_cdb_direct</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cmd-&gt;se_lun is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;transport_generic_handle_cdb cannot be called&quot;</span>
				<span class="s">&quot; from interrupt context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set TRANSPORT_NEW_CMD state and CMD_T_ACTIVE following</span>
<span class="cm">	 * transport_generic_handle_cdb*() -&gt; transport_add_cmd_to_queue()</span>
<span class="cm">	 * in existing usage to ensure that outstanding descriptors are handled</span>
<span class="cm">	 * correctly during shutdown via transport_wait_for_tasks()</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also, we don&#39;t take cmd-&gt;t_state_lock here as we only expect</span>
<span class="cm">	 * this to be called for initial descriptor submission.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">TRANSPORT_NEW_CMD</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_ACTIVE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * transport_generic_new_cmd() is already handling QUEUE_FULL,</span>
<span class="cm">	 * so follow TRANSPORT_NEW_CMD processing thread context usage</span>
<span class="cm">	 * and call transport_generic_request_failure() if necessary..</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">transport_generic_new_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">transport_generic_request_failure</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_handle_cdb_direct</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * target_submit_cmd - lookup unpacked lun and submit uninitialized se_cmd</span>
<span class="cm"> *</span>
<span class="cm"> * @se_cmd: command descriptor to submit</span>
<span class="cm"> * @se_sess: associated se_sess for endpoint</span>
<span class="cm"> * @cdb: pointer to SCSI CDB</span>
<span class="cm"> * @sense: pointer to SCSI sense buffer</span>
<span class="cm"> * @unpacked_lun: unpacked LUN to reference for struct se_lun</span>
<span class="cm"> * @data_length: fabric expected data transfer length</span>
<span class="cm"> * @task_addr: SAM task attribute</span>
<span class="cm"> * @data_dir: DMA data direction</span>
<span class="cm"> * @flags: flags for command submission from target_sc_flags_tables</span>
<span class="cm"> *</span>
<span class="cm"> * This may only be called from process context, and also currently</span>
<span class="cm"> * assumes internal allocation of fabric payload buffer by target-core.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">target_submit_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sense</span><span class="p">,</span> <span class="n">u32</span> <span class="n">unpacked_lun</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">data_length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">task_attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_portal_group</span> <span class="o">*</span><span class="n">se_tpg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">se_tpg</span> <span class="o">=</span> <span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_tpg</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">se_tpg</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span> <span class="o">||</span> <span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize se_cmd for target operation.  From this point</span>
<span class="cm">	 * exceptions are handled by sending exception status via</span>
<span class="cm">	 * target_core_fabric_ops-&gt;queue_status() callback</span>
<span class="cm">	 */</span>
	<span class="n">transport_init_se_cmd</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span> <span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="p">,</span> <span class="n">se_sess</span><span class="p">,</span>
				<span class="n">data_length</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span> <span class="n">task_attr</span><span class="p">,</span> <span class="n">sense</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TARGET_SCF_UNKNOWN_SIZE</span><span class="p">)</span>
		<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">unknown_data_length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Obtain struct se_cmd-&gt;cmd_kref reference and add new cmd to</span>
<span class="cm">	 * se_sess-&gt;sess_cmd_list.  A second kref_get here is necessary</span>
<span class="cm">	 * for fabrics using TARGET_SCF_ACK_KREF that expect a second</span>
<span class="cm">	 * kref_put() to happen during fabric packet acknowledgement.</span>
<span class="cm">	 */</span>
	<span class="n">target_get_sess_cmd</span><span class="p">(</span><span class="n">se_sess</span><span class="p">,</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TARGET_SCF_ACK_KREF</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Signal bidirectional data payloads to target-core</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TARGET_SCF_BIDI_OP</span><span class="p">)</span>
		<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_BIDI</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Locate se_lun pointer and attach it to struct se_cmd</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport_lookup_cmd_lun</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span> <span class="n">unpacked_lun</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport_send_check_condition_and_sense</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span>
				<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">target_put_sess_cmd</span><span class="p">(</span><span class="n">se_sess</span><span class="p">,</span> <span class="n">se_cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Sanitize CDBs via transport_generic_cmd_sequencer() and</span>
<span class="cm">	 * allocate the necessary tasks to complete the received CDB+data</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">target_setup_cmd_from_cdb</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span> <span class="n">cdb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport_generic_request_failure</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we need to delay processing because of ALUA</span>
<span class="cm">	 * Active/NonOptimized primary access state..</span>
<span class="cm">	 */</span>
	<span class="n">core_alua_check_nonop_delay</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Dispatch se_cmd descriptor to se_lun-&gt;lun_se_dev backend</span>
<span class="cm">	 * for immediate execution of READs, otherwise wait for</span>
<span class="cm">	 * transport_generic_handle_data() to be called for WRITEs</span>
<span class="cm">	 * when fabric has filled the incoming buffer.</span>
<span class="cm">	 */</span>
	<span class="n">transport_handle_cdb_direct</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">target_submit_cmd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_complete_tmr_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tmr_req</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">=</span> <span class="n">TMR_LUN_DOES_NOT_EXIST</span><span class="p">;</span>
	<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_tm_rsp</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>
	<span class="n">transport_generic_free_cmd</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * target_submit_tmr - lookup unpacked lun and submit uninitialized se_cmd</span>
<span class="cm"> *                     for TMR CDBs</span>
<span class="cm"> *</span>
<span class="cm"> * @se_cmd: command descriptor to submit</span>
<span class="cm"> * @se_sess: associated se_sess for endpoint</span>
<span class="cm"> * @sense: pointer to SCSI sense buffer</span>
<span class="cm"> * @unpacked_lun: unpacked LUN to reference for struct se_lun</span>
<span class="cm"> * @fabric_context: fabric context for TMR req</span>
<span class="cm"> * @tm_type: Type of TM request</span>
<span class="cm"> * @gfp: gfp type for caller</span>
<span class="cm"> * @tag: referenced task tag for TMR_ABORT_TASK</span>
<span class="cm"> * @flags: submit cmd flags</span>
<span class="cm"> *</span>
<span class="cm"> * Callable from all contexts.</span>
<span class="cm"> **/</span>

<span class="kt">int</span> <span class="nf">target_submit_tmr</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sense</span><span class="p">,</span> <span class="n">u32</span> <span class="n">unpacked_lun</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">fabric_tmr_ptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tm_type</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_portal_group</span> <span class="o">*</span><span class="n">se_tpg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">se_tpg</span> <span class="o">=</span> <span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_tpg</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">se_tpg</span><span class="p">);</span>

	<span class="n">transport_init_se_cmd</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span> <span class="n">se_tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="p">,</span> <span class="n">se_sess</span><span class="p">,</span>
			      <span class="mi">0</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">,</span> <span class="n">sense</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: Currently expect caller to handle se_cmd-&gt;se_tmr_req</span>
<span class="cm">	 * allocation failure.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">core_tmr_alloc_req</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span> <span class="n">fabric_tmr_ptr</span><span class="p">,</span> <span class="n">tm_type</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tm_type</span> <span class="o">==</span> <span class="n">TMR_ABORT_TASK</span><span class="p">)</span>
		<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tmr_req</span><span class="o">-&gt;</span><span class="n">ref_task_tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>

	<span class="cm">/* See target_submit_cmd for commentary */</span>
	<span class="n">target_get_sess_cmd</span><span class="p">(</span><span class="n">se_sess</span><span class="p">,</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TARGET_SCF_ACK_KREF</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">transport_lookup_tmr_lun</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span> <span class="n">unpacked_lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For callback during failure handling, push this work off</span>
<span class="cm">		 * to process context with TMR_LUN_DOES_NOT_EXIST status.</span>
<span class="cm">		 */</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">target_complete_tmr_failure</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">transport_generic_handle_tmr</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">target_submit_tmr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Used by fabric module frontends defining a TFO-&gt;new_cmd_map() caller</span>
<span class="cm"> * to  queue up a newly setup se_cmd w/ TRANSPORT_NEW_CMD_MAP in order to</span>
<span class="cm"> * complete setup in TCM process context w/ TFO-&gt;new_cmd_map().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">transport_generic_handle_cdb_map</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cmd-&gt;se_lun is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">transport_add_cmd_to_queue</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">TRANSPORT_NEW_CMD_MAP</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_generic_handle_cdb_map</span><span class="p">);</span>

<span class="cm">/*	transport_generic_handle_data():</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">transport_generic_handle_data</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * For the software fabric case, then we assume the nexus is being</span>
<span class="cm">	 * failed/shutdown when signals are pending from the kthread context</span>
<span class="cm">	 * caller, so we return a failure.  For the HW target mode case running</span>
<span class="cm">	 * in interrupt code, the signal_pending() check is skipped.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_interrupt</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the received CDB has aleady been ABORTED by the generic</span>
<span class="cm">	 * target engine, we now call transport_check_aborted_status()</span>
<span class="cm">	 * to queue any delated TASK_ABORTED status for the received CDB to the</span>
<span class="cm">	 * fabric module as we are expecting no further incoming DATA OUT</span>
<span class="cm">	 * sequences at this point.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport_check_aborted_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">transport_add_cmd_to_queue</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">TRANSPORT_PROCESS_WRITE</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_generic_handle_data</span><span class="p">);</span>

<span class="cm">/*	transport_generic_handle_tmr():</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">transport_generic_handle_tmr</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transport_add_cmd_to_queue</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">TRANSPORT_PROCESS_TMR</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_generic_handle_tmr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If the cmd is active, request it to be stopped and sleep until it</span>
<span class="cm"> * has completed.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">target_stop_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">was_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_REQUEST_STOP</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cmd %p waiting to complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">task_stop_comp</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cmd %p stopped successfully</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_REQUEST_STOP</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_BUSY</span><span class="p">;</span>
		<span class="n">was_active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">was_active</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle SAM-esque emulation for generic transport request failures.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">transport_generic_request_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;-----[ Storage Engine Exception for cmd: %p ITT: 0x%08x&quot;</span>
		<span class="s">&quot; CDB: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;-----[ i_state: %d t_state: %d scsi_sense_reason: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_cmd_state</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;-----[ CMD_T_ACTIVE: %d CMD_T_STOP: %d CMD_T_SENT: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_ACTIVE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_STOP</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_SENT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For SAM Task Attribute emulation for failed struct se_cmd</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_task_attr_type</span> <span class="o">==</span> <span class="n">SAM_TASK_ATTR_EMULATED</span><span class="p">)</span>
		<span class="n">transport_complete_task_attr</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCM_NON_EXISTENT_LUN</span>:
	<span class="k">case</span> <span class="n">TCM_UNSUPPORTED_SCSI_OPCODE</span>:
	<span class="k">case</span> <span class="n">TCM_INVALID_CDB_FIELD</span>:
	<span class="k">case</span> <span class="n">TCM_INVALID_PARAMETER_LIST</span>:
	<span class="k">case</span> <span class="n">TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE</span>:
	<span class="k">case</span> <span class="n">TCM_UNKNOWN_MODE_PAGE</span>:
	<span class="k">case</span> <span class="n">TCM_WRITE_PROTECTED</span>:
	<span class="k">case</span> <span class="n">TCM_CHECK_CONDITION_ABORT_CMD</span>:
	<span class="k">case</span> <span class="n">TCM_CHECK_CONDITION_UNIT_ATTENTION</span>:
	<span class="k">case</span> <span class="n">TCM_CHECK_CONDITION_NOT_READY</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_RESERVATION_CONFLICT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * No SENSE Data payload for this case, set SCSI Status</span>
<span class="cm">		 * and queue the response to $FABRIC_MOD.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Uses linux/include/scsi/scsi.h SAM status codes defs</span>
<span class="cm">		 */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="n">SAM_STAT_RESERVATION_CONFLICT</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * For UA Interlock Code 11b, a RESERVATION CONFLICT will</span>
<span class="cm">		 * establish a UNIT ATTENTION with PREVIOUS RESERVATION</span>
<span class="cm">		 * CONFLICT STATUS.</span>
<span class="cm">		 *</span>
<span class="cm">		 * See spc4r17, section 7.4.6 Control Mode Page, Table 349</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_ua_intlck_ctrl</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">core_scsi3_ua_allocate</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_node_acl</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">orig_fe_lun</span><span class="p">,</span> <span class="mh">0x2C</span><span class="p">,</span>
				<span class="n">ASCQ_2CH_PREVIOUS_RESERVATION_CONFLICT_STATUS</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">queue_full</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">check_stop</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unknown transport error for CDB 0x%02x: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_UNSUPPORTED_SCSI_OPCODE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If a fabric does not define a cmd-&gt;se_tfo-&gt;new_cmd_map caller,</span>
<span class="cm">	 * make the call to transport_send_check_condition_and_sense()</span>
<span class="cm">	 * directly.  Otherwise expect the fabric to make the call to</span>
<span class="cm">	 * transport_send_check_condition_and_sense() after handling</span>
<span class="cm">	 * possible unsoliticied write data payloads.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">transport_send_check_condition_and_sense</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">queue_full</span><span class="p">;</span>

<span class="nl">check_stop:</span>
	<span class="n">transport_lun_remove_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport_cmd_check_stop_to_fabric</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
		<span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">queue_full:</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">TRANSPORT_COMPLETE_QF_OK</span><span class="p">;</span>
	<span class="n">transport_handle_queue_full</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_generic_request_failure</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">transport_lba_21</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">transport_lba_32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">transport_lba_64</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__v1</span><span class="p">,</span> <span class="n">__v2</span><span class="p">;</span>

	<span class="n">__v1</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">__v2</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>

	<span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">__v2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">__v1</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For VARIABLE_LENGTH_CDB w/ 32 byte extended CDBs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">transport_lba_64_ext</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__v1</span><span class="p">,</span> <span class="n">__v2</span><span class="p">;</span>

	<span class="n">__v1</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
	<span class="n">__v2</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">19</span><span class="p">];</span>

	<span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">__v2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">__v1</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_set_supported_SAM_opcode</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SUPPORTED_SAM_OPCODE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from Fabric Module context from transport_execute_tasks()</span>
<span class="cm"> *</span>
<span class="cm"> * The return of this function determins if the tasks from struct se_cmd</span>
<span class="cm"> * get added to the execution queue in transport_execute_tasks(),</span>
<span class="cm"> * or are added to the delayed or ordered lists here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">transport_execute_task_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_task_attr_type</span> <span class="o">!=</span> <span class="n">SAM_TASK_ATTR_EMULATED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for the existence of HEAD_OF_QUEUE, and if true return 1</span>
<span class="cm">	 * to allow the passed struct se_cmd list of tasks to the front of the list.</span>
<span class="cm">	 */</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">==</span> <span class="n">MSG_HEAD_TAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Added HEAD_OF_QUEUE for CDB:&quot;</span>
			<span class="s">&quot; 0x%02x, se_ordered_id: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_ordered_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">==</span> <span class="n">MSG_ORDERED_TAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_ordered_sync</span><span class="p">);</span>
		<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Added ORDERED for CDB: 0x%02x to ordered&quot;</span>
				<span class="s">&quot; list, se_ordered_id: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_ordered_id</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Add ORDERED command to tail of execution queue if</span>
<span class="cm">		 * no other older commands exist that need to be</span>
<span class="cm">		 * completed first.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">simple_cmds</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For SIMPLE and UNTAGGED Task Attribute commands</span>
<span class="cm">		 */</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">simple_cmds</span><span class="p">);</span>
		<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Otherwise if one or more outstanding ORDERED task attribute exist,</span>
<span class="cm">	 * add the dormant task(s) built for the passed struct se_cmd to the</span>
<span class="cm">	 * execution queue and become in Active state for this struct se_device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_ordered_sync</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Otherwise, add cmd w/ tasks to delayed cmd queue that</span>
<span class="cm">		 * will be drained upon completion of HEAD_OF_QUEUE task.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">delayed_cmd_lock</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_DELAYED_CMD_FROM_SAM_ATTR</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_delayed_node</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">delayed_cmd_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">delayed_cmd_lock</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Added CDB: 0x%02x Task Attr: 0x%02x to&quot;</span>
			<span class="s">&quot; delayed CMD list, se_ordered_id: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_ordered_id</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Return zero to let transport_execute_tasks() know</span>
<span class="cm">		 * not to add the delayed tasks to the execution list.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Otherwise, no ORDERED task attributes exist..</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from fabric module context in transport_generic_new_cmd() and</span>
<span class="cm"> * transport_generic_process_write()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_execute_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">add_tasks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">se_dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Call transport_cmd_check_stop() to see if a fabric exception</span>
<span class="cm">	 * has occurred that prevents execution.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport_cmd_check_stop</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TRANSPORT_PROCESSING</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check for SAM Task Attribute emulation and HEAD_OF_QUEUE</span>
<span class="cm">		 * attribute for the tasks of the received struct se_cmd CDB</span>
<span class="cm">		 */</span>
		<span class="n">add_tasks</span> <span class="o">=</span> <span class="n">transport_execute_task_attr</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">add_tasks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__transport_execute_tasks</span><span class="p">(</span><span class="n">se_dev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">__transport_execute_tasks</span><span class="p">(</span><span class="n">se_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__transport_execute_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">new_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

<span class="nl">check_depth:</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_cmd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">__target_add_to_execute_list</span><span class="p">(</span><span class="n">new_cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">execute_list</span><span class="p">);</span>
	<span class="n">__target_remove_from_execute_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_BUSY</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_SENT</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">execute_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_direction</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_BUSY</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_SENT</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">transport_generic_request_failure</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">new_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">check_depth</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">transport_get_sectors_6</span><span class="p">(</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assume TYPE_DISK for non struct se_device objects.</span>
<span class="cm">	 * Use 8-bit sector value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">type_disk</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use 24-bit allocation length for TYPE_TAPE.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_TAPE</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Everything else assume TYPE_DISK Sector CDB location.</span>
<span class="cm">	 * Use 8-bit sector value.  SBC-3 says:</span>
<span class="cm">	 *</span>
<span class="cm">	 *   A TRANSFER LENGTH field set to zero specifies that 256</span>
<span class="cm">	 *   logical blocks shall be written.  Any other value</span>
<span class="cm">	 *   specifies the number of logical blocks that shall be</span>
<span class="cm">	 *   written.</span>
<span class="cm">	 */</span>
<span class="nl">type_disk:</span>
	<span class="k">return</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">?</span> <span class="o">:</span> <span class="mi">256</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">transport_get_sectors_10</span><span class="p">(</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assume TYPE_DISK for non struct se_device objects.</span>
<span class="cm">	 * Use 16-bit sector value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">type_disk</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX_10 is not defined in SSC, throw an exception</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_TAPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Everything else assume TYPE_DISK Sector CDB location.</span>
<span class="cm">	 * Use 16-bit sector value.</span>
<span class="cm">	 */</span>
<span class="nl">type_disk:</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">transport_get_sectors_12</span><span class="p">(</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assume TYPE_DISK for non struct se_device objects.</span>
<span class="cm">	 * Use 32-bit sector value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">type_disk</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX_12 is not defined in SSC, throw an exception</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_TAPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Everything else assume TYPE_DISK Sector CDB location.</span>
<span class="cm">	 * Use 32-bit sector value.</span>
<span class="cm">	 */</span>
<span class="nl">type_disk:</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">transport_get_sectors_16</span><span class="p">(</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assume TYPE_DISK for non struct se_device objects.</span>
<span class="cm">	 * Use 32-bit sector value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">type_disk</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use 24-bit allocation length for TYPE_TAPE.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_TAPE</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>

<span class="nl">type_disk:</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used for VARIABLE_LENGTH_CDB WRITE_32 and READ_32 variants</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">transport_get_sectors_32</span><span class="p">(</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Assume TYPE_DISK for non struct se_device objects.</span>
<span class="cm">	 * Use 32-bit sector value.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">28</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">transport_get_size</span><span class="p">(</span>
	<span class="n">u32</span> <span class="n">sectors</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_TAPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* sectors */</span>
			<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">*</span> <span class="n">sectors</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="cm">/* bytes */</span>
			<span class="k">return</span> <span class="n">sectors</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Returning block_size: %u, sectors: %u == %u for&quot;</span>
		<span class="s">&quot; %s object</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span><span class="p">,</span>
		<span class="n">sectors</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">*</span> <span class="n">sectors</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">*</span> <span class="n">sectors</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_xor_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * From sbc3r22.pdf section 5.48 XDWRITEREAD (10) command</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) read the specified logical block(s);</span>
<span class="cm">	 * 2) transfer logical blocks from the data-out buffer;</span>
<span class="cm">	 * 3) XOR the logical blocks transferred from the data-out buffer with</span>
<span class="cm">	 *    the logical blocks read, storing the resulting XOR data in a buffer;</span>
<span class="cm">	 * 4) if the DISABLE WRITE bit is set to zero, then write the logical</span>
<span class="cm">	 *    blocks transferred from the data-out buffer; and</span>
<span class="cm">	 * 5) transfer the resulting XOR data to the data-in buffer.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to allocate xor_callback buf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy the scatterlist WRITE buffer located at cmd-&gt;t_data_sg</span>
<span class="cm">	 * into the locally allocated *buf</span>
<span class="cm">	 */</span>
	<span class="n">sg_copy_to_buffer</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">,</span>
			  <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span><span class="p">,</span>
			  <span class="n">buf</span><span class="p">,</span>
			  <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now perform the XOR against the BIDI read memory located at</span>
<span class="cm">	 * cmd-&gt;t_mem_bidi_list</span>
<span class="cm">	 */</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_bidi_data_sg</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_bidi_data_nents</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">^=</span> <span class="o">*</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">offset</span> <span class="o">+=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used to obtain Sense Data from underlying Linux/SCSI struct scsi_cmnd</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_get_sense_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="o">*</span><span class="n">sense_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SENT_CHECK_CONDITION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_TRANSPORT_TASK_SENSE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_sense_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;dev-&gt;transport-&gt;get_sense_buffer is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sense_buffer</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_sense_buffer</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sense_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ITT 0x%08x cmd %p: Unable to locate&quot;</span>
			<span class="s">&quot; sense buffer for task with sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">set_fabric_sense_len</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">TRANSPORT_SENSE_BUFFER</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="n">sense_buffer</span><span class="p">,</span> <span class="n">TRANSPORT_SENSE_BUFFER</span><span class="p">);</span>

	<span class="cm">/* Automatically padded */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_length</span> <span class="o">=</span> <span class="n">TRANSPORT_SENSE_BUFFER</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;HBA_[%u]_PLUG[%s]: Set SAM STATUS: 0x%02x and sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_hba</span><span class="o">-&gt;</span><span class="n">hba_id</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">transport_dev_end_lba</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_blocks</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_cmd_get_valid_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sectors</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TYPE_DISK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sectors</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">/</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">+</span> <span class="n">sectors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">transport_dev_end_lba</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;LBA: %llu Sectors: %u exceeds&quot;</span>
			<span class="s">&quot; transport_dev_end_lba(): %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span><span class="p">,</span> <span class="n">sectors</span><span class="p">,</span>
			<span class="n">transport_dev_end_lba</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">target_check_write_same_discard</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Determine if the received WRITE_SAME is used to for direct</span>
<span class="cm">	 * passthrough into Linux/SCSI with struct request via TCM/pSCSI</span>
<span class="cm">	 * or we are signaling the use of internal WRITE_SAME + UNMAP=1</span>
<span class="cm">	 * emulation for -&gt; Linux/BLOCK disbard with TCM/IBLOCK code.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">passthrough</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transport_type</span> <span class="o">==</span>
				<span class="n">TRANSPORT_PLUGIN_PHBA_PDEV</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;WRITE_SAME PBDATA and LBDATA&quot;</span>
				<span class="s">&quot; bits not supported for Block Discard&quot;</span>
				<span class="s">&quot; Emulation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Currently for the emulated case we only accept</span>
<span class="cm">		 * tpws with the UNMAP=1 bit set.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;WRITE_SAME w/o UNMAP bit not&quot;</span>
				<span class="s">&quot; supported for Block Discard Emulation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*	transport_generic_cmd_sequencer():</span>
<span class="cm"> *</span>
<span class="cm"> *	Generic Command Sequencer that should work for most DAS transport</span>
<span class="cm"> *	drivers.</span>
<span class="cm"> *</span>
<span class="cm"> *	Called from target_setup_cmd_from_cdb() in the $FABRIC_MOD</span>
<span class="cm"> *	RX Thread.</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: Need to support other SCSI OPCODES where as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_generic_cmd_sequencer</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_subsystem_dev</span> <span class="o">*</span><span class="n">su_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sector_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">passthrough</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pr_reg_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">service_action</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">alua_ascq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for an existing UNIT ATTENTION condition</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">core_scsi3_ua_check</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cdb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CDB_EXCEPTION</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_CHECK_CONDITION_UNIT_ATTENTION</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check status of Asymmetric Logical Unit Assignment port</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">t10_alua</span><span class="p">.</span><span class="n">alua_state_check</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alua_ascq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set SCSI additional sense code (ASC) to &#39;LUN Not Accessible&#39;;</span>
<span class="cm">		 * The ALUA additional sense code qualifier (ASCQ) is determined</span>
<span class="cm">		 * by the ALUA primary or secondary access state..</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;[%s]: ALUA TG Port not available,&quot;</span>
				<span class="s">&quot; SenseKey: NOT_READY, ASC/ASCQ: 0x04/0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_name</span><span class="p">(),</span> <span class="n">alua_ascq</span><span class="p">);</span>

			<span class="n">transport_set_sense_codes</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="n">alua_ascq</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CDB_EXCEPTION</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_CHECK_CONDITION_NOT_READY</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check status for SPC-3 Persistent Reservations</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">t10_pr</span><span class="p">.</span><span class="n">pr_ops</span><span class="p">.</span><span class="n">t10_reservation_check</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pr_reg_type</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">t10_pr</span><span class="p">.</span><span class="n">pr_ops</span><span class="p">.</span><span class="n">t10_seq_non_holder</span><span class="p">(</span>
					<span class="n">cmd</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">pr_reg_type</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CDB_EXCEPTION</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_RESERVATION_CONFLICT</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="n">SAM_STAT_RESERVATION_CONFLICT</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_RESERVATION_CONFLICT</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * This means the CDB is allowed for the SCSI Initiator port</span>
<span class="cm">		 * when said port is *NOT* holding the legacy SPC-2 or</span>
<span class="cm">		 * SPC-3 Persistent Reservation.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we operate in passthrough mode we skip most CDB emulation and</span>
<span class="cm">	 * instead hand the commands down to the physical SCSI device.</span>
<span class="cm">	 */</span>
	<span class="n">passthrough</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transport_type</span> <span class="o">==</span> <span class="n">TRANSPORT_PLUGIN_PHBA_PDEV</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">READ_6</span>:
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_6</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_21</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_10</span>:
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_10</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_32</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_12</span>:
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_12</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_32</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_16</span>:
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_16</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_64</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WRITE_6</span>:
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_6</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_21</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WRITE_10</span>:
	<span class="k">case</span> <span class="n">WRITE_VERIFY</span>:
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_10</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_32</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_FUA</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WRITE_12</span>:
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_12</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_32</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_FUA</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WRITE_16</span>:
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_16</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_64</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_FUA</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XDWRITEREAD_10</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_direction</span> <span class="o">!=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_BIDI</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_10</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_32</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do now allow BIDI commands for passthrough mode.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Setup BIDI XOR callback to be run after I/O completion.</span>
<span class="cm">		 */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_complete_callback</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transport_xor_callback</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_FUA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VARIABLE_LENGTH_CMD</span>:
		<span class="n">service_action</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">service_action</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XDWRITEREAD_32</span>:
			<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_32</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Use WRITE_32 and READ_32 opcodes for the emulated</span>
<span class="cm">			 * XDWRITE_READ_32 logic.</span>
<span class="cm">			 */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_64_ext</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Do now allow BIDI commands for passthrough mode.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">passthrough</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Setup BIDI XOR callback to be run during after I/O</span>
<span class="cm">			 * completion.</span>
<span class="cm">			 */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_complete_callback</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transport_xor_callback</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_FUA</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">WRITE_SAME_32</span>:
			<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_32</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sectors</span><span class="p">)</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;WSNZ=1, WRITE_SAME w/sectors=0 not&quot;</span>
				       <span class="s">&quot; supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">get_unaligned_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">12</span><span class="p">]);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">target_check_write_same_discard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">dev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_write_same</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;VARIABLE_LENGTH_CMD service action&quot;</span>
				<span class="s">&quot; 0x%04x not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">service_action</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MAINTENANCE_IN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TYPE_ROM</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* MAINTENANCE_IN from SCC-2 */</span>
			<span class="cm">/*</span>
<span class="cm">			 * Check for emulated MI_REPORT_TARGET_PGS.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">==</span> <span class="n">MI_REPORT_TARGET_PGS</span> <span class="o">&amp;&amp;</span>
			    <span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">t10_alua</span><span class="p">.</span><span class="n">alua_type</span> <span class="o">==</span> <span class="n">SPC3_ALUA_EMULATED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span>
					<span class="n">target_emulate_report_target_port_groups</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* GPCMD_SEND_KEY from multi media commands */</span>
			<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MODE_SELECT</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MODE_SELECT_10</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MODE_SENSE</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_modesense</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MODE_SENSE_10</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_modesense</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GPCMD_READ_BUFFER_CAPACITY</span>:
	<span class="k">case</span> <span class="n">GPCMD_SEND_OPC</span>:
	<span class="k">case</span> <span class="n">LOG_SELECT</span>:
	<span class="k">case</span> <span class="n">LOG_SENSE</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_BLOCK_LIMITS</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="n">READ_BLOCK_LEN</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GPCMD_GET_CONFIGURATION</span>:
	<span class="k">case</span> <span class="n">GPCMD_READ_FORMAT_CAPACITIES</span>:
	<span class="k">case</span> <span class="n">GPCMD_READ_DISC_INFO</span>:
	<span class="k">case</span> <span class="n">GPCMD_READ_TRACK_RZONE_INFO</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PERSISTENT_RESERVE_IN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">t10_pr</span><span class="p">.</span><span class="n">res_type</span> <span class="o">==</span> <span class="n">SPC3_PERSISTENT_RESERVATIONS</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_scsi3_emulate_pr_in</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PERSISTENT_RESERVE_OUT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">t10_pr</span><span class="p">.</span><span class="n">res_type</span> <span class="o">==</span> <span class="n">SPC3_PERSISTENT_RESERVATIONS</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_scsi3_emulate_pr_out</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GPCMD_MECHANISM_STATUS</span>:
	<span class="k">case</span> <span class="n">GPCMD_READ_DVD_STRUCTURE</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_POSITION</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="n">READ_POSITION_LEN</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MAINTENANCE_OUT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">get_device_type</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TYPE_ROM</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* MAINTENANCE_OUT from SCC-2</span>
<span class="cm">			 *</span>
<span class="cm">			 * Check for emulated MO_SET_TARGET_PGS.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">MO_SET_TARGET_PGS</span> <span class="o">&amp;&amp;</span>
			    <span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">t10_alua</span><span class="p">.</span><span class="n">alua_type</span> <span class="o">==</span> <span class="n">SPC3_ALUA_EMULATED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span>
					<span class="n">target_emulate_set_target_port_groups</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
			<span class="cm">/* GPCMD_REPORT_KEY from multi media commands */</span>
			<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INQUIRY</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do implict HEAD_OF_QUEUE processing for INQUIRY.</span>
<span class="cm">		 * See spc4r17 section 5.3</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_task_attr_type</span> <span class="o">==</span> <span class="n">SAM_TASK_ATTR_EMULATED</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">=</span> <span class="n">MSG_HEAD_TAG</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_inquiry</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_BUFFER</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_CAPACITY</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="n">READ_CAP_LEN</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_readcapacity</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_MEDIA_SERIAL_NUMBER</span>:
	<span class="k">case</span> <span class="n">SECURITY_PROTOCOL_IN</span>:
	<span class="k">case</span> <span class="n">SECURITY_PROTOCOL_OUT</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SERVICE_ACTION_IN</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SAI_READ_CAPACITY_16</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span>
					<span class="n">target_emulate_readcapacity_16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">passthrough</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unsupported SA: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*FALLTHROUGH*/</span>
	<span class="k">case</span> <span class="n">ACCESS_CONTROL_IN</span>:
	<span class="k">case</span> <span class="n">ACCESS_CONTROL_OUT</span>:
	<span class="k">case</span> <span class="n">EXTENDED_COPY</span>:
	<span class="k">case</span> <span class="n">READ_ATTRIBUTE</span>:
	<span class="k">case</span> <span class="n">RECEIVE_COPY_RESULTS</span>:
	<span class="k">case</span> <span class="n">WRITE_ATTRIBUTE</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		       <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECEIVE_DIAGNOSTIC</span>:
	<span class="k">case</span> <span class="n">SEND_DIAGNOSTIC</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cm">/* #warning FIXME: Figure out correct GPCMD_READ_CD blocksize. */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	case GPCMD_READ_CD:</span>
<span class="c">		sectors = (cdb[6] &lt;&lt; 16) + (cdb[7] &lt;&lt; 8) + cdb[8];</span>
<span class="c">		size = (2336 * sectors);</span>
<span class="c">		cmd-&gt;se_cmd_flags |= SCF_SCSI_CONTROL_SG_IO_CDB;</span>
<span class="c">		break;</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">READ_TOC</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">REQUEST_SENSE</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_request_sense</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_ELEMENT_STATUS</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="mi">65536</span> <span class="o">*</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="mi">256</span> <span class="o">*</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WRITE_BUFFER</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RESERVE</span>:
	<span class="k">case</span> <span class="n">RESERVE_10</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The SPC-2 RESERVE does not contain a size in the SCSI CDB.</span>
<span class="cm">		 * Assume the passthrough or $FABRIC_MOD will tell us about it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">RESERVE_10</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Setup the legacy emulated handler for SPC-2 and</span>
<span class="cm">		 * &gt;= SPC-3 compatible reservation handling (CRH=1)</span>
<span class="cm">		 * Otherwise, we assume the underlying SCSI logic is</span>
<span class="cm">		 * is running in SPC_PASSTHROUGH, and wants reservations</span>
<span class="cm">		 * emulation disabled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">t10_pr</span><span class="p">.</span><span class="n">res_type</span> <span class="o">!=</span> <span class="n">SPC_PASSTHROUGH</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_scsi2_reservation_reserve</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_NON_DATA_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RELEASE</span>:
	<span class="k">case</span> <span class="n">RELEASE_10</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The SPC-2 RELEASE does not contain a size in the SCSI CDB.</span>
<span class="cm">		 * Assume the passthrough or $FABRIC_MOD will tell us about it.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">RELEASE_10</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">t10_pr</span><span class="p">.</span><span class="n">res_type</span> <span class="o">!=</span> <span class="n">SPC_PASSTHROUGH</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_scsi2_reservation_release</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_NON_DATA_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYNCHRONIZE_CACHE</span>:
	<span class="k">case</span> <span class="n">SYNCHRONIZE_CACHE_16</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Extract LBA and range to be flushed for emulated SYNCHRONIZE_CACHE</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">SYNCHRONIZE_CACHE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_10</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_32</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_16</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">transport_lba_64</span><span class="p">(</span><span class="n">cdb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_NON_DATA_CDB</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check to ensure that LBA + Range does not exceed past end of</span>
<span class="cm">		 * device for IBLOCK and FILEIO -&gt;do_sync_cache() backend calls</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sectors</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">transport_cmd_get_valid_sectors</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_synchronize_cache</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UNMAP</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_unmap</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WRITE_SAME_16</span>:
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_16</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sectors</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;WSNZ=1, WRITE_SAME w/sectors=0 not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">get_unaligned_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">target_check_write_same_discard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_write_same</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WRITE_SAME</span>:
		<span class="n">sectors</span> <span class="o">=</span> <span class="n">transport_get_sectors_10</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sector_ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sectors</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">transport_get_size</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;WSNZ=1, WRITE_SAME w/sectors=0 not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Follow sbcr26 with WRITE_SAME (10) and check for the existence</span>
<span class="cm">		 * of byte 1 bit 3 UNMAP instead of original reserved field</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target_check_write_same_discard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_write_same</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ALLOW_MEDIUM_REMOVAL</span>:
	<span class="k">case</span> <span class="n">ERASE</span>:
	<span class="k">case</span> <span class="n">REZERO_UNIT</span>:
	<span class="k">case</span> <span class="n">SEEK_10</span>:
	<span class="k">case</span> <span class="n">SPACE</span>:
	<span class="k">case</span> <span class="n">START_STOP</span>:
	<span class="k">case</span> <span class="n">TEST_UNIT_READY</span>:
	<span class="k">case</span> <span class="n">VERIFY</span>:
	<span class="k">case</span> <span class="n">WRITE_FILEMARKS</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_NON_DATA_CDB</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_emulate_noop</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GPCMD_CLOSE_TRACK</span>:
	<span class="k">case</span> <span class="n">INITIALIZE_ELEMENT_STATUS</span>:
	<span class="k">case</span> <span class="n">GPCMD_LOAD_UNLOAD</span>:
	<span class="k">case</span> <span class="n">GPCMD_SET_SPEED</span>:
	<span class="k">case</span> <span class="n">MOVE_MEDIUM</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_NON_DATA_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">REPORT_LUNS</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">=</span> <span class="n">target_report_luns</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do implict HEAD_OF_QUEUE processing for REPORT_LUNS</span>
<span class="cm">		 * See spc4r17 section 5.3</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_task_attr_type</span> <span class="o">==</span> <span class="n">SAM_TASK_ATTR_EMULATED</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">=</span> <span class="n">MSG_HEAD_TAG</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GET_EVENT_STATUS_NOTIFICATION</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_16</span>:
		<span class="cm">/* Only support ATA passthrough to pSCSI backends.. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passthrough</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>

		<span class="cm">/* T_LENGTH */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x0</span>:
			<span class="n">sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x1</span>:
			<span class="n">sectors</span> <span class="o">=</span> <span class="p">(((</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">?</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x2</span>:
			<span class="n">sectors</span> <span class="o">=</span> <span class="p">(((</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">?</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x3</span>:
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;T_LENGTH=0x3 not supported for ATA_16</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* BYTE_BLOCK */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x4</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* BLOCK T_TYPE: 512 or sector */</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="p">((</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">:</span> <span class="mi">512</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* BYTE */</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">sectors</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;TARGET_CORE[%s]: Unsupported SCSI Opcode&quot;</span>
			<span class="s">&quot; 0x%02x, sending CHECK_CONDITION.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_name</span><span class="p">(),</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">unknown_data_length</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;TARGET_CORE[%s]: Expected Transfer Length:&quot;</span>
			<span class="s">&quot; %u does not match SCSI CDB Length: %u for SAM Opcode:&quot;</span>
			<span class="s">&quot; 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_name</span><span class="p">(),</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_spdtl</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Rejecting underflow/overflow&quot;</span>
					<span class="s">&quot; WRITE data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reject READ_* or WRITE_* with overflow/underflow for</span>
<span class="cm">		 * type SCF_SCSI_DATA_SG_IO_CDB.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">block_size</span> <span class="o">!=</span> <span class="mi">512</span><span class="p">))</span>  <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failing OVERFLOW/UNDERFLOW for LBA op&quot;</span>
				<span class="s">&quot; CDB on non 512-byte sector setup subsystem&quot;</span>
				<span class="s">&quot; plugin: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="cm">/* Returns CHECK_CONDITION + INVALID_CDB_FIELD */</span>
			<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_OVERFLOW_BIT</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">residual_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_UNDERFLOW_BIT</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">residual_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">-</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sectors</span> <span class="o">&gt;</span> <span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">fabric_max_sectors</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SCSI OP %02xh with too&quot;</span>
				<span class="s">&quot; big sectors %u exceeds fabric_max_sectors:&quot;</span>
				<span class="s">&quot; %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sectors</span><span class="p">,</span>
				<span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">fabric_max_sectors</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sectors</span> <span class="o">&gt;</span> <span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">hw_max_sectors</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SCSI OP %02xh with too&quot;</span>
				<span class="s">&quot; big sectors %u exceeds backend hw_max_sectors:&quot;</span>
				<span class="s">&quot; %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sectors</span><span class="p">,</span>
				<span class="n">su_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">hw_max_sectors</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_invalid_cdb_field</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* reject any command that we don&#39;t have a handler for */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">passthrough</span> <span class="o">||</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_cmd</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_unsupported_cdb</span><span class="p">;</span>

	<span class="n">transport_set_supported_SAM_opcode</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">out_unsupported_cdb:</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CDB_EXCEPTION</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_UNSUPPORTED_SCSI_OPCODE</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">out_invalid_cdb_field:</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CDB_EXCEPTION</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_INVALID_CDB_FIELD</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from I/O completion to determine which dormant/delayed</span>
<span class="cm"> * and ordered cmds need to have their tasks added to the execution queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_complete_task_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd_p</span><span class="p">,</span> <span class="o">*</span><span class="n">cmd_tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_active_tasks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">==</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">simple_cmds</span><span class="p">);</span>
		<span class="n">smp_mb__after_atomic_dec</span><span class="p">();</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_cur_ordered_id</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Incremented dev-&gt;dev_cur_ordered_id: %u for&quot;</span>
			<span class="s">&quot; SIMPLE: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_cur_ordered_id</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_ordered_id</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">==</span> <span class="n">MSG_HEAD_TAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_cur_ordered_id</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Incremented dev_cur_ordered_id: %u for&quot;</span>
			<span class="s">&quot; HEAD_OF_QUEUE: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_cur_ordered_id</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_ordered_id</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">==</span> <span class="n">MSG_ORDERED_TAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_ordered_sync</span><span class="p">);</span>
		<span class="n">smp_mb__after_atomic_dec</span><span class="p">();</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_cur_ordered_id</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Incremented dev_cur_ordered_id: %u for ORDERED:&quot;</span>
			<span class="s">&quot; %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_cur_ordered_id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_ordered_id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Process all commands up to the last received</span>
<span class="cm">	 * ORDERED task attribute which requires another blocking</span>
<span class="cm">	 * boundary</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delayed_cmd_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cmd_p</span><span class="p">,</span> <span class="n">cmd_tmp</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delayed_cmd_list</span><span class="p">,</span> <span class="n">se_delayed_node</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd_p</span><span class="o">-&gt;</span><span class="n">se_delayed_node</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delayed_cmd_lock</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Calling add_tasks() for&quot;</span>
			<span class="s">&quot; cmd_p: 0x%02x Task Attr: 0x%02x&quot;</span>
			<span class="s">&quot; Dormant -&gt; Active, se_ordered_id: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd_p</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">cmd_p</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span><span class="p">,</span> <span class="n">cmd_p</span><span class="o">-&gt;</span><span class="n">se_ordered_id</span><span class="p">);</span>

		<span class="n">target_add_to_execute_list</span><span class="p">(</span><span class="n">cmd_p</span><span class="p">);</span>
		<span class="n">new_active_tasks</span><span class="o">++</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delayed_cmd_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_p</span><span class="o">-&gt;</span><span class="n">sam_task_attr</span> <span class="o">==</span> <span class="n">MSG_ORDERED_TAG</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delayed_cmd_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If new tasks have become active, wake up the transport thread</span>
<span class="cm">	 * to do the processing of the Active tasks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_active_tasks</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">.</span><span class="n">thread_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_complete_qf</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_task_attr_type</span> <span class="o">==</span> <span class="n">SAM_TASK_ATTR_EMULATED</span><span class="p">)</span>
		<span class="n">transport_complete_task_attr</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_TRANSPORT_TASK_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_direction</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_FROM_DEVICE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_data_in</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_TO_DEVICE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_bidi_data_sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_data_in</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Fall through for DMA_TO_DEVICE */</span>
	<span class="k">case</span> <span class="n">DMA_NONE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport_handle_queue_full</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">transport_lun_remove_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">transport_cmd_check_stop_to_fabric</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_handle_queue_full</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">qf_cmd_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_qf_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">qf_cmd_list</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_qf_count</span><span class="p">);</span>
	<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">qf_cmd_lock</span><span class="p">);</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">qf_work_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_complete_ok_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">reason</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we need to move delayed/dormant tasks from cmds on the</span>
<span class="cm">	 * delayed execution list after a HEAD_OF_QUEUE or ORDERED Task</span>
<span class="cm">	 * Attribute.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_task_attr_type</span> <span class="o">==</span> <span class="n">SAM_TASK_ATTR_EMULATED</span><span class="p">)</span>
		<span class="n">transport_complete_task_attr</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check to schedule QUEUE_FULL work, or execute an existing</span>
<span class="cm">	 * cmd-&gt;transport_qf_callback()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_qf_count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">qf_work_queue</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we need to retrieve a sense buffer from</span>
<span class="cm">	 * the struct se_cmd in question.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_TRANSPORT_TASK_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport_get_sense_data</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reason</span> <span class="o">=</span> <span class="n">TCM_NON_EXISTENT_LUN</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">transport_send_check_condition_and_sense</span><span class="p">(</span>
					<span class="n">cmd</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">queue_full</span><span class="p">;</span>

			<span class="n">transport_lun_remove_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">transport_cmd_check_stop_to_fabric</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for a callback, used by amongst other things</span>
<span class="cm">	 * XDWRITE_READ_10 emulation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_complete_callback</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_complete_callback</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_direction</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_FROM_DEVICE</span>:
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="o">-&gt;</span><span class="n">sep_stats</span><span class="p">.</span><span class="n">tx_data_octets</span> <span class="o">+=</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep_lock</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_data_in</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">queue_full</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_TO_DEVICE</span>:
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="o">-&gt;</span><span class="n">sep_stats</span><span class="p">.</span><span class="n">rx_data_octets</span> <span class="o">+=</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check if we need to send READ payload for BIDI-COMMAND</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_bidi_data_sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep</span><span class="o">-&gt;</span><span class="n">sep_stats</span><span class="p">.</span><span class="n">tx_data_octets</span> <span class="o">+=</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">lun_sep_lock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_data_in</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">queue_full</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Fall through for DMA_TO_DEVICE */</span>
	<span class="k">case</span> <span class="n">DMA_NONE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">queue_full</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">transport_lun_remove_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">transport_cmd_check_stop_to_fabric</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">queue_full:</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Handling complete_ok QUEUE_FULL: se_cmd: %p,&quot;</span>
		<span class="s">&quot; data_direction: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_direction</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">TRANSPORT_COMPLETE_QF_OK</span><span class="p">;</span>
	<span class="n">transport_handle_queue_full</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">transport_free_sgl</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sgl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">transport_free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">transport_free_sgl</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">transport_free_sgl</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_bidi_data_sg</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_bidi_data_nents</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_bidi_data_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_bidi_data_nents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * transport_release_cmd - free a command</span>
<span class="cm"> * @cmd:       command to free</span>
<span class="cm"> *</span>
<span class="cm"> * This routine unconditionally frees a command, and reference counting</span>
<span class="cm"> * or list removal must be done in the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_release_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_TMR_CDB</span><span class="p">)</span>
		<span class="n">core_tmr_release_req</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tmr_req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">__t_task_cdb</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this cmd has been setup with target_get_sess_cmd(), drop</span>
<span class="cm">	 * the kref and call -&gt;release_cmd() in kref callback.</span>
<span class="cm">	 */</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">check_release</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">target_put_sess_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">release_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * transport_put_cmd - release a reference to a command</span>
<span class="cm"> * @cmd:       command to release</span>
<span class="cm"> *</span>
<span class="cm"> * This routine releases our reference to the command and frees it if possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_put_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_fe_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_fe_count</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_busy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_DEV_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_DEV_ACTIVE</span><span class="p">;</span>
		<span class="n">target_remove_from_state_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">transport_free_pages</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">transport_release_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">out_busy:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * transport_generic_map_mem_to_cmd - Use fabric-alloced pages instead of</span>
<span class="cm"> * allocating in the core.</span>
<span class="cm"> * @cmd:  Associated se_cmd descriptor</span>
<span class="cm"> * @mem:  SGL style memory for TCM WRITE / READ</span>
<span class="cm"> * @sg_mem_num: Number of SGL elements</span>
<span class="cm"> * @mem_bidi_in: SGL style memory for TCM BIDI READ</span>
<span class="cm"> * @sg_mem_bidi_num: Number of BIDI READ SGL elements</span>
<span class="cm"> *</span>
<span class="cm"> * Return: nonzero return cmd was rejected for -ENOMEM or inproper usage</span>
<span class="cm"> * of parameters.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">transport_generic_map_mem_to_cmd</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">sgl_count</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl_bidi</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">sgl_bidi_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgl</span> <span class="o">||</span> <span class="o">!</span><span class="n">sgl_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reject SCSI data overflow with map_mem_to_cmd() as incoming</span>
<span class="cm">		 * scatterlists already have been set to follow what the fabric</span>
<span class="cm">		 * passes for the original expected data transfer length.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_OVERFLOW_BIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Rejecting SCSI DATA overflow for fabric using&quot;</span>
				<span class="s">&quot; SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CDB_EXCEPTION</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_INVALID_CDB_FIELD</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span> <span class="o">=</span> <span class="n">sgl</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span> <span class="o">=</span> <span class="n">sgl_count</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sgl_bidi</span> <span class="o">&amp;&amp;</span> <span class="n">sgl_bidi_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_bidi_data_sg</span> <span class="o">=</span> <span class="n">sgl_bidi</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_bidi_data_nents</span> <span class="o">=</span> <span class="n">sgl_bidi_count</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_generic_map_mem_to_cmd</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">transport_kmap_data_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to take into account a possible offset here for fabrics like</span>
<span class="cm">	 * tcm_loop who may be using a contig buffer from the SCSI midlayer for</span>
<span class="cm">	 * control CDBs passed as SGLs via transport_generic_map_mem_to_cmd()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">kmap</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>

	<span class="cm">/* &gt;1 page. use vmap */</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">)</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* convert sg[] to pages[] */</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_vmap</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span><span class="p">,</span>  <span class="n">VM_MAP</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_vmap</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_vmap</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_kmap_data_sg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">transport_kunmap_data_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vunmap</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_vmap</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_vmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_kunmap_data_sg</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">transport_generic_get_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">length</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">zero_flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nents</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span><span class="p">)</span> <span class="o">*</span> <span class="n">nents</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_nents</span> <span class="o">=</span> <span class="n">nents</span><span class="p">;</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>

	<span class="n">zero_flag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">__GFP_ZERO</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">page_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">zero_flag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">sg_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">page</span><span class="p">,</span> <span class="n">page_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">length</span> <span class="o">-=</span> <span class="n">page_len</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_data_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate any required resources to execute the command.  For writes we</span>
<span class="cm"> * might not have the payload yet, so notify the fabric via a call to</span>
<span class="cm"> * -&gt;write_pending instead. Otherwise place it on the execution queue.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">transport_generic_new_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine is the TCM fabric module has already allocated physical</span>
<span class="cm">	 * memory, and is directly calling transport_generic_map_mem_to_cmd()</span>
<span class="cm">	 * beforehand.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">transport_generic_get_mem</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Workaround for handling zero-length control CDBs */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_CONTROL_SG_IO_CDB</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">TRANSPORT_COMPLETE</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_ACTIVE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">ua_asc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ua_ascq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">core_scsi3_ua_clear_for_request_sense</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">ua_asc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ua_ascq</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">target_complete_ok_work</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">target_completion_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_DATA_SG_IO_CDB</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">se_dev_attrib</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">transport_cmd_get_valid_sectors</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">%</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_length</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">)</span> <span class="o">&gt;</span>
			<span class="n">attr</span><span class="o">-&gt;</span><span class="n">hw_max_sectors</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_fe_count</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For WRITEs, let the fabric know its buffer is ready.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The command will be added to the execution queue after its write</span>
<span class="cm">	 * data has arrived.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">target_add_to_state_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">transport_generic_write_pending</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Everything else but a WRITE, add the command to the execution queue.</span>
<span class="cm">	 */</span>
	<span class="n">transport_execute_tasks</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_fail:</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_CDB_EXCEPTION</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_reason</span> <span class="o">=</span> <span class="n">TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_generic_new_cmd</span><span class="p">);</span>

<span class="cm">/*	transport_generic_process_write():</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">transport_generic_process_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transport_execute_tasks</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_generic_process_write</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_write_pending_qf</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">write_pending</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Handling write_pending QUEUE__FULL: se_cmd: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">cmd</span><span class="p">);</span>
		<span class="n">transport_handle_queue_full</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_generic_write_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">TRANSPORT_WRITE_PENDING</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the se_cmd for WRITE_PENDING status in order to set</span>
<span class="cm">	 * CMD_T_ACTIVE so that transport_generic_handle_data can be called</span>
<span class="cm">	 * from HW target mode interrupt code.  This is safe to be called</span>
<span class="cm">	 * with transport_off=1 before the cmd-&gt;se_tfo-&gt;write_pending</span>
<span class="cm">	 * because the se_cmd-&gt;se_lun pointer is not being cleared.</span>
<span class="cm">	 */</span>
	<span class="n">transport_cmd_check_stop</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call the fabric write_pending function here to let the</span>
<span class="cm">	 * frontend know that WRITE buffers are ready.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">write_pending</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">queue_full</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">queue_full:</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Handling write_pending QUEUE__FULL: se_cmd: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">TRANSPORT_COMPLETE_QF_WP</span><span class="p">;</span>
	<span class="n">transport_handle_queue_full</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">transport_generic_free_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait_for_tasks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SE_LUN_CMD</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_tasks</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_TMR_CDB</span><span class="p">))</span>
			 <span class="n">transport_wait_for_tasks</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

		<span class="n">transport_release_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_tasks</span><span class="p">)</span>
			<span class="n">transport_wait_for_tasks</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

		<span class="n">core_dec_lacl_count</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_node_acl</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="p">)</span>
			<span class="n">transport_lun_remove_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

		<span class="n">transport_put_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_generic_free_cmd</span><span class="p">);</span>

<span class="cm">/* target_get_sess_cmd - Add command to active -&gt;sess_cmd_list</span>
<span class="cm"> * @se_sess:	session to reference</span>
<span class="cm"> * @se_cmd:	command descriptor to add</span>
<span class="cm"> * @ack_kref:	Signal that fabric will perform an ack target_put_sess_cmd()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">target_get_sess_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">ack_kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">cmd_kref</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Add a second kref if the fabric caller is expecting to handle</span>
<span class="cm">	 * fabric acknowledgement that requires two target_put_sess_cmd()</span>
<span class="cm">	 * invocations before se_cmd descriptor release.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ack_kref</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">cmd_kref</span><span class="p">);</span>
		<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_ACK_KREF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_list</span><span class="p">);</span>
	<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">check_release</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">target_get_sess_cmd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_release_cmd_kref</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">cmd_kref</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span> <span class="o">=</span> <span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">release_cmd</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_tearing_down</span> <span class="o">&amp;&amp;</span> <span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">cmd_wait_set</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">cmd_wait_comp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">release_cmd</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* target_put_sess_cmd - Check for active I/O shutdown via kref_put</span>
<span class="cm"> * @se_sess:	session to reference</span>
<span class="cm"> * @se_cmd:	command descriptor to drop</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">target_put_sess_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">cmd_kref</span><span class="p">,</span> <span class="n">target_release_cmd_kref</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">target_put_sess_cmd</span><span class="p">);</span>

<span class="cm">/* target_splice_sess_cmd_list - Split active cmds into sess_wait_list</span>
<span class="cm"> * @se_sess:	session to split</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">target_splice_sess_cmd_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_wait_list</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_wait_list</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_tearing_down</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_wait_list</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_wait_list</span><span class="p">,</span> <span class="n">se_cmd_list</span><span class="p">)</span>
		<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">cmd_wait_set</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">target_splice_sess_cmd_list</span><span class="p">);</span>

<span class="cm">/* target_wait_for_sess_cmds - Wait for outstanding descriptors</span>
<span class="cm"> * @se_sess:    session to wait for active I/O</span>
<span class="cm"> * @wait_for_tasks:	Make extra transport_wait_for_tasks call</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">target_wait_for_sess_cmds</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">wait_for_tasks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_cmd</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span> <span class="n">tmp_cmd</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_wait_list</span><span class="p">,</span> <span class="n">se_cmd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_list</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Waiting for se_cmd: %p t_state: %d, fabric state:&quot;</span>
			<span class="s">&quot; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">,</span>
			<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_cmd_state</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_tasks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Calling transport_wait_for_tasks se_cmd: %p t_state: %d,&quot;</span>
				<span class="s">&quot; fabric state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">,</span>
				<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_cmd_state</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">));</span>

			<span class="n">rc</span> <span class="o">=</span> <span class="n">transport_wait_for_tasks</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;After transport_wait_for_tasks se_cmd: %p t_state: %d,&quot;</span>
				<span class="s">&quot; fabric state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">,</span>
				<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_cmd_state</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">cmd_wait_comp</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;After cmd_wait_comp: se_cmd: %p t_state: %d&quot;</span>
				<span class="s">&quot; fabric state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">,</span>
				<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_cmd_state</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">release_cmd</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">target_wait_for_sess_cmds</span><span class="p">);</span>

<span class="cm">/*	transport_lun_wait_for_tasks():</span>
<span class="cm"> *</span>
<span class="cm"> *	Called from ConfigFS context to stop the passed struct se_cmd to allow</span>
<span class="cm"> *	an struct se_lun to be successfully shutdown.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_lun_wait_for_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the frontend has already requested this struct se_cmd to</span>
<span class="cm">	 * be stopped, we can safely ignore this struct se_cmd.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_LUN_STOP</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ConfigFS ITT[0x%08x] - CMD_T_STOP, skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">transport_cmd_check_stop</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_LUN_FE_STOP</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">.</span><span class="n">thread_wq</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>XXX: audit task_flags checks.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_BUSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_SENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target_stop_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span>
				<span class="n">flags</span><span class="p">);</span>
		<span class="n">target_remove_from_execute_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ConfigFS: cmd: %p stop tasks ret:&quot;</span>
			<span class="s">&quot; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ConfigFS: ITT[0x%08x] - stopping cmd....</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_lun_stop_comp</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ConfigFS: ITT[0x%08x] - stopped cmd....</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">transport_remove_cmd_from_queue</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__transport_clear_lun_from_sessions</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lun_flags</span><span class="p">,</span> <span class="n">cmd_flags</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do exception processing and return CHECK_CONDITION status to the</span>
<span class="cm">	 * Initiator Port.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_cmd_lock</span><span class="p">,</span> <span class="n">lun_flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_cmd_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_cmd_list</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">se_lun_node</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun_node</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * This will notify iscsi_target_transport.c:</span>
<span class="cm">		 * transport_cmd_check_stop() that a LUN shutdown is in</span>
<span class="cm">		 * progress for the iscsi_cmd_t.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;SE_LUN[%d] - Setting cmd-&gt;transport&quot;</span>
			<span class="s">&quot;_lun_stop for  ITT: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">unpacked_lun</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_LUN_STOP</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_cmd_lock</span><span class="p">,</span> <span class="n">lun_flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ITT: 0x%08x, [i,t]_state: %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_cmd_state</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the Storage engine still owns the iscsi_cmd_t, determine</span>
<span class="cm">		 * and/or stop its context.</span>
<span class="cm">		 */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;SE_LUN[%d] - ITT: 0x%08x before transport&quot;</span>
			<span class="s">&quot;_lun_wait_for_tasks()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">unpacked_lun</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">transport_lun_wait_for_tasks</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_cmd_lock</span><span class="p">,</span> <span class="n">lun_flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;SE_LUN[%d] - ITT: 0x%08x after transport_lun&quot;</span>
			<span class="s">&quot;_wait_for_tasks(): SUCCESS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">unpacked_lun</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">cmd_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_DEV_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">cmd_flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">check_cond</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_DEV_ACTIVE</span><span class="p">;</span>
		<span class="n">target_remove_from_state_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">cmd_flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The Storage engine stopped this struct se_cmd before it was</span>
<span class="cm">		 * send to the fabric frontend for delivery back to the</span>
<span class="cm">		 * Initiator Node.  Return this SCSI CDB back with an</span>
<span class="cm">		 * CHECK_CONDITION status.</span>
<span class="cm">		 */</span>
<span class="nl">check_cond:</span>
		<span class="n">transport_send_check_condition_and_sense</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
				<span class="n">TCM_NON_EXISTENT_LUN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 *  If the fabric frontend is waiting for this iscsi_cmd_t to</span>
<span class="cm">		 * be released, notify the waiting thread now that LU has</span>
<span class="cm">		 * finished accessing it.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">cmd_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_LUN_FE_STOP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;SE_LUN[%d] - Detected FE stop for&quot;</span>
				<span class="s">&quot; struct se_cmd: %p ITT: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">lun</span><span class="o">-&gt;</span><span class="n">unpacked_lun</span><span class="p">,</span>
				<span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span>
					<span class="n">cmd_flags</span><span class="p">);</span>
			<span class="n">transport_cmd_check_stop</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_lun_fe_stop_comp</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_cmd_lock</span><span class="p">,</span> <span class="n">lun_flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;SE_LUN[%d] - ITT: 0x%08x finished processing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">lun</span><span class="o">-&gt;</span><span class="n">unpacked_lun</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">cmd_flags</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_cmd_lock</span><span class="p">,</span> <span class="n">lun_flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_cmd_lock</span><span class="p">,</span> <span class="n">lun_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_clear_lun_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="n">__transport_clear_lun_from_sessions</span><span class="p">(</span><span class="n">lun</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_shutdown_comp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">transport_clear_lun_from_sessions</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kt</span><span class="p">;</span>

	<span class="n">kt</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">transport_clear_lun_thread</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span>
			<span class="s">&quot;tcm_cl_%u&quot;</span><span class="p">,</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">unpacked_lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to start clear_lun thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">lun_shutdown_comp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * transport_wait_for_tasks - wait for completion to occur</span>
<span class="cm"> * @cmd:	command to wait</span>
<span class="cm"> *</span>
<span class="cm"> * Called from frontend fabric context to wait for storage engine</span>
<span class="cm"> * to pause and/or release frontend generated struct se_cmd.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">transport_wait_for_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SE_LUN_CMD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_TMR_CDB</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only perform a possible wait_for_tasks if SCF_SUPPORTED_SAM_OPCODE</span>
<span class="cm">	 * has been set in transport_set_supported_SAM_opcode().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SUPPORTED_SAM_OPCODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SCSI_TMR_CDB</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we are already stopped due to an external event (ie: LUN shutdown)</span>
<span class="cm">	 * sleep until the connection can have the passed struct se_cmd back.</span>
<span class="cm">	 * The cmd-&gt;transport_lun_stopped_sem will be upped by</span>
<span class="cm">	 * transport_clear_lun_from_sessions() once the ConfigFS context caller</span>
<span class="cm">	 * has completed its operation on the struct se_cmd.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_LUN_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;wait_for_tasks: Stopping&quot;</span>
			<span class="s">&quot; wait_for_completion(&amp;cmd-&gt;t_tasktransport_lun_fe&quot;</span>
			<span class="s">&quot;_stop_comp); for ITT: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is a special case for WRITES where a FE exception +</span>
<span class="cm">		 * LUN shutdown means ConfigFS context is still sleeping on</span>
<span class="cm">		 * transport_lun_stop_comp in transport_lun_wait_for_tasks().</span>
<span class="cm">		 * We go ahead and up transport_lun_stop_comp just to be sure</span>
<span class="cm">		 * here.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_lun_stop_comp</span><span class="p">);</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_lun_fe_stop_comp</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">target_remove_from_state_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * At this point, the frontend who was the originator of this</span>
<span class="cm">		 * struct se_cmd, now owns the structure and can be released through</span>
<span class="cm">		 * normal means below.</span>
<span class="cm">		 */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;wait_for_tasks: Stopped&quot;</span>
			<span class="s">&quot; wait_for_completion(&amp;cmd-&gt;t_tasktransport_lun_fe_&quot;</span>
			<span class="s">&quot;stop_comp); for ITT: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_LUN_STOP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_STOP</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;wait_for_tasks: Stopping %p ITT: 0x%08x&quot;</span>
		<span class="s">&quot; i_state: %d, t_state: %d, CMD_T_STOP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_cmd_state</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">.</span><span class="n">thread_wq</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_transport_stop_comp</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CMD_T_ACTIVE</span> <span class="o">|</span> <span class="n">CMD_T_STOP</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;wait_for_tasks: Stopped wait_for_compltion(&quot;</span>
		<span class="s">&quot;&amp;cmd-&gt;t_transport_stop_comp) for ITT: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_wait_for_tasks</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_get_sense_codes</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">asc</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ascq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">asc</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_asc</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ascq</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_ascq</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_set_sense_codes</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">asc</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">ascq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_asc</span> <span class="o">=</span> <span class="n">asc</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_ascq</span> <span class="o">=</span> <span class="n">ascq</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">transport_send_check_condition_and_sense</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">reason</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">from_transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">asc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ascq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SENT_CHECK_CONDITION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SENT_CHECK_CONDITION</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reason</span> <span class="o">&amp;&amp;</span> <span class="n">from_transport</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">after_reason</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">from_transport</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_EMULATED_TASK_SENSE</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Data Segment and SenseLength of the fabric response PDU.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TRANSPORT_SENSE_BUFFER is now set to SCSI_SENSE_BUFFERSIZE</span>
<span class="cm">	 * from include/scsi/scsi_cmnd.h</span>
<span class="cm">	 */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">set_fabric_sense_len</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
				<span class="n">TRANSPORT_SENSE_BUFFER</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Actual SENSE DATA, see SPC-3 7.23.2  SPC_SENSE_KEY_OFFSET uses</span>
<span class="cm">	 * SENSE KEY values from include/scsi/scsi.h</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCM_NON_EXISTENT_LUN</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ILLEGAL REQUEST */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">;</span>
		<span class="cm">/* LOGICAL UNIT NOT SUPPORTED */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x25</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_UNSUPPORTED_SCSI_OPCODE</span>:
	<span class="k">case</span> <span class="n">TCM_SECTOR_COUNT_TOO_MANY</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ILLEGAL REQUEST */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">;</span>
		<span class="cm">/* INVALID COMMAND OPERATION CODE */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_UNKNOWN_MODE_PAGE</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ILLEGAL REQUEST */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">;</span>
		<span class="cm">/* INVALID FIELD IN CDB */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x24</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_CHECK_CONDITION_ABORT_CMD</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ABORTED COMMAND */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ABORTED_COMMAND</span><span class="p">;</span>
		<span class="cm">/* BUS DEVICE RESET FUNCTION OCCURRED */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x29</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASCQ_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_INCORRECT_AMOUNT_OF_DATA</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ABORTED COMMAND */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ABORTED_COMMAND</span><span class="p">;</span>
		<span class="cm">/* WRITE ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0c</span><span class="p">;</span>
		<span class="cm">/* NOT ENOUGH UNSOLICITED DATA */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASCQ_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0d</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_INVALID_CDB_FIELD</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ILLEGAL REQUEST */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">;</span>
		<span class="cm">/* INVALID FIELD IN CDB */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x24</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_INVALID_PARAMETER_LIST</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ILLEGAL REQUEST */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">;</span>
		<span class="cm">/* INVALID FIELD IN PARAMETER LIST */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x26</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_UNEXPECTED_UNSOLICITED_DATA</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ABORTED COMMAND */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ABORTED_COMMAND</span><span class="p">;</span>
		<span class="cm">/* WRITE ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0c</span><span class="p">;</span>
		<span class="cm">/* UNEXPECTED_UNSOLICITED_DATA */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASCQ_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0c</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_SERVICE_CRC_ERROR</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ABORTED COMMAND */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ABORTED_COMMAND</span><span class="p">;</span>
		<span class="cm">/* PROTOCOL SERVICE CRC ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x47</span><span class="p">;</span>
		<span class="cm">/* N/A */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASCQ_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_SNACK_REJECTED</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ABORTED COMMAND */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ABORTED_COMMAND</span><span class="p">;</span>
		<span class="cm">/* READ ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x11</span><span class="p">;</span>
		<span class="cm">/* FAILED RETRANSMISSION REQUEST */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASCQ_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_WRITE_PROTECTED</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* DATA PROTECT */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">DATA_PROTECT</span><span class="p">;</span>
		<span class="cm">/* WRITE PROTECTED */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x27</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_CHECK_CONDITION_UNIT_ATTENTION</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* UNIT ATTENTION */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNIT_ATTENTION</span><span class="p">;</span>
		<span class="n">core_scsi3_ua_for_check_condition</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ascq</span><span class="p">);</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">asc</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASCQ_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ascq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_CHECK_CONDITION_NOT_READY</span>:
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* Not Ready */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOT_READY</span><span class="p">;</span>
		<span class="n">transport_get_sense_codes</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ascq</span><span class="p">);</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">asc</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASCQ_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ascq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE</span>:
	<span class="nl">default:</span>
		<span class="cm">/* CURRENT ERROR */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ADD_SENSE_LEN_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* ILLEGAL REQUEST */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_SENSE_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">;</span>
		<span class="cm">/* LOGICAL UNIT COMMUNICATION FAILURE */</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">SPC_ASC_KEY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * This code uses linux/include/scsi/scsi.h SAM status codes!</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Automatically padded, this value is encoded in the fabric&#39;s</span>
<span class="cm">	 * data_length response PDU containing the SCSI defined sense data.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_sense_length</span>  <span class="o">=</span> <span class="n">TRANSPORT_SENSE_BUFFER</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

<span class="nl">after_reason:</span>
	<span class="k">return</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_send_check_condition_and_sense</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">transport_check_aborted_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">send_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_ABORTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">send_status</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SENT_DELAYED_TAS</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Sending delayed SAM_STAT_TASK_ABORTED&quot;</span>
			<span class="s">&quot; status for CDB: 0x%02x ITT: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SENT_DELAYED_TAS</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">transport_check_aborted_status</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">transport_send_task_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_SENT_CHECK_CONDITION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are still expected incoming fabric WRITEs, we wait</span>
<span class="cm">	 * until until they have completed before sending a TASK_ABORTED</span>
<span class="cm">	 * response.  This response with TASK_ABORTED status will be</span>
<span class="cm">	 * queued back to fabric module by transport_check_aborted_status().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">write_pending_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_ABORTED</span><span class="p">;</span>
			<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="n">SAM_STAT_TASK_ABORTED</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Setting SAM_STAT_TASK_ABORTED status for CDB: 0x%02x,&quot;</span>
		<span class="s">&quot; ITT: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_generic_do_tmr</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_tmr_req</span> <span class="o">*</span><span class="n">tmr</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tmr_req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">tmr</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TMR_ABORT_TASK</span>:
		<span class="n">core_tmr_abort_task</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tmr</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TMR_ABORT_TASK_SET</span>:
	<span class="k">case</span> <span class="n">TMR_CLEAR_ACA</span>:
	<span class="k">case</span> <span class="n">TMR_CLEAR_TASK_SET</span>:
		<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">=</span> <span class="n">TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TMR_LUN_RESET</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">core_tmr_lun_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tmr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="o">?</span> <span class="n">TMR_FUNCTION_COMPLETE</span> <span class="o">:</span>
					 <span class="n">TMR_FUNCTION_REJECTED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TMR_TARGET_WARM_RESET</span>:
		<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">=</span> <span class="n">TMR_FUNCTION_REJECTED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TMR_TARGET_COLD_RESET</span>:
		<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">=</span> <span class="n">TMR_FUNCTION_REJECTED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Uknown TMR function: 0x%02x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">);</span>
		<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">=</span> <span class="n">TMR_FUNCTION_REJECTED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">TRANSPORT_ISTATE_PROCESSING</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">queue_tm_rsp</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">transport_cmd_check_stop_to_fabric</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*	transport_processing_thread():</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_processing_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">.</span><span class="n">thread_wq</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">.</span><span class="n">queue_cnt</span><span class="p">)</span> <span class="o">||</span>
				<span class="n">kthread_should_stop</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">get_cmd:</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">transport_get_cmd_from_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TRANSPORT_NEW_CMD</span>:
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TRANSPORT_NEW_CMD_MAP</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">new_cmd_map</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cmd-&gt;se_tfo-&gt;new_cmd_map is&quot;</span>
					<span class="s">&quot; NULL for TRANSPORT_NEW_CMD_MAP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">new_cmd_map</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">transport_generic_request_failure</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">transport_generic_new_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">transport_generic_request_failure</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TRANSPORT_PROCESS_WRITE</span>:
			<span class="n">transport_generic_process_write</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TRANSPORT_PROCESS_TMR</span>:
			<span class="n">transport_generic_do_tmr</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TRANSPORT_COMPLETE_QF_WP</span>:
			<span class="n">transport_write_pending_qf</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TRANSPORT_COMPLETE_QF_OK</span>:
			<span class="n">transport_complete_qf</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unknown t_state: %d  for ITT: 0x%08x &quot;</span>
				<span class="s">&quot;i_state: %d on SE LUN: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_cmd_state</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_lun</span><span class="o">-&gt;</span><span class="n">unpacked_lun</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">goto</span> <span class="n">get_cmd</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">.</span><span class="n">qobj_list</span><span class="p">));</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">process_thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
