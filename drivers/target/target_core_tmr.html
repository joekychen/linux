<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › target › target_core_tmr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>target_core_tmr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>
<span class="cm"> * Filename:  target_core_tmr.c</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains SPC-3 task management infrastructure</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2009,2010 Rising Tide Systems</span>
<span class="cm"> * Copyright (c) 2009,2010 Linux-iSCSI.org</span>
<span class="cm"> *</span>
<span class="cm"> * Nicholas A. Bellinger &lt;nab@kernel.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>

<span class="cp">#include &lt;target/target_core_base.h&gt;</span>
<span class="cp">#include &lt;target/target_core_backend.h&gt;</span>
<span class="cp">#include &lt;target/target_core_fabric.h&gt;</span>
<span class="cp">#include &lt;target/target_core_configfs.h&gt;</span>

<span class="cp">#include &quot;target_core_internal.h&quot;</span>
<span class="cp">#include &quot;target_core_alua.h&quot;</span>
<span class="cp">#include &quot;target_core_pr.h&quot;</span>

<span class="kt">int</span> <span class="nf">core_tmr_alloc_req</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">fabric_tmr_ptr</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">function</span><span class="p">,</span>
	<span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_tmr_req</span> <span class="o">*</span><span class="n">tmr</span><span class="p">;</span>

	<span class="n">tmr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">se_tmr_req</span><span class="p">),</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to allocate struct se_tmr_req</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">|=</span> <span class="n">SCF_SCSI_TMR_CDB</span><span class="p">;</span>
	<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tmr_req</span> <span class="o">=</span> <span class="n">tmr</span><span class="p">;</span>
	<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">task_cmd</span> <span class="o">=</span> <span class="n">se_cmd</span><span class="p">;</span>
	<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">fabric_tmr_ptr</span> <span class="o">=</span> <span class="n">fabric_tmr_ptr</span><span class="p">;</span>
	<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmr</span><span class="o">-&gt;</span><span class="n">tmr_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">core_tmr_alloc_req</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">core_tmr_release_req</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_tmr_req</span> <span class="o">*</span><span class="n">tmr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">tmr</span><span class="o">-&gt;</span><span class="n">tmr_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tmr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_tmr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmr</span><span class="o">-&gt;</span><span class="n">tmr_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_tmr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">tmr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">core_tmr_handle_tas_abort</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_node_acl</span> <span class="o">*</span><span class="n">tmr_nacl</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">tas</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">fe_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fe_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport_cmd_finish_abort</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * TASK ABORTED status (TAS) bit support</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tmr_nacl</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">tmr_nacl</span> <span class="o">==</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_node_acl</span><span class="p">))</span> <span class="o">||</span> <span class="n">tas</span><span class="p">)</span>
		<span class="n">transport_send_task_abort</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">transport_cmd_finish_abort</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">target_check_cdb_and_preempt</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">t10_pr_registration</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">pr_reg_abort_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">pr_res_key</span> <span class="o">==</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pr_res_key</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">core_tmr_abort_task</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_tmr_req</span> <span class="o">*</span><span class="n">tmr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_session</span> <span class="o">*</span><span class="n">se_sess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">se_cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ref_tag</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">,</span> <span class="n">tmp_cmd</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_list</span><span class="p">,</span> <span class="n">se_cmd_list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_dev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ref_tag</span> <span class="o">=</span> <span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmr</span><span class="o">-&gt;</span><span class="n">ref_task_tag</span> <span class="o">!=</span> <span class="n">ref_tag</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ABORT_TASK: Found referenced %s task_tag: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_name</span><span class="p">(),</span> <span class="n">ref_tag</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ABORT_TASK: ref_tag: %u already complete, skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ref_tag</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_ABORTED</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_list</span><span class="p">);</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">cmd_kref</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="n">transport_wait_for_tasks</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now send SAM_STAT_TASK_ABORTED status for the referenced</span>
<span class="cm">		 * se_cmd descriptor..</span>
<span class="cm">		 */</span>
		<span class="n">transport_send_task_abort</span><span class="p">(</span><span class="n">se_cmd</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Also deal with possible extra acknowledge reference..</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">se_cmd</span><span class="o">-&gt;</span><span class="n">se_cmd_flags</span> <span class="o">&amp;</span> <span class="n">SCF_ACK_KREF</span><span class="p">)</span>
			<span class="n">target_put_sess_cmd</span><span class="p">(</span><span class="n">se_sess</span><span class="p">,</span> <span class="n">se_cmd</span><span class="p">);</span>

		<span class="n">target_put_sess_cmd</span><span class="p">(</span><span class="n">se_sess</span><span class="p">,</span> <span class="n">se_cmd</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ABORT_TASK: Sending TMR_FUNCTION_COMPLETE for&quot;</span>
				<span class="s">&quot; ref_tag: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ref_tag</span><span class="p">);</span>
		<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">=</span> <span class="n">TMR_FUNCTION_COMPLETE</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">sess_cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ABORT_TASK: Sending TMR_TASK_DOES_NOT_EXIST for ref_tag: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">ref_task_tag</span><span class="p">);</span>
	<span class="n">tmr</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">=</span> <span class="n">TMR_TASK_DOES_NOT_EXIST</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">core_tmr_drain_tmr_list</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_tmr_req</span> <span class="o">*</span><span class="n">tmr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">preempt_and_abort_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">drain_tmr_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">se_tmr_req</span> <span class="o">*</span><span class="n">tmr_p</span><span class="p">,</span> <span class="o">*</span><span class="n">tmr_pp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Release all pending and outgoing TMRs aside from the received</span>
<span class="cm">	 * LUN_RESET tmr..</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_tmr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">tmr_p</span><span class="p">,</span> <span class="n">tmr_pp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_tmr_list</span><span class="p">,</span> <span class="n">tmr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allow the received TMR to return with FUNCTION_COMPLETE.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmr_p</span> <span class="o">==</span> <span class="n">tmr</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">tmr_p</span><span class="o">-&gt;</span><span class="n">task_cmd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to locate struct se_cmd for TMR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this function was called with a valid pr_res_key</span>
<span class="cm">		 * parameter (eg: for PROUT PREEMPT_AND_ABORT service action</span>
<span class="cm">		 * skip non regisration key matching TMRs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target_check_cdb_and_preempt</span><span class="p">(</span><span class="n">preempt_and_abort_list</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">TRANSPORT_ISTATE_PROCESSING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">);</span>

		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmr_p</span><span class="o">-&gt;</span><span class="n">tmr_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drain_tmr_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_tmr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">tmr_p</span><span class="p">,</span> <span class="n">tmr_pp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drain_tmr_list</span><span class="p">,</span> <span class="n">tmr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmr_p</span><span class="o">-&gt;</span><span class="n">tmr_list</span><span class="p">);</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">tmr_p</span><span class="o">-&gt;</span><span class="n">task_cmd</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;LUN_RESET: %s releasing TMR %p Function: 0x%02x,&quot;</span>
			<span class="s">&quot; Response: 0x%02x, t_state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">preempt_and_abort_list</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Preempt&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">tmr_p</span><span class="p">,</span>
			<span class="n">tmr_p</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">,</span> <span class="n">tmr_p</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">);</span>

		<span class="n">transport_cmd_finish_abort</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">core_tmr_drain_state_list</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">prout_cmd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_node_acl</span> <span class="o">*</span><span class="n">tmr_nacl</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">tas</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">preempt_and_abort_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">drain_task_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fe_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Complete outstanding commands with TASK_ABORTED SAM status.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is following sam4r17, section 5.6 Aborting commands, Table 38</span>
<span class="cm">	 * for TMR LUN_RESET:</span>
<span class="cm">	 *</span>
<span class="cm">	 * a) &quot;Yes&quot; indicates that each command that is aborted on an I_T nexus</span>
<span class="cm">	 * other than the one that caused the SCSI device condition is</span>
<span class="cm">	 * completed with TASK ABORTED status, if the TAS bit is set to one in</span>
<span class="cm">	 * the Control mode page (see SPC-4). &quot;No&quot; indicates that no status is</span>
<span class="cm">	 * returned for aborted commands.</span>
<span class="cm">	 *</span>
<span class="cm">	 * d) If the logical unit reset is caused by a particular I_T nexus</span>
<span class="cm">	 * (e.g., by a LOGICAL UNIT RESET task management function), then &quot;yes&quot;</span>
<span class="cm">	 * (TASK_ABORTED status) applies.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Otherwise (e.g., if triggered by a hard reset), &quot;no&quot;</span>
<span class="cm">	 * (no TASK_ABORTED SAM status) applies.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that this seems to be independent of TAS (Task Aborted Status)</span>
<span class="cm">	 * in the Control Mode Page.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">,</span> <span class="n">state_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For PREEMPT_AND_ABORT usage, only process commands</span>
<span class="cm">		 * with a matching reservation key.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target_check_cdb_and_preempt</span><span class="p">(</span><span class="n">preempt_and_abort_list</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Not aborting PROUT PREEMPT_AND_ABORT CDB..</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prout_cmd</span> <span class="o">==</span> <span class="n">cmd</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drain_task_list</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">execute_list</span><span class="p">))</span>
			<span class="n">__target_remove_from_execute_list</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">execute_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drain_task_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">drain_task_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">state_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state_list</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;LUN_RESET: %s cmd: %p&quot;</span>
			<span class="s">&quot; ITT/CmdSN: 0x%08x/0x%08x, i_state: %d, t_state: %d&quot;</span>
			<span class="s">&quot;cdb: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">preempt_and_abort_list</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Preempt&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_cmd_state</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_task_cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;LUN_RESET: ITT[0x%08x] - pr_res_key: 0x%016Lx&quot;</span>
			<span class="s">&quot; -- CMD_T_ACTIVE: %d&quot;</span>
			<span class="s">&quot; CMD_T_STOP: %d CMD_T_SENT: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_tfo</span><span class="o">-&gt;</span><span class="n">get_task_tag</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pr_res_key</span><span class="p">,</span>
			<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_ACTIVE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_STOP</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_SENT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the command may be queued onto a workqueue cancel it now.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This is equivalent to removal from the execute queue in the</span>
<span class="cm">		 * loop above, but we do it down here given that</span>
<span class="cm">		 * cancel_work_sync may block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">TRANSPORT_COMPLETE</span><span class="p">)</span>
			<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">target_stop_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">fe_count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_fe_count</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;</span> <span class="n">CMD_T_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;LUN_RESET: got CMD_T_ACTIVE for&quot;</span>
				<span class="s">&quot; cdb: %p, t_fe_count: %d dev: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
				<span class="n">fe_count</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_ABORTED</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">core_tmr_handle_tas_abort</span><span class="p">(</span><span class="n">tmr_nacl</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">tas</span><span class="p">,</span> <span class="n">fe_count</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;LUN_RESET: Got !CMD_T_ACTIVE for cdb: %p,&quot;</span>
			<span class="s">&quot; t_fe_count: %d dev: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">fe_count</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">|=</span> <span class="n">CMD_T_ABORTED</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">core_tmr_handle_tas_abort</span><span class="p">(</span><span class="n">tmr_nacl</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">tas</span><span class="p">,</span> <span class="n">fe_count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">core_tmr_drain_cmd_list</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">prout_cmd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">se_node_acl</span> <span class="o">*</span><span class="n">tmr_nacl</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">tas</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">preempt_and_abort_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">drain_cmd_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">se_queue_obj</span> <span class="o">*</span><span class="n">qobj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_queue_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">tcmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release all commands remaining in the per-device command queue.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This follows the same logic as above for the state list.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">qobj_list</span><span class="p">,</span> <span class="n">se_queue_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For PREEMPT_AND_ABORT usage, only process commands</span>
<span class="cm">		 * with a matching reservation key.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target_check_cdb_and_preempt</span><span class="p">(</span><span class="n">preempt_and_abort_list</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not aborting PROUT PREEMPT_AND_ABORT CDB..</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prout_cmd</span> <span class="o">==</span> <span class="n">cmd</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transport_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_T_QUEUED</span><span class="p">;</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">queue_cnt</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_queue_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drain_cmd_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qobj</span><span class="o">-&gt;</span><span class="n">cmd_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drain_cmd_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">drain_cmd_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">se_cmd</span><span class="p">,</span> <span class="n">se_queue_node</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">se_queue_node</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;LUN_RESET: %s from Device Queue: cmd: %p t_state:&quot;</span>
			<span class="s">&quot; %d t_fe_count: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">preempt_and_abort_list</span><span class="p">)</span> <span class="o">?</span>
			<span class="s">&quot;Preempt&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">,</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_fe_count</span><span class="p">));</span>

		<span class="n">core_tmr_handle_tas_abort</span><span class="p">(</span><span class="n">tmr_nacl</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">tas</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">t_fe_count</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">core_tmr_lun_reset</span><span class="p">(</span>
        <span class="k">struct</span> <span class="n">se_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">se_tmr_req</span> <span class="o">*</span><span class="n">tmr</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">preempt_and_abort_list</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">se_cmd</span> <span class="o">*</span><span class="n">prout_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">se_node_acl</span> <span class="o">*</span><span class="n">tmr_nacl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">se_portal_group</span> <span class="o">*</span><span class="n">tmr_tpg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tas</span><span class="p">;</span>
        <span class="cm">/*</span>
<span class="cm">	 * TASK_ABORTED status bit, this is configurable via ConfigFS</span>
<span class="cm">	 * struct se_device attributes.  spc4r17 section 7.4.6 Control mode page</span>
<span class="cm">	 *</span>
<span class="cm">	 * A task aborted status (TAS) bit set to zero specifies that aborted</span>
<span class="cm">	 * tasks shall be terminated by the device server without any response</span>
<span class="cm">	 * to the application client. A TAS bit set to one specifies that tasks</span>
<span class="cm">	 * aborted by the actions of an I_T nexus other than the I_T nexus on</span>
<span class="cm">	 * which the command was received shall be completed with TASK ABORTED</span>
<span class="cm">	 * status (see SAM-4).</span>
<span class="cm">	 */</span>
	<span class="n">tas</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">se_sub_dev</span><span class="o">-&gt;</span><span class="n">se_dev_attrib</span><span class="p">.</span><span class="n">emulate_tas</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Determine if this se_tmr is coming from a $FABRIC_MOD</span>
<span class="cm">	 * or struct se_device passthrough..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmr</span> <span class="o">&amp;&amp;</span> <span class="n">tmr</span><span class="o">-&gt;</span><span class="n">task_cmd</span> <span class="o">&amp;&amp;</span> <span class="n">tmr</span><span class="o">-&gt;</span><span class="n">task_cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmr_nacl</span> <span class="o">=</span> <span class="n">tmr</span><span class="o">-&gt;</span><span class="n">task_cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_node_acl</span><span class="p">;</span>
		<span class="n">tmr_tpg</span> <span class="o">=</span> <span class="n">tmr</span><span class="o">-&gt;</span><span class="n">task_cmd</span><span class="o">-&gt;</span><span class="n">se_sess</span><span class="o">-&gt;</span><span class="n">se_tpg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmr_nacl</span> <span class="o">&amp;&amp;</span> <span class="n">tmr_tpg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;LUN_RESET: TMR caller fabric: %s&quot;</span>
				<span class="s">&quot; initiator port %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tmr_tpg</span><span class="o">-&gt;</span><span class="n">se_tpg_tfo</span><span class="o">-&gt;</span><span class="n">get_fabric_name</span><span class="p">(),</span>
				<span class="n">tmr_nacl</span><span class="o">-&gt;</span><span class="n">initiatorname</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;LUN_RESET: %s starting for [%s], tas: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">preempt_and_abort_list</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Preempt&quot;</span> <span class="o">:</span> <span class="s">&quot;TMR&quot;</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">tas</span><span class="p">);</span>

	<span class="n">core_tmr_drain_tmr_list</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tmr</span><span class="p">,</span> <span class="n">preempt_and_abort_list</span><span class="p">);</span>
	<span class="n">core_tmr_drain_state_list</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">prout_cmd</span><span class="p">,</span> <span class="n">tmr_nacl</span><span class="p">,</span> <span class="n">tas</span><span class="p">,</span>
				<span class="n">preempt_and_abort_list</span><span class="p">);</span>
	<span class="n">core_tmr_drain_cmd_list</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">prout_cmd</span><span class="p">,</span> <span class="n">tmr_nacl</span><span class="p">,</span> <span class="n">tas</span><span class="p">,</span>
				<span class="n">preempt_and_abort_list</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear any legacy SPC-2 reservation when called during</span>
<span class="cm">	 * LOGICAL UNIT RESET</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">preempt_and_abort_list</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">DF_SPC2_RESERVATIONS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_reservation_lock</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_reserved_node_acl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DF_SPC2_RESERVATIONS</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_reservation_lock</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;LUN_RESET: SCSI-2 Released reservation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_resets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;LUN_RESET: %s for [%s] Complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">preempt_and_abort_list</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Preempt&quot;</span> <span class="o">:</span> <span class="s">&quot;TMR&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
