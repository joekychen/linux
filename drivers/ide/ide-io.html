<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › ide › ide-io.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ide-io.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	IDE I/O functions</span>
<span class="cm"> *</span>
<span class="cm"> *	Basic PIO and command management functionality.</span>
<span class="cm"> *</span>
<span class="cm"> * This code was split off from ide.c. See ide.c for history and original</span>
<span class="cm"> * copyrights.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * For the avoidance of doubt the &quot;preferred form&quot; of this code is one which</span>
<span class="cm"> * is in an open non patent encumbered format. Where cryptographic key signing</span>
<span class="cm"> * forms part of the process of creating an executable the information</span>
<span class="cm"> * including keys needed to generate an equivalently functional executable</span>
<span class="cm"> * are deemed to be part of the source code.</span>
<span class="cm"> */</span>
 
 
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/genhd.h&gt;</span>
<span class="cp">#include &lt;linux/blkpg.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ide.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/cdrom.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="kt">int</span> <span class="nf">ide_end_rq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * decide whether to reenable DMA -- 3 is a random magic for now,</span>
<span class="cm">	 * if we DMA timeout more than 3 times, just stay in PIO</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">IDE_DFLAG_DMA_PIO_RETRY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">drive</span><span class="o">-&gt;</span><span class="n">retry_pio</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IDE_DFLAG_DMA_PIO_RETRY</span><span class="p">;</span>
		<span class="n">ide_dma_on</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">blk_end_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">nr_bytes</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ide_end_rq</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ide_complete_cmd</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">stat</span><span class="p">,</span> <span class="n">u8</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_tp_ops</span> <span class="o">*</span><span class="n">tp_ops</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">tp_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ide_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tf_cmd</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">;</span>

	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ftf_flags</span> <span class="o">&amp;</span> <span class="n">IDE_FTFLAG_IN_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

		<span class="n">tp_ops</span><span class="o">-&gt;</span><span class="n">input_data</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">data</span>  <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">hob</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">ide_tf_readback</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tf_flags</span> <span class="o">&amp;</span> <span class="n">IDE_TFLAG_CUSTOM_HANDLER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tf_cmd</span> <span class="o">==</span> <span class="n">ATA_CMD_IDLEIMMEDIATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">!=</span> <span class="mh">0xc4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: head unload failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">drive</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">ide_tf_dump</span><span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">|=</span> <span class="n">IDE_DFLAG_PARKED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_ATA_TASKFILE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="n">orig_cmd</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tf_flags</span> <span class="o">&amp;</span> <span class="n">IDE_TFLAG_DYN</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">orig_cmd</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">orig_cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ide_complete_rq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">hwif</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if failfast is set on a request, override number of sectors</span>
<span class="cm">	 * and complete the whole request right now</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_noretry_request</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">error</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nr_bytes</span> <span class="o">=</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ide_end_rq</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">nr_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ide_complete_rq</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ide_kill_rq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">drv_req</span> <span class="o">=</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_SPECIAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">media</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">media</span><span class="p">;</span>

	<span class="n">drive</span><span class="o">-&gt;</span><span class="n">failed_pc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">media</span> <span class="o">==</span> <span class="n">ide_floppy</span> <span class="o">||</span> <span class="n">media</span> <span class="o">==</span> <span class="n">ide_tape</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">drv_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">media</span> <span class="o">==</span> <span class="n">ide_tape</span><span class="p">)</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="n">IDE_DRV_ERROR_GENERAL</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">!=</span> <span class="n">REQ_TYPE_FS</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ide_complete_rq</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">,</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ide_tf_set_specify_cmd</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span>   <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">sect</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span>    <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">sect</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span>    <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">cyl</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span>    <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">cyl</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span>  <span class="o">=</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">select</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_INIT_DEV_PARAMS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ide_tf_set_restore_cmd</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span>   <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">sect</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_RESTORE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ide_tf_set_setmult_cmd</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span>   <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">mult_req</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_SET_MULTI</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	do_special		-	issue some special commands</span>
<span class="cm"> *	@drive: drive the command is for</span>
<span class="cm"> *</span>
<span class="cm"> *	do_special() is used to issue ATA_CMD_INIT_DEV_PARAMS,</span>
<span class="cm"> *	ATA_CMD_RESTORE and ATA_CMD_SET_MULTI commands to a drive.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">ide_startstop_t</span> <span class="nf">do_special</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ide_cmd</span> <span class="n">cmd</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: %s: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">special_flags</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">media</span> <span class="o">!=</span> <span class="n">ide_disk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">special_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">mult_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ide_stopped</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">special_flags</span> <span class="o">&amp;</span> <span class="n">IDE_SFLAG_SET_GEOMETRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">special_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IDE_SFLAG_SET_GEOMETRY</span><span class="p">;</span>
		<span class="n">ide_tf_set_specify_cmd</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">tf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">special_flags</span> <span class="o">&amp;</span> <span class="n">IDE_SFLAG_RECALIBRATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">special_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IDE_SFLAG_RECALIBRATE</span><span class="p">;</span>
		<span class="n">ide_tf_set_restore_cmd</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">tf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">special_flags</span> <span class="o">&amp;</span> <span class="n">IDE_SFLAG_SET_MULTMODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">special_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IDE_SFLAG_SET_MULTMODE</span><span class="p">;</span>
		<span class="n">ide_tf_set_setmult_cmd</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">tf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">valid</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">IDE_VALID_OUT_TF</span> <span class="o">|</span> <span class="n">IDE_VALID_DEVICE</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">valid</span><span class="p">.</span><span class="n">in</span><span class="p">.</span><span class="n">tf</span>  <span class="o">=</span> <span class="n">IDE_VALID_IN_TF</span>  <span class="o">|</span> <span class="n">IDE_VALID_DEVICE</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">tf_flags</span> <span class="o">=</span> <span class="n">IDE_TFLAG_CUSTOM_HANDLER</span><span class="p">;</span>

	<span class="n">do_rw_taskfile</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ide_started</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ide_map_sg</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">hwif</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">sg_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sg_nents</span> <span class="o">=</span> <span class="n">blk_rq_map_sg</span><span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">sg</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ide_map_sg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ide_init_sg_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">nleft</span> <span class="o">=</span> <span class="n">nr_bytes</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cursg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ide_init_sg_cmd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	execute_drive_command	-	issue special drive command</span>
<span class="cm"> *	@drive: the drive to issue the command on</span>
<span class="cm"> *	@rq: the request structure holding the command</span>
<span class="cm"> *</span>
<span class="cm"> *	execute_drive_cmd() issues a special drive command,  usually </span>
<span class="cm"> *	initiated by ioctl() from the external hdparm program. The</span>
<span class="cm"> *	command can be a drive command, drive task or taskfile </span>
<span class="cm"> *	operation. Weirdly you can call it with NULL to wait for</span>
<span class="cm"> *	all commands to finish. Don&#39;t do this as that is due to change</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">ide_startstop_t</span> <span class="nf">execute_drive_cmd</span> <span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATA_PROT_PIO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ide_init_sg_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">);</span>
			<span class="n">ide_map_sg</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">do_rw_taskfile</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

 	<span class="cm">/*</span>
<span class="cm"> 	 * NULL is actually a valid way of waiting for</span>
<span class="cm"> 	 * all current requests to be flushed from the queue.</span>
<span class="cm"> 	 */</span>
<span class="cp">#ifdef DEBUG</span>
 	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: DRIVE_CMD (null)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ide_complete_rq</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>

 	<span class="k">return</span> <span class="n">ide_stopped</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ide_startstop_t</span> <span class="nf">ide_special_rq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">REQ_PARK_HEADS</span>:
	<span class="k">case</span> <span class="n">REQ_UNPARK_HEADS</span>:
		<span class="k">return</span> <span class="n">ide_do_park_unpark</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">REQ_DEVSET_EXEC</span>:
		<span class="k">return</span> <span class="n">ide_do_devset</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">REQ_DRIVE_RESET</span>:
		<span class="k">return</span> <span class="n">ide_do_reset</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	start_request	-	start of I/O and command issuing for IDE</span>
<span class="cm"> *</span>
<span class="cm"> *	start_request() initiates handling of a new I/O request. It</span>
<span class="cm"> *	accepts commands and I/O (read/write) requests.</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: this function needs a rename</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="n">ide_startstop_t</span> <span class="nf">start_request</span> <span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ide_startstop_t</span> <span class="n">startstop</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_STARTED</span><span class="p">));</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: start_request: current=0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">rq</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* bail early if we&#39;ve exceeded max_failures */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">max_failures</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">failures</span> <span class="o">&gt;</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">max_failures</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">REQ_FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">kill_rq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_pm_request</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
		<span class="n">ide_check_pm_state</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="n">drive</span><span class="o">-&gt;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">tp_ops</span><span class="o">-&gt;</span><span class="n">dev_select</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ide_wait_stat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">startstop</span><span class="p">,</span> <span class="n">drive</span><span class="p">,</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">ready_stat</span><span class="p">,</span>
			  <span class="n">ATA_BUSY</span> <span class="o">|</span> <span class="n">ATA_DRQ</span><span class="p">,</span> <span class="n">WAIT_READY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: drive not ready for command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">startstop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">special_flags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ide_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We reset the drive so we need to issue a SETFEATURES.</span>
<span class="cm">		 * Do it _after_ do_special() restored device parameters.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">current_speed</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="n">ide_config_drive_speed</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">desired_speed</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_ATA_TASKFILE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">execute_drive_cmd</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">blk_pm_request</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">request_pm_state</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_PM</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: start_power_step(step: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">drive</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">pm_step</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">startstop</span> <span class="o">=</span> <span class="n">ide_start_power_step</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">startstop</span> <span class="o">==</span> <span class="n">ide_stopped</span> <span class="o">&amp;&amp;</span>
			    <span class="n">pm</span><span class="o">-&gt;</span><span class="n">pm_step</span> <span class="o">==</span> <span class="n">IDE_PM_COMPLETED</span><span class="p">)</span>
				<span class="n">ide_complete_pm_rq</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">startstop</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_SPECIAL</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * TODO: Once all ULDs have been modified to</span>
<span class="cm">			 * check for specific op codes rather than</span>
<span class="cm">			 * blindly accepting any special request, the</span>
<span class="cm">			 * check for -&gt;rq_disk above may be replaced</span>
<span class="cm">			 * by a more suitable mechanism or even</span>
<span class="cm">			 * dropped entirely.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="n">ide_special_rq</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

		<span class="n">drv</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_driver</span> <span class="o">**</span><span class="p">)</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">do_request</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">do_special</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
<span class="nl">kill_rq:</span>
	<span class="n">ide_kill_rq</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ide_stopped</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ide_stall_queue		-	pause an IDE device</span>
<span class="cm"> *	@drive: drive to stall</span>
<span class="cm"> *	@timeout: time to stall for (jiffies)</span>
<span class="cm"> *</span>
<span class="cm"> *	ide_stall_queue() can be used by a drive to give excess bandwidth back</span>
<span class="cm"> *	to the port by sleeping for timeout jiffies.</span>
<span class="cm"> */</span>
 
<span class="kt">void</span> <span class="nf">ide_stall_queue</span> <span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">WAIT_WORSTCASE</span><span class="p">)</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">WAIT_WORSTCASE</span><span class="p">;</span>
	<span class="n">drive</span><span class="o">-&gt;</span><span class="n">sleep</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">|=</span> <span class="n">IDE_DFLAG_SLEEPING</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ide_stall_queue</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ide_lock_port</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_unlock_port</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ide_lock_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;</span> <span class="n">IDE_HFLAG_SERIALIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">test_and_set_bit_lock</span><span class="p">(</span><span class="n">IDE_HOST_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_busy</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">get_lock</span><span class="p">)</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">get_lock</span><span class="p">(</span><span class="n">ide_intr</span><span class="p">,</span> <span class="n">hwif</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_unlock_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;</span> <span class="n">IDE_HFLAG_SERIALIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">release_lock</span><span class="p">)</span>
			<span class="n">host</span><span class="o">-&gt;</span><span class="n">release_lock</span><span class="p">();</span>
		<span class="n">clear_bit_unlock</span><span class="p">(</span><span class="n">IDE_HOST_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_busy</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__ide_requeue_and_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="p">)</span>
		<span class="n">blk_requeue_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span> <span class="o">||</span> <span class="n">blk_peek_request</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Use 3ms as that was the old plug delay */</span>
		<span class="n">blk_delay_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ide_requeue_and_plug</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__ide_requeue_and_plug</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Issue a new request to a device.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">do_ide_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ide_drive_t</span>	<span class="o">*</span><span class="n">drive</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="n">ide_hwif_t</span>	<span class="o">*</span><span class="n">hwif</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">hwif</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ide_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span>	<span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ide_startstop_t</span>	<span class="n">startstop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">queue_run_ms</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* old plug delay */</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="cm">/* HLD do_request() callback might sleep, make sure it&#39;s okay */</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ide_lock_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">hwif</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">plug_device_2</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ide_lock_port</span><span class="p">(</span><span class="n">hwif</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">prev_port</span><span class="p">;</span>

		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">);</span>
<span class="nl">repeat:</span>
		<span class="n">prev_port</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cur_port</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">IDE_DFLAG_SLEEPING</span> <span class="o">&amp;&amp;</span>
		    <span class="n">time_after</span><span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">sleep</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">left</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">sleep</span><span class="p">;</span>

			<span class="n">queue_run_ms</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">ide_unlock_port</span><span class="p">(</span><span class="n">hwif</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">plug_device</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;</span> <span class="n">IDE_HFLAG_SERIALIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">hwif</span> <span class="o">!=</span> <span class="n">prev_port</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">cur_dev</span> <span class="o">=</span>
				<span class="n">prev_port</span> <span class="o">?</span> <span class="n">prev_port</span><span class="o">-&gt;</span><span class="n">cur_dev</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * set nIEN for previous port, drives in the</span>
<span class="cm">			 * quirk list may not like intr setups/cleanups</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur_dev</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">cur_dev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">IDE_DFLAG_NIEN_QUIRK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">prev_port</span><span class="o">-&gt;</span><span class="n">tp_ops</span><span class="o">-&gt;</span><span class="n">write_devctl</span><span class="p">(</span><span class="n">prev_port</span><span class="p">,</span>
								<span class="n">ATA_NIEN</span> <span class="o">|</span>
								<span class="n">ATA_DEVCTL_OBS</span><span class="p">);</span>

			<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cur_port</span> <span class="o">=</span> <span class="n">hwif</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">cur_dev</span> <span class="o">=</span> <span class="n">drive</span><span class="p">;</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IDE_DFLAG_SLEEPING</span> <span class="o">|</span> <span class="n">IDE_DFLAG_PARKED</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * we know that the queue isn&#39;t empty, but this can happen</span>
<span class="cm">		 * if the q-&gt;prep_rq_fn() decides to kill a request</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="p">)</span>
			<span class="n">rq</span> <span class="o">=</span> <span class="n">blk_fetch_request</span><span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ide_unlock_port</span><span class="p">(</span><span class="n">hwif</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Sanity: don&#39;t accept a request that isn&#39;t a PM request</span>
<span class="cm">		 * if we are currently power managed. This is very important as</span>
<span class="cm">		 * blk_stop_queue() doesn&#39;t prevent the blk_fetch_request()</span>
<span class="cm">		 * above to return us whatever is in the queue. Since we call</span>
<span class="cm">		 * ide_do_request() ourselves, we end up taking requests while</span>
<span class="cm">		 * the queue is blocked...</span>
<span class="cm">		 * </span>
<span class="cm">		 * We let requests forced at head of queue with ide-preempt</span>
<span class="cm">		 * though. I hope that doesn&#39;t happen too much, hopefully not</span>
<span class="cm">		 * unless the subdriver triggers such a thing in its own PM</span>
<span class="cm">		 * state machine.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">IDE_DFLAG_BLOCKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">blk_pm_request</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_PREEMPT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* there should be no pending command at this point */</span>
			<span class="n">ide_unlock_port</span><span class="p">(</span><span class="n">hwif</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">plug_device</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">startstop</span> <span class="o">=</span> <span class="n">start_request</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">startstop</span> <span class="o">==</span> <span class="n">ide_stopped</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rq</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
			<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">goto</span> <span class="n">plug_device</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ide_unlock_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">plug_device:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ide_unlock_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="nl">plug_device_2:</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">__ide_requeue_and_plug</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">drive_is_ready</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">hwif</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">waiting_for_dma</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">dma_test_irq</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">.</span><span class="n">ctl_addr</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;</span> <span class="n">IDE_HFLAG_BROKEN_ALTSTATUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">tp_ops</span><span class="o">-&gt;</span><span class="n">read_altstatus</span><span class="p">(</span><span class="n">hwif</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* Note: this may clear a pending IRQ!! */</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">tp_ops</span><span class="o">-&gt;</span><span class="n">read_status</span><span class="p">(</span><span class="n">hwif</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span>
		<span class="cm">/* drive busy: definitely not interrupting */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* drive ready: *might* be interrupting */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ide_timer_expiry	-	handle lack of an IDE interrupt</span>
<span class="cm"> *	@data: timer callback magic (hwif)</span>
<span class="cm"> *</span>
<span class="cm"> *	An IDE command has timed out before the expected drive return</span>
<span class="cm"> *	occurred. At this point we attempt to clean up the current</span>
<span class="cm"> *	mess. If the current handler includes an expiry handler then</span>
<span class="cm"> *	we invoke the expiry handler, and providing it is happy the</span>
<span class="cm"> *	work is done. If that fails we apply generic recovery rules</span>
<span class="cm"> *	invoking the handler and checking the drive DMA status. We</span>
<span class="cm"> *	have an excessively incestuous relationship with the DMA</span>
<span class="cm"> *	logic that wants cleaning up.</span>
<span class="cm"> */</span>
 
<span class="kt">void</span> <span class="nf">ide_timer_expiry</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ide_hwif_t</span>	<span class="o">*</span><span class="n">hwif</span> <span class="o">=</span> <span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ide_drive_t</span>	<span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
	<span class="n">ide_handler_t</span>	<span class="o">*</span><span class="n">handler</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">wait</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">plug_device</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span>	<span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">rq_in_flight</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">handler</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handler</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">req_gen</span> <span class="o">!=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">req_gen_timer</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Either a marginal timeout occurred</span>
<span class="cm">		 * (got the interrupt just as timer expired),</span>
<span class="cm">		 * or we were &quot;sleeping&quot; to give other devices a chance.</span>
<span class="cm">		 * Either way, we don&#39;t really want to complain about anything.</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ide_expiry_t</span> <span class="o">*</span><span class="n">expiry</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">expiry</span><span class="p">;</span>
		<span class="n">ide_startstop_t</span> <span class="n">startstop</span> <span class="o">=</span> <span class="n">ide_stopped</span><span class="p">;</span>

		<span class="n">drive</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">cur_dev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">expiry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait</span> <span class="o">=</span> <span class="n">expiry</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* continue */</span>
				<span class="cm">/* reset timer */</span>
				<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">wait</span><span class="p">;</span>
				<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">req_gen_timer</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">req_gen</span><span class="p">;</span>
				<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">expiry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to simulate a real interrupt when invoking</span>
<span class="cm">		 * the handler() function, which means we need to</span>
<span class="cm">		 * globally mask the specific IRQ:</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* disable_irq_nosync ?? */</span>
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="cm">/* local CPU only, as if we were handling an interrupt */</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">polling</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">startstop</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">drive_is_ready</span><span class="p">(</span><span class="n">drive</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">waiting_for_dma</span><span class="p">)</span>
				<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">dma_lost_irq</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">port_ops</span> <span class="o">&amp;&amp;</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">port_ops</span><span class="o">-&gt;</span><span class="n">clear_irq</span><span class="p">)</span>
				<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">port_ops</span><span class="o">-&gt;</span><span class="n">clear_irq</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: lost interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">drive</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">startstop</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">waiting_for_dma</span><span class="p">)</span>
				<span class="n">startstop</span> <span class="o">=</span> <span class="n">ide_dma_timeout_retry</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">startstop</span> <span class="o">=</span> <span class="n">ide_error</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="s">&quot;irq timeout&quot;</span><span class="p">,</span>
					<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">tp_ops</span><span class="o">-&gt;</span><span class="n">read_status</span><span class="p">(</span><span class="n">hwif</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">startstop</span> <span class="o">==</span> <span class="n">ide_stopped</span> <span class="o">&amp;&amp;</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">polling</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rq_in_flight</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
			<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ide_unlock_port</span><span class="p">(</span><span class="n">hwif</span><span class="p">);</span>
			<span class="n">plug_device</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plug_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ide_unlock_host</span><span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
		<span class="n">ide_requeue_and_plug</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq_in_flight</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	unexpected_intr		-	handle an unexpected IDE interrupt</span>
<span class="cm"> *	@irq: interrupt line</span>
<span class="cm"> *	@hwif: port being processed</span>
<span class="cm"> *</span>
<span class="cm"> *	There&#39;s nothing really useful we can do with an unexpected interrupt,</span>
<span class="cm"> *	other than reading the status register (to clear it), and logging it.</span>
<span class="cm"> *	There should be no way that an irq can happen before we&#39;re ready for it,</span>
<span class="cm"> *	so we needn&#39;t worry much about losing an &quot;important&quot; interrupt here.</span>
<span class="cm"> *</span>
<span class="cm"> *	On laptops (and &quot;green&quot; PCs), an unexpected interrupt occurs whenever</span>
<span class="cm"> *	the drive enters &quot;idle&quot;, &quot;standby&quot;, or &quot;sleep&quot; mode, so if the status</span>
<span class="cm"> *	looks &quot;good&quot;, we just ignore the interrupt completely.</span>
<span class="cm"> *</span>
<span class="cm"> *	This routine assumes __cli() is in effect when called.</span>
<span class="cm"> *</span>
<span class="cm"> *	If an unexpected interrupt happens on irq15 while we are handling irq14</span>
<span class="cm"> *	and if the two interfaces are &quot;serialized&quot; (CMD640), then it looks like</span>
<span class="cm"> *	we could screw up by interfering with a new request being set up for </span>
<span class="cm"> *	irq15.</span>
<span class="cm"> *</span>
<span class="cm"> *	In reality, this is a non-issue.  The new command is not sent unless </span>
<span class="cm"> *	the drive is ready to accept one, in which case we know the drive is</span>
<span class="cm"> *	not trying to interrupt us.  And ide_set_handler() is always invoked</span>
<span class="cm"> *	before completing the issuance of any new drive command, so we will not</span>
<span class="cm"> *	be accidentally invoked as a result of any valid command completion</span>
<span class="cm"> *	interrupt.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unexpected_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">tp_ops</span><span class="o">-&gt;</span><span class="n">read_status</span><span class="p">(</span><span class="n">hwif</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OK_STAT</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">ATA_DRDY</span><span class="p">,</span> <span class="n">BAD_STAT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Try to not flood the console with msgs */</span>
		<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_msgtime</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
		<span class="o">++</span><span class="n">count</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">last_msgtime</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">last_msgtime</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unexpected interrupt, &quot;</span>
				<span class="s">&quot;status=0x%02x, count=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ide_intr	-	default IDE interrupt handler</span>
<span class="cm"> *	@irq: interrupt number</span>
<span class="cm"> *	@dev_id: hwif</span>
<span class="cm"> *	@regs: unused weirdness from the kernel irq layer</span>
<span class="cm"> *</span>
<span class="cm"> *	This is the default IRQ handler for the IDE layer. You should</span>
<span class="cm"> *	not need to override it. If you do be aware it is subtle in</span>
<span class="cm"> *	places</span>
<span class="cm"> *</span>
<span class="cm"> *	hwif is the interface in the group currently performing</span>
<span class="cm"> *	a command. hwif-&gt;cur_dev is the drive and hwif-&gt;handler is</span>
<span class="cm"> *	the IRQ handler to call. As we issue a command the handlers</span>
<span class="cm"> *	step through multiple states, reassigning the handler to the</span>
<span class="cm"> *	next step in the process. Unlike a smart SCSI controller IDE</span>
<span class="cm"> *	expects the main processor to sequence the various transfer</span>
<span class="cm"> *	stages. We also manage a poll timer to catch up with most</span>
<span class="cm"> *	timeout situations. There are still a few where the handlers</span>
<span class="cm"> *	don&#39;t ever decide to give up.</span>
<span class="cm"> *</span>
<span class="cm"> *	The handler eventually returns ide_stopped to indicate the</span>
<span class="cm"> *	request completed. At this point we issue the next request</span>
<span class="cm"> *	on the port and the process begins again.</span>
<span class="cm"> */</span>

<span class="n">irqreturn_t</span> <span class="nf">ide_intr</span> <span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span> <span class="o">=</span> <span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ide_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
	<span class="n">ide_handler_t</span> <span class="o">*</span><span class="n">handler</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">ide_startstop_t</span> <span class="n">startstop</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">irq_ret</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">plug_device</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">rq_in_flight</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;</span> <span class="n">IDE_HFLAG_SERIALIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwif</span> <span class="o">!=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">cur_port</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_early</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">port_ops</span> <span class="o">&amp;&amp;</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">port_ops</span><span class="o">-&gt;</span><span class="n">test_irq</span> <span class="o">&amp;&amp;</span>
	    <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">port_ops</span><span class="o">-&gt;</span><span class="n">test_irq</span><span class="p">(</span><span class="n">hwif</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">handler</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handler</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">polling</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not expecting an interrupt from this drive.</span>
<span class="cm">		 * That means this could be:</span>
<span class="cm">		 *	(1) an interrupt from another PCI device</span>
<span class="cm">		 *	sharing the same PCI INT# as us.</span>
<span class="cm">		 * or	(2) a drive just entered sleep or standby mode,</span>
<span class="cm">		 *	and is interrupting to let us know.</span>
<span class="cm">		 * or	(3) a spurious interrupt of unknown origin.</span>
<span class="cm">		 *</span>
<span class="cm">		 * For PCI, we cannot tell the difference,</span>
<span class="cm">		 * so in that case we just ignore it and hope it goes away.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">irq_flags</span> <span class="o">&amp;</span> <span class="n">IRQF_SHARED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Probably not a shared PCI interrupt,</span>
<span class="cm">			 * so we can safely try to do something about it:</span>
<span class="cm">			 */</span>
			<span class="n">unexpected_intr</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">hwif</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Whack the status register, just in case</span>
<span class="cm">			 * we have a leftover pending IRQ.</span>
<span class="cm">			 */</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">tp_ops</span><span class="o">-&gt;</span><span class="n">read_status</span><span class="p">(</span><span class="n">hwif</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">drive</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">cur_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drive_is_ready</span><span class="p">(</span><span class="n">drive</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * This happens regularly when we share a PCI IRQ with</span>
<span class="cm">		 * another device.  Unfortunately, it can also happen</span>
<span class="cm">		 * with some buggy drives that trigger the IRQ before</span>
<span class="cm">		 * their status register is up to date.  Hopefully we have</span>
<span class="cm">		 * enough advance overhead that the latter isn&#39;t a problem.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">expiry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">req_gen</span><span class="o">++</span><span class="p">;</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">port_ops</span> <span class="o">&amp;&amp;</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">port_ops</span><span class="o">-&gt;</span><span class="n">clear_irq</span><span class="p">)</span>
		<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">port_ops</span><span class="o">-&gt;</span><span class="n">clear_irq</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">IDE_DFLAG_UNMASK</span><span class="p">)</span>
		<span class="n">local_irq_enable_in_hardirq</span><span class="p">();</span>

	<span class="cm">/* service this interrupt, may set handler for next interrupt */</span>
	<span class="n">startstop</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note that handler() may have set things up for another</span>
<span class="cm">	 * interrupt to occur soon, but it cannot happen until</span>
<span class="cm">	 * we exit from this routine, because it will be the</span>
<span class="cm">	 * same irq as is currently being serviced here, and Linux</span>
<span class="cm">	 * won&#39;t allow another of the same (on any CPU) until we return.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">startstop</span> <span class="o">==</span> <span class="n">ide_stopped</span> <span class="o">&amp;&amp;</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">polling</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">);</span>
		<span class="n">rq_in_flight</span> <span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
		<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ide_unlock_port</span><span class="p">(</span><span class="n">hwif</span><span class="p">);</span>
		<span class="n">plug_device</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">irq_ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out_early:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plug_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ide_unlock_host</span><span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
		<span class="n">ide_requeue_and_plug</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">rq_in_flight</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">irq_ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ide_intr</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ide_pad_transfer</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">hwif</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
			<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">tp_ops</span><span class="o">-&gt;</span><span class="n">output_data</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">tp_ops</span><span class="o">-&gt;</span><span class="n">input_data</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ide_pad_transfer</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
