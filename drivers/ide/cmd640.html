<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › ide › cmd640.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cmd640.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (C) 1995-1996  Linus Torvalds &amp; authors (see below)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  Original authors:	abramov@cecmow.enet.dec.com (Igor Abramov)</span>
<span class="cm"> *			mlord@pobox.com (Mark Lord)</span>
<span class="cm"> *</span>
<span class="cm"> *  See linux/MAINTAINERS for address of current maintainer.</span>
<span class="cm"> *</span>
<span class="cm"> *  This file provides support for the advanced features and bugs</span>
<span class="cm"> *  of IDE interfaces using the CMD Technologies 0640 IDE interface chip.</span>
<span class="cm"> *</span>
<span class="cm"> *  These chips are basically fucked by design, and getting this driver</span>
<span class="cm"> *  to work on every motherboard design that uses this screwed chip seems</span>
<span class="cm"> *  bloody well impossible.  However, we&#39;re still trying.</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.97 worked for everybody.</span>
<span class="cm"> *</span>
<span class="cm"> *  User feedback is essential.  Many thanks to the beta test team:</span>
<span class="cm"> *</span>
<span class="cm"> *  A.Hartgers@stud.tue.nl, JZDQC@CUNYVM.CUNY.edu, abramov@cecmow.enet.dec.com,</span>
<span class="cm"> *  bardj@utopia.ppp.sn.no, bart@gaga.tue.nl, bbol001@cs.auckland.ac.nz,</span>
<span class="cm"> *  chrisc@dbass.demon.co.uk, dalecki@namu26.Num.Math.Uni-Goettingen.de,</span>
<span class="cm"> *  derekn@vw.ece.cmu.edu, florian@btp2x3.phy.uni-bayreuth.de,</span>
<span class="cm"> *  flynn@dei.unipd.it, gadio@netvision.net.il, godzilla@futuris.net,</span>
<span class="cm"> *  j@pobox.com, jkemp1@mises.uni-paderborn.de, jtoppe@hiwaay.net,</span>
<span class="cm"> *  kerouac@ssnet.com, meskes@informatik.rwth-aachen.de, hzoli@cs.elte.hu,</span>
<span class="cm"> *  peter@udgaard.isgtec.com, phil@tazenda.demon.co.uk, roadcapw@cfw.com,</span>
<span class="cm"> *  s0033las@sun10.vsz.bme.hu, schaffer@tam.cornell.edu, sjd@slip.net,</span>
<span class="cm"> *  steve@ei.org, ulrpeg@bigcomm.gun.de, ism@tardis.ed.ac.uk, mack@cray.com</span>
<span class="cm"> *  liug@mama.indstate.edu, and others.</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.01	Initial version, hacked out of ide.c,</span>
<span class="cm"> *			and #include&#39;d rather than compiled separately.</span>
<span class="cm"> *			This will get cleaned up in a subsequent release.</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.02	Fixes for vlb initialization code, enable prefetch</span>
<span class="cm"> *			for versions &#39;B&#39; and &#39;C&#39; of chip by default,</span>
<span class="cm"> *			some code cleanup.</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.03	Added reset of secondary interface,</span>
<span class="cm"> *			and black list for devices which are not compatible</span>
<span class="cm"> *			with prefetch mode. Separate function for setting</span>
<span class="cm"> *			prefetch is added, possibly it will be called some</span>
<span class="cm"> *			day from ioctl processing code.</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.04	Now configs/compiles separate from ide.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.05	Major rewrite of interface timing code.</span>
<span class="cm"> *			Added new function cmd640_set_mode to set PIO mode</span>
<span class="cm"> *			from ioctl call. New drives added to black list.</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.06	More code cleanup. Prefetch is enabled only for</span>
<span class="cm"> *			detected hard drives, not included in prefetch</span>
<span class="cm"> *			black list.</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.07	Changed to more conservative drive tuning policy.</span>
<span class="cm"> *			Unknown drives, which report PIO &lt; 4 are set to</span>
<span class="cm"> *			(reported_PIO - 1) if it is supported, or to PIO0.</span>
<span class="cm"> *			List of known drives extended by info provided by</span>
<span class="cm"> *			CMD at their ftp site.</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.08	Added autotune/noautotune support.</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.09	Try to be smarter about 2nd port enabling.</span>
<span class="cm"> *  Version 0.10	Be nice and don&#39;t reset 2nd port.</span>
<span class="cm"> *  Version 0.11	Try to handle more weird situations.</span>
<span class="cm"> *</span>
<span class="cm"> *  Version 0.12	Lots of bug fixes from Laszlo Peter</span>
<span class="cm"> *			irq unmasking disabled for reliability.</span>
<span class="cm"> *			try to be even smarter about the second port.</span>
<span class="cm"> *			tidy up source code formatting.</span>
<span class="cm"> *  Version 0.13	permit irq unmasking again.</span>
<span class="cm"> *  Version 0.90	massive code cleanup, some bugs fixed.</span>
<span class="cm"> *			defaults all drives to PIO mode0, prefetch off.</span>
<span class="cm"> *			autotune is OFF by default, with compile time flag.</span>
<span class="cm"> *			prefetch can be turned OFF/ON using &quot;hdparm -p8/-p9&quot;</span>
<span class="cm"> *			 (requires hdparm-3.1 or newer)</span>
<span class="cm"> *  Version 0.91	first release to linux-kernel list.</span>
<span class="cm"> *  Version 0.92	move initial reg dump to separate callable function</span>
<span class="cm"> *			change &quot;readahead&quot; to &quot;prefetch&quot; to avoid confusion</span>
<span class="cm"> *  Version 0.95	respect original BIOS timings unless autotuning.</span>
<span class="cm"> *			tons of code cleanup and rearrangement.</span>
<span class="cm"> *			added CONFIG_BLK_DEV_CMD640_ENHANCED option</span>
<span class="cm"> *			prevent use of unmask when prefetch is on</span>
<span class="cm"> *  Version 0.96	prevent use of io_32bit when prefetch is off</span>
<span class="cm"> *  Version 0.97	fix VLB secondary interface for sjd@slip.net</span>
<span class="cm"> *			other minor tune-ups:  0.96 was very good.</span>
<span class="cm"> *  Version 0.98	ignore PCI version when disabled by BIOS</span>
<span class="cm"> *  Version 0.99	display setup/active/recovery clocks with PIO mode</span>
<span class="cm"> *  Version 1.00	Mmm.. cannot depend on PCMD_ENA in all systems</span>
<span class="cm"> *  Version 1.01	slow/fast devsel can be selected with &quot;hdparm -p6/-p7&quot;</span>
<span class="cm"> *			 (&quot;fast&quot; is necessary for 32bit I/O in some systems)</span>
<span class="cm"> *  Version 1.02	fix bug that resulted in slow &quot;setup times&quot;</span>
<span class="cm"> *			 (patch courtesy of Zoltan Hidvegi)</span>
<span class="cm"> */</span>

<span class="cp">#define CMD640_PREFETCH_MASKS 1</span>

<span class="cm">/*#define CMD640_DUMP_REGS */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ide.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#define DRV_NAME &quot;cmd640&quot;</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">cmd640_vlb</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * CMD640 specific registers definition.</span>
<span class="cm"> */</span>

<span class="cp">#define VID		0x00</span>
<span class="cp">#define DID		0x02</span>
<span class="cp">#define PCMD		0x04</span>
<span class="cp">#define   PCMD_ENA	0x01</span>
<span class="cp">#define PSTTS		0x06</span>
<span class="cp">#define REVID		0x08</span>
<span class="cp">#define PROGIF		0x09</span>
<span class="cp">#define SUBCL		0x0a</span>
<span class="cp">#define BASCL		0x0b</span>
<span class="cp">#define BaseA0		0x10</span>
<span class="cp">#define BaseA1		0x14</span>
<span class="cp">#define BaseA2		0x18</span>
<span class="cp">#define BaseA3		0x1c</span>
<span class="cp">#define INTLINE		0x3c</span>
<span class="cp">#define INPINE		0x3d</span>

<span class="cp">#define	CFR		0x50</span>
<span class="cp">#define   CFR_DEVREV		0x03</span>
<span class="cp">#define   CFR_IDE01INTR		0x04</span>
<span class="cp">#define	  CFR_DEVID		0x18</span>
<span class="cp">#define	  CFR_AT_VESA_078h	0x20</span>
<span class="cp">#define	  CFR_DSA1		0x40</span>
<span class="cp">#define	  CFR_DSA0		0x80</span>

<span class="cp">#define CNTRL		0x51</span>
<span class="cp">#define	  CNTRL_DIS_RA0		0x40</span>
<span class="cp">#define   CNTRL_DIS_RA1		0x80</span>
<span class="cp">#define	  CNTRL_ENA_2ND		0x08</span>

<span class="cp">#define	CMDTIM		0x52</span>
<span class="cp">#define	ARTTIM0		0x53</span>
<span class="cp">#define	DRWTIM0		0x54</span>
<span class="cp">#define ARTTIM1 	0x55</span>
<span class="cp">#define DRWTIM1		0x56</span>
<span class="cp">#define ARTTIM23	0x57</span>
<span class="cp">#define   ARTTIM23_DIS_RA2	0x04</span>
<span class="cp">#define   ARTTIM23_DIS_RA3	0x08</span>
<span class="cp">#define   ARTTIM23_IDE23INTR	0x10</span>
<span class="cp">#define DRWTIM23	0x58</span>
<span class="cp">#define BRST		0x59</span>

<span class="cm">/*</span>
<span class="cm"> * Registers and masks for easy access by drive index:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">prefetch_regs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{</span><span class="n">CNTRL</span><span class="p">,</span> <span class="n">CNTRL</span><span class="p">,</span> <span class="n">ARTTIM23</span><span class="p">,</span> <span class="n">ARTTIM23</span><span class="p">};</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">prefetch_masks</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">CNTRL_DIS_RA0</span><span class="p">,</span> <span class="n">CNTRL_DIS_RA1</span><span class="p">,</span> <span class="n">ARTTIM23_DIS_RA2</span><span class="p">,</span> <span class="n">ARTTIM23_DIS_RA3</span><span class="p">};</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED</span>

<span class="k">static</span> <span class="n">u8</span> <span class="n">arttim_regs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">ARTTIM0</span><span class="p">,</span> <span class="n">ARTTIM1</span><span class="p">,</span> <span class="n">ARTTIM23</span><span class="p">,</span> <span class="n">ARTTIM23</span><span class="p">};</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">drwtim_regs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">DRWTIM0</span><span class="p">,</span> <span class="n">DRWTIM1</span><span class="p">,</span> <span class="n">DRWTIM23</span><span class="p">,</span> <span class="n">DRWTIM23</span><span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Current cmd640 timing values for each drive.</span>
<span class="cm"> * The defaults for each are the slowest possible timings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">setup_counts</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>     <span class="cm">/* Address setup count (in clocks) */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">active_counts</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>   <span class="o">=</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">};</span> <span class="cm">/* Active count   (encoded) */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">recovery_counts</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">};</span> <span class="cm">/* Recovery count (encoded) */</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_CMD640_ENHANCED */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cmd640_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Interface to access cmd640x registers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd640_key</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__put_cmd640_reg</span><span class="p">)(</span><span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u8</span> <span class="p">(</span><span class="o">*</span><span class="n">__get_cmd640_reg</span><span class="p">)(</span><span class="n">u16</span> <span class="n">reg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is read from the CFR reg, and is used in several places.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd640_chip_version</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The CMD640x chip does not support DWORD config write cycles, but some</span>
<span class="cm"> * of the BIOSes use them to implement the config services.</span>
<span class="cm"> * Therefore, we must use direct IO instead.</span>
<span class="cm"> */</span>

<span class="cm">/* PCI method 1 access */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_cmd640_reg_pci1</span><span class="p">(</span><span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl_p</span><span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0xfc</span><span class="p">)</span> <span class="o">|</span> <span class="n">cmd640_key</span><span class="p">,</span> <span class="mh">0xcf8</span><span class="p">);</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xcfc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">get_cmd640_reg_pci1</span><span class="p">(</span><span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl_p</span><span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0xfc</span><span class="p">)</span> <span class="o">|</span> <span class="n">cmd640_key</span><span class="p">,</span> <span class="mh">0xcf8</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inb_p</span><span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xcfc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* PCI method 2 access (from CMD datasheet) */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_cmd640_reg_pci2</span><span class="p">(</span><span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0xcf8</span><span class="p">);</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cmd640_key</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0xcf8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">get_cmd640_reg_pci2</span><span class="p">(</span><span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">b</span><span class="p">;</span>

	<span class="n">outb_p</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0xcf8</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">cmd640_key</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0xcf8</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* VLB access */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_cmd640_reg_vlb</span><span class="p">(</span><span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">cmd640_key</span><span class="p">);</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cmd640_key</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">get_cmd640_reg_vlb</span><span class="p">(</span><span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">cmd640_key</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">cmd640_key</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">get_cmd640_reg</span><span class="p">(</span><span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">b</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">__get_cmd640_reg</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_cmd640_reg</span><span class="p">(</span><span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__put_cmd640_reg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">match_pci_cmd640_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">ven_dev</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x95</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_cmd640_reg</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ven_dev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef STUPIDLY_TRUST_BROKEN_PCMD_ENA_BIT</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">get_cmd640_reg</span><span class="p">(</span><span class="n">PCMD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PCMD_ENA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ide: cmd640 on PCI disabled by BIOS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* STUPIDLY_TRUST_BROKEN_PCMD_ENA_BIT */</span><span class="cp"></span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* success */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Probe for CMD640x -- pci method 1</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">probe_for_cmd640_pci1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__get_cmd640_reg</span> <span class="o">=</span> <span class="n">get_cmd640_reg_pci1</span><span class="p">;</span>
	<span class="n">__put_cmd640_reg</span> <span class="o">=</span> <span class="n">put_cmd640_reg_pci1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cmd640_key</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
	     <span class="n">cmd640_key</span> <span class="o">&lt;=</span> <span class="mh">0x8000f800</span><span class="p">;</span>
	     <span class="n">cmd640_key</span> <span class="o">+=</span> <span class="mh">0x800</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_pci_cmd640_device</span><span class="p">())</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* success */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Probe for CMD640x -- pci method 2</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">probe_for_cmd640_pci2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__get_cmd640_reg</span> <span class="o">=</span> <span class="n">get_cmd640_reg_pci2</span><span class="p">;</span>
	<span class="n">__put_cmd640_reg</span> <span class="o">=</span> <span class="n">put_cmd640_reg_pci2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cmd640_key</span> <span class="o">=</span> <span class="mh">0xc000</span><span class="p">;</span> <span class="n">cmd640_key</span> <span class="o">&lt;=</span> <span class="mh">0xcf00</span><span class="p">;</span> <span class="n">cmd640_key</span> <span class="o">+=</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_pci_cmd640_device</span><span class="p">())</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* success */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Probe for CMD640x -- vlb</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">probe_for_cmd640_vlb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">b</span><span class="p">;</span>

	<span class="n">__get_cmd640_reg</span> <span class="o">=</span> <span class="n">get_cmd640_reg_vlb</span><span class="p">;</span>
	<span class="n">__put_cmd640_reg</span> <span class="o">=</span> <span class="n">put_cmd640_reg_vlb</span><span class="p">;</span>
	<span class="n">cmd640_key</span> <span class="o">=</span> <span class="mh">0x178</span><span class="p">;</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">get_cmd640_reg</span><span class="p">(</span><span class="n">CFR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mh">0xff</span> <span class="o">||</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">||</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">CFR_AT_VESA_078h</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd640_key</span> <span class="o">=</span> <span class="mh">0x78</span><span class="p">;</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">get_cmd640_reg</span><span class="p">(</span><span class="n">CFR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mh">0xff</span> <span class="o">||</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">CFR_AT_VESA_078h</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* success */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Returns 1 if an IDE interface/drive exists at 0x170,</span>
<span class="cm"> *  Returns 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">secondary_port_responding</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">outb_p</span><span class="p">(</span><span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x176</span><span class="p">);</span>	<span class="cm">/* select drive0 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">inb_p</span><span class="p">(</span><span class="mh">0x176</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x0a</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="mh">0x1a</span><span class="p">,</span> <span class="mh">0x176</span><span class="p">);</span> <span class="cm">/* select drive1 */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inb_p</span><span class="p">(</span><span class="mh">0x176</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x1a</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* nothing responded */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* success */</span>
<span class="p">}</span>

<span class="cp">#ifdef CMD640_DUMP_REGS</span>
<span class="cm">/*</span>
<span class="cm"> * Dump out all cmd640 registers.  May be called from ide.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmd640_dump_regs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">cmd640_vlb</span> <span class="o">?</span> <span class="mh">0x50</span> <span class="o">:</span> <span class="mh">0x00</span><span class="p">;</span>

	<span class="cm">/* Dump current state of chip registers */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ide: cmd640 internal register dump:&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">reg</span> <span class="o">&lt;=</span> <span class="mh">0x59</span><span class="p">;</span> <span class="n">reg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">%04x:&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %02x&quot;</span><span class="p">,</span> <span class="n">get_cmd640_reg</span><span class="p">(</span><span class="n">reg</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__set_prefetch_mode</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* want prefetch on? */</span>
<span class="cp">#if CMD640_PREFETCH_MASKS</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">|=</span> <span class="n">IDE_DFLAG_NO_UNMASK</span><span class="p">;</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IDE_DFLAG_UNMASK</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IDE_DFLAG_NO_IO_32BIT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IDE_DFLAG_NO_UNMASK</span><span class="p">;</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">|=</span> <span class="n">IDE_DFLAG_NO_IO_32BIT</span><span class="p">;</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">io_32bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_BLK_DEV_CMD640_ENHANCED</span>
<span class="cm">/*</span>
<span class="cm"> * Check whether prefetch is on for a drive,</span>
<span class="cm"> * and initialize the unmask flags for safe operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">check_prefetch</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">b</span> <span class="o">=</span> <span class="n">get_cmd640_reg</span><span class="p">(</span><span class="n">prefetch_regs</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>

	<span class="n">__set_prefetch_mode</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">prefetch_masks</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>

<span class="cm">/*</span>
<span class="cm"> * Sets prefetch mode for a drive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_prefetch_mode</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">prefetch_regs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">b</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">__get_cmd640_reg</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">__set_prefetch_mode</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span>
		<span class="n">b</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">prefetch_masks</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>	<span class="cm">/* enable prefetch */</span>
	<span class="k">else</span>
		<span class="n">b</span> <span class="o">|=</span> <span class="n">prefetch_masks</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>	<span class="cm">/* disable prefetch */</span>
	<span class="n">__put_cmd640_reg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dump out current drive clocks settings</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">display_clocks</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">active_count</span><span class="p">,</span> <span class="n">recovery_count</span><span class="p">;</span>

	<span class="n">active_count</span> <span class="o">=</span> <span class="n">active_counts</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">active_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">++</span><span class="n">active_count</span><span class="p">;</span>
	<span class="n">recovery_count</span> <span class="o">=</span> <span class="n">recovery_counts</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">active_count</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">recovery_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">++</span><span class="n">recovery_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd640_chip_version</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">recovery_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* cmd640b uses (count + 1)*/</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, clocks=%d/%d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">setup_counts</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">active_count</span><span class="p">,</span> <span class="n">recovery_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pack active and recovery counts into single byte representation</span>
<span class="cm"> * used by controller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">pack_nibbles</span><span class="p">(</span><span class="n">u8</span> <span class="n">upper</span><span class="p">,</span> <span class="n">u8</span> <span class="n">lower</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">upper</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">lower</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine writes the prepared setup/active/recovery counts</span>
<span class="cm"> * for a drive into the cmd640 chipset registers to active them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">program_drive_counts</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">setup_count</span>    <span class="o">=</span> <span class="n">setup_counts</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">active_count</span>   <span class="o">=</span> <span class="n">active_counts</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">recovery_count</span> <span class="o">=</span> <span class="n">recovery_counts</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up address setup count and drive read/write timing registers.</span>
<span class="cm">	 * Primary interface has individual count/timing registers for</span>
<span class="cm">	 * each drive.  Secondary interface has one common set of registers,</span>
<span class="cm">	 * so we merge the timings, using the slowest value for each timing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">peer</span> <span class="o">=</span> <span class="n">ide_get_pair_dev</span><span class="p">(</span><span class="n">drive</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mate</span> <span class="o">=</span> <span class="n">index</span> <span class="o">^</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">setup_count</span> <span class="o">&lt;</span> <span class="n">setup_counts</span><span class="p">[</span><span class="n">mate</span><span class="p">])</span>
				<span class="n">setup_count</span> <span class="o">=</span> <span class="n">setup_counts</span><span class="p">[</span><span class="n">mate</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">active_count</span> <span class="o">&lt;</span> <span class="n">active_counts</span><span class="p">[</span><span class="n">mate</span><span class="p">])</span>
				<span class="n">active_count</span> <span class="o">=</span> <span class="n">active_counts</span><span class="p">[</span><span class="n">mate</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">recovery_count</span> <span class="o">&lt;</span> <span class="n">recovery_counts</span><span class="p">[</span><span class="n">mate</span><span class="p">])</span>
				<span class="n">recovery_count</span> <span class="o">=</span> <span class="n">recovery_counts</span><span class="p">[</span><span class="n">mate</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert setup_count to internal chipset representation</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">setup_count</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">4</span>:	 <span class="n">setup_count</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:	 <span class="n">setup_count</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="k">case</span> <span class="mi">2</span>:	 <span class="n">setup_count</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="n">setup_count</span> <span class="o">=</span> <span class="mh">0xc0</span><span class="p">;</span> <span class="cm">/* case 5 */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that everything is ready, program the new timings</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Program the address_setup clocks into ARTTIM reg,</span>
<span class="cm">	 * and then the active/recovery counts into the DRWTIM reg</span>
<span class="cm">	 * (this converts counts of 16 into counts of zero -- okay).</span>
<span class="cm">	 */</span>
	<span class="n">setup_count</span> <span class="o">|=</span> <span class="n">__get_cmd640_reg</span><span class="p">(</span><span class="n">arttim_regs</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
	<span class="n">__put_cmd640_reg</span><span class="p">(</span><span class="n">arttim_regs</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">setup_count</span><span class="p">);</span>
	<span class="n">__put_cmd640_reg</span><span class="p">(</span><span class="n">drwtim_regs</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">pack_nibbles</span><span class="p">(</span><span class="n">active_count</span><span class="p">,</span> <span class="n">recovery_count</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set a specific pio_mode for a drive</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmd640_set_mode</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
			    <span class="n">u8</span> <span class="n">pio_mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cycle_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ide_timing</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">setup_time</span><span class="p">,</span> <span class="n">active_time</span><span class="p">,</span> <span class="n">recovery_time</span><span class="p">,</span> <span class="n">clock_time</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">setup_count</span><span class="p">,</span> <span class="n">active_count</span><span class="p">,</span> <span class="n">recovery_count</span><span class="p">,</span> <span class="n">recovery_count2</span><span class="p">,</span> <span class="n">cycle_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bus_speed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd640_vlb</span><span class="p">)</span>
		<span class="n">bus_speed</span> <span class="o">=</span> <span class="n">ide_vlb_clk</span> <span class="o">?</span> <span class="n">ide_vlb_clk</span> <span class="o">:</span> <span class="mi">50</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bus_speed</span> <span class="o">=</span> <span class="n">ide_pci_clk</span> <span class="o">?</span> <span class="n">ide_pci_clk</span> <span class="o">:</span> <span class="mi">33</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pio_mode</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">pio_mode</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">ide_timing_find_mode</span><span class="p">(</span><span class="n">XFER_PIO_0</span> <span class="o">+</span> <span class="n">pio_mode</span><span class="p">);</span>
	<span class="n">setup_time</span>  <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">;</span>
	<span class="n">active_time</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>

	<span class="n">recovery_time</span> <span class="o">=</span> <span class="n">cycle_time</span> <span class="o">-</span> <span class="p">(</span><span class="n">setup_time</span> <span class="o">+</span> <span class="n">active_time</span><span class="p">);</span>
	<span class="n">clock_time</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">bus_speed</span><span class="p">;</span>
	<span class="n">cycle_count</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">cycle_time</span><span class="p">,</span> <span class="n">clock_time</span><span class="p">);</span>

	<span class="n">setup_count</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">setup_time</span><span class="p">,</span> <span class="n">clock_time</span><span class="p">);</span>

	<span class="n">active_count</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">active_time</span><span class="p">,</span> <span class="n">clock_time</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">active_count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">active_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* minimum allowed by cmd640 */</span>

	<span class="n">recovery_count</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">recovery_time</span><span class="p">,</span> <span class="n">clock_time</span><span class="p">);</span>
	<span class="n">recovery_count2</span> <span class="o">=</span> <span class="n">cycle_count</span> <span class="o">-</span> <span class="p">(</span><span class="n">setup_count</span> <span class="o">+</span> <span class="n">active_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recovery_count2</span> <span class="o">&gt;</span> <span class="n">recovery_count</span><span class="p">)</span>
		<span class="n">recovery_count</span> <span class="o">=</span> <span class="n">recovery_count2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recovery_count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">recovery_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* minimum allowed by cmd640 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recovery_count</span> <span class="o">&gt;</span> <span class="mi">17</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">active_count</span> <span class="o">+=</span> <span class="n">recovery_count</span> <span class="o">-</span> <span class="mi">17</span><span class="p">;</span>
		<span class="n">recovery_count</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">active_count</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">active_count</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="cm">/* maximum allowed by cmd640 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd640_chip_version</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">recovery_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* cmd640b uses (count + 1)*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recovery_count</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">recovery_count</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="cm">/* maximum allowed by cmd640 */</span>

	<span class="n">setup_counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>    <span class="o">=</span> <span class="n">setup_count</span><span class="p">;</span>
	<span class="n">active_counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>   <span class="o">=</span> <span class="n">active_count</span><span class="p">;</span>
	<span class="n">recovery_counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovery_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In a perfect world, we might set the drive pio mode here</span>
<span class="cm">	 * (using WIN_SETFEATURE) before continuing.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But we do not, because:</span>
<span class="cm">	 *	1) this is the wrong place to do it (proper is do_special() in ide.c)</span>
<span class="cm">	 * 	2) in practice this is rarely, if ever, necessary</span>
<span class="cm">	 */</span>
	<span class="n">program_drive_counts</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmd640_set_pio_mode</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">,</span> <span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cycle_time</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">pio</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">pio_mode</span> <span class="o">-</span> <span class="n">XFER_PIO_0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pio</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">6</span>: <span class="cm">/* set fast-devsel off */</span>
	<span class="k">case</span> <span class="mi">7</span>: <span class="cm">/* set fast-devsel on */</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">get_cmd640_reg</span><span class="p">(</span><span class="n">CNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x27</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pio</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">b</span> <span class="o">|=</span> <span class="mh">0x27</span><span class="p">;</span>
		<span class="n">put_cmd640_reg</span><span class="p">(</span><span class="n">CNTRL</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: %sabled cmd640 fast host timing (devsel)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">drive</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">pio</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;en&quot;</span> <span class="o">:</span> <span class="s">&quot;dis&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>: <span class="cm">/* set prefetch off */</span>
	<span class="k">case</span> <span class="mi">9</span>: <span class="cm">/* set prefetch on */</span>
		<span class="n">set_prefetch_mode</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">pio</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: %sabled cmd640 prefetch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">drive</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">pio</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;en&quot;</span> <span class="o">:</span> <span class="s">&quot;dis&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cycle_time</span> <span class="o">=</span> <span class="n">ide_pio_cycle_time</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">pio</span><span class="p">);</span>
	<span class="n">cmd640_set_mode</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">pio</span><span class="p">,</span> <span class="n">cycle_time</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: selected cmd640 PIO mode%d (%dns)&quot;</span><span class="p">,</span>
		<span class="n">drive</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pio</span><span class="p">,</span> <span class="n">cycle_time</span><span class="p">);</span>

	<span class="n">display_clocks</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_CMD640_ENHANCED */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">cmd640_init_dev</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">dn</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED</span>
	<span class="cm">/*</span>
<span class="cm">	 * Reset timing to the slowest speed and turn off prefetch.</span>
<span class="cm">	 * This way, the drive identify code has a better chance.</span>
<span class="cm">	 */</span>
	<span class="n">setup_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>    <span class="o">=</span>  <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* max possible */</span>
	<span class="n">active_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/* max possible */</span>
	<span class="n">recovery_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/* max possible */</span>
	<span class="n">program_drive_counts</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">set_prefetch_mode</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: drive%d timings/prefetch cleared</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set the drive unmask flags to match the prefetch setting.</span>
<span class="cm">	 */</span>
	<span class="n">check_prefetch</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: drive%d timings/prefetch(%s) preserved</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">IDE_DFLAG_NO_IO_32BIT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;off&quot;</span> <span class="o">:</span> <span class="s">&quot;on&quot;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_CMD640_ENHANCED */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmd640_test_irq</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq_reg</span>		<span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">?</span> <span class="n">ARTTIM23</span> <span class="o">:</span> <span class="n">CFR</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">irq_mask</span>		<span class="o">=</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">?</span> <span class="n">ARTTIM23_IDE23INTR</span> <span class="o">:</span>
						  <span class="n">CFR_IDE01INTR</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">irq_stat</span>		<span class="o">=</span> <span class="n">get_cmd640_reg</span><span class="p">(</span><span class="n">irq_reg</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">irq_stat</span> <span class="o">&amp;</span> <span class="n">irq_mask</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_ops</span> <span class="n">cmd640_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init_dev</span>		<span class="o">=</span> <span class="n">cmd640_init_dev</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED</span>
	<span class="p">.</span><span class="n">set_pio_mode</span>		<span class="o">=</span> <span class="n">cmd640_set_pio_mode</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">test_irq</span>		<span class="o">=</span> <span class="n">cmd640_test_irq</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_conf1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xCFB</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">inl</span><span class="p">(</span><span class="mh">0xCF8</span><span class="p">);</span>
	<span class="n">outl</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="mh">0xCF8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inl</span><span class="p">(</span><span class="mh">0xCF8</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outl</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mh">0xCF8</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mh">0xCF8</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_conf2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xCFB</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xCF8</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xCFA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="mh">0xCF8</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0xCF8</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="n">cmd640_port_info</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">chipset</span>		<span class="o">=</span> <span class="n">ide_cmd640</span><span class="p">,</span>
	<span class="p">.</span><span class="n">host_flags</span>		<span class="o">=</span> <span class="n">IDE_HFLAG_SERIALIZE</span> <span class="o">|</span>
				  <span class="n">IDE_HFLAG_NO_DMA</span> <span class="o">|</span>
				  <span class="n">IDE_HFLAG_ABUSE_PREFETCH</span> <span class="o">|</span>
				  <span class="n">IDE_HFLAG_ABUSE_FAST_DEVSEL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">port_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd640_port_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pio_mask</span>		<span class="o">=</span> <span class="n">ATA_PIO5</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmd640x_init_one</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: I/O resource 0x%lX-0x%lX not free.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">DRV_NAME</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="mi">7</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">ctl</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: I/O resource 0x%lX not free.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">DRV_NAME</span><span class="p">,</span> <span class="n">ctl</span><span class="p">);</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Probe for a cmd640 chipset, and initialize it if found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cmd640x_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">second_port_cmd640</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_type</span><span class="p">,</span> <span class="o">*</span><span class="n">port2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">b</span><span class="p">,</span> <span class="n">cfr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ide_hw</span> <span class="n">hw</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">hws</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd640_vlb</span> <span class="o">&amp;&amp;</span> <span class="n">probe_for_cmd640_vlb</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">bus_type</span> <span class="o">=</span> <span class="s">&quot;VLB&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd640_vlb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Find out what kind of PCI probing is supported otherwise</span>
<span class="cm">		   Justin Gibbs will sulk.. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_conf1</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">probe_for_cmd640_pci1</span><span class="p">())</span>
			<span class="n">bus_type</span> <span class="o">=</span> <span class="s">&quot;PCI (type1)&quot;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pci_conf2</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">probe_for_cmd640_pci2</span><span class="p">())</span>
			<span class="n">bus_type</span> <span class="o">=</span> <span class="s">&quot;PCI (type2)&quot;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Undocumented magic (there is no 0x5b reg in specs)</span>
<span class="cm">	 */</span>
	<span class="n">put_cmd640_reg</span><span class="p">(</span><span class="mh">0x5b</span><span class="p">,</span> <span class="mh">0xbd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_cmd640_reg</span><span class="p">(</span><span class="mh">0x5b</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xbd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ide: cmd640 init failed: wrong value in reg 0x5b</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">put_cmd640_reg</span><span class="p">(</span><span class="mh">0x5b</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef CMD640_DUMP_REGS</span>
	<span class="n">cmd640_dump_regs</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Documented magic begins here</span>
<span class="cm">	 */</span>
	<span class="n">cfr</span> <span class="o">=</span> <span class="n">get_cmd640_reg</span><span class="p">(</span><span class="n">CFR</span><span class="p">);</span>
	<span class="n">cmd640_chip_version</span> <span class="o">=</span> <span class="n">cfr</span> <span class="o">&amp;</span> <span class="n">CFR_DEVREV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd640_chip_version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ide: bad cmd640 revision: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd640_chip_version</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd640x_init_one</span><span class="p">(</span><span class="mh">0x1f0</span><span class="p">,</span> <span class="mh">0x3f6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd640x_init_one</span><span class="p">(</span><span class="mh">0x170</span><span class="p">,</span> <span class="mh">0x376</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">release_region</span><span class="p">(</span><span class="mh">0x3f6</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">release_region</span><span class="p">(</span><span class="mh">0x1f0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="p">));</span>

	<span class="n">ide_std_init_ports</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mh">0x1f0</span><span class="p">,</span> <span class="mh">0x3f6</span><span class="p">);</span>
	<span class="n">hw</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>

	<span class="n">ide_std_init_ports</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mh">0x170</span><span class="p">,</span> <span class="mh">0x376</span><span class="p">);</span>
	<span class="n">hw</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;cmd640: buggy cmd640%c interface on %s, config=0x%02x&quot;</span>
			 <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">cmd640_chip_version</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bus_type</span><span class="p">,</span> <span class="n">cfr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize data for primary port</span>
<span class="cm">	 */</span>
	<span class="n">hws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure compatibility by always using the slowest timings</span>
<span class="cm">	 * for access to the drive&#39;s command register block,</span>
<span class="cm">	 * and reset the prefetch burstsize to default (512 bytes).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Maybe we need a way to NOT do these on *some* systems?</span>
<span class="cm">	 */</span>
	<span class="n">put_cmd640_reg</span><span class="p">(</span><span class="n">CMDTIM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">put_cmd640_reg</span><span class="p">(</span><span class="n">BRST</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">);</span>

	<span class="n">b</span> <span class="o">=</span> <span class="n">get_cmd640_reg</span><span class="p">(</span><span class="n">CNTRL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to enable the secondary interface, if not already enabled</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secondary_port_responding</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">CNTRL_ENA_2ND</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">second_port_cmd640</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">port2</span> <span class="o">=</span> <span class="s">&quot;okay&quot;</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd640_vlb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">second_port_cmd640</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">port2</span> <span class="o">=</span> <span class="s">&quot;alive&quot;</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">port2</span> <span class="o">=</span> <span class="s">&quot;not cmd640&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">put_cmd640_reg</span><span class="p">(</span><span class="n">CNTRL</span><span class="p">,</span> <span class="n">b</span> <span class="o">^</span> <span class="n">CNTRL_ENA_2ND</span><span class="p">);</span> <span class="cm">/* toggle the bit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">secondary_port_responding</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">second_port_cmd640</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">port2</span> <span class="o">=</span> <span class="s">&quot;enabled&quot;</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">put_cmd640_reg</span><span class="p">(</span><span class="n">CNTRL</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="cm">/* restore original setting */</span>
			<span class="n">port2</span> <span class="o">=</span> <span class="s">&quot;not responding&quot;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize data for secondary cmd640 port, if enabled</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">second_port_cmd640</span><span class="p">)</span>
		<span class="n">hws</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;cmd640: %sserialized, secondary interface %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">second_port_cmd640</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;not &quot;</span><span class="p">,</span> <span class="n">port2</span><span class="p">);</span>

<span class="cp">#ifdef CMD640_DUMP_REGS</span>
	<span class="n">cmd640_dump_regs</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">ide_host_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd640_port_info</span><span class="p">,</span> <span class="n">hws</span><span class="p">,</span> <span class="n">second_port_cmd640</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
			    <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">probe_vlb</span><span class="p">,</span> <span class="n">cmd640_vlb</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">probe_vlb</span><span class="p">,</span> <span class="s">&quot;probe for VLB version of CMD640 chipset&quot;</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">cmd640x_init</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
