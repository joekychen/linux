<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › clk › clk.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>clk.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2010-2011 Canonical Ltd &lt;jeremy.kerr@canonical.com&gt;</span>
<span class="cm"> * Copyright (C) 2011-2012 Linaro Ltd &lt;mturquette@linaro.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Standard functionality for the common clock API.  See Documentation/clk.txt</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/clk-private.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">enable_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">prepare_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="n">HLIST_HEAD</span><span class="p">(</span><span class="n">clk_root_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">HLIST_HEAD</span><span class="p">(</span><span class="n">clk_orphan_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">clk_notifier_list</span><span class="p">);</span>

<span class="cm">/***        debugfs support        ***/</span>

<span class="cp">#ifdef CONFIG_COMMON_CLK_DEBUG</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">rootdir</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">orphandir</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">inited</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* caller must hold prepare_lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clk_debug_create_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">pdentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span> <span class="o">||</span> <span class="o">!</span><span class="n">pdentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pdentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">debugfs_create_u32</span><span class="p">(</span><span class="s">&quot;clk_rate&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">debugfs_create_x32</span><span class="p">(</span><span class="s">&quot;clk_flags&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">debugfs_create_u32</span><span class="p">(</span><span class="s">&quot;clk_prepare_count&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">debugfs_create_u32</span><span class="p">(</span><span class="s">&quot;clk_enable_count&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">debugfs_create_u32</span><span class="p">(</span><span class="s">&quot;clk_notifier_count&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">notifier_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* caller must hold prepare_lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clk_debug_create_subtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">pdentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span> <span class="o">||</span> <span class="o">!</span><span class="n">pdentry</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_debug_create_one</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">pdentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span>
		<span class="n">clk_debug_create_subtree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clk_debug_register - add a clk node to the debugfs clk tree</span>
<span class="cm"> * @clk: the clk being added to the debugfs clk tree</span>
<span class="cm"> *</span>
<span class="cm"> * Dynamically adds a clk to the debugfs clk tree if debugfs has been</span>
<span class="cm"> * initialized.  Otherwise it bails out early since the debugfs clk tree</span>
<span class="cm"> * will be created lazily by clk_debug_init as part of a late_initcall.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold prepare_lock.  Only clk_init calls this function (so</span>
<span class="cm"> * far) so this is taken care.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clk_debug_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">pdentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inited</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if a clk is a root clk.  Also check that it is</span>
<span class="cm">	 * safe to add this clk to debugfs</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLK_IS_ROOT</span><span class="p">)</span>
			<span class="n">pdentry</span> <span class="o">=</span> <span class="n">rootdir</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pdentry</span> <span class="o">=</span> <span class="n">orphandir</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)</span>
			<span class="n">pdentry</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_debug_create_subtree</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">pdentry</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clk_debug_init - lazily create the debugfs clk tree visualization</span>
<span class="cm"> *</span>
<span class="cm"> * clks are often initialized very early during boot before memory can</span>
<span class="cm"> * be dynamically allocated and well before debugfs is setup.</span>
<span class="cm"> * clk_debug_init walks the clk tree hierarchy while holding</span>
<span class="cm"> * prepare_lock and creates the topology as part of a late_initcall,</span>
<span class="cm"> * thus insuring that clks initialized very early will still be</span>
<span class="cm"> * represented in the debugfs clk tree.  This function should only be</span>
<span class="cm"> * called once at boot-time, and all other clks added dynamically will</span>
<span class="cm"> * be done so with clk_debug_register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">clk_debug_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">rootdir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;clk&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rootdir</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">orphandir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;orphans&quot;</span><span class="p">,</span> <span class="n">rootdir</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orphandir</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_root_list</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span>
		<span class="n">clk_debug_create_subtree</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">rootdir</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_orphan_list</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span>
		<span class="n">clk_debug_create_subtree</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">orphandir</span><span class="p">);</span>

	<span class="n">inited</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">clk_debug_init</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">clk_debug_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* caller must hold prepare_lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clk_disable_unused_subtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span>
		<span class="n">clk_disable_unused_subtree</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLK_IGNORE_UNUSED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__clk_is_enabled</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

<span class="nl">unlock_out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clk_disable_unused</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_root_list</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span>
		<span class="n">clk_disable_unused_subtree</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_orphan_list</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span>
		<span class="n">clk_disable_unused_subtree</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">clk_disable_unused</span><span class="p">);</span>

<span class="cm">/***    helper functions   ***/</span>

<span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__clk_get_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">clk</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="k">struct</span> <span class="n">clk_hw</span> <span class="o">*</span><span class="nf">__clk_get_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">clk</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">u8</span> <span class="nf">__clk_get_num_parents</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">clk</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="nf">__clk_get_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">clk</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__clk_get_enable_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">clk</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__clk_get_prepare_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">clk</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__clk_get_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLK_IS_ROOT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__clk_get_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">clk</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__clk_is_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * .is_enabled is only mandatory for clocks that gate</span>
<span class="cm">	 * fall back to software usage counter if .is_enabled is missing</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">is_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">is_enabled</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="nf">__clk_lookup_subtree</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">clk</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_lookup_subtree</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="nf">__clk_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">root_clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* search the &#39;proper&#39; clk tree first */</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">root_clk</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_root_list</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_lookup_subtree</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">root_clk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if not found, then search the orphan tree */</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">root_clk</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_orphan_list</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_lookup_subtree</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">root_clk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/***        clk api        ***/</span>

<span class="kt">void</span> <span class="nf">__clk_unprepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">unprepare</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">unprepare</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">__clk_unprepare</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clk_unprepare - undo preparation of a clock source</span>
<span class="cm"> * @clk: the clk being unprepare</span>
<span class="cm"> *</span>
<span class="cm"> * clk_unprepare may sleep, which differentiates it from clk_disable.  In a</span>
<span class="cm"> * simple case, clk_unprepare can be used instead of clk_disable to gate a clk</span>
<span class="cm"> * if the operation may sleep.  One example is a clk which is accessed over</span>
<span class="cm"> * I2c.  In the complex case a clk gate operation may require a fast and a slow</span>
<span class="cm"> * part.  It is this reason that clk_unprepare and clk_disable are not mutually</span>
<span class="cm"> * exclusive.  In fact clk_disable must be called before clk_unprepare.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clk_unprepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>
	<span class="n">__clk_unprepare</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_unprepare</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__clk_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_prepare</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__clk_unprepare</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clk_prepare - prepare a clock source</span>
<span class="cm"> * @clk: the clk being prepared</span>
<span class="cm"> *</span>
<span class="cm"> * clk_prepare may sleep, which differentiates it from clk_enable.  In a simple</span>
<span class="cm"> * case, clk_prepare can be used instead of clk_enable to ungate a clk if the</span>
<span class="cm"> * operation may sleep.  One example is a clk which is accessed over I2c.  In</span>
<span class="cm"> * the complex case a clk ungate operation may require a fast and a slow part.</span>
<span class="cm"> * It is this reason that clk_prepare and clk_enable are not mutually</span>
<span class="cm"> * exclusive.  In fact clk_prepare must be called before clk_enable.</span>
<span class="cm"> * Returns 0 on success, -EERROR otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clk_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_prepare</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_prepare</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__clk_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">__clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clk_disable - gate a clock</span>
<span class="cm"> * @clk: the clk being gated</span>
<span class="cm"> *</span>
<span class="cm"> * clk_disable must not sleep, which differentiates it from clk_unprepare.  In</span>
<span class="cm"> * a simple case, clk_disable can be used instead of clk_unprepare to gate a</span>
<span class="cm"> * clk if the operation is fast and will never sleep.  One example is a</span>
<span class="cm"> * SoC-internal clk which is controlled via simple register writes.  In the</span>
<span class="cm"> * complex case a clk gate operation may require a fast and a slow part.  It is</span>
<span class="cm"> * this reason that clk_unprepare and clk_disable are not mutually exclusive.</span>
<span class="cm"> * In fact clk_disable must be called before clk_unprepare.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clk_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_disable</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__clk_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_enable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clk_enable - ungate a clock</span>
<span class="cm"> * @clk: the clk being ungated</span>
<span class="cm"> *</span>
<span class="cm"> * clk_enable must not sleep, which differentiates it from clk_prepare.  In a</span>
<span class="cm"> * simple case, clk_enable can be used instead of clk_prepare to ungate a clk</span>
<span class="cm"> * if the operation will never sleep.  One example is a SoC-internal clk which</span>
<span class="cm"> * is controlled via simple register writes.  In the complex case a clk ungate</span>
<span class="cm"> * operation may require a fast and a slow part.  It is this reason that</span>
<span class="cm"> * clk_enable and clk_prepare are not mutually exclusive.  In fact clk_prepare</span>
<span class="cm"> * must be called before clk_enable.  Returns 0 on success, -EERROR</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clk_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_enable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_enable</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_get_rate - return the rate of clk</span>
<span class="cm"> * @clk: the clk whose rate is being returned</span>
<span class="cm"> *</span>
<span class="cm"> * Simply returns the cached rate of the clk.  Does not query the hardware.  If</span>
<span class="cm"> * clk is NULL then returns 0.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">clk_get_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>
	<span class="n">rate</span> <span class="o">=</span> <span class="n">__clk_get_rate</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rate</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_get_rate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __clk_round_rate - round the given rate for a clk</span>
<span class="cm"> * @clk: round the rate of this clock</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__clk_round_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">round_rate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLK_SET_RATE_PARENT</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">__clk_round_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">parent_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">round_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_rate</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clk_round_rate - round the given rate for a clk</span>
<span class="cm"> * @clk: the clk for which we are rounding a rate</span>
<span class="cm"> * @rate: the rate which is to be rounded</span>
<span class="cm"> *</span>
<span class="cm"> * Takes in a rate as input and rounds it to a rate that the clk can actually</span>
<span class="cm"> * use which is then returned.  If clk doesn&#39;t support round_rate operation</span>
<span class="cm"> * then the parent rate is returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">clk_round_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_round_rate</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_round_rate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __clk_notify - call clk notifier chain</span>
<span class="cm"> * @clk: struct clk * that is changing rate</span>
<span class="cm"> * @msg: clk notifier type (see include/linux/clk.h)</span>
<span class="cm"> * @old_rate: old clk rate</span>
<span class="cm"> * @new_rate: new clk rate</span>
<span class="cm"> *</span>
<span class="cm"> * Triggers a notifier call chain on the clk rate-change notification</span>
<span class="cm"> * for &#39;clk&#39;.  Passes a pointer to the struct clk and the previous</span>
<span class="cm"> * and current rates to the notifier callback.  Intended to be called by</span>
<span class="cm"> * internal clock code only.  Returns NOTIFY_DONE from the last driver</span>
<span class="cm"> * called if all went well, or NOTIFY_STOP or NOTIFY_BAD immediately if</span>
<span class="cm"> * a driver returns that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__clk_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msg</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_rate</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk_notifier</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk_notifier_data</span> <span class="n">cnd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="n">cnd</span><span class="p">.</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk</span><span class="p">;</span>
	<span class="n">cnd</span><span class="p">.</span><span class="n">old_rate</span> <span class="o">=</span> <span class="n">old_rate</span><span class="p">;</span>
	<span class="n">cnd</span><span class="p">.</span><span class="n">new_rate</span> <span class="o">=</span> <span class="n">new_rate</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_notifier_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">==</span> <span class="n">clk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">srcu_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">notifier_head</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">cnd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __clk_recalc_rates</span>
<span class="cm"> * @clk: first clk in the subtree</span>
<span class="cm"> * @msg: notification type (see include/linux/clk.h)</span>
<span class="cm"> *</span>
<span class="cm"> * Walks the subtree of clks starting with clk and recalculates rates as it</span>
<span class="cm"> * goes.  Note that if a clk does not implement the .recalc_rate callback then</span>
<span class="cm"> * it is assumed that the clock will take on the rate of it&#39;s parent.</span>
<span class="cm"> *</span>
<span class="cm"> * clk_recalc_rates also propagates the POST_RATE_CHANGE notification,</span>
<span class="cm"> * if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold prepare_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__clk_recalc_rates</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

	<span class="n">old_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">parent_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">parent_rate</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">parent_rate</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ignore NOTIFY_STOP and NOTIFY_BAD return values for POST_RATE_CHANGE</span>
<span class="cm">	 * &amp; ABORT_RATE_CHANGE notifiers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">notifier_count</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="n">__clk_notify</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">old_rate</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span>
		<span class="n">__clk_recalc_rates</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __clk_speculate_rates</span>
<span class="cm"> * @clk: first clk in the subtree</span>
<span class="cm"> * @parent_rate: the &quot;future&quot; rate of clk&#39;s parent</span>
<span class="cm"> *</span>
<span class="cm"> * Walks the subtree of clks starting with clk, speculating rates as it</span>
<span class="cm"> * goes and firing off PRE_RATE_CHANGE notifications as necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike clk_recalc_rates, clk_speculate_rates exists only for sending</span>
<span class="cm"> * pre-rate change notifications and returns early if no clks in the</span>
<span class="cm"> * subtree have subscribed to the notifications.  Note that if a clk does not</span>
<span class="cm"> * implement the .recalc_rate callback then it is assumed that the clock will</span>
<span class="cm"> * take on the rate of it&#39;s parent.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold prepare_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__clk_speculate_rates</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_rate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">)</span>
		<span class="n">new_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">parent_rate</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">new_rate</span> <span class="o">=</span> <span class="n">parent_rate</span><span class="p">;</span>

	<span class="cm">/* abort the rate change if a driver returns NOTIFY_BAD */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">notifier_count</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_notify</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">PRE_RATE_CHANGE</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span> <span class="n">new_rate</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NOTIFY_BAD</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_speculate_rates</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">new_rate</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NOTIFY_BAD</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clk_calc_subtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">new_rate</span> <span class="o">=</span> <span class="n">new_rate</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">)</span>
			<span class="n">child</span><span class="o">-&gt;</span><span class="n">new_rate</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">new_rate</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">child</span><span class="o">-&gt;</span><span class="n">new_rate</span> <span class="o">=</span> <span class="n">new_rate</span><span class="p">;</span>
		<span class="n">clk_calc_subtree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">new_rate</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * calculate the new rates returning the topmost clock that has to be</span>
<span class="cm"> * changed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="nf">clk_calc_new_rates</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">top</span> <span class="o">=</span> <span class="n">clk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">best_parent_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_rate</span><span class="p">;</span>

	<span class="cm">/* sanity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">clk</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* save parent rate, if it exists */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">best_parent_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="cm">/* never propagate up to the parent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLK_SET_RATE_PARENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">round_rate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clk</span><span class="o">-&gt;</span><span class="n">new_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">round_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">best_parent_rate</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* need clk-&gt;parent from here on out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: %s has NULL parent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">round_rate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">top</span> <span class="o">=</span> <span class="n">clk_calc_new_rates</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
		<span class="n">new_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">new_rate</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">round_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">best_parent_rate</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">best_parent_rate</span> <span class="o">!=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">top</span> <span class="o">=</span> <span class="n">clk_calc_new_rates</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">best_parent_rate</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">clk_calc_subtree</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">new_rate</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">top</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Notify about rate changes in a subtree. Always walk down the whole tree</span>
<span class="cm"> * so that in case of an error we can walk down the whole tree again and</span>
<span class="cm"> * abort the change.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="nf">clk_propagate_rate_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">fail_clk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">==</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">new_rate</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">notifier_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_notify</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">new_rate</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NOTIFY_BAD</span><span class="p">)</span>
			<span class="n">fail_clk</span> <span class="o">=</span> <span class="n">clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clk</span> <span class="o">=</span> <span class="n">clk_propagate_rate_change</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="p">)</span>
			<span class="n">fail_clk</span> <span class="o">=</span> <span class="n">clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">fail_clk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * walk down a subtree and set the new rates notifying the rate</span>
<span class="cm"> * change on the way</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clk_change_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">best_parent_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">old_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">best_parent_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_rate</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">new_rate</span><span class="p">,</span> <span class="n">best_parent_rate</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">best_parent_rate</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">best_parent_rate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">notifier_count</span> <span class="o">&amp;&amp;</span> <span class="n">old_rate</span> <span class="o">!=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">)</span>
		<span class="n">__clk_notify</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">POST_RATE_CHANGE</span><span class="p">,</span> <span class="n">old_rate</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span>
		<span class="n">clk_change_rate</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clk_set_rate - specify a new rate for clk</span>
<span class="cm"> * @clk: the clk whose rate is being changed</span>
<span class="cm"> * @rate: the new rate for clk</span>
<span class="cm"> *</span>
<span class="cm"> * In the simplest case clk_set_rate will only adjust the rate of clk.</span>
<span class="cm"> *</span>
<span class="cm"> * Setting the CLK_SET_RATE_PARENT flag allows the rate change operation to</span>
<span class="cm"> * propagate up to clk&#39;s parent; whether or not this happens depends on the</span>
<span class="cm"> * outcome of clk&#39;s .round_rate implementation.  If *parent_rate is unchanged</span>
<span class="cm"> * after calling .round_rate then upstream parent propagation is ignored.  If</span>
<span class="cm"> * *parent_rate comes back with a new rate for clk&#39;s parent then we propagate</span>
<span class="cm"> * up to clk&#39;s parent and set it&#39;s rate.  Upward propagation will continue</span>
<span class="cm"> * until either a clk does not support the CLK_SET_RATE_PARENT flag or</span>
<span class="cm"> * .round_rate stops requesting changes to clk&#39;s parent_rate.</span>
<span class="cm"> *</span>
<span class="cm"> * Rate changes are accomplished via tree traversal that also recalculates the</span>
<span class="cm"> * rates for the clocks and fires off POST_RATE_CHANGE notifiers.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -EERROR otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clk_set_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">top</span><span class="p">,</span> <span class="o">*</span><span class="n">fail_clk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* prevent racing with updates to the clock topology */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="cm">/* bail early if nothing to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rate</span> <span class="o">==</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLK_SET_RATE_GATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* calculate new rates and get the topmost changed clock */</span>
	<span class="n">top</span> <span class="o">=</span> <span class="n">clk_calc_new_rates</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* notify that we are about to change rates */</span>
	<span class="n">fail_clk</span> <span class="o">=</span> <span class="n">clk_propagate_rate_change</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">PRE_RATE_CHANGE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fail_clk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: failed to set %s rate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">fail_clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">clk_propagate_rate_change</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">ABORT_RATE_CHANGE</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* change the rates */</span>
	<span class="n">clk_change_rate</span><span class="p">(</span><span class="n">top</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_set_rate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_get_parent - return the parent of a clk</span>
<span class="cm"> * @clk: the clk whose parent gets returned</span>
<span class="cm"> *</span>
<span class="cm"> * Simply returns clk-&gt;parent.  Returns NULL if clk is NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="nf">clk_get_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">__clk_get_parent</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_get_parent</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * .get_parent is mandatory for clocks with multiple possible parents.  It is</span>
<span class="cm"> * optional for single-parent clocks.  Always call .get_parent if it is</span>
<span class="cm"> * available and WARN if it is missing for multi-parent clocks.</span>
<span class="cm"> *</span>
<span class="cm"> * For single-parent clocks without .get_parent, first check to see if the</span>
<span class="cm"> * .parents array exists, and if so use it to avoid an expensive tree</span>
<span class="cm"> * traversal.  If .parents does not exist then walk the tree with __clk_lookup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="nf">__clk_init_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* handle the trivial cases */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">__clk_lookup</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_parent</span><span class="p">,</span>
			<span class="s">&quot;%s: multi-parent clocks must implement .get_parent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do our best to cache parent clocks in clk-&gt;parents.  This prevents</span>
<span class="cm">	 * unnecessary and expensive calls to __clk_lookup.  We don&#39;t set</span>
<span class="cm">	 * clk-&gt;parent here; that is done by the calling function</span>
<span class="cm">	 */</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_parent</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_lookup</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">__clk_lookup</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__clk_reparent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">new_parent</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_COMMON_CLK_DEBUG</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_parent_d</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span> <span class="o">||</span> <span class="o">!</span><span class="n">new_parent</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">child_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_parent</span><span class="p">)</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">child_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">child_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_orphan_list</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMMON_CLK_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inited</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_parent</span><span class="p">)</span>
		<span class="n">new_parent_d</span> <span class="o">=</span> <span class="n">new_parent</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">new_parent_d</span> <span class="o">=</span> <span class="n">orphandir</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">debugfs_rename</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span>
			<span class="n">new_parent_d</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: failed to rename debugfs entry for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="nl">out:</span>
<span class="cp">#endif</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">new_parent</span><span class="p">;</span>

	<span class="n">__clk_recalc_rates</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">POST_RATE_CHANGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__clk_set_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">old_parent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">old_parent</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">),</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * find index of new parent clock using cached parent ptrs,</span>
<span class="cm">	 * or if not yet cached, use string name comparison and cache</span>
<span class="cm">	 * them now to avoid future calls to __clk_lookup.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span> <span class="o">&amp;&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">parent</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">)</span>
				<span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">__clk_lookup</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: clock %s is not a possible parent of clock %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* migrate prepare and enable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span><span class="p">)</span>
		<span class="n">__clk_prepare</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="cm">/* FIXME replace with clk_is_enabled(clk) someday */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span><span class="p">)</span>
		<span class="n">__clk_enable</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* change clock input source */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_parent</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* clean up old prepare and enable */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_count</span><span class="p">)</span>
		<span class="n">__clk_disable</span><span class="p">(</span><span class="n">old_parent</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span><span class="p">)</span>
		<span class="n">__clk_unprepare</span><span class="p">(</span><span class="n">old_parent</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clk_set_parent - switch the parent of a mux clk</span>
<span class="cm"> * @clk: the mux clk whose input we are switching</span>
<span class="cm"> * @parent: the new input to clk</span>
<span class="cm"> *</span>
<span class="cm"> * Re-parent clk to use parent as it&#39;s new input source.  If clk has the</span>
<span class="cm"> * CLK_SET_PARENT_GATE flag set then clk must be gated for this</span>
<span class="cm"> * operation to succeed.  After successfully changing clk&#39;s parent</span>
<span class="cm"> * clk_set_parent will update the clk topology, sysfs topology and</span>
<span class="cm"> * propagate rate recalculation via __clk_recalc_rates.  Returns 0 on</span>
<span class="cm"> * success, -EERROR otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clk_set_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span> <span class="o">||</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="cm">/* prevent racing with updates to the clock topology */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">parent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* propagate PRE_RATE_CHANGE notifications */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">notifier_count</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_speculate_rates</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>

	<span class="cm">/* abort if a driver objects */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* only re-parent if the clock is not in use */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLK_SET_PARENT_GATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">prepare_count</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_set_parent</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

	<span class="cm">/* propagate ABORT_RATE_CHANGE if .set_parent failed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__clk_recalc_rates</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">ABORT_RATE_CHANGE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* propagate rate recalculation downstream */</span>
	<span class="n">__clk_reparent</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_set_parent</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __clk_init - initialize the data structures in a struct clk</span>
<span class="cm"> * @dev:	device initializing this clk, placeholder for now</span>
<span class="cm"> * @clk:	clk being initialized</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes the lists in struct clk, queries the hardware for the</span>
<span class="cm"> * parent and rate and sets them both.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__clk_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">orphan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="cm">/* check to see if a clock with this name is already registered */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__clk_lookup</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: clk %s already initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check that clk_ops are sane.  See Documentation/clk.txt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_rate</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">round_rate</span> <span class="o">&amp;&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: %s must implement .round_rate &amp; .recalc_rate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_parent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: %s must implement .get_parent &amp; .set_parent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* throw a WARN if any entries in parent_names are NULL */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="s">&quot;%s: invalid NULL in %s&#39;s .parent_names</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate an array of struct clk *&#39;s to avoid unnecessary string</span>
<span class="cm">	 * look-ups of clk&#39;s possible parents.  This can fail for clocks passed</span>
<span class="cm">	 * in to clk_init during early boot; thus any access to clk-&gt;parents[]</span>
<span class="cm">	 * must always check for a NULL pointer and try to populate it if</span>
<span class="cm">	 * necessary.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If clk-&gt;parents is not NULL we skip this entire block.  This allows</span>
<span class="cm">	 * for clock drivers to statically initialize clk-&gt;parents.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * __clk_lookup returns NULL for parents that have not been</span>
<span class="cm">		 * clk_init&#39;d; thus any access to clk-&gt;parents[] must check</span>
<span class="cm">		 * for a NULL pointer.  We can always perform lazy lookups for</span>
<span class="cm">		 * missing parents later on.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">clk</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">__clk_lookup</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">__clk_init_parent</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Populate clk-&gt;parent if parent has already been __clk_init&#39;d.  If</span>
<span class="cm">	 * parent has not yet been __clk_init&#39;d then place clk in the orphan</span>
<span class="cm">	 * list.  If clk has set the CLK_IS_ROOT flag then place it in the root</span>
<span class="cm">	 * clk list.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Every time a new clk is clk_init&#39;d then we walk the list of orphan</span>
<span class="cm">	 * clocks and re-parent any that are children of the clock currently</span>
<span class="cm">	 * being clk_init&#39;d.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">child_node</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLK_IS_ROOT</span><span class="p">)</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">child_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_root_list</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">child_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_orphan_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set clk&#39;s rate.  The preferred method is to use .recalc_rate.  For</span>
<span class="cm">	 * simple clocks and lazy developers the default fallback is to use the</span>
<span class="cm">	 * parent&#39;s rate.  If a clock doesn&#39;t have a parent (or is orphaned)</span>
<span class="cm">	 * then rate is set to zero.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recalc_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span>
				<span class="n">__clk_get_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * walk the list of orphan clocks and reparent any that are children of</span>
<span class="cm">	 * this clock</span>
<span class="cm">	 */</span>
	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">orphan</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_orphan_list</span><span class="p">,</span> <span class="n">child_node</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">orphan</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">orphan</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">__clk_reparent</span><span class="p">(</span><span class="n">orphan</span><span class="p">,</span> <span class="n">clk</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * optional platform-specific magic</span>
<span class="cm">	 *</span>
<span class="cm">	 * The .init callback is not used by any of the basic clock types, but</span>
<span class="cm">	 * exists for weird hardware that must perform initialization magic.</span>
<span class="cm">	 * Please consider other ways of solving initialization problems before</span>
<span class="cm">	 * using this callback, as it&#39;s use is discouraged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">clk_debug_register</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __clk_register - register a clock and return a cookie.</span>
<span class="cm"> *</span>
<span class="cm"> * Same as clk_register, except that the .clk field inside hw shall point to a</span>
<span class="cm"> * preallocated (generally statically allocated) struct clk. None of the fields</span>
<span class="cm"> * of the struct clk need to be initialized.</span>
<span class="cm"> *</span>
<span class="cm"> * The data pointed to by .init and .clk field shall NOT be marked as init</span>
<span class="cm"> * data.</span>
<span class="cm"> *</span>
<span class="cm"> * __clk_register is only exposed via clk-private.h and is intended for use with</span>
<span class="cm"> * very large numbers of clocks that need to be statically initialized.  It is</span>
<span class="cm"> * a layering violation to include clk-private.h from any code which implements</span>
<span class="cm"> * a clock&#39;s .ops; as such any statically initialized clock data MUST be in a</span>
<span class="cm"> * separate C file from the logic that implements it&#39;s operations.  Returns 0</span>
<span class="cm"> * on success, otherwise an error code.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="nf">__clk_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>

	<span class="n">clk</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">;</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="n">hw</span><span class="p">;</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">;</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">clk</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__clk_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_register - allocate a new clock, register it and return an opaque cookie</span>
<span class="cm"> * @dev: device that is registering this clock</span>
<span class="cm"> * @hw: link to hardware-specific clock data</span>
<span class="cm"> *</span>
<span class="cm"> * clk_register is the primary interface for populating the clock tree with new</span>
<span class="cm"> * clock nodes.  It returns a pointer to the newly allocated struct clk which</span>
<span class="cm"> * cannot be dereferenced by driver code but may be used in conjuction with the</span>
<span class="cm"> * rest of the clock API.  In the event of an error clk_register will return an</span>
<span class="cm"> * error code; drivers must test for an error code after calling clk_register.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="nf">clk_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>

	<span class="n">clk</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">clk</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: could not allocate clk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: could not allocate clk-&gt;name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_name</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="n">hw</span><span class="p">;</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk</span><span class="p">;</span>

	<span class="cm">/* allocate local copy in case parent_names is __initdata */</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: could not allocate clk-&gt;parent_names</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_parent_names</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* copy each string name in case parent_names is __initdata */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: could not copy parent_names</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail_parent_names_copy</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__clk_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">clk</span><span class="p">;</span>

<span class="nl">fail_parent_names_copy:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent_names</span><span class="p">);</span>
<span class="nl">fail_parent_names:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="nl">fail_name:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
<span class="nl">fail_out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_unregister - unregister a currently registered clock</span>
<span class="cm"> * @clk: clock to unregister</span>
<span class="cm"> *</span>
<span class="cm"> * Currently unimplemented.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clk_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span> <span class="p">{}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_unregister</span><span class="p">);</span>

<span class="cm">/***        clk rate change notifiers        ***/</span>

<span class="cm">/**</span>
<span class="cm"> * clk_notifier_register - add a clk rate change notifier</span>
<span class="cm"> * @clk: struct clk * to watch</span>
<span class="cm"> * @nb: struct notifier_block * with callback info</span>
<span class="cm"> *</span>
<span class="cm"> * Request notification when clk&#39;s rate changes.  This uses an SRCU</span>
<span class="cm"> * notifier because we want it to block and notifier unregistrations are</span>
<span class="cm"> * uncommon.  The callbacks associated with the notifier must not</span>
<span class="cm"> * re-enter into the clk framework by calling any top-level clk APIs;</span>
<span class="cm"> * this will cause a nested prepare_lock mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * Pre-change notifier callbacks will be passed the current, pre-change</span>
<span class="cm"> * rate of the clk via struct clk_notifier_data.old_rate.  The new,</span>
<span class="cm"> * post-change rate of the clk is passed via struct</span>
<span class="cm"> * clk_notifier_data.new_rate.</span>
<span class="cm"> *</span>
<span class="cm"> * Post-change notifiers will pass the now-current, post-change rate of</span>
<span class="cm"> * the clk in both struct clk_notifier_data.old_rate and struct</span>
<span class="cm"> * clk_notifier_data.new_rate.</span>
<span class="cm"> *</span>
<span class="cm"> * Abort-change notifiers are effectively the opposite of pre-change</span>
<span class="cm"> * notifiers: the original pre-change clk rate is passed in via struct</span>
<span class="cm"> * clk_notifier_data.new_rate and the failed post-change rate is passed</span>
<span class="cm"> * in via struct clk_notifier_data.old_rate.</span>
<span class="cm"> *</span>
<span class="cm"> * clk_notifier_register() must be called from non-atomic context.</span>
<span class="cm"> * Returns -EINVAL if called with null arguments, -ENOMEM upon</span>
<span class="cm"> * allocation failure; otherwise, passes along the return value of</span>
<span class="cm"> * srcu_notifier_chain_register().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clk_notifier_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk_notifier</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span> <span class="o">||</span> <span class="o">!</span><span class="n">nb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="cm">/* search the list of notifiers for this clk */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_notifier_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">==</span> <span class="n">clk</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* if clk wasn&#39;t in the notifier list, allocate new clk_notifier */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">!=</span> <span class="n">clk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk_notifier</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">cn</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk</span><span class="p">;</span>
		<span class="n">srcu_init_notifier_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">notifier_head</span><span class="p">);</span>

		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_notifier_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">srcu_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">notifier_head</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">notifier_count</span><span class="o">++</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_notifier_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_notifier_unregister - remove a clk rate change notifier</span>
<span class="cm"> * @clk: struct clk *</span>
<span class="cm"> * @nb: struct notifier_block * with callback info</span>
<span class="cm"> *</span>
<span class="cm"> * Request no further notification for changes to &#39;clk&#39; and frees memory</span>
<span class="cm"> * allocated in clk_notifier_register.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EINVAL if called with null arguments; otherwise, passes</span>
<span class="cm"> * along the return value of srcu_notifier_chain_unregister().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clk_notifier_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk_notifier</span> <span class="o">*</span><span class="n">cn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span> <span class="o">||</span> <span class="o">!</span><span class="n">nb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_notifier_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">==</span> <span class="n">clk</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">==</span> <span class="n">clk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">srcu_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">notifier_head</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>

		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">notifier_count</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* XXX the notifier code should handle this better */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">notifier_head</span><span class="p">.</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">srcu_cleanup_notifier_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">notifier_head</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">cn</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prepare_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clk_notifier_unregister</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
