<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › cpufreq › gx-suspmod.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>gx-suspmod.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Cyrix MediaGX and NatSemi Geode Suspend Modulation</span>
<span class="cm"> *	(C) 2002 Zwane Mwaikambo &lt;zwane@commfireservices.com&gt;</span>
<span class="cm"> *	(C) 2002 Hiroshi Miura   &lt;miura@da-cha.org&gt;</span>
<span class="cm"> *	All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of the GNU General Public License</span>
<span class="cm"> *      version 2 as published by the Free Software Foundation</span>
<span class="cm"> *</span>
<span class="cm"> *      The author(s) of this software shall not be held liable for damages</span>
<span class="cm"> *      of any nature resulting due to the use of this software. This</span>
<span class="cm"> *      software is provided AS-IS with no warranties.</span>
<span class="cm"> *</span>
<span class="cm"> * Theoretical note:</span>
<span class="cm"> *</span>
<span class="cm"> *	(see Geode(tm) CS5530 manual (rev.4.1) page.56)</span>
<span class="cm"> *</span>
<span class="cm"> *	CPU frequency control on NatSemi Geode GX1/GXLV processor and CS55x0</span>
<span class="cm"> *	are based on Suspend Modulation.</span>
<span class="cm"> *</span>
<span class="cm"> *	Suspend Modulation works by asserting and de-asserting the SUSP# pin</span>
<span class="cm"> *	to CPU(GX1/GXLV) for configurable durations. When asserting SUSP#</span>
<span class="cm"> *	the CPU enters an idle state. GX1 stops its core clock when SUSP# is</span>
<span class="cm"> *	asserted then power consumption is reduced.</span>
<span class="cm"> *</span>
<span class="cm"> *	Suspend Modulation&#39;s OFF/ON duration are configurable</span>
<span class="cm"> *	with &#39;Suspend Modulation OFF Count Register&#39;</span>
<span class="cm"> *	and &#39;Suspend Modulation ON Count Register&#39;.</span>
<span class="cm"> *	These registers are 8bit counters that represent the number of</span>
<span class="cm"> *	32us intervals which the SUSP# pin is asserted(ON)/de-asserted(OFF)</span>
<span class="cm"> *	to the processor.</span>
<span class="cm"> *</span>
<span class="cm"> *	These counters define a ratio which is the effective frequency</span>
<span class="cm"> *	of operation of the system.</span>
<span class="cm"> *</span>
<span class="cm"> *			       OFF Count</span>
<span class="cm"> *	F_eff = Fgx * ----------------------</span>
<span class="cm"> *	                OFF Count + ON Count</span>
<span class="cm"> *</span>
<span class="cm"> *	0 &lt;= On Count, Off Count &lt;= 255</span>
<span class="cm"> *</span>
<span class="cm"> *	From these limits, we can get register values</span>
<span class="cm"> *</span>
<span class="cm"> *	off_duration + on_duration &lt;= MAX_DURATION</span>
<span class="cm"> *	on_duration = off_duration * (stock_freq - freq) / freq</span>
<span class="cm"> *</span>
<span class="cm"> *      off_duration  =  (freq * DURATION) / stock_freq</span>
<span class="cm"> *      on_duration = DURATION - off_duration</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *---------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * ChangeLog:</span>
<span class="cm"> *	Dec. 12, 2003	Hiroshi Miura &lt;miura@da-cha.org&gt;</span>
<span class="cm"> *		- fix on/off register mistake</span>
<span class="cm"> *		- fix cpu_khz calc when it stops cpu modulation.</span>
<span class="cm"> *</span>
<span class="cm"> *	Dec. 11, 2002	Hiroshi Miura &lt;miura@da-cha.org&gt;</span>
<span class="cm"> *		- rewrite for Cyrix MediaGX Cx5510/5520 and</span>
<span class="cm"> *		  NatSemi Geode Cs5530(A).</span>
<span class="cm"> *</span>
<span class="cm"> *	Jul. ??, 2002  Zwane Mwaikambo &lt;zwane@commfireservices.com&gt;</span>
<span class="cm"> *		- cs5530_mod patch for 2.4.19-rc1.</span>
<span class="cm"> *</span>
<span class="cm"> *---------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * Todo</span>
<span class="cm"> *	Test on machines with 5510, 5530, 5530A</span>
<span class="cm"> */</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *			Suspend Modulation - Definitions		*</span>
<span class="cm"> ************************************************************************/</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/cpufreq.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/cpu_device_id.h&gt;</span>
<span class="cp">#include &lt;asm/processor-cyrix.h&gt;</span>

<span class="cm">/* PCI config registers, all at F0 */</span>
<span class="cp">#define PCI_PMER1	0x80	</span><span class="cm">/* power management enable register 1 */</span><span class="cp"></span>
<span class="cp">#define PCI_PMER2	0x81	</span><span class="cm">/* power management enable register 2 */</span><span class="cp"></span>
<span class="cp">#define PCI_PMER3	0x82	</span><span class="cm">/* power management enable register 3 */</span><span class="cp"></span>
<span class="cp">#define PCI_IRQTC	0x8c	</span><span class="cm">/* irq speedup timer counter register:typical 2 to 4ms */</span><span class="cp"></span>
<span class="cp">#define PCI_VIDTC	0x8d	</span><span class="cm">/* video speedup timer counter register: typical 50 to 100ms */</span><span class="cp"></span>
<span class="cp">#define PCI_MODOFF	0x94	</span><span class="cm">/* suspend modulation OFF counter register, 1 = 32us */</span><span class="cp"></span>
<span class="cp">#define PCI_MODON	0x95	</span><span class="cm">/* suspend modulation ON counter register */</span><span class="cp"></span>
<span class="cp">#define PCI_SUSCFG	0x96	</span><span class="cm">/* suspend configuration register */</span><span class="cp"></span>

<span class="cm">/* PMER1 bits */</span>
<span class="cp">#define GPM		(1&lt;&lt;0)	</span><span class="cm">/* global power management */</span><span class="cp"></span>
<span class="cp">#define GIT		(1&lt;&lt;1)	</span><span class="cm">/* globally enable PM device idle timers */</span><span class="cp"></span>
<span class="cp">#define GTR		(1&lt;&lt;2)	</span><span class="cm">/* globally enable IO traps */</span><span class="cp"></span>
<span class="cp">#define IRQ_SPDUP	(1&lt;&lt;3)	</span><span class="cm">/* disable clock throttle during interrupt handling */</span><span class="cp"></span>
<span class="cp">#define VID_SPDUP	(1&lt;&lt;4)	</span><span class="cm">/* disable clock throttle during vga video handling */</span><span class="cp"></span>

<span class="cm">/* SUSCFG bits */</span>
<span class="cp">#define SUSMOD		(1&lt;&lt;0)	</span><span class="cm">/* enable/disable suspend modulation */</span><span class="cp"></span>
<span class="cm">/* the below is supported only with cs5530 (after rev.1.2)/cs5530A */</span>
<span class="cp">#define SMISPDUP	(1&lt;&lt;1)	</span><span class="cm">/* select how SMI re-enable suspend modulation: */</span><span class="cp"></span>
				<span class="cm">/* IRQTC timer or read SMI speedup disable reg.(F1BAR[08-09h]) */</span>
<span class="cp">#define SUSCFG		(1&lt;&lt;2)	</span><span class="cm">/* enable powering down a GXLV processor. &quot;Special 3Volt Suspend&quot; mode */</span><span class="cp"></span>
<span class="cm">/* the below is supported only with cs5530A */</span>
<span class="cp">#define PWRSVE_ISA	(1&lt;&lt;3)	</span><span class="cm">/* stop ISA clock  */</span><span class="cp"></span>
<span class="cp">#define PWRSVE		(1&lt;&lt;4)	</span><span class="cm">/* active idle */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">gxfreq_params</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">on_duration</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">off_duration</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pci_suscfg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pci_pmer1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pci_pmer2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">cs55x0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">gxfreq_params</span> <span class="o">*</span><span class="n">gx_params</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">stock_freq</span><span class="p">;</span>

<span class="cm">/* PCI bus clock - defaults to 30.000 if cpu_khz is not available */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci_busclk</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">pci_busclk</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>

<span class="cm">/* maximum duration for which the cpu may be suspended</span>
<span class="cm"> * (32us * MAX_DURATION). If no parameter is given, this defaults</span>
<span class="cm"> * to 255.</span>
<span class="cm"> * Note that this leads to a maximum of 8 ms(!) where the CPU clock</span>
<span class="cm"> * is suspended -- processing power is just 0.39% of what it used to be,</span>
<span class="cm"> * though. 781.25 kHz(!) for a 200 MHz processor -- wow. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_duration</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_duration</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>

<span class="cm">/* For the default policy, we want at least some processing power</span>
<span class="cm"> * - let&#39;s say 5%. (min = maxfreq / POLICY_MIN_DIV)</span>
<span class="cm"> */</span>
<span class="cp">#define POLICY_MIN_DIV 20</span>


<span class="cm">/**</span>
<span class="cm"> * we can detect a core multipiler from dir0_lsb</span>
<span class="cm"> * from GX1 datasheet p.56,</span>
<span class="cm"> *	MULT[3:0]:</span>
<span class="cm"> *	0000 = SYSCLK multiplied by 4 (test only)</span>
<span class="cm"> *	0001 = SYSCLK multiplied by 10</span>
<span class="cm"> *	0010 = SYSCLK multiplied by 4</span>
<span class="cm"> *	0011 = SYSCLK multiplied by 6</span>
<span class="cm"> *	0100 = SYSCLK multiplied by 9</span>
<span class="cm"> *	0101 = SYSCLK multiplied by 5</span>
<span class="cm"> *	0110 = SYSCLK multiplied by 7</span>
<span class="cm"> *	0111 = SYSCLK multiplied by 8</span>
<span class="cm"> *              of 33.3MHz</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gx_freq_mult</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>


<span class="cm">/****************************************************************</span>
<span class="cm"> *	Low Level chipset interface				*</span>
<span class="cm"> ****************************************************************/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">gx_chipset_tbl</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">CYRIX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_CYRIX_5530_LEGACY</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">CYRIX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_CYRIX_5520</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">CYRIX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_CYRIX_5510</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">gx_chipset_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gx_write_byte</span><span class="p">(</span><span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">cs55x0</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gx_detect_chipset:</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">__init</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="nf">gx_detect_chipset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">gx_pci</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* detect which companion chip is used */</span>
	<span class="n">for_each_pci_dev</span><span class="p">(</span><span class="n">gx_pci</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pci_match_id</span><span class="p">(</span><span class="n">gx_chipset_tbl</span><span class="p">,</span> <span class="n">gx_pci</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">gx_pci</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;error: no supported chipset found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gx_get_cpuspeed:</span>
<span class="cm"> *</span>
<span class="cm"> * Finds out at which efficient frequency the Cyrix MediaGX/NatSemi</span>
<span class="cm"> * Geode CPU runs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">gx_get_cpuspeed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">pci_suscfg</span> <span class="o">&amp;</span> <span class="n">SUSMOD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">stock_freq</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">stock_freq</span> <span class="o">*</span> <span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">off_duration</span><span class="p">)</span>
		<span class="o">/</span> <span class="p">(</span><span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">on_duration</span> <span class="o">+</span> <span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">off_duration</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      gx_validate_speed:</span>
<span class="cm"> *      determine current cpu speed</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">gx_validate_speed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">khz</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">on_duration</span><span class="p">,</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">off_duration</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tmp_on</span><span class="p">,</span> <span class="n">tmp_off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_tmp_freq</span> <span class="o">=</span> <span class="n">stock_freq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp_freq</span><span class="p">;</span>

	<span class="o">*</span><span class="n">off_duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">on_duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">max_duration</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp_off</span> <span class="o">=</span> <span class="p">((</span><span class="n">khz</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">stock_freq</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tmp_on</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">tmp_off</span><span class="p">;</span>
		<span class="n">tmp_freq</span> <span class="o">=</span> <span class="p">(</span><span class="n">stock_freq</span> <span class="o">*</span> <span class="n">tmp_off</span><span class="p">)</span> <span class="o">/</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/* if this relation is closer to khz, use this. If it&#39;s equal,</span>
<span class="cm">		 * prefer it, too - lower latency */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp_freq</span> <span class="o">-</span> <span class="n">khz</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">abs</span><span class="p">(</span><span class="n">old_tmp_freq</span> <span class="o">-</span> <span class="n">khz</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">on_duration</span> <span class="o">=</span> <span class="n">tmp_on</span><span class="p">;</span>
			<span class="o">*</span><span class="n">off_duration</span> <span class="o">=</span> <span class="n">tmp_off</span><span class="p">;</span>
			<span class="n">old_tmp_freq</span> <span class="o">=</span> <span class="n">tmp_freq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">old_tmp_freq</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * gx_set_cpuspeed:</span>
<span class="cm"> * set cpu speed in khz.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gx_set_cpuspeed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">khz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">suscfg</span><span class="p">,</span> <span class="n">pmer1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_khz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpufreq_freqs</span> <span class="n">freqs</span><span class="p">;</span>

	<span class="n">freqs</span><span class="p">.</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">freqs</span><span class="p">.</span><span class="n">old</span> <span class="o">=</span> <span class="n">gx_get_cpuspeed</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">new_khz</span> <span class="o">=</span> <span class="n">gx_validate_speed</span><span class="p">(</span><span class="n">khz</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">on_duration</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">off_duration</span><span class="p">);</span>

	<span class="n">freqs</span><span class="p">.</span><span class="n">new</span> <span class="o">=</span> <span class="n">new_khz</span><span class="p">;</span>

	<span class="n">cpufreq_notify_transition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freqs</span><span class="p">,</span> <span class="n">CPUFREQ_PRECHANGE</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>



	<span class="k">if</span> <span class="p">(</span><span class="n">new_khz</span> <span class="o">!=</span> <span class="n">stock_freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if new khz == 100% of CPU speed, it is special case */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">cs55x0</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PCI_DEVICE_ID_CYRIX_5530_LEGACY</span>:
			<span class="n">pmer1</span> <span class="o">=</span> <span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">pci_pmer1</span> <span class="o">|</span> <span class="n">IRQ_SPDUP</span> <span class="o">|</span> <span class="n">VID_SPDUP</span><span class="p">;</span>
			<span class="cm">/* FIXME: need to test other values -- Zwane,Miura */</span>
			<span class="cm">/* typical 2 to 4ms */</span>
			<span class="n">gx_write_byte</span><span class="p">(</span><span class="n">PCI_IRQTC</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
			<span class="cm">/* typical 50 to 100ms */</span>
			<span class="n">gx_write_byte</span><span class="p">(</span><span class="n">PCI_VIDTC</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
			<span class="n">gx_write_byte</span><span class="p">(</span><span class="n">PCI_PMER1</span><span class="p">,</span> <span class="n">pmer1</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">cs55x0</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* CS5530(rev 1.2, 1.3) */</span>
				<span class="n">suscfg</span> <span class="o">=</span> <span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">pci_suscfg</span><span class="o">|</span><span class="n">SUSMOD</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* CS5530A,B.. */</span>
				<span class="n">suscfg</span> <span class="o">=</span> <span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">pci_suscfg</span><span class="o">|</span><span class="n">SUSMOD</span><span class="o">|</span><span class="n">PWRSVE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PCI_DEVICE_ID_CYRIX_5520</span>:
		<span class="k">case</span> <span class="n">PCI_DEVICE_ID_CYRIX_5510</span>:
			<span class="n">suscfg</span> <span class="o">=</span> <span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">pci_suscfg</span> <span class="o">|</span> <span class="n">SUSMOD</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;fatal: try to set unknown chipset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">suscfg</span> <span class="o">=</span> <span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">pci_suscfg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SUSMOD</span><span class="p">);</span>
		<span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">off_duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">on_duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;suspend modulation disabled: cpu runs 100%% speed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">gx_write_byte</span><span class="p">(</span><span class="n">PCI_MODOFF</span><span class="p">,</span> <span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">off_duration</span><span class="p">);</span>
	<span class="n">gx_write_byte</span><span class="p">(</span><span class="n">PCI_MODON</span><span class="p">,</span> <span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">on_duration</span><span class="p">);</span>

	<span class="n">gx_write_byte</span><span class="p">(</span><span class="n">PCI_SUSCFG</span><span class="p">,</span> <span class="n">suscfg</span><span class="p">);</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">cs55x0</span><span class="p">,</span> <span class="n">PCI_SUSCFG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">suscfg</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">pci_suscfg</span> <span class="o">=</span> <span class="n">suscfg</span><span class="p">;</span>

	<span class="n">cpufreq_notify_transition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freqs</span><span class="p">,</span> <span class="n">CPUFREQ_POSTCHANGE</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;suspend modulation w/ duration of ON:%d us, OFF:%d us</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">on_duration</span> <span class="o">*</span> <span class="mi">32</span><span class="p">,</span> <span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">off_duration</span> <span class="o">*</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;suspend modulation w/ clock speed: %d kHz.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">freqs</span><span class="p">.</span><span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****************************************************************</span>
<span class="cm"> *             High level functions                             *</span>
<span class="cm"> ****************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> *	cpufreq_gx_verify: test if frequency range is valid</span>
<span class="cm"> *</span>
<span class="cm"> *	This function checks if a given frequency range in kHz is valid</span>
<span class="cm"> *      for the hardware supported by the driver.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpufreq_gx_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpufreq_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp_freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stock_freq</span> <span class="o">||</span> <span class="o">!</span><span class="n">policy</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpufreq_verify_within_limits</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="p">(</span><span class="n">stock_freq</span> <span class="o">/</span> <span class="n">max_duration</span><span class="p">),</span>
			<span class="n">stock_freq</span><span class="p">);</span>

	<span class="cm">/* it needs to be assured that at least one supported frequency is</span>
<span class="cm">	 * within policy-&gt;min and policy-&gt;max. If it is not, policy-&gt;max</span>
<span class="cm">	 * needs to be increased until one freuqency is supported.</span>
<span class="cm">	 * policy-&gt;min may not be decreased, though. This way we guarantee a</span>
<span class="cm">	 * specific processing capacity.</span>
<span class="cm">	 */</span>
	<span class="n">tmp_freq</span> <span class="o">=</span> <span class="n">gx_validate_speed</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp_freq</span> <span class="o">&lt;</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">)</span>
		<span class="n">tmp_freq</span> <span class="o">+=</span> <span class="n">stock_freq</span> <span class="o">/</span> <span class="n">max_duration</span><span class="p">;</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">tmp_freq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">&gt;</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span>
		<span class="n">policy</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">tmp_freq</span><span class="p">;</span>
	<span class="n">tmp_freq</span> <span class="o">=</span> <span class="n">gx_validate_speed</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp_freq</span> <span class="o">&gt;</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span>
		<span class="n">tmp_freq</span> <span class="o">-=</span> <span class="n">stock_freq</span> <span class="o">/</span> <span class="n">max_duration</span><span class="p">;</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">tmp_freq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">)</span>
		<span class="n">policy</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">;</span>
	<span class="n">cpufreq_verify_within_limits</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="p">(</span><span class="n">stock_freq</span> <span class="o">/</span> <span class="n">max_duration</span><span class="p">),</span>
			<span class="n">stock_freq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *      cpufreq_gx_target:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpufreq_gx_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpufreq_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target_freq</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">relation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp_freq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stock_freq</span> <span class="o">||</span> <span class="o">!</span><span class="n">policy</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tmp_freq</span> <span class="o">=</span> <span class="n">gx_validate_speed</span><span class="p">(</span><span class="n">target_freq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp2</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tmp_freq</span> <span class="o">&lt;</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp_freq</span> <span class="o">+=</span> <span class="n">stock_freq</span> <span class="o">/</span> <span class="n">max_duration</span><span class="p">;</span>
		<span class="n">tmp_freq</span> <span class="o">=</span> <span class="n">gx_validate_speed</span><span class="p">(</span><span class="n">tmp_freq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tmp_freq</span> <span class="o">&gt;</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp_freq</span> <span class="o">-=</span> <span class="n">stock_freq</span> <span class="o">/</span> <span class="n">max_duration</span><span class="p">;</span>
		<span class="n">tmp_freq</span> <span class="o">=</span> <span class="n">gx_validate_speed</span><span class="p">(</span><span class="n">tmp_freq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">gx_set_cpuspeed</span><span class="p">(</span><span class="n">tmp_freq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpufreq_gx_cpu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpufreq_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxfreq</span><span class="p">,</span> <span class="n">curfreq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policy</span> <span class="o">||</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* determine maximum frequency */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_busclk</span><span class="p">)</span>
		<span class="n">maxfreq</span> <span class="o">=</span> <span class="n">pci_busclk</span> <span class="o">*</span> <span class="n">gx_freq_mult</span><span class="p">[</span><span class="n">getCx86</span><span class="p">(</span><span class="n">CX86_DIR1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">];</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_khz</span><span class="p">)</span>
		<span class="n">maxfreq</span> <span class="o">=</span> <span class="n">cpu_khz</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">maxfreq</span> <span class="o">=</span> <span class="mi">30000</span> <span class="o">*</span> <span class="n">gx_freq_mult</span><span class="p">[</span><span class="n">getCx86</span><span class="p">(</span><span class="n">CX86_DIR1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">];</span>

	<span class="n">stock_freq</span> <span class="o">=</span> <span class="n">maxfreq</span><span class="p">;</span>
	<span class="n">curfreq</span> <span class="o">=</span> <span class="n">gx_get_cpuspeed</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cpu max frequency is %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">maxfreq</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cpu current frequency is %dkHz.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curfreq</span><span class="p">);</span>

	<span class="cm">/* setup basic struct for cpufreq API */</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_duration</span> <span class="o">&lt;</span> <span class="n">POLICY_MIN_DIV</span><span class="p">)</span>
		<span class="n">policy</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">maxfreq</span> <span class="o">/</span> <span class="n">max_duration</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">policy</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">maxfreq</span> <span class="o">/</span> <span class="n">POLICY_MIN_DIV</span><span class="p">;</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">maxfreq</span><span class="p">;</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">curfreq</span><span class="p">;</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">cpuinfo</span><span class="p">.</span><span class="n">min_freq</span> <span class="o">=</span> <span class="n">maxfreq</span> <span class="o">/</span> <span class="n">max_duration</span><span class="p">;</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">cpuinfo</span><span class="p">.</span><span class="n">max_freq</span> <span class="o">=</span> <span class="n">maxfreq</span><span class="p">;</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">cpuinfo</span><span class="p">.</span><span class="n">transition_latency</span> <span class="o">=</span> <span class="n">CPUFREQ_ETERNAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cpufreq_gx_init:</span>
<span class="cm"> *   MediaGX/Geode GX initialize cpufreq driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cpufreq_driver</span> <span class="n">gx_suspmod_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get</span>		<span class="o">=</span> <span class="n">gx_get_cpuspeed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">verify</span>		<span class="o">=</span> <span class="n">cpufreq_gx_verify</span><span class="p">,</span>
	<span class="p">.</span><span class="n">target</span>		<span class="o">=</span> <span class="n">cpufreq_gx_target</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">cpufreq_gx_cpu_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;gx-suspmod&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cpufreq_gx_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gxfreq_params</span> <span class="o">*</span><span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">gx_pci</span><span class="p">;</span>

	<span class="cm">/* Test if we have the right hardware */</span>
	<span class="n">gx_pci</span> <span class="o">=</span> <span class="n">gx_detect_chipset</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gx_pci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* check whether module parameters are sane */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_duration</span> <span class="o">&gt;</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="n">max_duration</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;geode suspend modulation available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">params</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gxfreq_params</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">params</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">params</span><span class="o">-&gt;</span><span class="n">cs55x0</span> <span class="o">=</span> <span class="n">gx_pci</span><span class="p">;</span>
	<span class="n">gx_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">;</span>

	<span class="cm">/* keep cs55x0 configurations */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">cs55x0</span><span class="p">,</span> <span class="n">PCI_SUSCFG</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">pci_suscfg</span><span class="p">));</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">cs55x0</span><span class="p">,</span> <span class="n">PCI_PMER1</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">pci_pmer1</span><span class="p">));</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">cs55x0</span><span class="p">,</span> <span class="n">PCI_PMER2</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">pci_pmer2</span><span class="p">));</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">cs55x0</span><span class="p">,</span> <span class="n">PCI_MODON</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">on_duration</span><span class="p">));</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">cs55x0</span><span class="p">,</span> <span class="n">PCI_MODOFF</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">off_duration</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cpufreq_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gx_suspmod_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>                   <span class="cm">/* register error! */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cpufreq_gx_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpufreq_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gx_suspmod_driver</span><span class="p">);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">gx_params</span><span class="o">-&gt;</span><span class="n">cs55x0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">gx_params</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Hiroshi Miura &lt;miura@da-cha.org&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Cpufreq driver for Cyrix MediaGX and NatSemi Geode&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">cpufreq_gx_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cpufreq_gx_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
