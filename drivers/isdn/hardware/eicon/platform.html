<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › isdn › hardware › eicon › platform.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>platform.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* $Id: platform.h,v 1.37.4.6 2005/01/31 12:22:20 armin Exp $</span>
<span class="cm"> *</span>
<span class="cm"> * platform.h</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2000-2003  by Armin Schindler (mac@melware.de)</span>
<span class="cm"> * Copyright 2000  Eicon Networks</span>
<span class="cm"> *</span>
<span class="cm"> * This software may be used and distributed according to the terms</span>
<span class="cm"> * of the GNU General Public License, incorporated herein by reference.</span>
<span class="cm"> */</span>


<span class="cp">#ifndef	__PLATFORM_H__</span>
<span class="cp">#define	__PLATFORM_H__</span>

<span class="cp">#if !defined(DIVA_BUILD)</span>
<span class="cp">#define DIVA_BUILD &quot;local&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#include &quot;cardtype.h&quot;</span>

<span class="cm">/* activate debuglib for modules only */</span>
<span class="cp">#ifndef MODULE</span>
<span class="cp">#define DIVA_NO_DEBUGLIB</span>
<span class="cp">#endif</span>

<span class="cp">#define DIVA_USER_MODE_CARD_CONFIG 1</span>
<span class="cp">#define	USE_EXTENDED_DEBUGS 1</span>

<span class="cp">#define MAX_ADAPTER     32</span>

<span class="cp">#define DIVA_ISTREAM 1</span>

<span class="cp">#define MEMORY_SPACE_TYPE  0</span>
<span class="cp">#define PORT_SPACE_TYPE    1</span>


<span class="cp">#include &lt;linux/string.h&gt;</span>

<span class="cp">#ifndef	byte</span>
<span class="cp">#define	byte   u8</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	word</span>
<span class="cp">#define	word   u16</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	dword</span>
<span class="cp">#define	dword  u32</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	qword</span>
<span class="cp">#define	qword  u64</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	NULL</span>
<span class="cp">#define	NULL	((void *) 0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	far</span>
<span class="cp">#define far</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	_pascal</span>
<span class="cp">#define _pascal</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	_loadds</span>
<span class="cp">#define _loadds</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	_cdecl</span>
<span class="cp">#define _cdecl</span>
<span class="cp">#endif</span>

<span class="cp">#define MEM_TYPE_RAM		0</span>
<span class="cp">#define MEM_TYPE_PORT		1</span>
<span class="cp">#define MEM_TYPE_PROM		2</span>
<span class="cp">#define MEM_TYPE_CTLREG		3</span>
<span class="cp">#define MEM_TYPE_RESET		4</span>
<span class="cp">#define MEM_TYPE_CFG		5</span>
<span class="cp">#define MEM_TYPE_ADDRESS	6</span>
<span class="cp">#define MEM_TYPE_CONFIG		7</span>
<span class="cp">#define MEM_TYPE_CONTROL	8</span>

<span class="cp">#define MAX_MEM_TYPE		10</span>

<span class="cp">#define DIVA_OS_MEM_ATTACH_RAM(a)	((a)-&gt;ram)</span>
<span class="cp">#define DIVA_OS_MEM_ATTACH_PORT(a)	((a)-&gt;port)</span>
<span class="cp">#define DIVA_OS_MEM_ATTACH_PROM(a)	((a)-&gt;prom)</span>
<span class="cp">#define DIVA_OS_MEM_ATTACH_CTLREG(a)	((a)-&gt;ctlReg)</span>
<span class="cp">#define DIVA_OS_MEM_ATTACH_RESET(a)	((a)-&gt;reset)</span>
<span class="cp">#define DIVA_OS_MEM_ATTACH_CFG(a)	((a)-&gt;cfg)</span>
<span class="cp">#define DIVA_OS_MEM_ATTACH_ADDRESS(a)	((a)-&gt;Address)</span>
<span class="cp">#define DIVA_OS_MEM_ATTACH_CONFIG(a)	((a)-&gt;Config)</span>
<span class="cp">#define DIVA_OS_MEM_ATTACH_CONTROL(a)	((a)-&gt;Control)</span>

<span class="cp">#define DIVA_OS_MEM_DETACH_RAM(a, x)	do { } while (0)</span>
<span class="cp">#define DIVA_OS_MEM_DETACH_PORT(a, x)	do { } while (0)</span>
<span class="cp">#define DIVA_OS_MEM_DETACH_PROM(a, x)	do { } while (0)</span>
<span class="cp">#define DIVA_OS_MEM_DETACH_CTLREG(a, x)	do { } while (0)</span>
<span class="cp">#define DIVA_OS_MEM_DETACH_RESET(a, x)	do { } while (0)</span>
<span class="cp">#define DIVA_OS_MEM_DETACH_CFG(a, x)	do { } while (0)</span>
<span class="cp">#define DIVA_OS_MEM_DETACH_ADDRESS(a, x)	do { } while (0)</span>
<span class="cp">#define DIVA_OS_MEM_DETACH_CONFIG(a, x)	do { } while (0)</span>
<span class="cp">#define DIVA_OS_MEM_DETACH_CONTROL(a, x)	do { } while (0)</span>

<span class="cp">#define DIVA_INVALID_FILE_HANDLE  ((dword)(-1))</span>

<span class="cp">#define DIVAS_CONTAINING_RECORD(address, type, field)			\</span>
<span class="cp">	((type *)((char *)(address) - (char *)(&amp;((type *)0)-&gt;field)))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="n">LIST_ENTRY</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">char</span> <span class="n">DEVICE_NAME</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_ISDN_ADAPTER</span> <span class="n">ISDN_ADAPTER</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_ISDN_ADAPTER</span> <span class="o">*</span><span class="n">PISDN_ADAPTER</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">DIVA_DI_PRINTF</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="cp">#include &quot;debuglib.h&quot;</span>

<span class="cp">#define dtrc(p) DBG_PRV0(p)</span>
<span class="cp">#define dbug(a, p) DBG_PRV1(p)</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">e_info_s</span> <span class="n">E_INFO</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">char</span> <span class="n">diva_os_dependent_devica_name_t</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="n">PDEVICE_OBJECT</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">_diva_os_soft_isr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">_diva_os_timer</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">_ISDN_ADAPTER</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">diva_log_info</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>

<span class="cm">/*</span>
<span class="cm">**  XDI DIDD Interface</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="n">diva_xdi_didd_register_adapter</span><span class="p">(</span><span class="kt">int</span> <span class="n">card</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">diva_xdi_didd_remove_adapter</span><span class="p">(</span><span class="kt">int</span> <span class="n">card</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">** memory allocation</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">diva_os_malloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">vmalloc</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">diva_os_free</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** use skbuffs for message buffer</span>
<span class="cm">*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="n">diva_os_message_buffer_s</span><span class="p">;</span>
<span class="n">diva_os_message_buffer_s</span> <span class="o">*</span><span class="n">diva_os_alloc_message_buffer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data_buf</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">diva_os_free_message_buffer</span><span class="p">(</span><span class="n">diva_os_message_buffer_s</span> <span class="o">*</span><span class="n">dmb</span><span class="p">);</span>
<span class="cp">#define DIVA_MESSAGE_BUFFER_LEN(x) x-&gt;len</span>
<span class="cp">#define DIVA_MESSAGE_BUFFER_DATA(x) x-&gt;data</span>

<span class="cm">/*</span>
<span class="cm">** mSeconds waiting</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">diva_os_sleep</span><span class="p">(</span><span class="n">dword</span> <span class="n">mSec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">mSec</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">diva_os_wait</span><span class="p">(</span><span class="n">dword</span> <span class="n">mSec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="n">mSec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">**  PCI Configuration space access</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="n">PCIwrite</span><span class="p">(</span><span class="n">byte</span> <span class="n">bus</span><span class="p">,</span> <span class="n">byte</span> <span class="n">func</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pci_dev_handle</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">PCIread</span><span class="p">(</span><span class="n">byte</span> <span class="n">bus</span><span class="p">,</span> <span class="n">byte</span> <span class="n">func</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pci_dev_handle</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">**  I/O Port utilities</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="n">diva_os_register_io_port</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="k">register</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">**  I/O port access abstraction</span>
<span class="cm">*/</span>
<span class="n">byte</span> <span class="n">inpp</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">);</span>
<span class="n">word</span> <span class="n">inppw</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">inppw_buffer</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">outppw</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">outppw_buffer</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">outpp</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">**  IRQ</span>
<span class="cm">*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_diva_os_adapter_irq_info</span> <span class="p">{</span>
	<span class="n">byte</span> <span class="n">irq_nr</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">registered</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">irq_name</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
<span class="p">}</span> <span class="n">diva_os_adapter_irq_info_t</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">diva_os_register_irq</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="n">byte</span> <span class="n">irq</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">diva_os_remove_irq</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="n">byte</span> <span class="n">irq</span><span class="p">);</span>

<span class="cp">#define diva_os_in_irq() in_irq()</span>

<span class="cm">/*</span>
<span class="cm">**  Spin Lock framework</span>
<span class="cm">*/</span>
<span class="k">typedef</span> <span class="kt">long</span> <span class="n">diva_os_spin_lock_magic_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">spinlock_t</span> <span class="n">diva_os_spin_lock_t</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">diva_os_initialize_spin_lock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span> <span class="p">{</span> \
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span> <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">diva_os_enter_spin_lock</span><span class="p">(</span><span class="n">diva_os_spin_lock_t</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> \
					       <span class="n">diva_os_spin_lock_magic_t</span> <span class="o">*</span><span class="n">old_irql</span><span class="p">,</span> \
					       <span class="kt">void</span> <span class="o">*</span><span class="n">dbg</span><span class="p">)</span> <span class="p">{</span> <span class="n">spin_lock_bh</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">diva_os_leave_spin_lock</span><span class="p">(</span><span class="n">diva_os_spin_lock_t</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> \
					       <span class="n">diva_os_spin_lock_magic_t</span> <span class="o">*</span><span class="n">old_irql</span><span class="p">,</span> \
					       <span class="kt">void</span> <span class="o">*</span><span class="n">dbg</span><span class="p">)</span> <span class="p">{</span> <span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>

<span class="cp">#define diva_os_destroy_spin_lock(a, b) do { } while (0)</span>

<span class="cm">/*</span>
<span class="cm">**  Deffered processing framework</span>
<span class="cm">*/</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">diva_os_isr_callback_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">_ISDN_ADAPTER</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">diva_os_soft_isr_callback_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">_diva_os_soft_isr</span> <span class="o">*</span><span class="n">psoft_isr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_diva_os_soft_isr</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="n">diva_os_soft_isr_callback_t</span> <span class="n">callback</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">callback_context</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dpc_thread_name</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
<span class="p">}</span> <span class="n">diva_os_soft_isr_t</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">diva_os_initialize_soft_isr</span><span class="p">(</span><span class="n">diva_os_soft_isr_t</span> <span class="o">*</span><span class="n">psoft_isr</span><span class="p">,</span> <span class="n">diva_os_soft_isr_callback_t</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">callback_context</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">diva_os_schedule_soft_isr</span><span class="p">(</span><span class="n">diva_os_soft_isr_t</span> <span class="o">*</span><span class="n">psoft_isr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">diva_os_cancel_soft_isr</span><span class="p">(</span><span class="n">diva_os_soft_isr_t</span> <span class="o">*</span><span class="n">psoft_isr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">diva_os_remove_soft_isr</span><span class="p">(</span><span class="n">diva_os_soft_isr_t</span> <span class="o">*</span><span class="n">psoft_isr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">  Get time service</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="n">diva_os_get_time</span><span class="p">(</span><span class="n">dword</span> <span class="o">*</span><span class="n">sec</span><span class="p">,</span> <span class="n">dword</span> <span class="o">*</span><span class="n">usec</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">**  atomic operation, fake because we use threads</span>
<span class="cm">*/</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">diva_os_atomic_t</span><span class="p">;</span>
<span class="k">static</span> <span class="n">diva_os_atomic_t</span> <span class="n">__inline__</span>
<span class="nf">diva_os_atomic_increment</span><span class="p">(</span><span class="n">diva_os_atomic_t</span> <span class="o">*</span><span class="n">pv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">pv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">pv</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">diva_os_atomic_t</span> <span class="n">__inline__</span>
<span class="nf">diva_os_atomic_decrement</span><span class="p">(</span><span class="n">diva_os_atomic_t</span> <span class="o">*</span><span class="n">pv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">pv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">pv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">**  CAPI SECTION</span>
<span class="cm">*/</span>
<span class="cp">#define NO_CORNETN</span>
<span class="cp">#define IMPLEMENT_DTMF 1</span>
<span class="cp">#define IMPLEMENT_ECHO_CANCELLER 1</span>
<span class="cp">#define IMPLEMENT_RTP 1</span>
<span class="cp">#define IMPLEMENT_T38 1</span>
<span class="cp">#define IMPLEMENT_FAX_SUB_SEP_PWD 1</span>
<span class="cp">#define IMPLEMENT_V18 1</span>
<span class="cp">#define IMPLEMENT_DTMF_TONE 1</span>
<span class="cp">#define IMPLEMENT_PIAFS 1</span>
<span class="cp">#define IMPLEMENT_FAX_PAPER_FORMATS 1</span>
<span class="cp">#define IMPLEMENT_VOWN 1</span>
<span class="cp">#define IMPLEMENT_CAPIDTMF 1</span>
<span class="cp">#define IMPLEMENT_FAX_NONSTANDARD 1</span>
<span class="cp">#define VSWITCH_SUPPORT 1</span>

<span class="cp">#define IMPLEMENT_MARKED_OK_AFTER_FC 1</span>

<span class="cp">#define DIVA_IDI_RX_DMA 1</span>

<span class="cm">/*</span>
<span class="cm">** endian macros</span>
<span class="cm">**</span>
<span class="cm">** If only...  In some cases we did use them for endianness conversion;</span>
<span class="cm">** unfortunately, other uses were real iomem accesses.</span>
<span class="cm">*/</span>
<span class="cp">#define READ_BYTE(addr)   readb(addr)</span>
<span class="cp">#define READ_WORD(addr)   readw(addr)</span>
<span class="cp">#define READ_DWORD(addr)  readl(addr)</span>

<span class="cp">#define WRITE_BYTE(addr, v)  writeb(v, addr)</span>
<span class="cp">#define WRITE_WORD(addr, v)  writew(v, addr)</span>
<span class="cp">#define WRITE_DWORD(addr, v) writel(v, addr)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span> <span class="nf">GET_WORD</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">GET_DWORD</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">PUT_WORD</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">PUT_DWORD</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** 32/64 bit macors</span>
<span class="cm">*/</span>
<span class="cp">#ifdef BITS_PER_LONG</span>
<span class="cp">#if BITS_PER_LONG &gt; 32</span>
<span class="cp">#define PLATFORM_GT_32BIT</span>
<span class="cp">#define ULongToPtr(x) (void *)(unsigned long)(x)</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">** undef os definitions of macros we use</span>
<span class="cm">*/</span>
<span class="cp">#undef ID_MASK</span>
<span class="cp">#undef N_DATA</span>
<span class="cp">#undef ADDR</span>

<span class="cm">/*</span>
<span class="cm">** dump file</span>
<span class="cm">*/</span>
<span class="cp">#define diva_os_dump_file_t char</span>
<span class="cp">#define diva_os_board_trace_t char</span>
<span class="cp">#define diva_os_dump_file(__x__) do { } while (0)</span>

<span class="cm">/*</span>
<span class="cm">** size of internal arrays</span>
<span class="cm">*/</span>
<span class="cp">#define MAX_DESCRIPTORS 64</span>

<span class="cp">#endif	</span><span class="cm">/* __PLATFORM_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
