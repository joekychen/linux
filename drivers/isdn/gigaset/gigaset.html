<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › isdn › gigaset › gigaset.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>gigaset.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Siemens Gigaset 307x driver</span>
<span class="cm"> * Common header file for all connection variants</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Stefan Eilers</span>
<span class="cm"> *        and Hansjoerg Lipp &lt;hjlipp@web.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * =====================================================================</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *	published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *	the License, or (at your option) any later version.</span>
<span class="cm"> * =====================================================================</span>
<span class="cm"> */</span>

<span class="cp">#ifndef GIGASET_H</span>
<span class="cp">#define GIGASET_H</span>

<span class="cm">/* define global prefix for pr_ macros in linux/kernel.h */</span>
<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ppp_defs.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_driver.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#define GIG_VERSION {0, 5, 0, 0}</span>
<span class="cp">#define GIG_COMPAT  {0, 4, 0, 0}</span>

<span class="cp">#define MAX_REC_PARAMS 10	</span><span class="cm">/* Max. number of params in response string */</span><span class="cp"></span>
<span class="cp">#define MAX_RESP_SIZE 511	</span><span class="cm">/* Max. size of a response string */</span><span class="cp"></span>

<span class="cp">#define MAX_EVENTS 64		</span><span class="cm">/* size of event queue */</span><span class="cp"></span>

<span class="cp">#define RBUFSIZE 8192</span>

<span class="cp">#define GIG_TICK 100		</span><span class="cm">/* in milliseconds */</span><span class="cp"></span>

<span class="cm">/* timeout values (unit: 1 sec) */</span>
<span class="cp">#define INIT_TIMEOUT 1</span>

<span class="cm">/* timeout values (unit: 0.1 sec) */</span>
<span class="cp">#define RING_TIMEOUT 3		</span><span class="cm">/* for additional parameters to RING */</span><span class="cp"></span>
<span class="cp">#define BAS_TIMEOUT 20		</span><span class="cm">/* for response to Base USB ops */</span><span class="cp"></span>
<span class="cp">#define ATRDY_TIMEOUT 3		</span><span class="cm">/* for HD_READY_SEND_ATDATA */</span><span class="cp"></span>

<span class="cp">#define BAS_RETRY 3		</span><span class="cm">/* max. retries for base USB ops */</span><span class="cp"></span>

<span class="cp">#define MAXACT 3</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">gigaset_debuglevel</span><span class="p">;</span>	<span class="cm">/* &quot;needs&quot; cast to (enum debuglevel) */</span>

<span class="cm">/* debug flags, combine by adding/bitwise OR */</span>
<span class="k">enum</span> <span class="n">debuglevel</span> <span class="p">{</span>
	<span class="n">DEBUG_INTR</span>	  <span class="o">=</span> <span class="mh">0x00008</span><span class="p">,</span> <span class="cm">/* interrupt processing */</span>
	<span class="n">DEBUG_CMD</span>	  <span class="o">=</span> <span class="mh">0x00020</span><span class="p">,</span> <span class="cm">/* sent/received LL commands */</span>
	<span class="n">DEBUG_STREAM</span>	  <span class="o">=</span> <span class="mh">0x00040</span><span class="p">,</span> <span class="cm">/* application data stream I/O events */</span>
	<span class="n">DEBUG_STREAM_DUMP</span> <span class="o">=</span> <span class="mh">0x00080</span><span class="p">,</span> <span class="cm">/* application data stream content */</span>
	<span class="n">DEBUG_LLDATA</span>	  <span class="o">=</span> <span class="mh">0x00100</span><span class="p">,</span> <span class="cm">/* sent/received LL data */</span>
	<span class="n">DEBUG_EVENT</span>	  <span class="o">=</span> <span class="mh">0x00200</span><span class="p">,</span> <span class="cm">/* event processing */</span>
	<span class="n">DEBUG_HDLC</span>	  <span class="o">=</span> <span class="mh">0x00800</span><span class="p">,</span> <span class="cm">/* M10x HDLC processing */</span>
	<span class="n">DEBUG_CHANNEL</span>	  <span class="o">=</span> <span class="mh">0x01000</span><span class="p">,</span> <span class="cm">/* channel allocation/deallocation */</span>
	<span class="n">DEBUG_TRANSCMD</span>	  <span class="o">=</span> <span class="mh">0x02000</span><span class="p">,</span> <span class="cm">/* AT-COMMANDS+RESPONSES */</span>
	<span class="n">DEBUG_MCMD</span>	  <span class="o">=</span> <span class="mh">0x04000</span><span class="p">,</span> <span class="cm">/* COMMANDS THAT ARE SENT VERY OFTEN */</span>
	<span class="n">DEBUG_INIT</span>	  <span class="o">=</span> <span class="mh">0x08000</span><span class="p">,</span> <span class="cm">/* (de)allocation+initialization of data</span>
<span class="cm">					structures */</span>
	<span class="n">DEBUG_SUSPEND</span>	  <span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span> <span class="cm">/* suspend/resume processing */</span>
	<span class="n">DEBUG_OUTPUT</span>	  <span class="o">=</span> <span class="mh">0x20000</span><span class="p">,</span> <span class="cm">/* output to device */</span>
	<span class="n">DEBUG_ISO</span>	  <span class="o">=</span> <span class="mh">0x40000</span><span class="p">,</span> <span class="cm">/* isochronous transfers */</span>
	<span class="n">DEBUG_IF</span>	  <span class="o">=</span> <span class="mh">0x80000</span><span class="p">,</span> <span class="cm">/* character device operations */</span>
	<span class="n">DEBUG_USBREQ</span>	  <span class="o">=</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="cm">/* USB communication (except payload</span>
<span class="cm">					 data) */</span>
	<span class="n">DEBUG_LOCKCMD</span>	  <span class="o">=</span> <span class="mh">0x200000</span><span class="p">,</span> <span class="cm">/* AT commands and responses when</span>
<span class="cm">					 MS_LOCKED */</span>

	<span class="n">DEBUG_ANY</span>	  <span class="o">=</span> <span class="mh">0x3fffff</span><span class="p">,</span> <span class="cm">/* print message if any of the others is</span>
<span class="cm">					 activated */</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_GIGASET_DEBUG</span>

<span class="cp">#define gig_dbg(level, format, arg...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (unlikely(((enum debuglevel)gigaset_debuglevel) &amp; (level))) \</span>
<span class="cp">			printk(KERN_DEBUG KBUILD_MODNAME &quot;: &quot; format &quot;\n&quot;, \</span>
<span class="cp">			       ## arg);					\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define DEBUG_DEFAULT (DEBUG_TRANSCMD | DEBUG_CMD | DEBUG_USBREQ)</span>

<span class="cp">#else</span>

<span class="cp">#define gig_dbg(level, format, arg...) do {} while (0)</span>
<span class="cp">#define DEBUG_DEFAULT 0</span>

<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">gigaset_dbg_buffer</span><span class="p">(</span><span class="k">enum</span> <span class="n">debuglevel</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/* connection state */</span>
<span class="cp">#define ZSAU_NONE			0</span>
<span class="cp">#define ZSAU_DISCONNECT_IND		4</span>
<span class="cp">#define ZSAU_OUTGOING_CALL_PROCEEDING	1</span>
<span class="cp">#define ZSAU_PROCEEDING			1</span>
<span class="cp">#define ZSAU_CALL_DELIVERED		2</span>
<span class="cp">#define ZSAU_ACTIVE			3</span>
<span class="cp">#define ZSAU_NULL			5</span>
<span class="cp">#define ZSAU_DISCONNECT_REQ		6</span>
<span class="cp">#define ZSAU_UNKNOWN			-1</span>

<span class="cm">/* USB control transfer requests */</span>
<span class="cp">#define OUT_VENDOR_REQ	(USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT)</span>
<span class="cp">#define IN_VENDOR_REQ	(USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT)</span>

<span class="cm">/* interrupt pipe messages */</span>
<span class="cp">#define HD_B1_FLOW_CONTROL		0x80</span>
<span class="cp">#define HD_B2_FLOW_CONTROL		0x81</span>
<span class="cp">#define HD_RECEIVEATDATA_ACK		(0x35)		</span><span class="cm">/* 3070 */</span><span class="cp"></span>
<span class="cp">#define HD_READY_SEND_ATDATA		(0x36)		</span><span class="cm">/* 3070 */</span><span class="cp"></span>
<span class="cp">#define HD_OPEN_ATCHANNEL_ACK		(0x37)		</span><span class="cm">/* 3070 */</span><span class="cp"></span>
<span class="cp">#define HD_CLOSE_ATCHANNEL_ACK		(0x38)		</span><span class="cm">/* 3070 */</span><span class="cp"></span>
<span class="cp">#define HD_DEVICE_INIT_OK		(0x11)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define HD_OPEN_B1CHANNEL_ACK		(0x51)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define HD_OPEN_B2CHANNEL_ACK		(0x52)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define HD_CLOSE_B1CHANNEL_ACK		(0x53)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define HD_CLOSE_B2CHANNEL_ACK		(0x54)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define HD_SUSPEND_END			(0x61)		</span><span class="cm">/* ISurf USB */</span><span class="cp"></span>
<span class="cp">#define HD_RESET_INTERRUPT_PIPE_ACK	(0xFF)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>

<span class="cm">/* control requests */</span>
<span class="cp">#define	HD_OPEN_B1CHANNEL		(0x23)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define	HD_CLOSE_B1CHANNEL		(0x24)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define	HD_OPEN_B2CHANNEL		(0x25)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define	HD_CLOSE_B2CHANNEL		(0x26)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define HD_RESET_INTERRUPT_PIPE		(0x27)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define	HD_DEVICE_INIT_ACK		(0x34)		</span><span class="cm">/* ISurf USB + 3070 */</span><span class="cp"></span>
<span class="cp">#define	HD_WRITE_ATMESSAGE		(0x12)		</span><span class="cm">/* 3070 */</span><span class="cp"></span>
<span class="cp">#define	HD_READ_ATMESSAGE		(0x13)		</span><span class="cm">/* 3070 */</span><span class="cp"></span>
<span class="cp">#define	HD_OPEN_ATCHANNEL		(0x28)		</span><span class="cm">/* 3070 */</span><span class="cp"></span>
<span class="cp">#define	HD_CLOSE_ATCHANNEL		(0x29)		</span><span class="cm">/* 3070 */</span><span class="cp"></span>

<span class="cm">/* number of B channels supported by base driver */</span>
<span class="cp">#define BAS_CHANNELS	2</span>

<span class="cm">/* USB frames for isochronous transfer */</span>
<span class="cp">#define BAS_FRAMETIME	1	</span><span class="cm">/* number of milliseconds between frames */</span><span class="cp"></span>
<span class="cp">#define BAS_NUMFRAMES	8	</span><span class="cm">/* number of frames per URB */</span><span class="cp"></span>
<span class="cp">#define BAS_MAXFRAME	16	</span><span class="cm">/* allocated bytes per frame */</span><span class="cp"></span>
<span class="cp">#define BAS_NORMFRAME	8	</span><span class="cm">/* send size without flow control */</span><span class="cp"></span>
<span class="cp">#define BAS_HIGHFRAME	10	</span><span class="cm">/* &quot;    &quot;    with positive flow control */</span><span class="cp"></span>
<span class="cp">#define BAS_LOWFRAME	5	</span><span class="cm">/* &quot;    &quot;    with negative flow control */</span><span class="cp"></span>
<span class="cp">#define BAS_CORRFRAMES	4	</span><span class="cm">/* flow control multiplicator */</span><span class="cp"></span>

<span class="cp">#define BAS_INBUFSIZE	(BAS_MAXFRAME * BAS_NUMFRAMES)	</span><span class="cm">/* size of isoc in buf</span>
<span class="cm">							 * per URB */</span><span class="cp"></span>
<span class="cp">#define BAS_OUTBUFSIZE	4096		</span><span class="cm">/* size of common isoc out buffer */</span><span class="cp"></span>
<span class="cp">#define BAS_OUTBUFPAD	BAS_MAXFRAME	</span><span class="cm">/* size of pad area for isoc out buf */</span><span class="cp"></span>

<span class="cp">#define BAS_INURBS	3</span>
<span class="cp">#define BAS_OUTURBS	3</span>

<span class="cm">/* variable commands in struct bc_state */</span>
<span class="cp">#define AT_ISO		0</span>
<span class="cp">#define AT_DIAL		1</span>
<span class="cp">#define AT_MSN		2</span>
<span class="cp">#define AT_BC		3</span>
<span class="cp">#define AT_PROTO	4</span>
<span class="cp">#define AT_TYPE		5</span>
<span class="cp">#define AT_CLIP		6</span>
<span class="cm">/* total number */</span>
<span class="cp">#define AT_NUM		7</span>

<span class="cm">/* variables in struct at_state_t */</span>
<span class="cp">#define VAR_ZSAU	0</span>
<span class="cp">#define VAR_ZDLE	1</span>
<span class="cp">#define VAR_ZCTP	2</span>
<span class="cp">#define VAR_NUM		3</span>

<span class="cp">#define STR_NMBR	0</span>
<span class="cp">#define STR_ZCPN	1</span>
<span class="cp">#define STR_ZCON	2</span>
<span class="cp">#define STR_ZBC		3</span>
<span class="cp">#define STR_ZHLC	4</span>
<span class="cp">#define STR_NUM		5</span>

<span class="cp">#define EV_TIMEOUT	-105</span>
<span class="cp">#define EV_IF_VER	-106</span>
<span class="cp">#define EV_PROC_CIDMODE	-107</span>
<span class="cp">#define EV_SHUTDOWN	-108</span>
<span class="cp">#define EV_START	-110</span>
<span class="cp">#define EV_STOP		-111</span>
<span class="cp">#define EV_IF_LOCK	-112</span>
<span class="cp">#define EV_ACCEPT	-114</span>
<span class="cp">#define EV_DIAL		-115</span>
<span class="cp">#define EV_HUP		-116</span>
<span class="cp">#define EV_BC_OPEN	-117</span>
<span class="cp">#define EV_BC_CLOSED	-118</span>

<span class="cm">/* input state */</span>
<span class="cp">#define INS_command	0x0001	</span><span class="cm">/* receiving messages (not payload data) */</span><span class="cp"></span>
<span class="cp">#define INS_DLE_char	0x0002	</span><span class="cm">/* DLE flag received (in DLE mode) */</span><span class="cp"></span>
<span class="cp">#define INS_byte_stuff	0x0004</span>
<span class="cp">#define INS_have_data	0x0008</span>
<span class="cp">#define INS_DLE_command	0x0020	</span><span class="cm">/* DLE message start (&lt;DLE&gt; X) received */</span><span class="cp"></span>
<span class="cp">#define INS_flag_hunt	0x0040</span>

<span class="cm">/* channel state */</span>
<span class="cp">#define CHS_D_UP	0x01</span>
<span class="cp">#define CHS_B_UP	0x02</span>
<span class="cp">#define CHS_NOTIFY_LL	0x04</span>

<span class="cp">#define ICALL_REJECT	0</span>
<span class="cp">#define ICALL_ACCEPT	1</span>
<span class="cp">#define ICALL_IGNORE	2</span>

<span class="cm">/* device state */</span>
<span class="cp">#define MS_UNINITIALIZED	0</span>
<span class="cp">#define MS_INIT			1</span>
<span class="cp">#define MS_LOCKED		2</span>
<span class="cp">#define MS_SHUTDOWN		3</span>
<span class="cp">#define MS_RECOVER		4</span>
<span class="cp">#define MS_READY		5</span>

<span class="cm">/* mode */</span>
<span class="cp">#define M_UNKNOWN	0</span>
<span class="cp">#define M_CONFIG	1</span>
<span class="cp">#define M_UNIMODEM	2</span>
<span class="cp">#define M_CID		3</span>

<span class="cm">/* start mode */</span>
<span class="cp">#define SM_LOCKED	0</span>
<span class="cp">#define SM_ISDN		1 </span><span class="cm">/* default */</span><span class="cp"></span>

<span class="cm">/* layer 2 protocols (AT^SBPR=...) */</span>
<span class="cp">#define L2_BITSYNC	0</span>
<span class="cp">#define L2_HDLC		1</span>
<span class="cp">#define L2_VOICE	2</span>

<span class="k">struct</span> <span class="n">gigaset_ops</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">gigaset_driver</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">usb_cardstate</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ser_cardstate</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">bas_cardstate</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">bc_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">usb_bc_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ser_bc_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">bas_bc_state</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">reply_t</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">resp_code</span><span class="p">;</span>	<span class="cm">/* RSP_XXXX */</span>
	<span class="kt">int</span>	<span class="n">min_ConState</span><span class="p">;</span>	<span class="cm">/* &lt;0 =&gt; ignore */</span>
	<span class="kt">int</span>	<span class="n">max_ConState</span><span class="p">;</span>	<span class="cm">/* &lt;0 =&gt; ignore */</span>
	<span class="kt">int</span>	<span class="n">parameter</span><span class="p">;</span>	<span class="cm">/* e.g. ZSAU_XXXX &lt;0: ignore*/</span>
	<span class="kt">int</span>	<span class="n">new_ConState</span><span class="p">;</span>	<span class="cm">/* &lt;0 =&gt; ignore */</span>
	<span class="kt">int</span>	<span class="n">timeout</span><span class="p">;</span>	<span class="cm">/* &gt;0 =&gt; *HZ; &lt;=0 =&gt; TOUT_XXXX*/</span>
	<span class="kt">int</span>	<span class="n">action</span><span class="p">[</span><span class="n">MAXACT</span><span class="p">];</span>	<span class="cm">/* ACT_XXXX */</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">command</span><span class="p">;</span>	<span class="cm">/* NULL==none */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">reply_t</span> <span class="n">gigaset_tab_cid</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">reply_t</span> <span class="n">gigaset_tab_nocid</span><span class="p">[];</span>

<span class="k">struct</span> <span class="n">inbuf_t</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cardstate</span>	<span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">inputstate</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">data</span><span class="p">[</span><span class="n">RBUFSIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* isochronous write buffer structure</span>
<span class="cm"> * circular buffer with pad area for extraction of complete USB frames</span>
<span class="cm"> * - data[read..nextread-1] is valid data already submitted to the USB subsystem</span>
<span class="cm"> * - data[nextread..write-1] is valid data yet to be sent</span>
<span class="cm"> * - data[write] is the next byte to write to</span>
<span class="cm"> *   - in byte-oriented L2 procotols, it is completely free</span>
<span class="cm"> *   - in bit-oriented L2 procotols, it may contain a partial byte of valid data</span>
<span class="cm"> * - data[write+1..read-1] is free</span>
<span class="cm"> * - wbits is the number of valid data bits in data[write], starting at the LSB</span>
<span class="cm"> * - writesem is the semaphore for writing to the buffer:</span>
<span class="cm"> *   if writesem &lt;= 0, data[write..read-1] is currently being written to</span>
<span class="cm"> * - idle contains the byte value to repeat when the end of valid data is</span>
<span class="cm"> *   reached; if nextread==write (buffer contains no data to send), either the</span>
<span class="cm"> *   BAS_OUTBUFPAD bytes immediately before data[write] (if</span>
<span class="cm"> *   write&gt;=BAS_OUTBUFPAD) or those of the pad area (if write&lt;BAS_OUTBUFPAD)</span>
<span class="cm"> *   are also filled with that value</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">isowbuf_t</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">read</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nextread</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">write</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">writesem</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">wbits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">data</span><span class="p">[</span><span class="n">BAS_OUTBUFSIZE</span> <span class="o">+</span> <span class="n">BAS_OUTBUFPAD</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">idle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* isochronous write URB context structure</span>
<span class="cm"> * data to be stored along with the URB and retrieved when it is returned</span>
<span class="cm"> * as completed by the USB subsystem</span>
<span class="cm"> * - urb: pointer to the URB itself</span>
<span class="cm"> * - bcs: pointer to the B Channel control structure</span>
<span class="cm"> * - limit: end of write buffer area covered by this URB</span>
<span class="cm"> * - status: URB completion status</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">isow_urbctx_t</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* AT state structure</span>
<span class="cm"> * data associated with the state of an ISDN connection, whether or not</span>
<span class="cm"> * it is currently assigned a B channel</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">at_state_t</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">waiting</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">getstring</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">timer_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">timer_expires</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">timer_active</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ConState</span><span class="p">;</span>	<span class="cm">/* State of connection */</span>
	<span class="k">struct</span> <span class="n">reply_t</span>		<span class="o">*</span><span class="n">replystruct</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cid</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">int_var</span><span class="p">[</span><span class="n">VAR_NUM</span><span class="p">];</span>	<span class="cm">/* see VAR_XXXX */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">str_var</span><span class="p">[</span><span class="n">STR_NUM</span><span class="p">];</span>	<span class="cm">/* see STR_XXXX */</span>
	<span class="kt">unsigned</span>		<span class="n">pending_commands</span><span class="p">;</span>	<span class="cm">/* see PC_XXXX */</span>
	<span class="kt">unsigned</span>		<span class="n">seq_index</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">cardstate</span>	<span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bc_state</span>		<span class="o">*</span><span class="n">bcs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">event_t</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">parameter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">at_state_t</span> <span class="o">*</span><span class="n">at_state</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This buffer holds all information about the used B-Channel */</span>
<span class="k">struct</span> <span class="n">bc_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skb</span><span class="p">;</span>		<span class="cm">/* Current transfer buffer to modem */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">squeue</span><span class="p">;</span>	<span class="cm">/* B-Channel send Queue */</span>

	<span class="cm">/* Variables for debugging .. */</span>
	<span class="kt">int</span> <span class="n">corrupted</span><span class="p">;</span>			<span class="cm">/* Counter for corrupted packages */</span>
	<span class="kt">int</span> <span class="n">trans_down</span><span class="p">;</span>			<span class="cm">/* Counter of packages (downstream) */</span>
	<span class="kt">int</span> <span class="n">trans_up</span><span class="p">;</span>			<span class="cm">/* Counter of packages (upstream) */</span>

	<span class="k">struct</span> <span class="n">at_state_t</span> <span class="n">at_state</span><span class="p">;</span>

	<span class="cm">/* receive buffer */</span>
	<span class="kt">unsigned</span> <span class="n">rx_bufsize</span><span class="p">;</span>		<span class="cm">/* max size accepted by application */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rx_skb</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">rx_fcs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inputstate</span><span class="p">;</span>			<span class="cm">/* see INS_XXXX */</span>

	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">chstate</span><span class="p">;</span>		<span class="cm">/* bitmap (CHS_*) */</span>
	<span class="kt">int</span> <span class="n">ignore</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">proto2</span><span class="p">;</span>		<span class="cm">/* layer 2 protocol (L2_*) */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">commands</span><span class="p">[</span><span class="n">AT_NUM</span><span class="p">];</span>		<span class="cm">/* see AT_XXXX */</span>

<span class="cp">#ifdef CONFIG_GIGASET_DEBUG</span>
	<span class="kt">int</span> <span class="n">emptycount</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">busy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_count</span><span class="p">;</span>

	<span class="cm">/* private data of hardware drivers */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ser_bc_state</span> <span class="o">*</span><span class="n">ser</span><span class="p">;</span>	<span class="cm">/* serial hardware driver */</span>
		<span class="k">struct</span> <span class="n">usb_bc_state</span> <span class="o">*</span><span class="n">usb</span><span class="p">;</span>	<span class="cm">/* usb hardware driver (m105) */</span>
		<span class="k">struct</span> <span class="n">bas_bc_state</span> <span class="o">*</span><span class="n">bas</span><span class="p">;</span>	<span class="cm">/* usb hardware driver (base) */</span>
	<span class="p">}</span> <span class="n">hw</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>			<span class="cm">/* associated LL application */</span>
	<span class="kt">int</span> <span class="n">apconnstate</span><span class="p">;</span>		<span class="cm">/* LL application connection state */</span>
	<span class="n">spinlock_t</span> <span class="n">aplock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cardstate</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">gigaset_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">minor_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">tty_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">gigaset_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="cm">/* Stuff to handle communication */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">waitqueue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">waiting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>			<span class="cm">/* see M_XXXX */</span>
	<span class="kt">int</span> <span class="n">mstate</span><span class="p">;</span>			<span class="cm">/* Modem state: see MS_XXXX */</span>
					<span class="cm">/* only changed by the event layer */</span>
	<span class="kt">int</span> <span class="n">cmd_result</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">channels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">;</span>		<span class="cm">/* Array of struct bc_state */</span>

	<span class="kt">int</span> <span class="n">onechannel</span><span class="p">;</span>			<span class="cm">/* data and commands transmitted in one</span>
<span class="cm">					   stream (M10x) */</span>

	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">at_state_t</span> <span class="n">at_state</span><span class="p">;</span>	<span class="cm">/* at_state_t for cid == 0 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">temp_at_states</span><span class="p">;</span><span class="cm">/* list of temporary &quot;struct</span>
<span class="cm">					   at_state_t&quot;s without B channel */</span>

	<span class="k">struct</span> <span class="n">inbuf_t</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">cmdbuf_t</span> <span class="o">*</span><span class="n">cmdbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">lastcmdbuf</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">cmdlock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">curlen</span><span class="p">,</span> <span class="n">cmdbytes</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tty_port</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">if_wake_tasklet</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">control_state</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">fwver</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">gotfwver</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">running</span><span class="p">;</span>		<span class="cm">/* !=0 if events are handled */</span>
	<span class="kt">unsigned</span> <span class="n">connected</span><span class="p">;</span>		<span class="cm">/* !=0 if hardware is connected */</span>
	<span class="kt">unsigned</span> <span class="n">isdn_up</span><span class="p">;</span>		<span class="cm">/* !=0 after gigaset_isdn_start() */</span>

	<span class="kt">unsigned</span> <span class="n">cidmode</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">myid</span><span class="p">;</span>			<span class="cm">/* id for communication with LL */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">iif</span><span class="p">;</span>			<span class="cm">/* LL interface structure */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">hw_hdr_len</span><span class="p">;</span>	<span class="cm">/* headroom needed in data skbs */</span>

	<span class="k">struct</span> <span class="n">reply_t</span> <span class="o">*</span><span class="n">tabnocid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reply_t</span> <span class="o">*</span><span class="n">tabcid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cs_init</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ignoreframes</span><span class="p">;</span>		<span class="cm">/* frames to ignore after setting up the</span>
<span class="cm">					   B channel */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>		<span class="cm">/* locks this structure:</span>
<span class="cm">					 *   connected is not changed,</span>
<span class="cm">					 *   hardware_up is not changed,</span>
<span class="cm">					 *   MState is not changed to or from</span>
<span class="cm">					 *   MS_LOCKED */</span>

	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retry_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dle</span><span class="p">;</span>			<span class="cm">/* !=0 if DLE mode is active</span>
<span class="cm">					   (ZDLE=1 received -- M10x only) */</span>
	<span class="kt">int</span> <span class="n">cur_at_seq</span><span class="p">;</span>			<span class="cm">/* sequence of AT commands being</span>
<span class="cm">					   processed */</span>
	<span class="kt">int</span> <span class="n">curchannel</span><span class="p">;</span>			<span class="cm">/* channel those commands are meant</span>
<span class="cm">					   for */</span>
	<span class="kt">int</span> <span class="n">commands_pending</span><span class="p">;</span>		<span class="cm">/* flag(s) in xxx.commands_pending have</span>
<span class="cm">					   been set */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span>
		<span class="n">event_tasklet</span><span class="p">;</span>		<span class="cm">/* tasklet for serializing AT commands.</span>
<span class="cm">					 * Scheduled</span>
<span class="cm">					 *   -&gt; for modem reponses (and</span>
<span class="cm">					 *      incoming data for M10x)</span>
<span class="cm">					 *   -&gt; on timeout</span>
<span class="cm">					 *   -&gt; after setting bits in</span>
<span class="cm">					 *      xxx.at_state.pending_command</span>
<span class="cm">					 *      (e.g. command from LL) */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span>
		<span class="n">write_tasklet</span><span class="p">;</span>		<span class="cm">/* tasklet for serial output</span>
<span class="cm">					 * (not used in base driver) */</span>

	<span class="cm">/* event queue */</span>
	<span class="k">struct</span> <span class="n">event_t</span> <span class="n">events</span><span class="p">[</span><span class="n">MAX_EVENTS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">ev_tail</span><span class="p">,</span> <span class="n">ev_head</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">ev_lock</span><span class="p">;</span>

	<span class="cm">/* current modem response */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">respdata</span><span class="p">[</span><span class="n">MAX_RESP_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">cbytes</span><span class="p">;</span>

	<span class="cm">/* private data of hardware drivers */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_cardstate</span> <span class="o">*</span><span class="n">usb</span><span class="p">;</span> <span class="cm">/* USB hardware driver (m105) */</span>
		<span class="k">struct</span> <span class="n">ser_cardstate</span> <span class="o">*</span><span class="n">ser</span><span class="p">;</span> <span class="cm">/* serial hardware driver */</span>
		<span class="k">struct</span> <span class="n">bas_cardstate</span> <span class="o">*</span><span class="n">bas</span><span class="p">;</span> <span class="cm">/* USB hardware driver (base) */</span>
	<span class="p">}</span> <span class="n">hw</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">gigaset_driver</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>		<span class="cm">/* locks minor tables and blocked */</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">have_tty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">minor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">minors</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blocked</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">gigaset_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cmdbuf_t</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmdbuf_t</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">wake_tasklet</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bas_bc_state</span> <span class="p">{</span>
	<span class="cm">/* isochronous output state */</span>
	<span class="kt">int</span>		<span class="n">running</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">corrbytes</span><span class="p">;</span>
	<span class="n">spinlock_t</span>	<span class="n">isooutlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isow_urbctx_t</span>	<span class="n">isoouturbs</span><span class="p">[</span><span class="n">BAS_OUTURBS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">isow_urbctx_t</span>	<span class="o">*</span><span class="n">isooutdone</span><span class="p">,</span> <span class="o">*</span><span class="n">isooutfree</span><span class="p">,</span> <span class="o">*</span><span class="n">isooutovfl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isowbuf_t</span>	<span class="o">*</span><span class="n">isooutbuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">numsub</span><span class="p">;</span>		<span class="cm">/* submitted URB counter</span>
<span class="cm">					   (for diagnostic messages only) */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span>	<span class="n">sent_tasklet</span><span class="p">;</span>

	<span class="cm">/* isochronous input state */</span>
	<span class="n">spinlock_t</span> <span class="n">isoinlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">isoinurbs</span><span class="p">[</span><span class="n">BAS_INURBS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">isoinbuf</span><span class="p">[</span><span class="n">BAS_INBUFSIZE</span> <span class="o">*</span> <span class="n">BAS_INURBS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">isoindone</span><span class="p">;</span>		<span class="cm">/* completed isoc read URB */</span>
	<span class="kt">int</span> <span class="n">isoinstatus</span><span class="p">;</span>		<span class="cm">/* status of completed URB */</span>
	<span class="kt">int</span> <span class="n">loststatus</span><span class="p">;</span>			<span class="cm">/* status of dropped URB */</span>
	<span class="kt">unsigned</span> <span class="n">isoinlost</span><span class="p">;</span>		<span class="cm">/* number of bytes lost */</span>
	<span class="cm">/* state of bit unstuffing algorithm</span>
<span class="cm">	   (in addition to BC_state.inputstate) */</span>
	<span class="kt">unsigned</span> <span class="n">seqlen</span><span class="p">;</span>		<span class="cm">/* number of &#39;1&#39; bits not yet</span>
<span class="cm">					   unstuffed */</span>
	<span class="kt">unsigned</span> <span class="n">inbyte</span><span class="p">,</span> <span class="n">inbits</span><span class="p">;</span>	<span class="cm">/* collected bits for next byte */</span>
	<span class="cm">/* statistics */</span>
	<span class="kt">unsigned</span> <span class="n">goodbytes</span><span class="p">;</span>		<span class="cm">/* bytes correctly received */</span>
	<span class="kt">unsigned</span> <span class="n">alignerrs</span><span class="p">;</span>		<span class="cm">/* frames with incomplete byte at end */</span>
	<span class="kt">unsigned</span> <span class="n">fcserrs</span><span class="p">;</span>		<span class="cm">/* FCS errors */</span>
	<span class="kt">unsigned</span> <span class="n">frameerrs</span><span class="p">;</span>		<span class="cm">/* framing errors */</span>
	<span class="kt">unsigned</span> <span class="n">giants</span><span class="p">;</span>		<span class="cm">/* long frames */</span>
	<span class="kt">unsigned</span> <span class="n">runts</span><span class="p">;</span>			<span class="cm">/* short frames */</span>
	<span class="kt">unsigned</span> <span class="n">aborts</span><span class="p">;</span>		<span class="cm">/* HDLC aborts */</span>
	<span class="kt">unsigned</span> <span class="n">shared0s</span><span class="p">;</span>		<span class="cm">/* &#39;0&#39; bits shared between flags */</span>
	<span class="kt">unsigned</span> <span class="n">stolen0s</span><span class="p">;</span>		<span class="cm">/* &#39;0&#39; stuff bits also serving as</span>
<span class="cm">					   leading flag bits */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">rcvd_tasklet</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">gigaset_ops</span> <span class="p">{</span>
	<span class="cm">/* Called from ev-layer.c/interface.c for sending AT commands to the</span>
<span class="cm">	   device */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_cmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cmdbuf_t</span> <span class="o">*</span><span class="n">cb</span><span class="p">);</span>

	<span class="cm">/* Called from interface.c for additional device control */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_room</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">chars_in_buffer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">brkchars</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>

	<span class="cm">/* Called from ev-layer.c after setting up connection</span>
<span class="cm">	 * Should call gigaset_bchannel_up(), when finished. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init_bchannel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>

	<span class="cm">/* Called from ev-layer.c after hanging up</span>
<span class="cm">	 * Should call gigaset_bchannel_down(), when finished. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">close_bchannel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>

	<span class="cm">/* Called by gigaset_initcs() for setting up bcs-&gt;hw.xxx */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">initbcshw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>

	<span class="cm">/* Called by gigaset_freecs() for freeing bcs-&gt;hw.xxx */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">freebcshw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>

	<span class="cm">/* Called by gigaset_bchannel_down() for resetting bcs-&gt;hw.xxx */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reinitbcshw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>

	<span class="cm">/* Called by gigaset_initcs() for setting up cs-&gt;hw.xxx */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">initcshw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

	<span class="cm">/* Called by gigaset_freecs() for freeing cs-&gt;hw.xxx */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">freecshw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

	<span class="cm">/* Called from common.c/interface.c for additional serial port</span>
<span class="cm">	   control */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_modem_ctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">old_state</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="n">new_state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">baud_rate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">cflag</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_line_ctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">cflag</span><span class="p">);</span>

	<span class="cm">/* Called from LL interface to put an skb into the send-queue.</span>
<span class="cm">	 * After sending is completed, gigaset_skb_sent() must be called</span>
<span class="cm">	 * with the skb&#39;s link layer header preserved. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">send_skb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Called from ev-layer.c to process a block of data</span>
<span class="cm">	 * received through the common/control channel. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handle_input</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inbuf_t</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">);</span>

<span class="p">};</span>

<span class="cm">/* = Common structures and definitions =======================================</span>
<span class="cm"> */</span>

<span class="cm">/* Parser states for DLE-Event:</span>
<span class="cm"> * &lt;DLE-EVENT&gt;: &lt;DLE_FLAG&gt; &quot;X&quot; &lt;EVENT&gt; &lt;DLE_FLAG&gt; &quot;.&quot;</span>
<span class="cm"> * &lt;DLE_FLAG&gt;:  0x10</span>
<span class="cm"> * &lt;EVENT&gt;:     ((a-z)* | (A-Z)* | (0-10)*)+</span>
<span class="cm"> */</span>
<span class="cp">#define DLE_FLAG	0x10</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> *  Functions implemented in asyncdata.c</span>
<span class="cm"> */</span>

<span class="cm">/* Called from LL interface to put an skb into the send queue. */</span>
<span class="kt">int</span> <span class="n">gigaset_m10x_send_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/* Called from ev-layer.c to process a block of data</span>
<span class="cm"> * received through the common/control channel. */</span>
<span class="kt">void</span> <span class="n">gigaset_m10x_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">inbuf_t</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">);</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> *  Functions implemented in isocdata.c</span>
<span class="cm"> */</span>

<span class="cm">/* Called from LL interface to put an skb into the send queue. */</span>
<span class="kt">int</span> <span class="n">gigaset_isoc_send_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/* Called from ev-layer.c to process a block of data</span>
<span class="cm"> * received through the common/control channel. */</span>
<span class="kt">void</span> <span class="n">gigaset_isoc_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">inbuf_t</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">);</span>

<span class="cm">/* Called from bas-gigaset.c to process a block of data</span>
<span class="cm"> * received through the isochronous channel */</span>
<span class="kt">void</span> <span class="n">gigaset_isoc_receive</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>

<span class="cm">/* Called from bas-gigaset.c to put a block of data</span>
<span class="cm"> * into the isochronous output buffer */</span>
<span class="kt">int</span> <span class="n">gigaset_isoc_buildframe</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Called from bas-gigaset.c to initialize the isochronous output buffer */</span>
<span class="kt">void</span> <span class="n">gigaset_isowbuf_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">isowbuf_t</span> <span class="o">*</span><span class="n">iwb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">idle</span><span class="p">);</span>

<span class="cm">/* Called from bas-gigaset.c to retrieve a block of bytes for sending */</span>
<span class="kt">int</span> <span class="n">gigaset_isowbuf_getbytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">isowbuf_t</span> <span class="o">*</span><span class="n">iwb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> *  Functions implemented in LL interface</span>
<span class="cm"> */</span>

<span class="cm">/* Called from common.c for setting up/shutting down with the ISDN subsystem */</span>
<span class="kt">void</span> <span class="n">gigaset_isdn_regdrv</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_isdn_unregdrv</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">gigaset_isdn_regdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">isdnid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_isdn_unregdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

<span class="cm">/* Called from hardware module to indicate completion of an skb */</span>
<span class="kt">void</span> <span class="n">gigaset_skb_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_skb_rcvd</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_isdn_rcv_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>

<span class="cm">/* Called from common.c/ev-layer.c to indicate events relevant to the LL */</span>
<span class="kt">void</span> <span class="n">gigaset_isdn_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_isdn_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">gigaset_isdn_icall</span><span class="p">(</span><span class="k">struct</span> <span class="n">at_state_t</span> <span class="o">*</span><span class="n">at_state</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_isdn_connD</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_isdn_hupD</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_isdn_connB</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_isdn_hupB</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> *  Functions implemented in ev-layer.c</span>
<span class="cm"> */</span>

<span class="cm">/* tasklet called from common.c to process queued events */</span>
<span class="kt">void</span> <span class="n">gigaset_handle_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="cm">/* called from isocdata.c / asyncdata.c</span>
<span class="cm"> * when a complete modem response line has been received */</span>
<span class="kt">void</span> <span class="n">gigaset_handle_modem_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> *  Functions implemented in proc.c</span>
<span class="cm"> */</span>

<span class="cm">/* initialize sysfs for device */</span>
<span class="kt">void</span> <span class="n">gigaset_init_dev_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_free_dev_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> *  Functions implemented in common.c/gigaset.h</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">gigaset_bcs_reinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_at_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">at_state_t</span> <span class="o">*</span><span class="n">at_state</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">gigaset_get_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">gigaset_get_free_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_free_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">gigaset_get_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_free_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_block_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

<span class="cm">/* Allocate and initialize driver structure. */</span>
<span class="k">struct</span> <span class="n">gigaset_driver</span> <span class="o">*</span><span class="n">gigaset_initdriver</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">minor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">minors</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">procname</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">gigaset_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">);</span>

<span class="cm">/* Deallocate driver structure. */</span>
<span class="kt">void</span> <span class="n">gigaset_freedriver</span><span class="p">(</span><span class="k">struct</span> <span class="n">gigaset_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">gigaset_get_cs_by_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">gigaset_get_cs_by_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gigaset_blockdriver</span><span class="p">(</span><span class="k">struct</span> <span class="n">gigaset_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>

<span class="cm">/* Allocate and initialize card state. Calls hardware dependent</span>
<span class="cm">   gigaset_init[b]cs(). */</span>
<span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">gigaset_initcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">gigaset_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channels</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">onechannel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ignoreframes</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">cidmode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modulename</span><span class="p">);</span>

<span class="cm">/* Free card state. Calls hardware dependent gigaset_free[b]cs(). */</span>
<span class="kt">void</span> <span class="n">gigaset_freecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

<span class="cm">/* Tell common.c that hardware and driver are ready. */</span>
<span class="kt">int</span> <span class="n">gigaset_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

<span class="cm">/* Tell common.c that the device is not present any more. */</span>
<span class="kt">void</span> <span class="n">gigaset_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

<span class="cm">/* Tell common.c that the driver is being unloaded. */</span>
<span class="kt">int</span> <span class="n">gigaset_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

<span class="cm">/* Tell common.c that an skb has been sent. */</span>
<span class="kt">void</span> <span class="n">gigaset_skb_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/* Append event to the queue.</span>
<span class="cm"> * Returns NULL on failure or a pointer to the event on success.</span>
<span class="cm"> * ptr must be kmalloc()ed (and not be freed by the caller).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">event_t</span> <span class="o">*</span><span class="n">gigaset_add_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">at_state_t</span> <span class="o">*</span><span class="n">at_state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parameter</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="cm">/* Called on CONFIG1 command from frontend. */</span>
<span class="kt">int</span> <span class="n">gigaset_enterconfigmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

<span class="cm">/* cs-&gt;lock must not be locked */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gigaset_schedule_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">event_tasklet</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Tell common.c that B channel has been closed. */</span>
<span class="cm">/* cs-&gt;lock must not be locked */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gigaset_bchannel_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gigaset_add_event</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">at_state</span><span class="p">,</span> <span class="n">EV_BC_CLOSED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">gigaset_schedule_event</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Tell common.c that B channel has been opened. */</span>
<span class="cm">/* cs-&gt;lock must not be locked */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gigaset_bchannel_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gigaset_add_event</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">at_state</span><span class="p">,</span> <span class="n">EV_BC_OPEN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">gigaset_schedule_event</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* set up next receive skb for data mode */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">gigaset_new_rx_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bc_state</span> <span class="o">*</span><span class="n">bcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">hw_hdr_len</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">hw_hdr_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">ignore</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bcs</span><span class="o">-&gt;</span><span class="n">rx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bcs</span><span class="o">-&gt;</span><span class="n">rx_skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">rx_bufsize</span> <span class="o">+</span> <span class="n">hw_hdr_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">rx_skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not allocate skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">,</span> <span class="n">hw_hdr_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bcs</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* append received bytes to inbuf */</span>
<span class="kt">int</span> <span class="n">gigaset_fill_inbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">inbuf_t</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="n">numbytes</span><span class="p">);</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> *  Functions implemented in interface.c</span>
<span class="cm"> */</span>

<span class="cm">/* initialize interface */</span>
<span class="kt">void</span> <span class="n">gigaset_if_initdriver</span><span class="p">(</span><span class="k">struct</span> <span class="n">gigaset_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">procname</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">);</span>
<span class="cm">/* release interface */</span>
<span class="kt">void</span> <span class="n">gigaset_if_freedriver</span><span class="p">(</span><span class="k">struct</span> <span class="n">gigaset_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
<span class="cm">/* add minor */</span>
<span class="kt">void</span> <span class="n">gigaset_if_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="cm">/* remove minor */</span>
<span class="kt">void</span> <span class="n">gigaset_if_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="cm">/* device received data */</span>
<span class="kt">void</span> <span class="n">gigaset_if_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">cardstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
