<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › sgi-xp › xpc_main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xpc_main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004-2009 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Cross Partition Communication (XPC) support - standard version.</span>
<span class="cm"> *</span>
<span class="cm"> *	XPC provides a message passing capability that crosses partition</span>
<span class="cm"> *	boundaries. This module is made up of two parts:</span>
<span class="cm"> *</span>
<span class="cm"> *	    partition	This part detects the presence/absence of other</span>
<span class="cm"> *			partitions. It provides a heartbeat and monitors</span>
<span class="cm"> *			the heartbeats of other partitions.</span>
<span class="cm"> *</span>
<span class="cm"> *	    channel	This part manages the channels and sends/receives</span>
<span class="cm"> *			messages across them to/from other partitions.</span>
<span class="cm"> *</span>
<span class="cm"> *	There are a couple of additional functions residing in XP, which</span>
<span class="cm"> *	provide an interface to XPC for its users.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *	Caveats:</span>
<span class="cm"> *</span>
<span class="cm"> *	  . Currently on sn2, we have no way to determine which nasid an IRQ</span>
<span class="cm"> *	    came from. Thus, xpc_send_IRQ_sn2() does a remote amo write</span>
<span class="cm"> *	    followed by an IPI. The amo indicates where data is to be pulled</span>
<span class="cm"> *	    from, so after the IPI arrives, the remote partition checks the amo</span>
<span class="cm"> *	    word. The IPI can actually arrive before the amo however, so other</span>
<span class="cm"> *	    code must periodically check for this case. Also, remote amo</span>
<span class="cm"> *	    operations do not reliably time out. Thus we do a remote PIO read</span>
<span class="cm"> *	    solely to know whether the remote partition is down and whether we</span>
<span class="cm"> *	    should stop sending IPIs to it. This remote PIO read operation is</span>
<span class="cm"> *	    set up in a special nofault region so SAL knows to ignore (and</span>
<span class="cm"> *	    cleanup) any errors due to the remote amo write, PIO read, and/or</span>
<span class="cm"> *	    PIO write operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	    If/when new hardware solves this IPI problem, we should abandon</span>
<span class="cm"> *	    the current approach.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &quot;xpc.h&quot;</span>

<span class="cm">/* define two XPC debug device structures to be used with dev_dbg() et al */</span>

<span class="k">struct</span> <span class="n">device_driver</span> <span class="n">xpc_dbg_name</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;xpc&quot;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device</span> <span class="n">xpc_part_dbg_subname</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init_name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span>	<span class="cm">/* set to &quot;part&quot; at xpc_init() time */</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_dbg_name</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device</span> <span class="n">xpc_chan_dbg_subname</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init_name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span>	<span class="cm">/* set to &quot;chan&quot; at xpc_init() time */</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_dbg_name</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">xpc_part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_part_dbg_subname</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">xpc_chan</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_chan_dbg_subname</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_kdebug_ignore</span><span class="p">;</span>

<span class="cm">/* systune related variables for /proc/sys directories */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_hb_interval</span> <span class="o">=</span> <span class="n">XPC_HB_DEFAULT_INTERVAL</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_hb_min_interval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_hb_max_interval</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_hb_check_interval</span> <span class="o">=</span> <span class="n">XPC_HB_CHECK_DEFAULT_INTERVAL</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_hb_check_min_interval</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_hb_check_max_interval</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">xpc_disengage_timelimit</span> <span class="o">=</span> <span class="n">XPC_DISENGAGE_DEFAULT_TIMELIMIT</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_disengage_min_timelimit</span><span class="p">;</span>	<span class="cm">/* = 0 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_disengage_max_timelimit</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>

<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">xpc_sys_xpc_hb_dir</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">procname</span> <span class="o">=</span> <span class="s">&quot;hb_interval&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_hb_interval</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">maxlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
	 <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">proc_handler</span> <span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">extra1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_hb_min_interval</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">extra2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_hb_max_interval</span><span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">procname</span> <span class="o">=</span> <span class="s">&quot;hb_check_interval&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_hb_check_interval</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">maxlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
	 <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">proc_handler</span> <span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">extra1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_hb_check_min_interval</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">extra2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_hb_check_max_interval</span><span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">xpc_sys_xpc_dir</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">procname</span> <span class="o">=</span> <span class="s">&quot;hb&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0555</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">xpc_sys_xpc_hb_dir</span><span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">procname</span> <span class="o">=</span> <span class="s">&quot;disengage_timelimit&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_disengage_timelimit</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">maxlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
	 <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">proc_handler</span> <span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">extra1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_disengage_min_timelimit</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">extra2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_disengage_max_timelimit</span><span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">xpc_sys_dir</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">procname</span> <span class="o">=</span> <span class="s">&quot;xpc&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0555</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">xpc_sys_xpc_dir</span><span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="n">xpc_sysctl</span><span class="p">;</span>

<span class="cm">/* non-zero if any remote partition disengage was timed out */</span>
<span class="kt">int</span> <span class="n">xpc_disengage_timedout</span><span class="p">;</span>

<span class="cm">/* #of activate IRQs received and not yet processed */</span>
<span class="kt">int</span> <span class="n">xpc_activate_IRQ_rcvd</span><span class="p">;</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">xpc_activate_IRQ_rcvd_lock</span><span class="p">);</span>

<span class="cm">/* IRQ handler notifies this wait queue on receipt of an IRQ */</span>
<span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">xpc_activate_IRQ_wq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xpc_hb_check_timeout</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">xpc_hb_timer</span><span class="p">;</span>

<span class="cm">/* notification that the xpc_hb_checker thread has exited */</span>
<span class="k">static</span> <span class="n">DECLARE_COMPLETION</span><span class="p">(</span><span class="n">xpc_hb_checker_exited</span><span class="p">);</span>

<span class="cm">/* notification that the xpc_discovery thread has exited */</span>
<span class="k">static</span> <span class="n">DECLARE_COMPLETION</span><span class="p">(</span><span class="n">xpc_discovery_exited</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">xpc_kthread_waitmsgs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_system_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">xpc_reboot_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">xpc_system_reboot</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_system_die</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">xpc_die_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">xpc_system_die</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_arch_operations</span> <span class="n">xpc_arch_ops</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Timer function to enforce the timelimit on the partition disengage.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_timeout_partition_disengage</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">time_is_after_jiffies</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timeout</span><span class="p">));</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">xpc_partition_disengaged</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timeout</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">partition_engaged</span><span class="p">(</span><span class="n">XPC_PARTID</span><span class="p">(</span><span class="n">part</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Timer to produce the heartbeat.  The timer structures function is</span>
<span class="cm"> * already set when this is initially called.  A tunable is used to</span>
<span class="cm"> * specify when the next timeout should occur.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_hb_beater</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">increment_heartbeat</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_is_before_eq_jiffies</span><span class="p">(</span><span class="n">xpc_hb_check_timeout</span><span class="p">))</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_activate_IRQ_wq</span><span class="p">);</span>

	<span class="n">xpc_hb_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">xpc_hb_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_hb_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_start_hb_beater</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">heartbeat_init</span><span class="p">();</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_hb_timer</span><span class="p">);</span>
	<span class="n">xpc_hb_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">xpc_hb_beater</span><span class="p">;</span>
	<span class="n">xpc_hb_beater</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_stop_hb_beater</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_hb_timer</span><span class="p">);</span>
	<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">heartbeat_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * At periodic intervals, scan through all active partitions and ensure</span>
<span class="cm"> * their heartbeat is still active.  If not, the partition is deactivated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_check_remote_hb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">partid</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">partid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">partid</span> <span class="o">&lt;</span> <span class="n">xp_max_npartitions</span><span class="p">;</span> <span class="n">partid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xpc_exiting</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">partid</span> <span class="o">==</span> <span class="n">xp_partition_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_partitions</span><span class="p">[</span><span class="n">partid</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">==</span> <span class="n">XPC_P_AS_INACTIVE</span> <span class="o">||</span>
		    <span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">==</span> <span class="n">XPC_P_AS_DEACTIVATING</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">get_remote_heartbeat</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">xpSuccess</span><span class="p">)</span>
			<span class="n">XPC_DEACTIVATE_PARTITION</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This thread is responsible for nearly all of the partition</span>
<span class="cm"> * activation/deactivation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xpc_hb_checker</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ignore</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">force_IRQ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* this thread was marked active by xpc_hb_init() */</span>

	<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">XPC_HB_CHECK_CPU</span><span class="p">));</span>

	<span class="cm">/* set our heartbeating to other partitions into motion */</span>
	<span class="n">xpc_hb_check_timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">xpc_hb_check_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">xpc_start_hb_beater</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">xpc_exiting</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;woke up with %d ticks rem; %d IRQs have &quot;</span>
			<span class="s">&quot;been received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">xpc_hb_check_timeout</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">),</span>
			<span class="n">xpc_activate_IRQ_rcvd</span><span class="p">);</span>

		<span class="cm">/* checking of remote heartbeats is skewed by IRQ handling */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_is_before_eq_jiffies</span><span class="p">(</span><span class="n">xpc_hb_check_timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xpc_hb_check_timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">xpc_hb_check_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;checking remote heartbeats</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">xpc_check_remote_hb</span><span class="p">();</span>

			<span class="cm">/*</span>
<span class="cm">			 * On sn2 we need to periodically recheck to ensure no</span>
<span class="cm">			 * IRQ/amo pairs have been missed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_shub</span><span class="p">())</span>
				<span class="n">force_IRQ</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* check for outstanding IRQs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xpc_activate_IRQ_rcvd</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">force_IRQ</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">force_IRQ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;processing activate IRQs &quot;</span>
				<span class="s">&quot;received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">process_activate_IRQ_rcvd</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="cm">/* wait for IRQ or timeout */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">xpc_activate_IRQ_wq</span><span class="p">,</span>
					       <span class="p">(</span><span class="n">time_is_before_eq_jiffies</span><span class="p">(</span>
						<span class="n">xpc_hb_check_timeout</span><span class="p">)</span> <span class="o">||</span>
						<span class="n">xpc_activate_IRQ_rcvd</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
						<span class="n">xpc_exiting</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">xpc_stop_hb_beater</span><span class="p">();</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;heartbeat checker is exiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* mark this thread as having exited */</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_hb_checker_exited</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This thread will attempt to discover other partitions to activate</span>
<span class="cm"> * based on info provided by SAL. This new thread is short lived and</span>
<span class="cm"> * will exit once discovery is complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xpc_initiate_discovery</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ignore</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xpc_discovery</span><span class="p">();</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;discovery thread is exiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* mark this thread as having exited */</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_discovery_exited</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The first kthread assigned to a newly activated partition is the one</span>
<span class="cm"> * created by XPC HB with which it calls xpc_activating(). XPC hangs on to</span>
<span class="cm"> * that kthread until the partition is brought down, at which time that kthread</span>
<span class="cm"> * returns back to XPC HB. (The return of that kthread will signify to XPC HB</span>
<span class="cm"> * that XPC has dismantled all communication infrastructure for the associated</span>
<span class="cm"> * partition.) This kthread becomes the channel manager for that partition.</span>
<span class="cm"> *</span>
<span class="cm"> * Each active partition has a channel manager, who, besides connecting and</span>
<span class="cm"> * disconnecting channels, will ensure that each of the partition&#39;s connected</span>
<span class="cm"> * channels has the required number of assigned kthreads to get the work done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_channel_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">!=</span> <span class="n">XPC_P_AS_DEACTIVATING</span> <span class="o">||</span>
	       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels_active</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">xpc_partition_disengaged</span><span class="p">(</span><span class="n">part</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">xpc_process_sent_chctl_flags</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait until we&#39;ve been requested to activate kthreads or</span>
<span class="cm">		 * all of the channel&#39;s message queues have been torn down or</span>
<span class="cm">		 * a signal is pending.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The channel_mgr_requests is set to 1 after being awakened,</span>
<span class="cm">		 * This is done to prevent the channel mgr from making one pass</span>
<span class="cm">		 * through the loop for each request, since he will</span>
<span class="cm">		 * be servicing all the requests in one pass. The reason it&#39;s</span>
<span class="cm">		 * set to 1 instead of 0 is so that other kthreads will know</span>
<span class="cm">		 * that the channel mgr is running and won&#39;t bother trying to</span>
<span class="cm">		 * wake him up.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channel_mgr_requests</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channel_mgr_wq</span><span class="p">,</span>
				<span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channel_mgr_requests</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
				 <span class="n">part</span><span class="o">-&gt;</span><span class="n">chctl</span><span class="p">.</span><span class="n">all_flags</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
				 <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">==</span> <span class="n">XPC_P_AS_DEACTIVATING</span> <span class="o">&amp;&amp;</span>
				 <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels_active</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				 <span class="n">xpc_partition_disengaged</span><span class="p">(</span><span class="n">part</span><span class="p">))));</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channel_mgr_requests</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Guarantee that the kzalloc&#39;d memory is cacheline aligned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">xpc_kzalloc_cacheline_aligned</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* see if kzalloc will give us cachline aligned memory by default */</span>
	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">*</span><span class="n">base</span> <span class="o">==</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">*</span><span class="n">base</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">base</span><span class="p">);</span>

	<span class="cm">/* nope, we&#39;ll have to do it ourselves */</span>
	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">L1_CACHE_BYTES</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">L1_CACHE_ALIGN</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">*</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup the channel structures necessary to support XPartition Communication</span>
<span class="cm"> * between the specified remote partition and the local one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">xp_retval</span>
<span class="nf">xpc_setup_ch_structures</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ch_number</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">partid</span> <span class="o">=</span> <span class="n">XPC_PARTID</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate all of the channel structures as a contiguous chunk of</span>
<span class="cm">	 * memory.</span>
<span class="cm">	 */</span>
	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span><span class="p">)</span> <span class="o">*</span> <span class="n">XPC_MAX_NCHANNELS</span><span class="p">,</span>
				 <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_chan</span><span class="p">,</span> <span class="s">&quot;can&#39;t get memory for channels</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">xpNoMemory</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate the remote open and close args */</span>

	<span class="n">part</span><span class="o">-&gt;</span><span class="n">remote_openclose_args</span> <span class="o">=</span>
	    <span class="n">xpc_kzalloc_cacheline_aligned</span><span class="p">(</span><span class="n">XPC_OPENCLOSE_ARGS_SIZE</span><span class="p">,</span>
					  <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span>
					  <span class="n">remote_openclose_args_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">remote_openclose_args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_chan</span><span class="p">,</span> <span class="s">&quot;can&#39;t get memory for remote connect args</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xpNoMemory</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">part</span><span class="o">-&gt;</span><span class="n">chctl</span><span class="p">.</span><span class="n">all_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">chctl_lock</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channel_mgr_requests</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channel_mgr_wq</span><span class="p">);</span>

	<span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels</span> <span class="o">=</span> <span class="n">XPC_MAX_NCHANNELS</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels_active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels_engaged</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ch_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ch_number</span> <span class="o">&lt;</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels</span><span class="p">;</span> <span class="n">ch_number</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">ch_number</span><span class="p">];</span>

		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">partid</span> <span class="o">=</span> <span class="n">partid</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">ch_number</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">XPC_C_DISCONNECTED</span><span class="p">;</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_assigned</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_idle</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">n_to_notify</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">wdisconnect_wait</span><span class="p">);</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">n_on_msg_allocate_wq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">msg_allocate_wq</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">idle_wq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">setup_ch_structures</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">xpSuccess</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * With the setting of the partition setup_state to XPC_P_SS_SETUP,</span>
<span class="cm">	 * we&#39;re declaring that this partition is ready to go.</span>
<span class="cm">	 */</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">=</span> <span class="n">XPC_P_SS_SETUP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">xpSuccess</span><span class="p">;</span>

	<span class="cm">/* setup of ch structures failed */</span>
<span class="nl">out_2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">remote_openclose_args_base</span><span class="p">);</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">remote_openclose_args</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">);</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Teardown the channel structures necessary to support XPartition Communication</span>
<span class="cm"> * between the specified remote partition and the local one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_teardown_ch_structures</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels_engaged</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels_active</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make this partition inaccessible to local processes by marking it</span>
<span class="cm">	 * as no longer setup. Then wait before proceeding with the teardown</span>
<span class="cm">	 * until all existing references cease.</span>
<span class="cm">	 */</span>
	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">!=</span> <span class="n">XPC_P_SS_SETUP</span><span class="p">);</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">=</span> <span class="n">XPC_P_SS_WTEARDOWN</span><span class="p">;</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">teardown_wq</span><span class="p">,</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>

	<span class="cm">/* now we can begin tearing down the infrastructure */</span>

	<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">teardown_ch_structures</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">remote_openclose_args_base</span><span class="p">);</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">remote_openclose_args</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">);</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">part</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">=</span> <span class="n">XPC_P_SS_TORNDOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When XPC HB determines that a partition has come up, it will create a new</span>
<span class="cm"> * kthread and that kthread will call this function to attempt to set up the</span>
<span class="cm"> * basic infrastructure used for Cross Partition Communication with the newly</span>
<span class="cm"> * upped partition.</span>
<span class="cm"> *</span>
<span class="cm"> * The kthread that was created by XPC HB and which setup the XPC</span>
<span class="cm"> * infrastructure will remain assigned to the partition becoming the channel</span>
<span class="cm"> * manager for that partition until the partition is deactivating, at which</span>
<span class="cm"> * time the kthread will teardown the XPC infrastructure and then exit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xpc_activating</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__partid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">partid</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">__partid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_partitions</span><span class="p">[</span><span class="n">partid</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">partid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">partid</span> <span class="o">&gt;=</span> <span class="n">xp_max_npartitions</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">==</span> <span class="n">XPC_P_AS_DEACTIVATING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">=</span> <span class="n">XPC_P_AS_INACTIVE</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
		<span class="n">part</span><span class="o">-&gt;</span><span class="n">remote_rp_pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* indicate the thread is activating */</span>
	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">!=</span> <span class="n">XPC_P_AS_ACTIVATION_REQ</span><span class="p">);</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">=</span> <span class="n">XPC_P_AS_ACTIVATING</span><span class="p">;</span>

	<span class="n">XPC_SET_REASON</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;activating partition %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">partid</span><span class="p">);</span>

	<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">allow_hb</span><span class="p">(</span><span class="n">partid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xpc_setup_ch_structures</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="o">==</span> <span class="n">xpSuccess</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">xpc_part_ref</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>	<span class="cm">/* this will always succeed */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">make_first_contact</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="o">==</span> <span class="n">xpSuccess</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xpc_mark_partition_active</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
			<span class="n">xpc_channel_mgr</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
			<span class="cm">/* won&#39;t return until partition is deactivating */</span>
		<span class="p">}</span>

		<span class="n">xpc_part_deref</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
		<span class="n">xpc_teardown_ch_structures</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">disallow_hb</span><span class="p">(</span><span class="n">partid</span><span class="p">);</span>
	<span class="n">xpc_mark_partition_inactive</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">reason</span> <span class="o">==</span> <span class="n">xpReactivating</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* interrupting ourselves results in activating partition */</span>
		<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">request_partition_reactivation</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xpc_activate_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">partid</span> <span class="o">=</span> <span class="n">XPC_PARTID</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kthread</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">!=</span> <span class="n">XPC_P_AS_INACTIVE</span><span class="p">);</span>

	<span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">=</span> <span class="n">XPC_P_AS_ACTIVATION_REQ</span><span class="p">;</span>
	<span class="n">XPC_SET_REASON</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">xpCloneKThread</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">kthread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">xpc_activating</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u64</span><span class="p">)</span><span class="n">partid</span><span class="p">),</span> <span class="s">&quot;xpc%02d&quot;</span><span class="p">,</span>
			      <span class="n">partid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kthread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
		<span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">=</span> <span class="n">XPC_P_AS_INACTIVE</span><span class="p">;</span>
		<span class="n">XPC_SET_REASON</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">xpCloneKThreadFailed</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xpc_activate_kthreads</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idle</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_idle</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">assigned</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_assigned</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">wakeup</span><span class="p">;</span>

	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">needed</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idle</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wakeup</span> <span class="o">=</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&gt;</span> <span class="n">idle</span><span class="p">)</span> <span class="o">?</span> <span class="n">idle</span> <span class="o">:</span> <span class="n">needed</span><span class="p">;</span>
		<span class="n">needed</span> <span class="o">-=</span> <span class="n">wakeup</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_chan</span><span class="p">,</span> <span class="s">&quot;wakeup %d idle kthreads, partid=%d, &quot;</span>
			<span class="s">&quot;channel=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wakeup</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">partid</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>

		<span class="cm">/* only wakeup the requested number of kthreads */</span>
		<span class="n">wake_up_nr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">idle_wq</span><span class="p">,</span> <span class="n">wakeup</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">+</span> <span class="n">assigned</span> <span class="o">&gt;</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_assigned_limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">needed</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_assigned_limit</span> <span class="o">-</span> <span class="n">assigned</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_chan</span><span class="p">,</span> <span class="s">&quot;create %d new kthreads, partid=%d, channel=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">needed</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">partid</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>

	<span class="n">xpc_create_kthreads</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">needed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is where XPC&#39;s kthreads wait for messages to deliver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_kthread_waitmsgs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">n_of_deliverable_payloads</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">n_of_deliverable_payloads</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* deliver messages to their intended recipients */</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">n_of_deliverable_payloads</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_DISCONNECTING</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xpc_deliver_payload</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_idle</span><span class="p">)</span> <span class="o">&gt;</span>
		    <span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_idle_limit</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* too many idle kthreads on this channel */</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_idle</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_chan</span><span class="p">,</span> <span class="s">&quot;idle kthread calling &quot;</span>
			<span class="s">&quot;wait_event_interruptible_exclusive()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">wait_event_interruptible_exclusive</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">idle_wq</span><span class="p">,</span>
				<span class="p">(</span><span class="n">n_of_deliverable_payloads</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
				 <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_DISCONNECTING</span><span class="p">)));</span>

		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_idle</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_DISCONNECTING</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xpc_kthread_start</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">partid</span> <span class="o">=</span> <span class="n">XPC_UNPACK_ARG1</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">ch_number</span> <span class="o">=</span> <span class="n">XPC_UNPACK_ARG2</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_partitions</span><span class="p">[</span><span class="n">partid</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_needed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">n_of_deliverable_payloads</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">n_of_deliverable_payloads</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_chan</span><span class="p">,</span> <span class="s">&quot;kthread starting, partid=%d, channel=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">partid</span><span class="p">,</span> <span class="n">ch_number</span><span class="p">);</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">ch_number</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_DISCONNECTING</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* let registerer know that connection has been established */</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_CONNECTEDCALLOUT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XPC_C_CONNECTEDCALLOUT</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

			<span class="n">xpc_connected_callout</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XPC_C_CONNECTEDCALLOUT_MADE</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * It is possible that while the callout was being</span>
<span class="cm">			 * made that the remote partition sent some messages.</span>
<span class="cm">			 * If that is the case, we may need to activate</span>
<span class="cm">			 * additional kthreads to help deliver them. We only</span>
<span class="cm">			 * need one less than total #of messages to deliver.</span>
<span class="cm">			 */</span>
			<span class="n">n_needed</span> <span class="o">=</span> <span class="n">n_of_deliverable_payloads</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n_needed</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_DISCONNECTING</span><span class="p">))</span>
				<span class="n">xpc_activate_kthreads</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">n_needed</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">xpc_kthread_waitmsgs</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* let registerer know that connection is disconnecting */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_CONNECTEDCALLOUT_MADE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_DISCONNECTINGCALLOUT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XPC_C_DISCONNECTINGCALLOUT</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

		<span class="n">xpc_disconnect_callout</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">xpDisconnecting</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XPC_C_DISCONNECTINGCALLOUT_MADE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_assigned</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels_engaged</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">indicate_partition_disengaged</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xpc_msgqueue_deref</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_chan</span><span class="p">,</span> <span class="s">&quot;kthread exiting, partid=%d, channel=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">partid</span><span class="p">,</span> <span class="n">ch_number</span><span class="p">);</span>

	<span class="n">xpc_part_deref</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For each partition that XPC has established communications with, there is</span>
<span class="cm"> * a minimum of one kernel thread assigned to perform any operation that</span>
<span class="cm"> * may potentially sleep or block (basically the callouts to the asynchronous</span>
<span class="cm"> * functions registered via xpc_connect()).</span>
<span class="cm"> *</span>
<span class="cm"> * Additional kthreads are created and destroyed by XPC as the workload</span>
<span class="cm"> * demands.</span>
<span class="cm"> *</span>
<span class="cm"> * A kthread is assigned to one of the active channels that exists for a given</span>
<span class="cm"> * partition.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xpc_create_kthreads</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">needed</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">ignore_disconnecting</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">args</span> <span class="o">=</span> <span class="n">XPC_PACK_ARGS</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">partid</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_partitions</span><span class="p">[</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">partid</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kthread</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">indicate_partition_disengaged</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">indicate_partition_disengaged</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">needed</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * The following is done on behalf of the newly created</span>
<span class="cm">		 * kthread. That kthread is responsible for doing the</span>
<span class="cm">		 * counterpart to the following before it exits.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ignore_disconnecting</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_assigned</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* kthreads assigned had gone to zero */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
					 <span class="n">XPC_C_DISCONNECTINGCALLOUT_MADE</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_DISCONNECTING</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_assigned</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			   <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels_engaged</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">indicate_partition_engaged</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">xpc_part_ref</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
		<span class="n">xpc_msgqueue_ref</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>

		<span class="n">kthread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">xpc_kthread_start</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">,</span>
				      <span class="s">&quot;xpc%02dc%d&quot;</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">partid</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kthread</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* the fork failed */</span>

			<span class="cm">/*</span>
<span class="cm">			 * NOTE: if (ignore_disconnecting &amp;&amp;</span>
<span class="cm">			 * !(ch-&gt;flags &amp; XPC_C_DISCONNECTINGCALLOUT)) is true,</span>
<span class="cm">			 * then we&#39;ll deadlock if all other kthreads assigned</span>
<span class="cm">			 * to this channel are blocked in the channel&#39;s</span>
<span class="cm">			 * registerer, because the only thing that will unblock</span>
<span class="cm">			 * them is the xpDisconnecting callout that this</span>
<span class="cm">			 * failed kthread_run() would have made.</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_assigned</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nchannels_engaged</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">indicate_partition_disengaged</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">xpc_msgqueue_deref</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
			<span class="n">xpc_part_deref</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_assigned</span><span class="p">)</span> <span class="o">&lt;</span>
			    <span class="n">ch</span><span class="o">-&gt;</span><span class="n">kthreads_idle_limit</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Flag this as an error only if we have an</span>
<span class="cm">				 * insufficient #of kthreads for the channel</span>
<span class="cm">				 * to function.</span>
<span class="cm">				 */</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
				<span class="n">XPC_DISCONNECT_CHANNEL</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">xpLackOfResources</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">irq_flags</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xpc_disconnect_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch_number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">partid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wakeup_channel_mgr</span><span class="p">;</span>

	<span class="cm">/* now wait for all callouts to the caller&#39;s function to cease */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">partid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">partid</span> <span class="o">&lt;</span> <span class="n">xp_max_npartitions</span><span class="p">;</span> <span class="n">partid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_partitions</span><span class="p">[</span><span class="n">partid</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xpc_part_ref</span><span class="p">(</span><span class="n">part</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">ch_number</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_WDISCONNECT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xpc_part_deref</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">wdisconnect_wait</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
		<span class="n">DBUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XPC_C_DISCONNECTED</span><span class="p">));</span>
		<span class="n">wakeup_channel_mgr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">delayed_chctl_flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">!=</span> <span class="n">XPC_P_AS_DEACTIVATING</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">chctl_lock</span><span class="p">);</span>
				<span class="n">part</span><span class="o">-&gt;</span><span class="n">chctl</span><span class="p">.</span><span class="n">flags</span><span class="p">[</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">]</span> <span class="o">|=</span>
				    <span class="n">ch</span><span class="o">-&gt;</span><span class="n">delayed_chctl_flags</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">chctl_lock</span><span class="p">);</span>
				<span class="n">wakeup_channel_mgr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">delayed_chctl_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XPC_C_WDISCONNECT</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wakeup_channel_mgr</span><span class="p">)</span>
			<span class="n">xpc_wakeup_channel_mgr</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

		<span class="n">xpc_part_deref</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xpc_setup_partitions</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">partid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>

	<span class="n">xpc_partitions</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span><span class="p">)</span> <span class="o">*</span>
				 <span class="n">xp_max_npartitions</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xpc_partitions</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;can&#39;t get memory for partition structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The first few fields of each entry of xpc_partitions[] need to</span>
<span class="cm">	 * be initialized now so that calls to xpc_connect() and</span>
<span class="cm">	 * xpc_disconnect() can be made prior to the activation of any remote</span>
<span class="cm">	 * partition. NOTE THAT NONE OF THE OTHER FIELDS BELONGING TO THESE</span>
<span class="cm">	 * ENTRIES ARE MEANINGFUL UNTIL AFTER AN ENTRY&#39;S CORRESPONDING</span>
<span class="cm">	 * PARTITION HAS BEEN ACTIVATED.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">partid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">partid</span> <span class="o">&lt;</span> <span class="n">xp_max_npartitions</span><span class="p">;</span> <span class="n">partid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_partitions</span><span class="p">[</span><span class="n">partid</span><span class="p">];</span>

		<span class="n">DBUG_ON</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">part</span> <span class="o">!=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">part</span><span class="p">));</span>

		<span class="n">part</span><span class="o">-&gt;</span><span class="n">activate_IRQ_rcvd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">);</span>
		<span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">=</span> <span class="n">XPC_P_AS_INACTIVE</span><span class="p">;</span>
		<span class="n">XPC_SET_REASON</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timer</span><span class="p">);</span>
		<span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span>
		    <span class="n">xpc_timeout_partition_disengage</span><span class="p">;</span>
		<span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">part</span><span class="p">;</span>

		<span class="n">part</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">=</span> <span class="n">XPC_P_SS_UNSET</span><span class="p">;</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">teardown_wq</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">setup_partitions</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_teardown_partitions</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">teardown_partitions</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xpc_partitions</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_do_exit</span><span class="p">(</span><span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">partid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">active_part_count</span><span class="p">,</span> <span class="n">printed_waiting_msg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">printmsg_time</span><span class="p">,</span> <span class="n">disengage_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* a &#39;rmmod XPC&#39; and a &#39;reboot&#39; cannot both end up here together */</span>
	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">xpc_exiting</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let the heartbeat checker thread and the discovery thread</span>
<span class="cm">	 * (if one is running) know that they should exit. Also wake up</span>
<span class="cm">	 * the heartbeat checker thread in case it&#39;s sleeping.</span>
<span class="cm">	 */</span>
	<span class="n">xpc_exiting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_activate_IRQ_wq</span><span class="p">);</span>

	<span class="cm">/* wait for the discovery thread to exit */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_discovery_exited</span><span class="p">);</span>

	<span class="cm">/* wait for the heartbeat checker thread to exit */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_hb_checker_exited</span><span class="p">);</span>

	<span class="cm">/* sleep for a 1/3 of a second or so */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span>

	<span class="cm">/* wait for all partitions to become inactive */</span>

	<span class="n">printmsg_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">XPC_DEACTIVATE_PRINTMSG_INTERVAL</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">xpc_disengage_timedout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">active_part_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">partid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">partid</span> <span class="o">&lt;</span> <span class="n">xp_max_npartitions</span><span class="p">;</span> <span class="n">partid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_partitions</span><span class="p">[</span><span class="n">partid</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">xpc_partition_disengaged</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">==</span> <span class="n">XPC_P_AS_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">active_part_count</span><span class="o">++</span><span class="p">;</span>

			<span class="n">XPC_DEACTIVATE_PARTITION</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timeout</span> <span class="o">&gt;</span> <span class="n">disengage_timeout</span><span class="p">)</span>
				<span class="n">disengage_timeout</span> <span class="o">=</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timeout</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">any_partition_engaged</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_is_before_jiffies</span><span class="p">(</span><span class="n">printmsg_time</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_info</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;waiting for remote &quot;</span>
					 <span class="s">&quot;partitions to deactivate, timeout in &quot;</span>
					 <span class="s">&quot;%ld seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">disengage_timeout</span> <span class="o">-</span>
					 <span class="n">jiffies</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
				<span class="n">printmsg_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
				    <span class="p">(</span><span class="n">XPC_DEACTIVATE_PRINTMSG_INTERVAL</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
				<span class="n">printed_waiting_msg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">active_part_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">printed_waiting_msg</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_info</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;waiting for local partition&quot;</span>
					 <span class="s">&quot; to deactivate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">printed_waiting_msg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xpc_disengage_timedout</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_info</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;all partitions have &quot;</span>
					 <span class="s">&quot;deactivated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* sleep for a 1/3 of a second or so */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">any_partition_engaged</span><span class="p">());</span>

	<span class="n">xpc_teardown_rsvd_page</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">xpUnloading</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">unregister_die_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_die_notifier</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_reboot_notifier</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* clear the interface to XPC&#39;s functions */</span>
	<span class="n">xpc_clear_interface</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xpc_sysctl</span><span class="p">)</span>
		<span class="n">unregister_sysctl_table</span><span class="p">(</span><span class="n">xpc_sysctl</span><span class="p">);</span>

	<span class="n">xpc_teardown_partitions</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_shub</span><span class="p">())</span>
		<span class="n">xpc_exit_sn2</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_uv</span><span class="p">())</span>
		<span class="n">xpc_exit_uv</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called when the system is being rebooted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xpc_system_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">reason</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SYS_RESTART</span>:
		<span class="n">reason</span> <span class="o">=</span> <span class="n">xpSystemReboot</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_HALT</span>:
		<span class="n">reason</span> <span class="o">=</span> <span class="n">xpSystemHalt</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_POWER_OFF</span>:
		<span class="n">reason</span> <span class="o">=</span> <span class="n">xpSystemPoweroff</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">xpSystemGoingDown</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xpc_do_exit</span><span class="p">(</span><span class="n">reason</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Notify other partitions to deactivate from us by first disengaging from all</span>
<span class="cm"> * references to our memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xpc_die_deactivate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">partid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">any_engaged</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">keep_waiting</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">wait_to_print</span><span class="p">;</span>

	<span class="cm">/* keep xpc_hb_checker thread from doing anything (just in case) */</span>
	<span class="n">xpc_exiting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">disallow_all_hbs</span><span class="p">();</span>   <span class="cm">/*indicate we&#39;re deactivated */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">partid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">partid</span> <span class="o">&lt;</span> <span class="n">xp_max_npartitions</span><span class="p">;</span> <span class="n">partid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_partitions</span><span class="p">[</span><span class="n">partid</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">partition_engaged</span><span class="p">(</span><span class="n">partid</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">!=</span> <span class="n">XPC_P_AS_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">request_partition_deactivation</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
			<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">indicate_partition_disengaged</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Though we requested that all other partitions deactivate from us,</span>
<span class="cm">	 * we only wait until they&#39;ve all disengaged or we&#39;ve reached the</span>
<span class="cm">	 * defined timelimit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Given that one iteration through the following while-loop takes</span>
<span class="cm">	 * approximately 200 microseconds, calculate the #of loops to take</span>
<span class="cm">	 * before bailing and the #of loops before printing a waiting message.</span>
<span class="cm">	 */</span>
	<span class="n">keep_waiting</span> <span class="o">=</span> <span class="n">xpc_disengage_timelimit</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">wait_to_print</span> <span class="o">=</span> <span class="n">XPC_DEACTIVATE_PRINTMSG_INTERVAL</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">any_engaged</span> <span class="o">=</span> <span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">any_partition_engaged</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">any_engaged</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;all partitions have deactivated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">keep_waiting</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">partid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">partid</span> <span class="o">&lt;</span> <span class="n">xp_max_npartitions</span><span class="p">;</span>
			     <span class="n">partid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">partition_engaged</span><span class="p">(</span><span class="n">partid</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">dev_info</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;deactivate from &quot;</span>
						 <span class="s">&quot;remote partition %d timed &quot;</span>
						 <span class="s">&quot;out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">partid</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_to_print</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;waiting for remote partitions to &quot;</span>
				 <span class="s">&quot;deactivate, timeout in %ld seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">keep_waiting</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="mi">5</span><span class="p">));</span>
			<span class="n">wait_to_print</span> <span class="o">=</span> <span class="n">XPC_DEACTIVATE_PRINTMSG_INTERVAL</span> <span class="o">*</span>
			    <span class="mi">1000</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called when the system is being restarted or halted due</span>
<span class="cm"> * to some sort of system failure. If this is the case we need to notify the</span>
<span class="cm"> * other partitions to disengage from all references to our memory.</span>
<span class="cm"> * This function can also be called when our heartbeater could be offlined</span>
<span class="cm"> * for a time. In this case we need to notify other partitions to not worry</span>
<span class="cm"> * about the lack of a heartbeat.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xpc_system_die</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_IA64		</span><span class="cm">/* !!! temporary kludge */</span><span class="cp"></span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DIE_MACHINE_RESTART</span>:
	<span class="k">case</span> <span class="n">DIE_MACHINE_HALT</span>:
		<span class="n">xpc_die_deactivate</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DIE_KDEBUG_ENTER</span>:
		<span class="cm">/* Should lack of heartbeat be ignored by other partitions? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xpc_kdebug_ignore</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">DIE_MCA_MONARCH_ENTER</span>:
	<span class="k">case</span> <span class="n">DIE_INIT_MONARCH_ENTER</span>:
		<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">offline_heartbeat</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DIE_KDEBUG_LEAVE</span>:
		<span class="cm">/* Is lack of heartbeat being ignored by other partitions? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xpc_kdebug_ignore</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">DIE_MCA_MONARCH_LEAVE</span>:
	<span class="k">case</span> <span class="n">DIE_INIT_MONARCH_LEAVE</span>:
		<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">online_heartbeat</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">xpc_die_deactivate</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span>
<span class="nf">xpc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kthread</span><span class="p">;</span>

	<span class="n">dev_set_name</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;part&quot;</span><span class="p">);</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="n">xpc_chan</span><span class="p">,</span> <span class="s">&quot;chan&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_shub</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The ia64-sn2 architecture supports at most 64 partitions.</span>
<span class="cm">		 * And the inability to unregister remote amos restricts us</span>
<span class="cm">		 * further to only support exactly 64 partitions on this</span>
<span class="cm">		 * architecture, no less.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xp_max_npartitions</span> <span class="o">!=</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;max #of partitions not set to 64</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">xpc_init_sn2</span><span class="p">();</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_uv</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xpc_init_uv</span><span class="p">();</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xpc_setup_partitions</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;can&#39;t get memory for partition structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xpc_sysctl</span> <span class="o">=</span> <span class="n">register_sysctl_table</span><span class="p">(</span><span class="n">xpc_sys_dir</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill the partition reserved page with the information needed by</span>
<span class="cm">	 * other partitions to discover we are alive and establish initial</span>
<span class="cm">	 * communications.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xpc_setup_rsvd_page</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;can&#39;t setup our reserved page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* add ourselves to the reboot_notifier_list */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_reboot_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;can&#39;t register reboot notifier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* add ourselves to the die_notifier list */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_die_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_die_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;can&#39;t register die notifier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The real work-horse behind xpc.  This processes incoming</span>
<span class="cm">	 * interrupts and monitors remote heartbeats.</span>
<span class="cm">	 */</span>
	<span class="n">kthread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">xpc_hb_checker</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">XPC_HB_CHECK_THREAD_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kthread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;failed while forking hb check thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Startup a thread that will attempt to discover other partitions to</span>
<span class="cm">	 * activate based on info provided by SAL. This new thread is short</span>
<span class="cm">	 * lived and will exit once discovery is complete.</span>
<span class="cm">	 */</span>
	<span class="n">kthread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">xpc_initiate_discovery</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			      <span class="n">XPC_DISCOVERY_THREAD_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kthread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;failed while forking discovery thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* mark this new thread as a non-starter */</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_discovery_exited</span><span class="p">);</span>

		<span class="n">xpc_do_exit</span><span class="p">(</span><span class="n">xpUnloading</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set the interface to point at XPC&#39;s functions */</span>
	<span class="n">xpc_set_interface</span><span class="p">(</span><span class="n">xpc_initiate_connect</span><span class="p">,</span> <span class="n">xpc_initiate_disconnect</span><span class="p">,</span>
			  <span class="n">xpc_initiate_send</span><span class="p">,</span> <span class="n">xpc_initiate_send_notify</span><span class="p">,</span>
			  <span class="n">xpc_initiate_received</span><span class="p">,</span> <span class="n">xpc_initiate_partid_to_nasids</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* initialization was not successful */</span>
<span class="nl">out_3:</span>
	<span class="n">xpc_teardown_rsvd_page</span><span class="p">();</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">unregister_die_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_die_notifier</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_reboot_notifier</span><span class="p">);</span>
<span class="nl">out_2:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xpc_sysctl</span><span class="p">)</span>
		<span class="n">unregister_sysctl_table</span><span class="p">(</span><span class="n">xpc_sysctl</span><span class="p">);</span>

	<span class="n">xpc_teardown_partitions</span><span class="p">();</span>
<span class="nl">out_1:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_shub</span><span class="p">())</span>
		<span class="n">xpc_exit_sn2</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_uv</span><span class="p">())</span>
		<span class="n">xpc_exit_uv</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">xpc_init</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__exit</span>
<span class="nf">xpc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xpc_do_exit</span><span class="p">(</span><span class="n">xpUnloading</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">xpc_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Silicon Graphics, Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Cross Partition Communication (XPC) support&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">xpc_hb_interval</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">xpc_hb_interval</span><span class="p">,</span> <span class="s">&quot;Number of seconds between &quot;</span>
		 <span class="s">&quot;heartbeat increments.&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">xpc_hb_check_interval</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">xpc_hb_check_interval</span><span class="p">,</span> <span class="s">&quot;Number of seconds between &quot;</span>
		 <span class="s">&quot;heartbeat checks.&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">xpc_disengage_timelimit</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">xpc_disengage_timelimit</span><span class="p">,</span> <span class="s">&quot;Number of seconds to wait &quot;</span>
		 <span class="s">&quot;for disengage to complete.&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">xpc_kdebug_ignore</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">xpc_kdebug_ignore</span><span class="p">,</span> <span class="s">&quot;Should lack of heartbeat be ignored by &quot;</span>
		 <span class="s">&quot;other partitions when dropping into kdebug.&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
