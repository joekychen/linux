<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › sgi-xp › xpc_partition.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xpc_partition.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004-2008 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Cross Partition Communication (XPC) partition support.</span>
<span class="cm"> *</span>
<span class="cm"> *	This is the part of XPC that detects the presence/absence of</span>
<span class="cm"> *	other partitions. It provides a heartbeat and monitors the</span>
<span class="cm"> *	heartbeats of other partitions.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;xpc.h&quot;</span>
<span class="cp">#include &lt;asm/uv/uv_hub.h&gt;</span>

<span class="cm">/* XPC is exiting flag */</span>
<span class="kt">int</span> <span class="n">xpc_exiting</span><span class="p">;</span>

<span class="cm">/* this partition&#39;s reserved page pointers */</span>
<span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="n">xpc_rsvd_page</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">xpc_part_nasids</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">xpc_mach_nasids</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">xpc_nasid_mask_nbytes</span><span class="p">;</span>	<span class="cm">/* #of bytes in nasid mask */</span>
<span class="kt">int</span> <span class="n">xpc_nasid_mask_nlongs</span><span class="p">;</span>	<span class="cm">/* #of longs in nasid mask */</span>

<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">xpc_partitions</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Guarantee that the kmalloc&#39;d memory is cacheline aligned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">xpc_kmalloc_cacheline_aligned</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* see if kmalloc will give us cachline aligned memory by default */</span>
	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">*</span><span class="n">base</span> <span class="o">==</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">*</span><span class="n">base</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">base</span><span class="p">);</span>

	<span class="cm">/* nope, we&#39;ll have to do it ourselves */</span>
	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">L1_CACHE_BYTES</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">L1_CACHE_ALIGN</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">*</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given a nasid, get the physical address of the  partition&#39;s reserved page</span>
<span class="cm"> * for that nasid. This function returns 0 on any error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">xpc_get_rsvd_page_pa</span><span class="p">(</span><span class="kt">int</span> <span class="n">nasid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rp_pa</span> <span class="o">=</span> <span class="n">nasid</span><span class="p">;</span>	<span class="cm">/* seed with nasid */</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">buf_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">get_partition_rsvd_page_pa</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">get_partition_rsvd_page_pa</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* !!! rp_pa will need to be _gpa on UV.</span>
<span class="cm">		 * ??? So do we save it into the architecture specific parts</span>
<span class="cm">		 * ??? of the xpc_partition structure? Do we rename this</span>
<span class="cm">		 * ??? function or have two versions? Rename rp_pa for UV to</span>
<span class="cm">		 * ??? rp_gpa?</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_partition_rsvd_page_pa</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rp_pa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;SAL returned with ret=%d, cookie=0x%016lx, &quot;</span>
			<span class="s">&quot;address=0x%016lx, len=0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cookie</span><span class="p">,</span> <span class="n">rp_pa</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">xpNeedMoreInfo</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* !!! L1_CACHE_ALIGN() is only a sn2-bte_copy requirement */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_shub</span><span class="p">())</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">buf_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">buf_base</span><span class="p">);</span>
			<span class="n">buf_len</span> <span class="o">=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="n">xpc_kmalloc_cacheline_aligned</span><span class="p">(</span><span class="n">buf_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
							    <span class="o">&amp;</span><span class="n">buf_base</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;unable to kmalloc &quot;</span>
					<span class="s">&quot;len=0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">xpNoMemory</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">xp_remote_memcpy</span><span class="p">(</span><span class="n">xp_pa</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">rp_pa</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">xpSuccess</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;xp_remote_memcpy failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">xpSuccess</span><span class="p">)</span>
		<span class="n">rp_pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;reserved page at phys address 0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rp_pa</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rp_pa</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fill the partition reserved page with the information needed by</span>
<span class="cm"> * other partitions to discover we are alive and establish initial</span>
<span class="cm"> * communications.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xpc_setup_rsvd_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rp_pa</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_ts_jiffies</span><span class="p">;</span>

	<span class="cm">/* get the local reserved page&#39;s address */</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">rp_pa</span> <span class="o">=</span> <span class="n">xpc_get_rsvd_page_pa</span><span class="p">(</span><span class="n">xp_cpu_to_nasid</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()));</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp_pa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;SAL failed to locate the reserved page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">xp_socket_pa</span><span class="p">(</span><span class="n">rp_pa</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SAL_version</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* SAL_versions &lt; 3 had a SAL_partid defined as a u8 */</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">SAL_partid</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SAL_partid</span> <span class="o">!=</span> <span class="n">xp_partition_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SAL_partid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">SAL_partid</span> <span class="o">&gt;=</span> <span class="n">xp_max_npartitions</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;the reserved page&#39;s partid of %d is outside &quot;</span>
			<span class="s">&quot;supported range (&lt; 0 || &gt;= %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">SAL_partid</span><span class="p">,</span>
			<span class="n">xp_max_npartitions</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">XPC_RP_VERSION</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">max_npartitions</span> <span class="o">=</span> <span class="n">xp_max_npartitions</span><span class="p">;</span>

	<span class="cm">/* establish the actual sizes of the nasid masks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SAL_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* SAL_version 1 didn&#39;t set the nasids_size field */</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">SAL_nasids_size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xpc_nasid_mask_nbytes</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">SAL_nasids_size</span><span class="p">;</span>
	<span class="n">xpc_nasid_mask_nlongs</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SAL_nasids_size</span> <span class="o">*</span>
					      <span class="n">BITS_PER_BYTE</span><span class="p">);</span>

	<span class="cm">/* setup the pointers to the various items in the reserved page */</span>
	<span class="n">xpc_part_nasids</span> <span class="o">=</span> <span class="n">XPC_RP_PART_NASIDS</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="n">xpc_mach_nasids</span> <span class="o">=</span> <span class="n">XPC_RP_MACH_NASIDS</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">setup_rsvd_page</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set timestamp of when reserved page was setup by XPC.</span>
<span class="cm">	 * This signifies to the remote partition that our reserved</span>
<span class="cm">	 * page is initialized.</span>
<span class="cm">	 */</span>
	<span class="n">new_ts_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_ts_jiffies</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">new_ts_jiffies</span> <span class="o">==</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span><span class="p">)</span>
		<span class="n">new_ts_jiffies</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span> <span class="o">=</span> <span class="n">new_ts_jiffies</span><span class="p">;</span>

	<span class="n">xpc_rsvd_page</span> <span class="o">=</span> <span class="n">rp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xpc_teardown_rsvd_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* a zero timestamp indicates our rsvd page is not initialized */</span>
	<span class="n">xpc_rsvd_page</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a copy of a portion of the remote partition&#39;s rsvd page.</span>
<span class="cm"> *</span>
<span class="cm"> * remote_rp points to a buffer that is cacheline aligned for BTE copies and</span>
<span class="cm"> * is large enough to contain a copy of their reserved page header and</span>
<span class="cm"> * part_nasids mask.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xp_retval</span>
<span class="nf">xpc_get_remote_rp</span><span class="p">(</span><span class="kt">int</span> <span class="n">nasid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">discovered_nasids</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="n">remote_rp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">remote_rp_pa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* get the reserved page&#39;s physical address */</span>

	<span class="o">*</span><span class="n">remote_rp_pa</span> <span class="o">=</span> <span class="n">xpc_get_rsvd_page_pa</span><span class="p">(</span><span class="n">nasid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">remote_rp_pa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xpNoRsvdPageAddr</span><span class="p">;</span>

	<span class="cm">/* pull over the reserved page header and part_nasids mask */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xp_remote_memcpy</span><span class="p">(</span><span class="n">xp_pa</span><span class="p">(</span><span class="n">remote_rp</span><span class="p">),</span> <span class="o">*</span><span class="n">remote_rp_pa</span><span class="p">,</span>
			       <span class="n">XPC_RP_HEADER_SIZE</span> <span class="o">+</span> <span class="n">xpc_nasid_mask_nbytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">xpSuccess</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">discovered_nasids</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">remote_part_nasids</span> <span class="o">=</span>
		    <span class="n">XPC_RP_PART_NASIDS</span><span class="p">(</span><span class="n">remote_rp</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">xpc_nasid_mask_nlongs</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span>
			<span class="n">discovered_nasids</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">|=</span> <span class="n">remote_part_nasids</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/* zero timestamp indicates the reserved page has not been setup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remote_rp</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xpRsvdPageNotSet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XPC_VERSION_MAJOR</span><span class="p">(</span><span class="n">remote_rp</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">XPC_VERSION_MAJOR</span><span class="p">(</span><span class="n">XPC_RP_VERSION</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">xpBadVersion</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check that both remote and local partids are valid for each side */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remote_rp</span><span class="o">-&gt;</span><span class="n">SAL_partid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">remote_rp</span><span class="o">-&gt;</span><span class="n">SAL_partid</span> <span class="o">&gt;=</span> <span class="n">xp_max_npartitions</span> <span class="o">||</span>
	    <span class="n">remote_rp</span><span class="o">-&gt;</span><span class="n">max_npartitions</span> <span class="o">&lt;=</span> <span class="n">xp_partition_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">xpInvalidPartid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remote_rp</span><span class="o">-&gt;</span><span class="n">SAL_partid</span> <span class="o">==</span> <span class="n">xp_partition_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xpLocalPartid</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">xpSuccess</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See if the other side has responded to a partition deactivate request</span>
<span class="cm"> * from us. Though we requested the remote partition to deactivate with regard</span>
<span class="cm"> * to us, we really only need to wait for the other side to disengage from us.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xpc_partition_disengaged</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">partid</span> <span class="o">=</span> <span class="n">XPC_PARTID</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">disengaged</span><span class="p">;</span>

	<span class="n">disengaged</span> <span class="o">=</span> <span class="o">!</span><span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">partition_engaged</span><span class="p">(</span><span class="n">partid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disengaged</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_is_after_jiffies</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timeout</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* timelimit hasn&#39;t been reached yet */</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Other side hasn&#39;t responded to our deactivate</span>
<span class="cm">			 * request in a timely fashion, so assume it&#39;s dead.</span>
<span class="cm">			 */</span>

			<span class="n">dev_info</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;deactivate request to remote &quot;</span>
				 <span class="s">&quot;partition %d timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">partid</span><span class="p">);</span>
			<span class="n">xpc_disengage_timedout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">assume_partition_disengaged</span><span class="p">(</span><span class="n">partid</span><span class="p">);</span>
			<span class="n">disengaged</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* cancel the timer function, provided it&#39;s not us */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_interrupt</span><span class="p">())</span>
			<span class="n">del_singleshot_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timer</span><span class="p">);</span>

		<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">!=</span> <span class="n">XPC_P_AS_DEACTIVATING</span> <span class="o">&amp;&amp;</span>
			<span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">!=</span> <span class="n">XPC_P_AS_INACTIVE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">!=</span> <span class="n">XPC_P_AS_INACTIVE</span><span class="p">)</span>
			<span class="n">xpc_wakeup_channel_mgr</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

		<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">cancel_partition_deactivation_request</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">disengaged</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark specified partition as active.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xp_retval</span>
<span class="nf">xpc_mark_partition_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;setting partition %d to ACTIVE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">XPC_PARTID</span><span class="p">(</span><span class="n">part</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">==</span> <span class="n">XPC_P_AS_ACTIVATING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">=</span> <span class="n">XPC_P_AS_ACTIVE</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xpSuccess</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">reason</span> <span class="o">==</span> <span class="n">xpSuccess</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">reason</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start the process of deactivating the specified partition.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xpc_deactivate_partition</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">==</span> <span class="n">XPC_P_AS_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">XPC_SET_REASON</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">xpReactivating</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we interrupt ourselves to reactivate partition */</span>
			<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">request_partition_reactivation</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">==</span> <span class="n">XPC_P_AS_DEACTIVATING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">reason</span> <span class="o">==</span> <span class="n">xpUnloading</span> <span class="o">&amp;&amp;</span> <span class="n">reason</span> <span class="o">!=</span> <span class="n">xpUnloading</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">reason</span> <span class="o">==</span> <span class="n">xpReactivating</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">XPC_SET_REASON</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">=</span> <span class="n">XPC_P_AS_DEACTIVATING</span><span class="p">;</span>
	<span class="n">XPC_SET_REASON</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="cm">/* ask remote partition to deactivate with regard to us */</span>
	<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">request_partition_deactivation</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

	<span class="cm">/* set a timelimit on the disengage phase of the deactivation request */</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">xpc_disengage_timelimit</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timeout</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">disengage_timer</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;bringing partition %d down, reason = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">XPC_PARTID</span><span class="p">(</span><span class="n">part</span><span class="p">),</span> <span class="n">reason</span><span class="p">);</span>

	<span class="n">xpc_partition_going_down</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark specified partition as inactive.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xpc_mark_partition_inactive</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;setting partition %d to INACTIVE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">XPC_PARTID</span><span class="p">(</span><span class="n">part</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">act_state</span> <span class="o">=</span> <span class="n">XPC_P_AS_INACTIVE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">act_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">remote_rp_pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SAL has provided a partition and machine mask.  The partition mask</span>
<span class="cm"> * contains a bit for each even nasid in our partition.  The machine</span>
<span class="cm"> * mask contains a bit for each even nasid in the entire machine.</span>
<span class="cm"> *</span>
<span class="cm"> * Using those two bit arrays, we can determine which nasids are</span>
<span class="cm"> * known in the machine.  Each should also have a reserved page</span>
<span class="cm"> * initialized if they are available for partitioning.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xpc_discovery</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">remote_rp_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="n">remote_rp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remote_rp_pa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">region</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">region_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_regions</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nasid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">discovered_nasids</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">remote_rp</span> <span class="o">=</span> <span class="n">xpc_kmalloc_cacheline_aligned</span><span class="p">(</span><span class="n">XPC_RP_HEADER_SIZE</span> <span class="o">+</span>
						  <span class="n">xpc_nasid_mask_nbytes</span><span class="p">,</span>
						  <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remote_rp_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remote_rp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">discovered_nasids</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="o">*</span> <span class="n">xpc_nasid_mask_nlongs</span><span class="p">,</span>
				    <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">discovered_nasids</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">remote_rp_base</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="p">)</span><span class="n">xpc_rsvd_page</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The term &#39;region&#39; in this context refers to the minimum number of</span>
<span class="cm">	 * nodes that can comprise an access protection grouping. The access</span>
<span class="cm">	 * protection is in regards to memory, IOI and IPI.</span>
<span class="cm">	 */</span>
	<span class="n">region_size</span> <span class="o">=</span> <span class="n">xp_region_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_uv</span><span class="p">())</span>
		<span class="n">max_regions</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">max_regions</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">region_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">128</span>:
			<span class="n">max_regions</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">64</span>:
			<span class="n">max_regions</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">32</span>:
			<span class="n">max_regions</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">region_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">DBUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_shub2</span><span class="p">());</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">region</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">region</span> <span class="o">&lt;</span> <span class="n">max_regions</span><span class="p">;</span> <span class="n">region</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xpc_exiting</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;searching region %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">nasid</span> <span class="o">=</span> <span class="p">(</span><span class="n">region</span> <span class="o">*</span> <span class="n">region_size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		     <span class="n">nasid</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">region</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">region_size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span> <span class="n">nasid</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">xpc_exiting</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;checking nasid %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nasid</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">nasid</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">xpc_part_nasids</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;PROM indicates Nasid %d is &quot;</span>
					<span class="s">&quot;part of the local partition; skipping &quot;</span>
					<span class="s">&quot;region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nasid</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">nasid</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">xpc_mach_nasids</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;PROM indicates Nasid %d was &quot;</span>
					<span class="s">&quot;not on Numa-Link network at reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">nasid</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">nasid</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">discovered_nasids</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;Nasid %d is part of a &quot;</span>
					<span class="s">&quot;partition which was previously &quot;</span>
					<span class="s">&quot;discovered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nasid</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* pull over the rsvd page header &amp; part_nasids mask */</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">xpc_get_remote_rp</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">discovered_nasids</span><span class="p">,</span>
						<span class="n">remote_rp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remote_rp_pa</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">xpSuccess</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">xpc_part</span><span class="p">,</span> <span class="s">&quot;unable to get reserved page &quot;</span>
					<span class="s">&quot;from nasid %d, reason=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nasid</span><span class="p">,</span>
					<span class="n">ret</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">xpLocalPartid</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">xpc_arch_ops</span><span class="p">.</span><span class="n">request_partition_activation</span><span class="p">(</span><span class="n">remote_rp</span><span class="p">,</span>
							 <span class="n">remote_rp_pa</span><span class="p">,</span> <span class="n">nasid</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">discovered_nasids</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">remote_rp_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given a partid, get the nasids owned by that partition from the</span>
<span class="cm"> * remote partition&#39;s reserved page.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xp_retval</span>
<span class="nf">xpc_initiate_partid_to_nasids</span><span class="p">(</span><span class="kt">short</span> <span class="n">partid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">nasid_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">part_nasid_pa</span><span class="p">;</span>

	<span class="n">part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xpc_partitions</span><span class="p">[</span><span class="n">partid</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">remote_rp_pa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xpPartitionDown</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">nasid_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xpc_nasid_mask_nbytes</span><span class="p">);</span>

	<span class="n">part_nasid_pa</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">XPC_RP_PART_NASIDS</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">remote_rp_pa</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">xp_remote_memcpy</span><span class="p">(</span><span class="n">xp_pa</span><span class="p">(</span><span class="n">nasid_mask</span><span class="p">),</span> <span class="n">part_nasid_pa</span><span class="p">,</span>
				<span class="n">xpc_nasid_mask_nbytes</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
