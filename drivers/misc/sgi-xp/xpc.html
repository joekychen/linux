<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › sgi-xp › xpc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xpc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004-2009 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Cross Partition Communication (XPC) structures and macros.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _DRIVERS_MISC_SGIXP_XPC_H</span>
<span class="cp">#define _DRIVERS_MISC_SGIXP_XPC_H</span>

<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &quot;xp.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * XPC Version numbers consist of a major and minor number. XPC can always</span>
<span class="cm"> * talk to versions with same major #, and never talk to versions with a</span>
<span class="cm"> * different major #.</span>
<span class="cm"> */</span>
<span class="cp">#define _XPC_VERSION(_maj, _min)	(((_maj) &lt;&lt; 4) | ((_min) &amp; 0xf))</span>
<span class="cp">#define XPC_VERSION_MAJOR(_v)		((_v) &gt;&gt; 4)</span>
<span class="cp">#define XPC_VERSION_MINOR(_v)		((_v) &amp; 0xf)</span>

<span class="cm">/* define frequency of the heartbeat and frequency how often it&#39;s checked */</span>
<span class="cp">#define XPC_HB_DEFAULT_INTERVAL		5	</span><span class="cm">/* incr HB every x secs */</span><span class="cp"></span>
<span class="cp">#define XPC_HB_CHECK_DEFAULT_INTERVAL	20	</span><span class="cm">/* check HB every x secs */</span><span class="cp"></span>

<span class="cm">/* define the process name of HB checker and the CPU it is pinned to */</span>
<span class="cp">#define XPC_HB_CHECK_THREAD_NAME	&quot;xpc_hb&quot;</span>
<span class="cp">#define XPC_HB_CHECK_CPU		0</span>

<span class="cm">/* define the process name of the discovery thread */</span>
<span class="cp">#define XPC_DISCOVERY_THREAD_NAME	&quot;xpc_discovery&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * the reserved page</span>
<span class="cm"> *</span>
<span class="cm"> *   SAL reserves one page of memory per partition for XPC. Though a full page</span>
<span class="cm"> *   in length (16384 bytes), its starting address is not page aligned, but it</span>
<span class="cm"> *   is cacheline aligned. The reserved page consists of the following:</span>
<span class="cm"> *</span>
<span class="cm"> *   reserved page header</span>
<span class="cm"> *</span>
<span class="cm"> *     The first two 64-byte cachelines of the reserved page contain the</span>
<span class="cm"> *     header (struct xpc_rsvd_page). Before SAL initialization has completed,</span>
<span class="cm"> *     SAL has set up the following fields of the reserved page header:</span>
<span class="cm"> *     SAL_signature, SAL_version, SAL_partid, and SAL_nasids_size. The</span>
<span class="cm"> *     other fields are set up by XPC. (xpc_rsvd_page points to the local</span>
<span class="cm"> *     partition&#39;s reserved page.)</span>
<span class="cm"> *</span>
<span class="cm"> *   part_nasids mask</span>
<span class="cm"> *   mach_nasids mask</span>
<span class="cm"> *</span>
<span class="cm"> *     SAL also sets up two bitmaps (or masks), one that reflects the actual</span>
<span class="cm"> *     nasids in this partition (part_nasids), and the other that reflects</span>
<span class="cm"> *     the actual nasids in the entire machine (mach_nasids). We&#39;re only</span>
<span class="cm"> *     interested in the even numbered nasids (which contain the processors</span>
<span class="cm"> *     and/or memory), so we only need half as many bits to represent the</span>
<span class="cm"> *     nasids. When mapping nasid to bit in a mask (or bit to nasid) be sure</span>
<span class="cm"> *     to either divide or multiply by 2. The part_nasids mask is located</span>
<span class="cm"> *     starting at the first cacheline following the reserved page header. The</span>
<span class="cm"> *     mach_nasids mask follows right after the part_nasids mask. The size in</span>
<span class="cm"> *     bytes of each mask is reflected by the reserved page header field</span>
<span class="cm"> *     &#39;SAL_nasids_size&#39;. (Local partition&#39;s mask pointers are xpc_part_nasids</span>
<span class="cm"> *     and xpc_mach_nasids.)</span>
<span class="cm"> *</span>
<span class="cm"> *   vars	(ia64-sn2 only)</span>
<span class="cm"> *   vars part	(ia64-sn2 only)</span>
<span class="cm"> *</span>
<span class="cm"> *     Immediately following the mach_nasids mask are the XPC variables</span>
<span class="cm"> *     required by other partitions. First are those that are generic to all</span>
<span class="cm"> *     partitions (vars), followed on the next available cacheline by those</span>
<span class="cm"> *     which are partition specific (vars part). These are setup by XPC.</span>
<span class="cm"> *     (Local partition&#39;s vars pointers are xpc_vars and xpc_vars_part.)</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Until &#39;ts_jiffies&#39; is set non-zero, the partition XPC code has not been</span>
<span class="cm"> *       initialized.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">SAL_signature</span><span class="p">;</span>	<span class="cm">/* SAL: unique signature */</span>
	<span class="n">u64</span> <span class="n">SAL_version</span><span class="p">;</span>	<span class="cm">/* SAL: version */</span>
	<span class="kt">short</span> <span class="n">SAL_partid</span><span class="p">;</span>	<span class="cm">/* SAL: partition ID */</span>
	<span class="kt">short</span> <span class="n">max_npartitions</span><span class="p">;</span>	<span class="cm">/* value of XPC_MAX_PARTITIONS */</span>
	<span class="n">u8</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* align to next u64 in 1st 64-byte cacheline */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ts_jiffies</span><span class="p">;</span> <span class="cm">/* timestamp when rsvd pg was setup by XPC */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vars_pa</span><span class="p">;</span>	<span class="cm">/* phys addr */</span>
		<span class="p">}</span> <span class="n">sn2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">heartbeat_gpa</span><span class="p">;</span> <span class="cm">/* phys addr */</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">activate_gru_mq_desc_gpa</span><span class="p">;</span> <span class="cm">/* phys addr */</span>
		<span class="p">}</span> <span class="n">uv</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sn</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pad2</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>		<span class="cm">/* align to last u64 in 2nd 64-byte cacheline */</span>
	<span class="n">u64</span> <span class="n">SAL_nasids_size</span><span class="p">;</span>	<span class="cm">/* SAL: size of each nasid mask in bytes */</span>
<span class="p">};</span>

<span class="cp">#define XPC_RP_VERSION _XPC_VERSION(3, 0) </span><span class="cm">/* version 3.0 of the reserved page */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Define the structures by which XPC variables can be exported to other</span>
<span class="cm"> * partitions. (There are two: struct xpc_vars and struct xpc_vars_part)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The following structure describes the partition generic variables</span>
<span class="cm"> * needed by other partitions in order to properly initialize.</span>
<span class="cm"> *</span>
<span class="cm"> * struct xpc_vars version number also applies to struct xpc_vars_part.</span>
<span class="cm"> * Changes to either structure and/or related functionality should be</span>
<span class="cm"> * reflected by incrementing either the major or minor version numbers</span>
<span class="cm"> * of struct xpc_vars.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_vars_sn2</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">heartbeat</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">heartbeating_to_mask</span><span class="p">,</span> <span class="n">XP_MAX_NPARTITIONS_SN2</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">heartbeat_offline</span><span class="p">;</span>	<span class="cm">/* if 0, heartbeat should be changing */</span>
	<span class="kt">int</span> <span class="n">activate_IRQ_nasid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">activate_IRQ_phys_cpuid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vars_part_pa</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">amos_page_pa</span><span class="p">;</span><span class="cm">/* paddr of page of amos from MSPEC driver */</span>
	<span class="k">struct</span> <span class="n">amo</span> <span class="o">*</span><span class="n">amos_page</span><span class="p">;</span>	<span class="cm">/* vaddr of page of amos from MSPEC driver */</span>
<span class="p">};</span>

<span class="cp">#define XPC_V_VERSION _XPC_VERSION(3, 1)    </span><span class="cm">/* version 3.1 of the cross vars */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The following structure describes the per partition specific variables.</span>
<span class="cm"> *</span>
<span class="cm"> * An array of these structures, one per partition, will be defined. As a</span>
<span class="cm"> * partition becomes active XPC will copy the array entry corresponding to</span>
<span class="cm"> * itself from that partition. It is desirable that the size of this structure</span>
<span class="cm"> * evenly divides into a 128-byte cacheline, such that none of the entries in</span>
<span class="cm"> * this array crosses a 128-byte cacheline boundary. As it is now, each entry</span>
<span class="cm"> * occupies 64-bytes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_vars_part_sn2</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">magic</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">openclose_args_pa</span><span class="p">;</span> <span class="cm">/* phys addr of open and close args */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">GPs_pa</span><span class="p">;</span>	<span class="cm">/* physical address of Get/Put values */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">chctl_amo_pa</span><span class="p">;</span> <span class="cm">/* physical address of chctl flags&#39; amo */</span>

	<span class="kt">int</span> <span class="n">notify_IRQ_nasid</span><span class="p">;</span>	<span class="cm">/* nasid of where to send notify IRQs */</span>
	<span class="kt">int</span> <span class="n">notify_IRQ_phys_cpuid</span><span class="p">;</span>	<span class="cm">/* CPUID of where to send notify IRQs */</span>

	<span class="n">u8</span> <span class="n">nchannels</span><span class="p">;</span>		<span class="cm">/* #of defined channels supported */</span>

	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">23</span><span class="p">];</span>	<span class="cm">/* pad to a full 64 bytes */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The vars_part MAGIC numbers play a part in the first contact protocol.</span>
<span class="cm"> *</span>
<span class="cm"> * MAGIC1 indicates that the per partition specific variables for a remote</span>
<span class="cm"> * partition have been initialized by this partition.</span>
<span class="cm"> *</span>
<span class="cm"> * MAGIC2 indicates that this partition has pulled the remote partititions</span>
<span class="cm"> * per partition variables that pertain to this partition.</span>
<span class="cm"> */</span>
<span class="cp">#define XPC_VP_MAGIC1_SN2 0x0053524156435058L </span><span class="cm">/* &#39;XPCVARS\0&#39;L (little endian) */</span><span class="cp"></span>
<span class="cp">#define XPC_VP_MAGIC2_SN2 0x0073726176435058L </span><span class="cm">/* &#39;XPCvars\0&#39;L (little endian) */</span><span class="cp"></span>

<span class="cm">/* the reserved page sizes and offsets */</span>

<span class="cp">#define XPC_RP_HEADER_SIZE	L1_CACHE_ALIGN(sizeof(struct xpc_rsvd_page))</span>
<span class="cp">#define XPC_RP_VARS_SIZE	L1_CACHE_ALIGN(sizeof(struct xpc_vars_sn2))</span>

<span class="cp">#define XPC_RP_PART_NASIDS(_rp) ((unsigned long *)((u8 *)(_rp) + \</span>
<span class="cp">				 XPC_RP_HEADER_SIZE))</span>
<span class="cp">#define XPC_RP_MACH_NASIDS(_rp) (XPC_RP_PART_NASIDS(_rp) + \</span>
<span class="cp">				 xpc_nasid_mask_nlongs)</span>
<span class="cp">#define XPC_RP_VARS(_rp)	((struct xpc_vars_sn2 *) \</span>
<span class="cp">				 (XPC_RP_MACH_NASIDS(_rp) + \</span>
<span class="cp">				  xpc_nasid_mask_nlongs))</span>


<span class="cm">/*</span>
<span class="cm"> * The following structure describes the partition&#39;s heartbeat info which</span>
<span class="cm"> * will be periodically read by other partitions to determine whether this</span>
<span class="cm"> * XPC is still &#39;alive&#39;.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_heartbeat_uv</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offline</span><span class="p">;</span>	<span class="cm">/* if 0, heartbeat should be changing */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Info pertinent to a GRU message queue using a watch list for irq generation.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_gru_mq_uv</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">;</span>		<span class="cm">/* address of GRU message queue */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">;</span>	<span class="cm">/* size of GRU message queue as a power of 2 */</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>		<span class="cm">/* irq raised when message is received in mq */</span>
	<span class="kt">int</span> <span class="n">mmr_blade</span><span class="p">;</span>		<span class="cm">/* blade where watchlist was allocated from */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_offset</span><span class="p">;</span> <span class="cm">/* offset of irq mmr located on mmr_blade */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_value</span><span class="p">;</span> <span class="cm">/* value of irq mmr located on mmr_blade */</span>
	<span class="kt">int</span> <span class="n">watchlist_num</span><span class="p">;</span>	<span class="cm">/* number of watchlist allocatd by BIOS */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">gru_mq_desc</span><span class="p">;</span>	<span class="cm">/* opaque structure used by the GRU driver */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The activate_mq is used to send/receive GRU messages that affect XPC&#39;s</span>
<span class="cm"> * partition active state and channel state. This is uv only.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_activate_mq_msghdr_uv</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gru_msg_hdr</span><span class="p">;</span> <span class="cm">/* FOR GRU INTERNAL USE ONLY */</span>
	<span class="kt">short</span> <span class="n">partid</span><span class="p">;</span>		<span class="cm">/* sender&#39;s partid */</span>
	<span class="n">u8</span> <span class="n">act_state</span><span class="p">;</span>		<span class="cm">/* sender&#39;s act_state at time msg sent */</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* message&#39;s type */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rp_ts_jiffies</span><span class="p">;</span> <span class="cm">/* timestamp of sender&#39;s rp setup by XPC */</span>
<span class="p">};</span>

<span class="cm">/* activate_mq defined message types */</span>
<span class="cp">#define XPC_ACTIVATE_MQ_MSG_SYNC_ACT_STATE_UV		0</span>

<span class="cp">#define XPC_ACTIVATE_MQ_MSG_ACTIVATE_REQ_UV		1</span>
<span class="cp">#define XPC_ACTIVATE_MQ_MSG_DEACTIVATE_REQ_UV		2</span>

<span class="cp">#define XPC_ACTIVATE_MQ_MSG_CHCTL_CLOSEREQUEST_UV	3</span>
<span class="cp">#define XPC_ACTIVATE_MQ_MSG_CHCTL_CLOSEREPLY_UV		4</span>
<span class="cp">#define XPC_ACTIVATE_MQ_MSG_CHCTL_OPENREQUEST_UV	5</span>
<span class="cp">#define XPC_ACTIVATE_MQ_MSG_CHCTL_OPENREPLY_UV		6</span>
<span class="cp">#define XPC_ACTIVATE_MQ_MSG_CHCTL_OPENCOMPLETE_UV	7</span>

<span class="cp">#define XPC_ACTIVATE_MQ_MSG_MARK_ENGAGED_UV		8</span>
<span class="cp">#define XPC_ACTIVATE_MQ_MSG_MARK_DISENGAGED_UV		9</span>

<span class="k">struct</span> <span class="n">xpc_activate_mq_msg_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_activate_mq_msghdr_uv</span> <span class="n">hdr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_activate_mq_msg_activate_req_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_activate_mq_msghdr_uv</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rp_gpa</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">heartbeat_gpa</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">activate_gru_mq_desc_gpa</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_activate_mq_msg_deactivate_req_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_activate_mq_msghdr_uv</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">reason</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_activate_mq_msg_chctl_closerequest_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_activate_mq_msghdr_uv</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">ch_number</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">reason</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_activate_mq_msg_chctl_closereply_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_activate_mq_msghdr_uv</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">ch_number</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_activate_mq_msg_chctl_openrequest_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_activate_mq_msghdr_uv</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">ch_number</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">entry_size</span><span class="p">;</span>	<span class="cm">/* size of notify_mq&#39;s GRU messages */</span>
	<span class="kt">short</span> <span class="n">local_nentries</span><span class="p">;</span>	<span class="cm">/* ??? Is this needed? What is? */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_activate_mq_msg_chctl_openreply_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_activate_mq_msghdr_uv</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">ch_number</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">remote_nentries</span><span class="p">;</span>	<span class="cm">/* ??? Is this needed? What is? */</span>
	<span class="kt">short</span> <span class="n">local_nentries</span><span class="p">;</span>	<span class="cm">/* ??? Is this needed? What is? */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">notify_gru_mq_desc_gpa</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_activate_mq_msg_chctl_opencomplete_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_activate_mq_msghdr_uv</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">ch_number</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Functions registered by add_timer() or called by kernel_thread() only</span>
<span class="cm"> * allow for a single 64-bit argument. The following macros can be used to</span>
<span class="cm"> * pack and unpack two (32-bit, 16-bit or 8-bit) arguments into or out from</span>
<span class="cm"> * the passed argument.</span>
<span class="cm"> */</span>
<span class="cp">#define XPC_PACK_ARGS(_arg1, _arg2) \</span>
<span class="cp">			((((u64)_arg1) &amp; 0xffffffff) | \</span>
<span class="cp">			((((u64)_arg2) &amp; 0xffffffff) &lt;&lt; 32))</span>

<span class="cp">#define XPC_UNPACK_ARG1(_args)	(((u64)_args) &amp; 0xffffffff)</span>
<span class="cp">#define XPC_UNPACK_ARG2(_args)	((((u64)_args) &gt;&gt; 32) &amp; 0xffffffff)</span>

<span class="cm">/*</span>
<span class="cm"> * Define a Get/Put value pair (pointers) used with a message queue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_gp_sn2</span> <span class="p">{</span>
	<span class="n">s64</span> <span class="n">get</span><span class="p">;</span>		<span class="cm">/* Get value */</span>
	<span class="n">s64</span> <span class="n">put</span><span class="p">;</span>		<span class="cm">/* Put value */</span>
<span class="p">};</span>

<span class="cp">#define XPC_GP_SIZE \</span>
<span class="cp">		L1_CACHE_ALIGN(sizeof(struct xpc_gp_sn2) * XPC_MAX_NCHANNELS)</span>

<span class="cm">/*</span>
<span class="cm"> * Define a structure that contains arguments associated with opening and</span>
<span class="cm"> * closing a channel.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_openclose_args</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">reason</span><span class="p">;</span>		<span class="cm">/* reason why channel is closing */</span>
	<span class="n">u16</span> <span class="n">entry_size</span><span class="p">;</span>		<span class="cm">/* sizeof each message entry */</span>
	<span class="n">u16</span> <span class="n">remote_nentries</span><span class="p">;</span>	<span class="cm">/* #of message entries in remote msg queue */</span>
	<span class="n">u16</span> <span class="n">local_nentries</span><span class="p">;</span>	<span class="cm">/* #of message entries in local msg queue */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">local_msgqueue_pa</span><span class="p">;</span> <span class="cm">/* phys addr of local message queue */</span>
<span class="p">};</span>

<span class="cp">#define XPC_OPENCLOSE_ARGS_SIZE \</span>
<span class="cp">	      L1_CACHE_ALIGN(sizeof(struct xpc_openclose_args) * \</span>
<span class="cp">	      XPC_MAX_NCHANNELS)</span>


<span class="cm">/*</span>
<span class="cm"> * Structures to define a fifo singly-linked list.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">xpc_fifo_entry_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_fifo_entry_uv</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_fifo_head_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_fifo_entry_uv</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_fifo_entry_uv</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_entries</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Define a sn2 styled message.</span>
<span class="cm"> *</span>
<span class="cm"> * A user-defined message resides in the payload area. The max size of the</span>
<span class="cm"> * payload is defined by the user via xpc_connect().</span>
<span class="cm"> *</span>
<span class="cm"> * The size of a message entry (within a message queue) must be a 128-byte</span>
<span class="cm"> * cacheline sized multiple in order to facilitate the BTE transfer of messages</span>
<span class="cm"> * from one message queue to another.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_msg_sn2</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* FOR XPC INTERNAL USE ONLY */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>		<span class="cm">/* FOR XPC INTERNAL USE ONLY */</span>
	<span class="n">s64</span> <span class="n">number</span><span class="p">;</span>		<span class="cm">/* FOR XPC INTERNAL USE ONLY */</span>

	<span class="n">u64</span> <span class="n">payload</span><span class="p">;</span>		<span class="cm">/* user defined portion of message */</span>
<span class="p">};</span>

<span class="cm">/* struct xpc_msg_sn2 flags */</span>

<span class="cp">#define	XPC_M_SN2_DONE		0x01	</span><span class="cm">/* msg has been received/consumed */</span><span class="cp"></span>
<span class="cp">#define	XPC_M_SN2_READY		0x02	</span><span class="cm">/* msg is ready to be sent */</span><span class="cp"></span>
<span class="cp">#define	XPC_M_SN2_INTERRUPT	0x04	</span><span class="cm">/* send interrupt when msg consumed */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The format of a uv XPC notify_mq GRU message is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * A user-defined message resides in the payload area. The max size of the</span>
<span class="cm"> * payload is defined by the user via xpc_connect().</span>
<span class="cm"> *</span>
<span class="cm"> * The size of a message (payload and header) sent via the GRU must be either 1</span>
<span class="cm"> * or 2 GRU_CACHE_LINE_BYTES in length.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">xpc_notify_mq_msghdr_uv</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gru_msg_hdr</span><span class="p">;</span>	<span class="cm">/* FOR GRU INTERNAL USE ONLY */</span>
		<span class="k">struct</span> <span class="n">xpc_fifo_entry_uv</span> <span class="n">next</span><span class="p">;</span>	<span class="cm">/* FOR XPC INTERNAL USE ONLY */</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">partid</span><span class="p">;</span>		<span class="cm">/* FOR XPC INTERNAL USE ONLY */</span>
	<span class="n">u8</span> <span class="n">ch_number</span><span class="p">;</span>		<span class="cm">/* FOR XPC INTERNAL USE ONLY */</span>
	<span class="n">u8</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* FOR XPC INTERNAL USE ONLY */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msg_slot_number</span><span class="p">;</span>	<span class="cm">/* FOR XPC INTERNAL USE ONLY */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_notify_mq_msg_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_notify_mq_msghdr_uv</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">payload</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Define sn2&#39;s notify entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to notify a message&#39;s sender that their message was received</span>
<span class="cm"> * and consumed by the intended recipient.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_notify_sn2</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* type of notification */</span>

	<span class="cm">/* the following two fields are only used if type == XPC_N_CALL */</span>
	<span class="n">xpc_notify_func</span> <span class="n">func</span><span class="p">;</span>	<span class="cm">/* user&#39;s notify function */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* pointer to user&#39;s key */</span>
<span class="p">};</span>

<span class="cm">/* struct xpc_notify_sn2 type of notification */</span>

<span class="cp">#define	XPC_N_CALL	0x01	</span><span class="cm">/* notify function provided by user */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Define uv&#39;s version of the notify entry. It additionally is used to allocate</span>
<span class="cm"> * a msg slot on the remote partition into which is copied a sent message.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_send_msg_slot_uv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_fifo_entry_uv</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msg_slot_number</span><span class="p">;</span>
	<span class="n">xpc_notify_func</span> <span class="n">func</span><span class="p">;</span>	<span class="cm">/* user&#39;s notify function */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* pointer to user&#39;s key */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Define the structure that manages all the stuff required by a channel. In</span>
<span class="cm"> * particular, they are used to manage the messages sent across the channel.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is private to a partition, and is NOT shared across the</span>
<span class="cm"> * partition boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * There is an array of these structures for each remote partition. It is</span>
<span class="cm"> * allocated at the time a partition becomes active. The array contains one</span>
<span class="cm"> * of these structures for each potential channel connection to that partition.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The following is sn2 only.</span>
<span class="cm"> *</span>
<span class="cm"> * Each channel structure manages two message queues (circular buffers).</span>
<span class="cm"> * They are allocated at the time a channel connection is made. One of</span>
<span class="cm"> * these message queues (local_msgqueue) holds the locally created messages</span>
<span class="cm"> * that are destined for the remote partition. The other of these message</span>
<span class="cm"> * queues (remote_msgqueue) is a locally cached copy of the remote partition&#39;s</span>
<span class="cm"> * own local_msgqueue.</span>
<span class="cm"> *</span>
<span class="cm"> * The following is a description of the Get/Put pointers used to manage these</span>
<span class="cm"> * two message queues. Consider the local_msgqueue to be on one partition</span>
<span class="cm"> * and the remote_msgqueue to be its cached copy on another partition. A</span>
<span class="cm"> * description of what each of the lettered areas contains is included.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *                     local_msgqueue      remote_msgqueue</span>
<span class="cm"> *</span>
<span class="cm"> *                        |/////////|      |/////////|</span>
<span class="cm"> *    w_remote_GP.get --&gt; +---------+      |/////////|</span>
<span class="cm"> *                        |    F    |      |/////////|</span>
<span class="cm"> *     remote_GP.get  --&gt; +---------+      +---------+ &lt;-- local_GP-&gt;get</span>
<span class="cm"> *                        |         |      |         |</span>
<span class="cm"> *                        |         |      |    E    |</span>
<span class="cm"> *                        |         |      |         |</span>
<span class="cm"> *                        |         |      +---------+ &lt;-- w_local_GP.get</span>
<span class="cm"> *                        |    B    |      |/////////|</span>
<span class="cm"> *                        |         |      |////D////|</span>
<span class="cm"> *                        |         |      |/////////|</span>
<span class="cm"> *                        |         |      +---------+ &lt;-- w_remote_GP.put</span>
<span class="cm"> *                        |         |      |////C////|</span>
<span class="cm"> *      local_GP-&gt;put --&gt; +---------+      +---------+ &lt;-- remote_GP.put</span>
<span class="cm"> *                        |         |      |/////////|</span>
<span class="cm"> *                        |    A    |      |/////////|</span>
<span class="cm"> *                        |         |      |/////////|</span>
<span class="cm"> *     w_local_GP.put --&gt; +---------+      |/////////|</span>
<span class="cm"> *                        |/////////|      |/////////|</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *	    ( remote_GP.[get|put] are cached copies of the remote</span>
<span class="cm"> *	      partition&#39;s local_GP-&gt;[get|put], and thus their values can</span>
<span class="cm"> *	      lag behind their counterparts on the remote partition. )</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  A - Messages that have been allocated, but have not yet been sent to the</span>
<span class="cm"> *	remote partition.</span>
<span class="cm"> *</span>
<span class="cm"> *  B - Messages that have been sent, but have not yet been acknowledged by the</span>
<span class="cm"> *      remote partition as having been received.</span>
<span class="cm"> *</span>
<span class="cm"> *  C - Area that needs to be prepared for the copying of sent messages, by</span>
<span class="cm"> *	the clearing of the message flags of any previously received messages.</span>
<span class="cm"> *</span>
<span class="cm"> *  D - Area into which sent messages are to be copied from the remote</span>
<span class="cm"> *	partition&#39;s local_msgqueue and then delivered to their intended</span>
<span class="cm"> *	recipients. [ To allow for a multi-message copy, another pointer</span>
<span class="cm"> *	(next_msg_to_pull) has been added to keep track of the next message</span>
<span class="cm"> *	number needing to be copied (pulled). It chases after w_remote_GP.put.</span>
<span class="cm"> *	Any messages lying between w_local_GP.get and next_msg_to_pull have</span>
<span class="cm"> *	been copied and are ready to be delivered. ]</span>
<span class="cm"> *</span>
<span class="cm"> *  E - Messages that have been copied and delivered, but have not yet been</span>
<span class="cm"> *	acknowledged by the recipient as having been received.</span>
<span class="cm"> *</span>
<span class="cm"> *  F - Messages that have been acknowledged, but XPC has not yet notified the</span>
<span class="cm"> *	sender that the message was received by its intended recipient.</span>
<span class="cm"> *	This is also an area that needs to be prepared for the allocating of</span>
<span class="cm"> *	new messages, by the clearing of the message flags of the acknowledged</span>
<span class="cm"> *	messages.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">xpc_channel_sn2</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xpc_openclose_args</span> <span class="o">*</span><span class="n">local_openclose_args</span><span class="p">;</span> <span class="cm">/* args passed on */</span>
					     <span class="cm">/* opening or closing of channel */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">local_msgqueue_base</span><span class="p">;</span>	<span class="cm">/* base address of kmalloc&#39;d space */</span>
	<span class="k">struct</span> <span class="n">xpc_msg_sn2</span> <span class="o">*</span><span class="n">local_msgqueue</span><span class="p">;</span>	<span class="cm">/* local message queue */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">remote_msgqueue_base</span><span class="p">;</span>	<span class="cm">/* base address of kmalloc&#39;d space */</span>
	<span class="k">struct</span> <span class="n">xpc_msg_sn2</span> <span class="o">*</span><span class="n">remote_msgqueue</span><span class="p">;</span> <span class="cm">/* cached copy of remote */</span>
					   <span class="cm">/* partition&#39;s local message queue */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remote_msgqueue_pa</span><span class="p">;</span> <span class="cm">/* phys addr of remote partition&#39;s */</span>
					  <span class="cm">/* local message queue */</span>

	<span class="k">struct</span> <span class="n">xpc_notify_sn2</span> <span class="o">*</span><span class="n">notify_queue</span><span class="p">;</span><span class="cm">/* notify queue for messages sent */</span>

	<span class="cm">/* various flavors of local and remote Get/Put values */</span>

	<span class="k">struct</span> <span class="n">xpc_gp_sn2</span> <span class="o">*</span><span class="n">local_GP</span><span class="p">;</span>	<span class="cm">/* local Get/Put values */</span>
	<span class="k">struct</span> <span class="n">xpc_gp_sn2</span> <span class="n">remote_GP</span><span class="p">;</span>	<span class="cm">/* remote Get/Put values */</span>
	<span class="k">struct</span> <span class="n">xpc_gp_sn2</span> <span class="n">w_local_GP</span><span class="p">;</span>	<span class="cm">/* working local Get/Put values */</span>
	<span class="k">struct</span> <span class="n">xpc_gp_sn2</span> <span class="n">w_remote_GP</span><span class="p">;</span>	<span class="cm">/* working remote Get/Put values */</span>
	<span class="n">s64</span> <span class="n">next_msg_to_pull</span><span class="p">;</span>	<span class="cm">/* Put value of next msg to pull */</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">msg_to_pull_mutex</span><span class="p">;</span>	<span class="cm">/* next msg to pull serialization */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_channel_uv</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cached_notify_gru_mq_desc</span><span class="p">;</span> <span class="cm">/* remote partition&#39;s notify mq&#39;s */</span>
					 <span class="cm">/* gru mq descriptor */</span>

	<span class="k">struct</span> <span class="n">xpc_send_msg_slot_uv</span> <span class="o">*</span><span class="n">send_msg_slots</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">recv_msg_slots</span><span class="p">;</span>	<span class="cm">/* each slot will hold a xpc_notify_mq_msg_uv */</span>
				<span class="cm">/* structure plus the user&#39;s payload */</span>

	<span class="k">struct</span> <span class="n">xpc_fifo_head_uv</span> <span class="n">msg_slot_free_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xpc_fifo_head_uv</span> <span class="n">recv_msg_list</span><span class="p">;</span>	<span class="cm">/* deliverable payloads */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_channel</span> <span class="p">{</span>
	<span class="kt">short</span> <span class="n">partid</span><span class="p">;</span>		<span class="cm">/* ID of remote partition connected */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* lock for updating this structure */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* general flags */</span>

	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">reason</span><span class="p">;</span>	<span class="cm">/* reason why channel is disconnect&#39;g */</span>
	<span class="kt">int</span> <span class="n">reason_line</span><span class="p">;</span>	<span class="cm">/* line# disconnect initiated from */</span>

	<span class="n">u16</span> <span class="n">number</span><span class="p">;</span>		<span class="cm">/* channel # */</span>

	<span class="n">u16</span> <span class="n">entry_size</span><span class="p">;</span>		<span class="cm">/* sizeof each msg entry */</span>
	<span class="n">u16</span> <span class="n">local_nentries</span><span class="p">;</span>	<span class="cm">/* #of msg entries in local msg queue */</span>
	<span class="n">u16</span> <span class="n">remote_nentries</span><span class="p">;</span>	<span class="cm">/* #of msg entries in remote msg queue */</span>

	<span class="n">atomic_t</span> <span class="n">references</span><span class="p">;</span>	<span class="cm">/* #of external references to queues */</span>

	<span class="n">atomic_t</span> <span class="n">n_on_msg_allocate_wq</span><span class="p">;</span>	<span class="cm">/* #on msg allocation wait queue */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">msg_allocate_wq</span><span class="p">;</span>	<span class="cm">/* msg allocation wait queue */</span>

	<span class="n">u8</span> <span class="n">delayed_chctl_flags</span><span class="p">;</span>	<span class="cm">/* chctl flags received, but delayed */</span>
				<span class="cm">/* action until channel disconnected */</span>

	<span class="n">atomic_t</span> <span class="n">n_to_notify</span><span class="p">;</span>	<span class="cm">/* #of msg senders to notify */</span>

	<span class="n">xpc_channel_func</span> <span class="n">func</span><span class="p">;</span>	<span class="cm">/* user&#39;s channel function */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* pointer to user&#39;s key */</span>

	<span class="k">struct</span> <span class="n">completion</span> <span class="n">wdisconnect_wait</span><span class="p">;</span>    <span class="cm">/* wait for channel disconnect */</span>

	<span class="cm">/* kthread management related fields */</span>

	<span class="n">atomic_t</span> <span class="n">kthreads_assigned</span><span class="p">;</span>	<span class="cm">/* #of kthreads assigned to channel */</span>
	<span class="n">u32</span> <span class="n">kthreads_assigned_limit</span><span class="p">;</span>	<span class="cm">/* limit on #of kthreads assigned */</span>
	<span class="n">atomic_t</span> <span class="n">kthreads_idle</span><span class="p">;</span>	<span class="cm">/* #of kthreads idle waiting for work */</span>
	<span class="n">u32</span> <span class="n">kthreads_idle_limit</span><span class="p">;</span>	<span class="cm">/* limit on #of kthreads idle */</span>
	<span class="n">atomic_t</span> <span class="n">kthreads_active</span><span class="p">;</span>	<span class="cm">/* #of kthreads actively working */</span>

	<span class="n">wait_queue_head_t</span> <span class="n">idle_wq</span><span class="p">;</span>	<span class="cm">/* idle kthread wait queue */</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xpc_channel_sn2</span> <span class="n">sn2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xpc_channel_uv</span> <span class="n">uv</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sn</span><span class="p">;</span>

<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="cm">/* struct xpc_channel flags */</span>

<span class="cp">#define	XPC_C_WASCONNECTED	0x00000001	</span><span class="cm">/* channel was connected */</span><span class="cp"></span>

<span class="cp">#define XPC_C_ROPENCOMPLETE	0x00000002    </span><span class="cm">/* remote open channel complete */</span><span class="cp"></span>
<span class="cp">#define XPC_C_OPENCOMPLETE	0x00000004     </span><span class="cm">/* local open channel complete */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_ROPENREPLY	0x00000008	</span><span class="cm">/* remote open channel reply */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_OPENREPLY		0x00000010	</span><span class="cm">/* local open channel reply */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_ROPENREQUEST	0x00000020     </span><span class="cm">/* remote open channel request */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_OPENREQUEST	0x00000040	</span><span class="cm">/* local open channel request */</span><span class="cp"></span>

<span class="cp">#define	XPC_C_SETUP		0x00000080 </span><span class="cm">/* channel&#39;s msgqueues are alloc&#39;d */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_CONNECTEDCALLOUT	0x00000100     </span><span class="cm">/* connected callout initiated */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_CONNECTEDCALLOUT_MADE \</span>
<span class="cp">				0x00000200     </span><span class="cm">/* connected callout completed */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_CONNECTED		0x00000400	</span><span class="cm">/* local channel is connected */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_CONNECTING	0x00000800	</span><span class="cm">/* channel is being connected */</span><span class="cp"></span>

<span class="cp">#define	XPC_C_RCLOSEREPLY	0x00001000	</span><span class="cm">/* remote close channel reply */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_CLOSEREPLY	0x00002000	</span><span class="cm">/* local close channel reply */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_RCLOSEREQUEST	0x00004000    </span><span class="cm">/* remote close channel request */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_CLOSEREQUEST	0x00008000     </span><span class="cm">/* local close channel request */</span><span class="cp"></span>

<span class="cp">#define	XPC_C_DISCONNECTED	0x00010000	</span><span class="cm">/* channel is disconnected */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_DISCONNECTING	0x00020000   </span><span class="cm">/* channel is being disconnected */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_DISCONNECTINGCALLOUT \</span>
<span class="cp">				0x00040000 </span><span class="cm">/* disconnecting callout initiated */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_DISCONNECTINGCALLOUT_MADE \</span>
<span class="cp">				0x00080000 </span><span class="cm">/* disconnecting callout completed */</span><span class="cp"></span>
<span class="cp">#define	XPC_C_WDISCONNECT	0x00100000  </span><span class="cm">/* waiting for channel disconnect */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The channel control flags (chctl) union consists of a 64-bit variable which</span>
<span class="cm"> * is divided up into eight bytes, ordered from right to left. Byte zero</span>
<span class="cm"> * pertains to channel 0, byte one to channel 1, and so on. Each channel&#39;s byte</span>
<span class="cm"> * can have one or more of the chctl flags set in it.</span>
<span class="cm"> */</span>

<span class="k">union</span> <span class="n">xpc_channel_ctl_flags</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">all_flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">[</span><span class="n">XPC_MAX_NCHANNELS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* chctl flags */</span>
<span class="cp">#define	XPC_CHCTL_CLOSEREQUEST	0x01</span>
<span class="cp">#define	XPC_CHCTL_CLOSEREPLY	0x02</span>
<span class="cp">#define	XPC_CHCTL_OPENREQUEST	0x04</span>
<span class="cp">#define	XPC_CHCTL_OPENREPLY	0x08</span>
<span class="cp">#define XPC_CHCTL_OPENCOMPLETE	0x10</span>
<span class="cp">#define	XPC_CHCTL_MSGREQUEST	0x20</span>

<span class="cp">#define XPC_OPENCLOSE_CHCTL_FLAGS \</span>
<span class="cp">			(XPC_CHCTL_CLOSEREQUEST | XPC_CHCTL_CLOSEREPLY | \</span>
<span class="cp">			 XPC_CHCTL_OPENREQUEST | XPC_CHCTL_OPENREPLY | \</span>
<span class="cp">			 XPC_CHCTL_OPENCOMPLETE)</span>
<span class="cp">#define XPC_MSG_CHCTL_FLAGS	XPC_CHCTL_MSGREQUEST</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xpc_any_openclose_chctl_flags_set</span><span class="p">(</span><span class="k">union</span> <span class="n">xpc_channel_ctl_flags</span> <span class="o">*</span><span class="n">chctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ch_number</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ch_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ch_number</span> <span class="o">&lt;</span> <span class="n">XPC_MAX_NCHANNELS</span><span class="p">;</span> <span class="n">ch_number</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chctl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">ch_number</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">XPC_OPENCLOSE_CHCTL_FLAGS</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xpc_any_msg_chctl_flags_set</span><span class="p">(</span><span class="k">union</span> <span class="n">xpc_channel_ctl_flags</span> <span class="o">*</span><span class="n">chctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ch_number</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ch_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ch_number</span> <span class="o">&lt;</span> <span class="n">XPC_MAX_NCHANNELS</span><span class="p">;</span> <span class="n">ch_number</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chctl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">ch_number</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">XPC_MSG_CHCTL_FLAGS</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Manage channels on a partition basis. There is one of these structures</span>
<span class="cm"> * for each partition (a partition will never utilize the structure that</span>
<span class="cm"> * represents itself).</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">xpc_partition_sn2</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remote_amos_page_pa</span><span class="p">;</span> <span class="cm">/* paddr of partition&#39;s amos page */</span>
	<span class="kt">int</span> <span class="n">activate_IRQ_nasid</span><span class="p">;</span>	<span class="cm">/* active partition&#39;s act/deact nasid */</span>
	<span class="kt">int</span> <span class="n">activate_IRQ_phys_cpuid</span><span class="p">;</span>	<span class="cm">/* active part&#39;s act/deact phys cpuid */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remote_vars_pa</span><span class="p">;</span>	<span class="cm">/* phys addr of partition&#39;s vars */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remote_vars_part_pa</span><span class="p">;</span> <span class="cm">/* paddr of partition&#39;s vars part */</span>
	<span class="n">u8</span> <span class="n">remote_vars_version</span><span class="p">;</span>	<span class="cm">/* version# of partition&#39;s vars */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">local_GPs_base</span><span class="p">;</span>	<span class="cm">/* base address of kmalloc&#39;d space */</span>
	<span class="k">struct</span> <span class="n">xpc_gp_sn2</span> <span class="o">*</span><span class="n">local_GPs</span><span class="p">;</span>	<span class="cm">/* local Get/Put values */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">remote_GPs_base</span><span class="p">;</span>	<span class="cm">/* base address of kmalloc&#39;d space */</span>
	<span class="k">struct</span> <span class="n">xpc_gp_sn2</span> <span class="o">*</span><span class="n">remote_GPs</span><span class="p">;</span>	<span class="cm">/* copy of remote partition&#39;s local */</span>
					<span class="cm">/* Get/Put values */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remote_GPs_pa</span><span class="p">;</span> <span class="cm">/* phys addr of remote partition&#39;s local */</span>
				     <span class="cm">/* Get/Put values */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">local_openclose_args_base</span><span class="p">;</span>   <span class="cm">/* base address of kmalloc&#39;d space */</span>
	<span class="k">struct</span> <span class="n">xpc_openclose_args</span> <span class="o">*</span><span class="n">local_openclose_args</span><span class="p">;</span>      <span class="cm">/* local&#39;s args */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remote_openclose_args_pa</span><span class="p">;</span>	<span class="cm">/* phys addr of remote&#39;s args */</span>

	<span class="kt">int</span> <span class="n">notify_IRQ_nasid</span><span class="p">;</span>	<span class="cm">/* nasid of where to send notify IRQs */</span>
	<span class="kt">int</span> <span class="n">notify_IRQ_phys_cpuid</span><span class="p">;</span>	<span class="cm">/* CPUID of where to send notify IRQs */</span>
	<span class="kt">char</span> <span class="n">notify_IRQ_owner</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* notify IRQ&#39;s owner&#39;s name */</span>

	<span class="k">struct</span> <span class="n">amo</span> <span class="o">*</span><span class="n">remote_chctl_amo_va</span><span class="p">;</span> <span class="cm">/* addr of remote chctl flags&#39; amo */</span>
	<span class="k">struct</span> <span class="n">amo</span> <span class="o">*</span><span class="n">local_chctl_amo_va</span><span class="p">;</span>	<span class="cm">/* address of chctl flags&#39; amo */</span>

	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">dropped_notify_IRQ_timer</span><span class="p">;</span>	<span class="cm">/* dropped IRQ timer */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xpc_partition_uv</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">heartbeat_gpa</span><span class="p">;</span> <span class="cm">/* phys addr of partition&#39;s heartbeat */</span>
	<span class="k">struct</span> <span class="n">xpc_heartbeat_uv</span> <span class="n">cached_heartbeat</span><span class="p">;</span> <span class="cm">/* cached copy of */</span>
						  <span class="cm">/* partition&#39;s heartbeat */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">activate_gru_mq_desc_gpa</span><span class="p">;</span>	<span class="cm">/* phys addr of parititon&#39;s */</span>
						<span class="cm">/* activate mq&#39;s gru mq */</span>
						<span class="cm">/* descriptor */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cached_activate_gru_mq_desc</span><span class="p">;</span> <span class="cm">/* cached copy of partition&#39;s */</span>
					   <span class="cm">/* activate mq&#39;s gru mq descriptor */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">cached_activate_gru_mq_desc_mutex</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">flags_lock</span><span class="p">;</span>	<span class="cm">/* protect updating of flags */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* general flags */</span>
	<span class="n">u8</span> <span class="n">remote_act_state</span><span class="p">;</span>	<span class="cm">/* remote partition&#39;s act_state */</span>
	<span class="n">u8</span> <span class="n">act_state_req</span><span class="p">;</span>	<span class="cm">/* act_state request from remote partition */</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">reason</span><span class="p">;</span>	<span class="cm">/* reason for deactivate act_state request */</span>
<span class="p">};</span>

<span class="cm">/* struct xpc_partition_uv flags */</span>

<span class="cp">#define XPC_P_CACHED_ACTIVATE_GRU_MQ_DESC_UV	0x00000001</span>
<span class="cp">#define XPC_P_ENGAGED_UV			0x00000002</span>

<span class="cm">/* struct xpc_partition_uv act_state change requests */</span>

<span class="cp">#define XPC_P_ASR_ACTIVATE_UV		0x01</span>
<span class="cp">#define XPC_P_ASR_REACTIVATE_UV		0x02</span>
<span class="cp">#define XPC_P_ASR_DEACTIVATE_UV		0x03</span>

<span class="k">struct</span> <span class="n">xpc_partition</span> <span class="p">{</span>

	<span class="cm">/* XPC HB infrastructure */</span>

	<span class="n">u8</span> <span class="n">remote_rp_version</span><span class="p">;</span>	<span class="cm">/* version# of partition&#39;s rsvd pg */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remote_rp_ts_jiffies</span><span class="p">;</span> <span class="cm">/* timestamp when rsvd pg setup */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remote_rp_pa</span><span class="p">;</span>	<span class="cm">/* phys addr of partition&#39;s rsvd pg */</span>
	<span class="n">u64</span> <span class="n">last_heartbeat</span><span class="p">;</span>	<span class="cm">/* HB at last read */</span>
	<span class="n">u32</span> <span class="n">activate_IRQ_rcvd</span><span class="p">;</span>	<span class="cm">/* IRQs since activation */</span>
	<span class="n">spinlock_t</span> <span class="n">act_lock</span><span class="p">;</span>	<span class="cm">/* protect updating of act_state */</span>
	<span class="n">u8</span> <span class="n">act_state</span><span class="p">;</span>		<span class="cm">/* from XPC HB viewpoint */</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">reason</span><span class="p">;</span>	<span class="cm">/* reason partition is deactivating */</span>
	<span class="kt">int</span> <span class="n">reason_line</span><span class="p">;</span>	<span class="cm">/* line# deactivation initiated from */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">disengage_timeout</span><span class="p">;</span>	<span class="cm">/* timeout in jiffies */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">disengage_timer</span><span class="p">;</span>

	<span class="cm">/* XPC infrastructure referencing and teardown control */</span>

	<span class="n">u8</span> <span class="n">setup_state</span><span class="p">;</span>		<span class="cm">/* infrastructure setup state */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">teardown_wq</span><span class="p">;</span>	<span class="cm">/* kthread waiting to teardown infra */</span>
	<span class="n">atomic_t</span> <span class="n">references</span><span class="p">;</span>	<span class="cm">/* #of references to infrastructure */</span>

	<span class="n">u8</span> <span class="n">nchannels</span><span class="p">;</span>		<span class="cm">/* #of defined channels supported */</span>
	<span class="n">atomic_t</span> <span class="n">nchannels_active</span><span class="p">;</span>  <span class="cm">/* #of channels that are not DISCONNECTED */</span>
	<span class="n">atomic_t</span> <span class="n">nchannels_engaged</span><span class="p">;</span>  <span class="cm">/* #of channels engaged with remote part */</span>
	<span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="n">channels</span><span class="p">;</span>	<span class="cm">/* array of channel structures */</span>

	<span class="cm">/* fields used for managing channel avialability and activity */</span>

	<span class="k">union</span> <span class="n">xpc_channel_ctl_flags</span> <span class="n">chctl</span><span class="p">;</span> <span class="cm">/* chctl flags yet to be processed */</span>
	<span class="n">spinlock_t</span> <span class="n">chctl_lock</span><span class="p">;</span>	<span class="cm">/* chctl flags lock */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">remote_openclose_args_base</span><span class="p">;</span>  <span class="cm">/* base address of kmalloc&#39;d space */</span>
	<span class="k">struct</span> <span class="n">xpc_openclose_args</span> <span class="o">*</span><span class="n">remote_openclose_args</span><span class="p">;</span> <span class="cm">/* copy of remote&#39;s */</span>
							  <span class="cm">/* args */</span>

	<span class="cm">/* channel manager related fields */</span>

	<span class="n">atomic_t</span> <span class="n">channel_mgr_requests</span><span class="p">;</span>	<span class="cm">/* #of requests to activate chan mgr */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">channel_mgr_wq</span><span class="p">;</span>	<span class="cm">/* channel mgr&#39;s wait queue */</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xpc_partition_sn2</span> <span class="n">sn2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xpc_partition_uv</span> <span class="n">uv</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sn</span><span class="p">;</span>

<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">xpc_arch_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_partitions</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">teardown_partitions</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">process_activate_IRQ_rcvd</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">get_partition_rsvd_page_pa</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_rsvd_page</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">allow_hb</span><span class="p">)</span> <span class="p">(</span><span class="kt">short</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disallow_hb</span><span class="p">)</span> <span class="p">(</span><span class="kt">short</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disallow_all_hbs</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">increment_heartbeat</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">offline_heartbeat</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">online_heartbeat</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">heartbeat_init</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">heartbeat_exit</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">get_remote_heartbeat</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">request_partition_activation</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">request_partition_reactivation</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">request_partition_deactivation</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cancel_partition_deactivation_request</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_ch_structures</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">teardown_ch_structures</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">make_first_contact</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>

	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">get_chctl_all_flags</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_chctl_closerequest</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_chctl_closereply</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_chctl_openrequest</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_chctl_openreply</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_chctl_opencomplete</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">process_msg_chctl_flags</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">save_remote_msgqueue_pa</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span>
						      <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_msg_structures</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">teardown_msg_structures</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">indicate_partition_engaged</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">indicate_partition_disengaged</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">assume_partition_disengaged</span><span class="p">)</span> <span class="p">(</span><span class="kt">short</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">partition_engaged</span><span class="p">)</span> <span class="p">(</span><span class="kt">short</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">any_partition_engaged</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">n_of_deliverable_payloads</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">send_payload</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span>
					   <span class="n">u16</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">xpc_notify_func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_deliverable_payload</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">received_payload</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify_senders_of_disconnect</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* struct xpc_partition act_state values (for XPC HB) */</span>

<span class="cp">#define	XPC_P_AS_INACTIVE	0x00	</span><span class="cm">/* partition is not active */</span><span class="cp"></span>
<span class="cp">#define XPC_P_AS_ACTIVATION_REQ	0x01	</span><span class="cm">/* created thread to activate */</span><span class="cp"></span>
<span class="cp">#define XPC_P_AS_ACTIVATING	0x02	</span><span class="cm">/* activation thread started */</span><span class="cp"></span>
<span class="cp">#define XPC_P_AS_ACTIVE		0x03	</span><span class="cm">/* xpc_partition_up() was called */</span><span class="cp"></span>
<span class="cp">#define XPC_P_AS_DEACTIVATING	0x04	</span><span class="cm">/* partition deactivation initiated */</span><span class="cp"></span>

<span class="cp">#define XPC_DEACTIVATE_PARTITION(_p, _reason) \</span>
<span class="cp">			xpc_deactivate_partition(__LINE__, (_p), (_reason))</span>

<span class="cm">/* struct xpc_partition setup_state values */</span>

<span class="cp">#define XPC_P_SS_UNSET		0x00	</span><span class="cm">/* infrastructure was never setup */</span><span class="cp"></span>
<span class="cp">#define XPC_P_SS_SETUP		0x01	</span><span class="cm">/* infrastructure is setup */</span><span class="cp"></span>
<span class="cp">#define XPC_P_SS_WTEARDOWN	0x02	</span><span class="cm">/* waiting to teardown infrastructure */</span><span class="cp"></span>
<span class="cp">#define XPC_P_SS_TORNDOWN	0x03	</span><span class="cm">/* infrastructure is torndown */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * struct xpc_partition_sn2&#39;s dropped notify IRQ timer is set to wait the</span>
<span class="cm"> * following interval #of seconds before checking for dropped notify IRQs.</span>
<span class="cm"> * These can occur whenever an IRQ&#39;s associated amo write doesn&#39;t complete</span>
<span class="cm"> * until after the IRQ was received.</span>
<span class="cm"> */</span>
<span class="cp">#define XPC_DROPPED_NOTIFY_IRQ_WAIT_INTERVAL	(0.25 * HZ)</span>

<span class="cm">/* number of seconds to wait for other partitions to disengage */</span>
<span class="cp">#define XPC_DISENGAGE_DEFAULT_TIMELIMIT		90</span>

<span class="cm">/* interval in seconds to print &#39;waiting deactivation&#39; messages */</span>
<span class="cp">#define XPC_DEACTIVATE_PRINTMSG_INTERVAL	10</span>

<span class="cp">#define XPC_PARTID(_p)	((short)((_p) - &amp;xpc_partitions[0]))</span>

<span class="cm">/* found in xp_main.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xpc_registration</span> <span class="n">xpc_registrations</span><span class="p">[];</span>

<span class="cm">/* found in xpc_main.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">xpc_part</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">xpc_chan</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xpc_arch_operations</span> <span class="n">xpc_arch_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xpc_disengage_timelimit</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xpc_disengage_timedout</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xpc_activate_IRQ_rcvd</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">xpc_activate_IRQ_rcvd_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">wait_queue_head_t</span> <span class="n">xpc_activate_IRQ_wq</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">xpc_kzalloc_cacheline_aligned</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_activate_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_activate_kthreads</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_create_kthreads</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_disconnect_wait</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* found in xpc_sn2.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xpc_init_sn2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_exit_sn2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* found in xpc_uv.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xpc_init_uv</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_exit_uv</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* found in xpc_partition.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xpc_exiting</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xpc_nasid_mask_nlongs</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="n">xpc_rsvd_page</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">xpc_mach_nasids</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">xpc_partitions</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">xpc_kmalloc_cacheline_aligned</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xpc_setup_rsvd_page</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_teardown_rsvd_page</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xpc_identify_activate_IRQ_sender</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xpc_partition_disengaged</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">xpc_mark_partition_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_mark_partition_inactive</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_discovery</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">xpc_get_remote_rp</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">xpc_rsvd_page</span> <span class="o">*</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_deactivate_partition</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">xp_retval</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">xpc_initiate_partid_to_nasids</span><span class="p">(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* found in xpc_channel.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_initiate_connect</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_initiate_disconnect</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">xpc_allocate_msg_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">xpc_initiate_send</span><span class="p">(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">xpc_initiate_send_notify</span><span class="p">(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span>
					       <span class="n">xpc_notify_func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_initiate_received</span><span class="p">(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_process_sent_chctl_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_connected_callout</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_deliver_payload</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_disconnect_channel</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">xp_retval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_disconnect_callout</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">xp_retval</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_partition_going_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">xp_retval</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xpc_wakeup_channel_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channel_mgr_requests</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">channel_mgr_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These next two inlines are used to keep us from tearing down a channel&#39;s</span>
<span class="cm"> * msg queues while a thread may be referencing them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xpc_msgqueue_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xpc_msgqueue_deref</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">refs</span> <span class="o">=</span> <span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">);</span>

	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">refs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">refs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xpc_wakeup_channel_mgr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpc_partitions</span><span class="p">[</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">partid</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cp">#define XPC_DISCONNECT_CHANNEL(_ch, _reason, _irqflgs) \</span>
<span class="cp">		xpc_disconnect_channel(__LINE__, _ch, _reason, _irqflgs)</span>

<span class="cm">/*</span>
<span class="cm"> * These two inlines are used to keep us from tearing down a partition&#39;s</span>
<span class="cm"> * setup infrastructure while a thread may be referencing it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xpc_part_deref</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">refs</span> <span class="o">=</span> <span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">);</span>

	<span class="n">DBUG_ON</span><span class="p">(</span><span class="n">refs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">refs</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">==</span> <span class="n">XPC_P_SS_WTEARDOWN</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">teardown_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xpc_part_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">xpc_partition</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">setup</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">);</span>
	<span class="n">setup</span> <span class="o">=</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">==</span> <span class="n">XPC_P_SS_SETUP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">setup</span><span class="p">)</span>
		<span class="n">xpc_part_deref</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">setup</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following macro is to be used for the setting of the reason and</span>
<span class="cm"> * reason_line fields in both the struct xpc_channel and struct xpc_partition</span>
<span class="cm"> * structures.</span>
<span class="cm"> */</span>
<span class="cp">#define XPC_SET_REASON(_p, _reason, _line) \</span>
<span class="cp">	{ \</span>
<span class="cp">		(_p)-&gt;reason = _reason; \</span>
<span class="cp">		(_p)-&gt;reason_line = _line; \</span>
<span class="cp">	}</span>

<span class="cp">#endif </span><span class="cm">/* _DRIVERS_MISC_SGIXP_XPC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
