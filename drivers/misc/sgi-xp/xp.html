<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › sgi-xp › xp.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xp.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2008 Silicon Graphics, Inc. All rights reserved.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * External Cross Partition (XP) structures and defines.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _DRIVERS_MISC_SGIXP_XP_H</span>
<span class="cp">#define _DRIVERS_MISC_SGIXP_XP_H</span>

<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#if defined CONFIG_X86_UV || defined CONFIG_IA64_SGI_UV</span>
<span class="cp">#include &lt;asm/uv/uv.h&gt;</span>
<span class="cp">#define is_uv()		is_uv_system()</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef is_uv</span>
<span class="cp">#define is_uv()		0</span>
<span class="cp">#endif</span>

<span class="cp">#if defined CONFIG_IA64</span>
<span class="cp">#include &lt;asm/sn/arch.h&gt;	</span><span class="cm">/* defines is_shub1() and is_shub2() */</span><span class="cp"></span>
<span class="cp">#define is_shub()	ia64_platform_is(&quot;sn2&quot;)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef is_shub1</span>
<span class="cp">#define is_shub1()	0</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef is_shub2</span>
<span class="cp">#define is_shub2()	0</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef is_shub</span>
<span class="cp">#define is_shub()	0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef USE_DBUG_ON</span>
<span class="cp">#define DBUG_ON(condition)	BUG_ON(condition)</span>
<span class="cp">#else</span>
<span class="cp">#define DBUG_ON(condition)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Define the maximum number of partitions the system can possibly support.</span>
<span class="cm"> * It is based on the maximum number of hardware partitionable regions. The</span>
<span class="cm"> * term &#39;region&#39; in this context refers to the minimum number of nodes that</span>
<span class="cm"> * can comprise an access protection grouping. The access protection is in</span>
<span class="cm"> * regards to memory, IPI and IOI.</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum number of hardware partitionable regions is equal to the</span>
<span class="cm"> * maximum number of nodes in the entire system divided by the minimum number</span>
<span class="cm"> * of nodes that comprise an access protection grouping.</span>
<span class="cm"> */</span>
<span class="cp">#define XP_MAX_NPARTITIONS_SN2	64</span>
<span class="cp">#define XP_MAX_NPARTITIONS_UV	256</span>

<span class="cm">/*</span>
<span class="cm"> * XPC establishes channel connections between the local partition and any</span>
<span class="cm"> * other partition that is currently up. Over these channels, kernel-level</span>
<span class="cm"> * `users&#39; can communicate with their counterparts on the other partitions.</span>
<span class="cm"> *</span>
<span class="cm"> * If the need for additional channels arises, one can simply increase</span>
<span class="cm"> * XPC_MAX_NCHANNELS accordingly. If the day should come where that number</span>
<span class="cm"> * exceeds the absolute MAXIMUM number of channels possible (eight), then one</span>
<span class="cm"> * will need to make changes to the XPC code to accommodate for this.</span>
<span class="cm"> *</span>
<span class="cm"> * The absolute maximum number of channels possible is limited to eight for</span>
<span class="cm"> * performance reasons on sn2 hardware. The internal cross partition structures</span>
<span class="cm"> * require sixteen bytes per channel, and eight allows all of this</span>
<span class="cm"> * interface-shared info to fit in one 128-byte cacheline.</span>
<span class="cm"> */</span>
<span class="cp">#define XPC_MEM_CHANNEL		0	</span><span class="cm">/* memory channel number */</span><span class="cp"></span>
<span class="cp">#define	XPC_NET_CHANNEL		1	</span><span class="cm">/* network channel number */</span><span class="cp"></span>

<span class="cp">#define XPC_MAX_NCHANNELS	2	</span><span class="cm">/* max #of channels allowed */</span><span class="cp"></span>

<span class="cp">#if XPC_MAX_NCHANNELS &gt; 8</span>
<span class="cp">#error	XPC_MAX_NCHANNELS exceeds absolute MAXIMUM possible.</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Define macro, XPC_MSG_SIZE(), is provided for the user</span>
<span class="cm"> * that wants to fit as many msg entries as possible in a given memory size</span>
<span class="cm"> * (e.g. a memory page).</span>
<span class="cm"> */</span>
<span class="cp">#define XPC_MSG_MAX_SIZE	128</span>
<span class="cp">#define XPC_MSG_HDR_MAX_SIZE	16</span>
<span class="cp">#define XPC_MSG_PAYLOAD_MAX_SIZE (XPC_MSG_MAX_SIZE - XPC_MSG_HDR_MAX_SIZE)</span>

<span class="cp">#define XPC_MSG_SIZE(_payload_size) \</span>
<span class="cp">				ALIGN(XPC_MSG_HDR_MAX_SIZE + (_payload_size), \</span>
<span class="cp">				      is_uv() ? 64 : 128)</span>


<span class="cm">/*</span>
<span class="cm"> * Define the return values and values passed to user&#39;s callout functions.</span>
<span class="cm"> * (It is important to add new value codes at the end just preceding</span>
<span class="cm"> * xpUnknownReason, which must have the highest numerical value.)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">{</span>
	<span class="n">xpSuccess</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

	<span class="n">xpNotConnected</span><span class="p">,</span>		<span class="cm">/*  1: channel is not connected */</span>
	<span class="n">xpConnected</span><span class="p">,</span>		<span class="cm">/*  2: channel connected (opened) */</span>
	<span class="n">xpRETIRED1</span><span class="p">,</span>		<span class="cm">/*  3: (formerly xpDisconnected) */</span>

	<span class="n">xpMsgReceived</span><span class="p">,</span>		<span class="cm">/*  4: message received */</span>
	<span class="n">xpMsgDelivered</span><span class="p">,</span>		<span class="cm">/*  5: message delivered and acknowledged */</span>

	<span class="n">xpRETIRED2</span><span class="p">,</span>		<span class="cm">/*  6: (formerly xpTransferFailed) */</span>

	<span class="n">xpNoWait</span><span class="p">,</span>		<span class="cm">/*  7: operation would require wait */</span>
	<span class="n">xpRetry</span><span class="p">,</span>		<span class="cm">/*  8: retry operation */</span>
	<span class="n">xpTimeout</span><span class="p">,</span>		<span class="cm">/*  9: timeout in xpc_allocate_msg_wait() */</span>
	<span class="n">xpInterrupted</span><span class="p">,</span>		<span class="cm">/* 10: interrupted wait */</span>

	<span class="n">xpUnequalMsgSizes</span><span class="p">,</span>	<span class="cm">/* 11: message size disparity between sides */</span>
	<span class="n">xpInvalidAddress</span><span class="p">,</span>	<span class="cm">/* 12: invalid address */</span>

	<span class="n">xpNoMemory</span><span class="p">,</span>		<span class="cm">/* 13: no memory available for XPC structures */</span>
	<span class="n">xpLackOfResources</span><span class="p">,</span>	<span class="cm">/* 14: insufficient resources for operation */</span>
	<span class="n">xpUnregistered</span><span class="p">,</span>		<span class="cm">/* 15: channel is not registered */</span>
	<span class="n">xpAlreadyRegistered</span><span class="p">,</span>	<span class="cm">/* 16: channel is already registered */</span>

	<span class="n">xpPartitionDown</span><span class="p">,</span>	<span class="cm">/* 17: remote partition is down */</span>
	<span class="n">xpNotLoaded</span><span class="p">,</span>		<span class="cm">/* 18: XPC module is not loaded */</span>
	<span class="n">xpUnloading</span><span class="p">,</span>		<span class="cm">/* 19: this side is unloading XPC module */</span>

	<span class="n">xpBadMagic</span><span class="p">,</span>		<span class="cm">/* 20: XPC MAGIC string not found */</span>

	<span class="n">xpReactivating</span><span class="p">,</span>		<span class="cm">/* 21: remote partition was reactivated */</span>

	<span class="n">xpUnregistering</span><span class="p">,</span>	<span class="cm">/* 22: this side is unregistering channel */</span>
	<span class="n">xpOtherUnregistering</span><span class="p">,</span>	<span class="cm">/* 23: other side is unregistering channel */</span>

	<span class="n">xpCloneKThread</span><span class="p">,</span>		<span class="cm">/* 24: cloning kernel thread */</span>
	<span class="n">xpCloneKThreadFailed</span><span class="p">,</span>	<span class="cm">/* 25: cloning kernel thread failed */</span>

	<span class="n">xpNoHeartbeat</span><span class="p">,</span>		<span class="cm">/* 26: remote partition has no heartbeat */</span>

	<span class="n">xpPioReadError</span><span class="p">,</span>		<span class="cm">/* 27: PIO read error */</span>
	<span class="n">xpPhysAddrRegFailed</span><span class="p">,</span>	<span class="cm">/* 28: registration of phys addr range failed */</span>

	<span class="n">xpRETIRED3</span><span class="p">,</span>		<span class="cm">/* 29: (formerly xpBteDirectoryError) */</span>
	<span class="n">xpRETIRED4</span><span class="p">,</span>		<span class="cm">/* 30: (formerly xpBtePoisonError) */</span>
	<span class="n">xpRETIRED5</span><span class="p">,</span>		<span class="cm">/* 31: (formerly xpBteWriteError) */</span>
	<span class="n">xpRETIRED6</span><span class="p">,</span>		<span class="cm">/* 32: (formerly xpBteAccessError) */</span>
	<span class="n">xpRETIRED7</span><span class="p">,</span>		<span class="cm">/* 33: (formerly xpBtePWriteError) */</span>
	<span class="n">xpRETIRED8</span><span class="p">,</span>		<span class="cm">/* 34: (formerly xpBtePReadError) */</span>
	<span class="n">xpRETIRED9</span><span class="p">,</span>		<span class="cm">/* 35: (formerly xpBteTimeOutError) */</span>
	<span class="n">xpRETIRED10</span><span class="p">,</span>		<span class="cm">/* 36: (formerly xpBteXtalkError) */</span>
	<span class="n">xpRETIRED11</span><span class="p">,</span>		<span class="cm">/* 37: (formerly xpBteNotAvailable) */</span>
	<span class="n">xpRETIRED12</span><span class="p">,</span>		<span class="cm">/* 38: (formerly xpBteUnmappedError) */</span>

	<span class="n">xpBadVersion</span><span class="p">,</span>		<span class="cm">/* 39: bad version number */</span>
	<span class="n">xpVarsNotSet</span><span class="p">,</span>		<span class="cm">/* 40: the XPC variables are not set up */</span>
	<span class="n">xpNoRsvdPageAddr</span><span class="p">,</span>	<span class="cm">/* 41: unable to get rsvd page&#39;s phys addr */</span>
	<span class="n">xpInvalidPartid</span><span class="p">,</span>	<span class="cm">/* 42: invalid partition ID */</span>
	<span class="n">xpLocalPartid</span><span class="p">,</span>		<span class="cm">/* 43: local partition ID */</span>

	<span class="n">xpOtherGoingDown</span><span class="p">,</span>	<span class="cm">/* 44: other side going down, reason unknown */</span>
	<span class="n">xpSystemGoingDown</span><span class="p">,</span>	<span class="cm">/* 45: system is going down, reason unknown */</span>
	<span class="n">xpSystemHalt</span><span class="p">,</span>		<span class="cm">/* 46: system is being halted */</span>
	<span class="n">xpSystemReboot</span><span class="p">,</span>		<span class="cm">/* 47: system is being rebooted */</span>
	<span class="n">xpSystemPoweroff</span><span class="p">,</span>	<span class="cm">/* 48: system is being powered off */</span>

	<span class="n">xpDisconnecting</span><span class="p">,</span>	<span class="cm">/* 49: channel disconnecting (closing) */</span>

	<span class="n">xpOpenCloseError</span><span class="p">,</span>	<span class="cm">/* 50: channel open/close protocol error */</span>

	<span class="n">xpDisconnected</span><span class="p">,</span>		<span class="cm">/* 51: channel disconnected (closed) */</span>

	<span class="n">xpBteCopyError</span><span class="p">,</span>		<span class="cm">/* 52: bte_copy() returned error */</span>
	<span class="n">xpSalError</span><span class="p">,</span>		<span class="cm">/* 53: sn SAL error */</span>
	<span class="n">xpRsvdPageNotSet</span><span class="p">,</span>	<span class="cm">/* 54: the reserved page is not set up */</span>
	<span class="n">xpPayloadTooBig</span><span class="p">,</span>	<span class="cm">/* 55: payload too large for message slot */</span>

	<span class="n">xpUnsupported</span><span class="p">,</span>		<span class="cm">/* 56: unsupported functionality or resource */</span>
	<span class="n">xpNeedMoreInfo</span><span class="p">,</span>		<span class="cm">/* 57: more info is needed by SAL */</span>

	<span class="n">xpGruCopyError</span><span class="p">,</span>		<span class="cm">/* 58: gru_copy_gru() returned error */</span>
	<span class="n">xpGruSendMqError</span><span class="p">,</span>	<span class="cm">/* 59: gru send message queue related error */</span>

	<span class="n">xpBadChannelNumber</span><span class="p">,</span>	<span class="cm">/* 60: invalid channel number */</span>
	<span class="n">xpBadMsgType</span><span class="p">,</span>		<span class="cm">/* 61: invalid message type */</span>
	<span class="n">xpBiosError</span><span class="p">,</span>		<span class="cm">/* 62: BIOS error */</span>

	<span class="n">xpUnknownReason</span>		<span class="cm">/* 63: unknown reason - must be last in enum */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Define the callout function type used by XPC to update the user on</span>
<span class="cm"> * connection activity and state changes via the user function registered</span>
<span class="cm"> * by xpc_connect().</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *	reason - reason code.</span>
<span class="cm"> *	partid - partition ID associated with condition.</span>
<span class="cm"> *	ch_number - channel # associated with condition.</span>
<span class="cm"> *	data - pointer to optional data.</span>
<span class="cm"> *	key - pointer to optional user-defined value provided as the &quot;key&quot;</span>
<span class="cm"> *	      argument to xpc_connect().</span>
<span class="cm"> *</span>
<span class="cm"> * A reason code of xpConnected indicates that a connection has been</span>
<span class="cm"> * established to the specified partition on the specified channel. The data</span>
<span class="cm"> * argument indicates the max number of entries allowed in the message queue.</span>
<span class="cm"> *</span>
<span class="cm"> * A reason code of xpMsgReceived indicates that a XPC message arrived from</span>
<span class="cm"> * the specified partition on the specified channel. The data argument</span>
<span class="cm"> * specifies the address of the message&#39;s payload. The user must call</span>
<span class="cm"> * xpc_received() when finished with the payload.</span>
<span class="cm"> *</span>
<span class="cm"> * All other reason codes indicate failure. The data argmument is NULL.</span>
<span class="cm"> * When a failure reason code is received, one can assume that the channel</span>
<span class="cm"> * is not connected.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">xpc_channel_func</span><span class="p">)</span> <span class="p">(</span><span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">short</span> <span class="n">partid</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">ch_number</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Define the callout function type used by XPC to notify the user of</span>
<span class="cm"> * messages received and delivered via the user function registered by</span>
<span class="cm"> * xpc_send_notify().</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *	reason - reason code.</span>
<span class="cm"> *	partid - partition ID associated with condition.</span>
<span class="cm"> *	ch_number - channel # associated with condition.</span>
<span class="cm"> *	key - pointer to optional user-defined value provided as the &quot;key&quot;</span>
<span class="cm"> *	      argument to xpc_send_notify().</span>
<span class="cm"> *</span>
<span class="cm"> * A reason code of xpMsgDelivered indicates that the message was delivered</span>
<span class="cm"> * to the intended recipient and that they have acknowledged its receipt by</span>
<span class="cm"> * calling xpc_received().</span>
<span class="cm"> *</span>
<span class="cm"> * All other reason codes indicate failure.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: The user defined function must be callable by an interrupt handler</span>
<span class="cm"> *       and thus cannot block.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">xpc_notify_func</span><span class="p">)</span> <span class="p">(</span><span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">short</span> <span class="n">partid</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">ch_number</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The following is a registration entry. There is a global array of these,</span>
<span class="cm"> * one per channel. It is used to record the connection registration made</span>
<span class="cm"> * by the users of XPC. As long as a registration entry exists, for any</span>
<span class="cm"> * partition that comes up, XPC will attempt to establish a connection on</span>
<span class="cm"> * that channel. Notification that a connection has been made will occur via</span>
<span class="cm"> * the xpc_channel_func function.</span>
<span class="cm"> *</span>
<span class="cm"> * The &#39;func&#39; field points to the function to call when aynchronous</span>
<span class="cm"> * notification is required for such events as: a connection established/lost,</span>
<span class="cm"> * or an incoming message received, or an error condition encountered. A</span>
<span class="cm"> * non-NULL &#39;func&#39; field indicates that there is an active registration for</span>
<span class="cm"> * the channel.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xpc_registration</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="n">xpc_channel_func</span> <span class="n">func</span><span class="p">;</span>	<span class="cm">/* function to call */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* pointer to user&#39;s key */</span>
	<span class="n">u16</span> <span class="n">nentries</span><span class="p">;</span>		<span class="cm">/* #of msg entries in local msg queue */</span>
	<span class="n">u16</span> <span class="n">entry_size</span><span class="p">;</span>		<span class="cm">/* message queue&#39;s message entry size */</span>
	<span class="n">u32</span> <span class="n">assigned_limit</span><span class="p">;</span>	<span class="cm">/* limit on #of assigned kthreads */</span>
	<span class="n">u32</span> <span class="n">idle_limit</span><span class="p">;</span>		<span class="cm">/* limit on #of idle kthreads */</span>
<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="cp">#define XPC_CHANNEL_REGISTERED(_c)	(xpc_registrations[_c].func != NULL)</span>

<span class="cm">/* the following are valid xpc_send() or xpc_send_notify() flags */</span>
<span class="cp">#define XPC_WAIT	0	</span><span class="cm">/* wait flag */</span><span class="cp"></span>
<span class="cp">#define XPC_NOWAIT	1	</span><span class="cm">/* no wait flag */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">xpc_interface</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">send</span><span class="p">)</span> <span class="p">(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">send_notify</span><span class="p">)</span> <span class="p">(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span>
					<span class="n">xpc_notify_func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">received</span><span class="p">)</span> <span class="p">(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">partid_to_nasids</span><span class="p">)</span> <span class="p">(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">xpc_interface</span> <span class="n">xpc_interface</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_set_interface</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span>
			      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span>
			      <span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">),</span>
			      <span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span>
						 <span class="n">xpc_notify_func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			      <span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">short</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_clear_interface</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">xpc_connect</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">xpc_channel_func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span>
				   <span class="n">u16</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xpc_disconnect</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">xp_retval</span>
<span class="nf">xpc_send</span><span class="p">(</span><span class="kt">short</span> <span class="n">partid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch_number</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span>
	 <span class="n">u16</span> <span class="n">payload_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xpc_interface</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">partid</span><span class="p">,</span> <span class="n">ch_number</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span>
				  <span class="n">payload_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">xp_retval</span>
<span class="nf">xpc_send_notify</span><span class="p">(</span><span class="kt">short</span> <span class="n">partid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch_number</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">payload_size</span><span class="p">,</span> <span class="n">xpc_notify_func</span> <span class="n">func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xpc_interface</span><span class="p">.</span><span class="n">send_notify</span><span class="p">(</span><span class="n">partid</span><span class="p">,</span> <span class="n">ch_number</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span>
					 <span class="n">payload_size</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xpc_received</span><span class="p">(</span><span class="kt">short</span> <span class="n">partid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch_number</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xpc_interface</span><span class="p">.</span><span class="n">received</span><span class="p">(</span><span class="n">partid</span><span class="p">,</span> <span class="n">ch_number</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">xp_retval</span>
<span class="nf">xpc_partid_to_nasids</span><span class="p">(</span><span class="kt">short</span> <span class="n">partid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">nasids</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xpc_interface</span><span class="p">.</span><span class="n">partid_to_nasids</span><span class="p">(</span><span class="n">partid</span><span class="p">,</span> <span class="n">nasids</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">short</span> <span class="n">xp_max_npartitions</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">short</span> <span class="n">xp_partition_id</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">xp_region_size</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">xp_pa</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">xp_socket_pa</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">xp_remote_memcpy</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
		       <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">xp_cpu_to_nasid</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">xp_expand_memprotect</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="p">(</span><span class="o">*</span><span class="n">xp_restrict_memprotect</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">u64</span> <span class="n">xp_nofault_PIOR_target</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xp_nofault_PIOR</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xp_error_PIOR</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">xp</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">xp_init_sn2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">xp_retval</span> <span class="n">xp_init_uv</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xp_exit_sn2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xp_exit_uv</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _DRIVERS_MISC_SGIXP_XP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
