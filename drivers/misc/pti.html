<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › pti.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pti.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  pti.c - PTI driver for cJTAG data extration</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) Intel 2010</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * The PTI (Parallel Trace Interface) driver directs trace data routed from</span>
<span class="cm"> * various parts in the system out through the Intel Penwell PTI port and</span>
<span class="cm"> * out of the mobile device for analysis with a debugging tool</span>
<span class="cm"> * (Lauterbach, Fido). This is part of a solution for the MIPI P1149.7,</span>
<span class="cm"> * compact JTAG, standard.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_driver.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/pti.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#define DRIVERNAME		&quot;pti&quot;</span>
<span class="cp">#define PCINAME			&quot;pciPTI&quot;</span>
<span class="cp">#define TTYNAME			&quot;ttyPTI&quot;</span>
<span class="cp">#define CHARNAME		&quot;pti&quot;</span>
<span class="cp">#define PTITTY_MINOR_START	0</span>
<span class="cp">#define PTITTY_MINOR_NUM	2</span>
<span class="cp">#define MAX_APP_IDS		16   </span><span class="cm">/* 128 channel ids / u8 bit size */</span><span class="cp"></span>
<span class="cp">#define MAX_OS_IDS		16   </span><span class="cm">/* 128 channel ids / u8 bit size */</span><span class="cp"></span>
<span class="cp">#define MAX_MODEM_IDS		16   </span><span class="cm">/* 128 channel ids / u8 bit size */</span><span class="cp"></span>
<span class="cp">#define MODEM_BASE_ID		71   </span><span class="cm">/* modem master ID address    */</span><span class="cp"></span>
<span class="cp">#define CONTROL_ID		72   </span><span class="cm">/* control master ID address  */</span><span class="cp"></span>
<span class="cp">#define CONSOLE_ID		73   </span><span class="cm">/* console master ID address  */</span><span class="cp"></span>
<span class="cp">#define OS_BASE_ID		74   </span><span class="cm">/* base OS master ID address  */</span><span class="cp"></span>
<span class="cp">#define APP_BASE_ID		80   </span><span class="cm">/* base App master ID address */</span><span class="cp"></span>
<span class="cp">#define CONTROL_FRAME_LEN	32   </span><span class="cm">/* PTI control frame maximum size */</span><span class="cp"></span>
<span class="cp">#define USER_COPY_SIZE		8192 </span><span class="cm">/* 8Kb buffer for user space copy */</span><span class="cp"></span>
<span class="cp">#define APERTURE_14		0x3800000 </span><span class="cm">/* offset to first OS write addr */</span><span class="cp"></span>
<span class="cp">#define APERTURE_LEN		0x400000  </span><span class="cm">/* address length */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">pti_tty</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="n">mc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pti_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pti_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">aperture_base</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pti_ioaddr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ia_app</span><span class="p">[</span><span class="n">MAX_APP_IDS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ia_os</span><span class="p">[</span><span class="n">MAX_OS_IDS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ia_modem</span><span class="p">[</span><span class="n">MAX_MODEM_IDS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This protects access to ia_app, ia_os, and ia_modem,</span>
<span class="cm"> * which keeps track of channels allocated in</span>
<span class="cm"> * an aperture write id.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">alloclock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">pci_ids</span><span class="p">[]</span> <span class="n">__devinitconst</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x82B</span><span class="p">)},</span>
		<span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">pti_tty_driver</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pti_dev</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pti_console_channel</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pti_control_channel</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *  pti_write_to_aperture()- The private write function to PTI HW.</span>
<span class="cm"> *</span>
<span class="cm"> *  @mc: The &#39;aperture&#39;. It&#39;s part of a write address that holds</span>
<span class="cm"> *       a master and channel ID.</span>
<span class="cm"> *  @buf: Data being written to the HW that will ultimately be seen</span>
<span class="cm"> *        in a debugging tool (Fido, Lauterbach).</span>
<span class="cm"> *  @len: Size of buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *  Since each aperture is specified by a unique</span>
<span class="cm"> *  master/channel ID, no two processes will be writing</span>
<span class="cm"> *  to the same aperture at the same time so no lock is required. The</span>
<span class="cm"> *  PTI-Output agent will send these out in the order that they arrived, and</span>
<span class="cm"> *  thus, it will intermix these messages. The debug tool can then later</span>
<span class="cm"> *  regroup the appropriate message segments together reconstituting each</span>
<span class="cm"> *  message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pti_write_to_aperture</span><span class="p">(</span><span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dwordcnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">final</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ptiword</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">aperture</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * calculate the aperture offset from the base using the master and</span>
<span class="cm">	 * channel id&#39;s.</span>
<span class="cm">	 */</span>
	<span class="n">aperture</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pti_ioaddr</span> <span class="o">+</span> <span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span>
		<span class="o">+</span> <span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">dwordcnt</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">final</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">dwordcnt</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>	    <span class="cm">/* final = trailing bytes    */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">final</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dwordcnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* always need a final dword */</span>
		<span class="n">final</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">dwordcnt</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dwordcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ptiword</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">ptiword</span><span class="p">,</span> <span class="n">aperture</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">aperture</span> <span class="o">+=</span> <span class="n">PTI_LASTDWORD_DTS</span><span class="p">;</span>	<span class="cm">/* adding DTS signals that is EOM */</span>

	<span class="n">ptiword</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">final</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ptiword</span> <span class="o">|=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">24</span><span class="o">-</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="p">));</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="n">ptiword</span><span class="p">,</span> <span class="n">aperture</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  pti_control_frame_built_and_sent()- control frame build and send function.</span>
<span class="cm"> *</span>
<span class="cm"> *  @mc:          The master / channel structure on which the function</span>
<span class="cm"> *                built a control frame.</span>
<span class="cm"> *  @thread_name: The thread name associated with the master / channel or</span>
<span class="cm"> *                &#39;NULL&#39; if using the &#39;current&#39; global variable.</span>
<span class="cm"> *</span>
<span class="cm"> *  To be able to post process the PTI contents on host side, a control frame</span>
<span class="cm"> *  is added before sending any PTI content. So the host side knows on</span>
<span class="cm"> *  each PTI frame the name of the thread using a dedicated master / channel.</span>
<span class="cm"> *  The thread name is retrieved from &#39;current&#39; global variable if &#39;thread_name&#39;</span>
<span class="cm"> *  is &#39;NULL&#39;, else it is retrieved from &#39;thread_name&#39; parameter.</span>
<span class="cm"> *  This function builds this frame and sends it to a master ID CONTROL_ID.</span>
<span class="cm"> *  The overhead is only 32 bytes since the driver only writes to HW</span>
<span class="cm"> *  in 32 byte chunks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pti_control_frame_built_and_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span>
					     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">thread_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since we access the comm member in current&#39;s task_struct, we only</span>
<span class="cm">	 * need to be as large as what &#39;comm&#39; in that structure is.</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="n">mccontrol</span> <span class="o">=</span> <span class="p">{.</span><span class="n">master</span> <span class="o">=</span> <span class="n">CONTROL_ID</span><span class="p">,</span>
					      <span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">thread_name_p</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">control_format</span> <span class="o">=</span> <span class="s">&quot;%3d %3d %s&quot;</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">control_frame</span><span class="p">[</span><span class="n">CONTROL_FRAME_LEN</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thread_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_interrupt</span><span class="p">())</span>
			<span class="n">get_task_comm</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">strncpy</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="s">&quot;Interrupt&quot;</span><span class="p">,</span> <span class="n">TASK_COMM_LEN</span><span class="p">);</span>

		<span class="cm">/* Absolutely ensure our buffer is zero terminated. */</span>
		<span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">thread_name_p</span> <span class="o">=</span> <span class="n">comm</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">thread_name_p</span> <span class="o">=</span> <span class="n">thread_name</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mccontrol</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">pti_control_channel</span><span class="p">;</span>
	<span class="n">pti_control_channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">pti_control_channel</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">control_frame</span><span class="p">,</span> <span class="n">CONTROL_FRAME_LEN</span><span class="p">,</span> <span class="n">control_format</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">,</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">thread_name_p</span><span class="p">);</span>
	<span class="n">pti_write_to_aperture</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mccontrol</span><span class="p">,</span> <span class="n">control_frame</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">control_frame</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  pti_write_full_frame_to_aperture()- high level function to</span>
<span class="cm"> *					write to PTI.</span>
<span class="cm"> *</span>
<span class="cm"> *  @mc:  The &#39;aperture&#39;. It&#39;s part of a write address that holds</span>
<span class="cm"> *        a master and channel ID.</span>
<span class="cm"> *  @buf: Data being written to the HW that will ultimately be seen</span>
<span class="cm"> *        in a debugging tool (Fido, Lauterbach).</span>
<span class="cm"> *  @len: Size of buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *  All threads sending data (either console, user space application, ...)</span>
<span class="cm"> *  are calling the high level function to write to PTI meaning that it is</span>
<span class="cm"> *  possible to add a control frame before sending the content.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pti_write_full_frame_to_aperture</span><span class="p">(</span><span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pti_control_frame_built_and_sent</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pti_write_to_aperture</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_id()- Allocate a master and channel ID.</span>
<span class="cm"> *</span>
<span class="cm"> * @id_array:    an array of bits representing what channel</span>
<span class="cm"> *               id&#39;s are allocated for writing.</span>
<span class="cm"> * @max_ids:     The max amount of available write IDs to use.</span>
<span class="cm"> * @base_id:     The starting SW channel ID, based on the Intel</span>
<span class="cm"> *               PTI arch.</span>
<span class="cm"> * @thread_name: The thread name associated with the master / channel or</span>
<span class="cm"> *               &#39;NULL&#39; if using the &#39;current&#39; global variable.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	pti_masterchannel struct with master, channel ID address</span>
<span class="cm"> *	0 for error</span>
<span class="cm"> *</span>
<span class="cm"> * Each bit in the arrays ia_app and ia_os correspond to a master and</span>
<span class="cm"> * channel id. The bit is one if the id is taken and 0 if free. For</span>
<span class="cm"> * every master there are 128 channel id&#39;s.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="nf">get_id</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">id_array</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">max_ids</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">base_id</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">thread_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="n">mc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pti_masterchannel</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* look for a byte with a free bit */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_ids</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">max_ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mc</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* find the bit in the 128 possible channel opportunities */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">id_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* grab it */</span>
	<span class="n">id_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">master</span>  <span class="o">=</span> <span class="n">base_id</span><span class="p">;</span>
	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
	<span class="cm">/* write new master Id / channel Id allocation to channel control */</span>
	<span class="n">pti_control_frame_built_and_sent</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">thread_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following three functions:</span>
<span class="cm"> * pti_request_mastercahannel(), mipi_release_masterchannel()</span>
<span class="cm"> * and pti_writedata() are an API for other kernel drivers to</span>
<span class="cm"> * access PTI.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * pti_request_masterchannel()- Kernel API function used to allocate</span>
<span class="cm"> *				a master, channel ID address</span>
<span class="cm"> *				to write to PTI HW.</span>
<span class="cm"> *</span>
<span class="cm"> * @type:        0- request Application  master, channel aperture ID</span>
<span class="cm"> *                  write address.</span>
<span class="cm"> *               1- request OS master, channel aperture ID write</span>
<span class="cm"> *                  address.</span>
<span class="cm"> *               2- request Modem master, channel aperture ID</span>
<span class="cm"> *                  write address.</span>
<span class="cm"> *               Other values, error.</span>
<span class="cm"> * @thread_name: The thread name associated with the master / channel or</span>
<span class="cm"> *               &#39;NULL&#39; if using the &#39;current&#39; global variable.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	pti_masterchannel struct</span>
<span class="cm"> *	0 for error</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="nf">pti_request_masterchannel</span><span class="p">(</span><span class="n">u8</span> <span class="n">type</span><span class="p">,</span>
						    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">thread_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="n">mc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alloclock</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">mc</span> <span class="o">=</span> <span class="n">get_id</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ia_app</span><span class="p">,</span> <span class="n">MAX_APP_IDS</span><span class="p">,</span>
			    <span class="n">APP_BASE_ID</span><span class="p">,</span> <span class="n">thread_name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">mc</span> <span class="o">=</span> <span class="n">get_id</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ia_os</span><span class="p">,</span> <span class="n">MAX_OS_IDS</span><span class="p">,</span>
			    <span class="n">OS_BASE_ID</span><span class="p">,</span> <span class="n">thread_name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">mc</span> <span class="o">=</span> <span class="n">get_id</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ia_modem</span><span class="p">,</span> <span class="n">MAX_MODEM_IDS</span><span class="p">,</span>
			    <span class="n">MODEM_BASE_ID</span><span class="p">,</span> <span class="n">thread_name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">mc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alloclock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pti_request_masterchannel</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pti_release_masterchannel()- Kernel API function used to release</span>
<span class="cm"> *				a master, channel ID address</span>
<span class="cm"> *				used to write to PTI HW.</span>
<span class="cm"> *</span>
<span class="cm"> * @mc: master, channel apeture ID address to be released.  This</span>
<span class="cm"> *      will de-allocate the structure via kfree().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pti_release_masterchannel</span><span class="p">(</span><span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="n">mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">master</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alloclock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">master</span> <span class="o">=</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">master</span> <span class="o">==</span> <span class="n">APP_BASE_ID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ia_app</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span>  <span class="o">~</span><span class="p">(</span><span class="mh">0x80</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">master</span> <span class="o">==</span> <span class="n">OS_BASE_ID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ia_os</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x80</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ia_modem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x80</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">mc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alloclock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pti_release_masterchannel</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pti_writedata()- Kernel API function used to write trace</span>
<span class="cm"> *                  debugging data to PTI HW.</span>
<span class="cm"> *</span>
<span class="cm"> * @mc:    Master, channel aperture ID address to write to.</span>
<span class="cm"> *         Null value will return with no write occurring.</span>
<span class="cm"> * @buf:   Trace debuging data to write to the PTI HW.</span>
<span class="cm"> *         Null value will return with no write occurring.</span>
<span class="cm"> * @count: Size of buf. Value of 0 or a negative number will</span>
<span class="cm"> *         return with no write occuring.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pti_writedata</span><span class="p">(</span><span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * since this function is exported, this is treated like an</span>
<span class="cm">	 * API function, thus, all parameters should</span>
<span class="cm">	 * be checked for validity.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">pti_write_to_aperture</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pti_writedata</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pti_pci_remove()- Driver exit method to remove PTI from</span>
<span class="cm"> *		   PCI bus.</span>
<span class="cm"> * @pdev: variable containing pci info of PTI.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">pti_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pti_dev</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">;</span>

	<span class="n">drv_data</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pti_ioaddr</span><span class="p">);</span>
		<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
		<span class="n">pci_release_region</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * for the tty_driver_*() basic function descriptions, see tty_driver.h.</span>
<span class="cm"> * Specific header comments made for PTI-related specifics.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * pti_tty_driver_open()- Open an Application master, channel aperture</span>
<span class="cm"> * ID to the PTI device via tty device.</span>
<span class="cm"> *</span>
<span class="cm"> * @tty: tty interface.</span>
<span class="cm"> * @filp: filp interface pased to tty_port_open() call.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	int, 0 for success</span>
<span class="cm"> *	otherwise, fail value</span>
<span class="cm"> *</span>
<span class="cm"> * The main purpose of using the tty device interface is for</span>
<span class="cm"> * each tty port to have a unique PTI write aperture.  In an</span>
<span class="cm"> * example use case, ttyPTI0 gets syslogd and an APP aperture</span>
<span class="cm"> * ID and ttyPTI1 is where the n_tracesink ldisc hooks to route</span>
<span class="cm"> * modem messages into PTI.  Modem trace data does not have to</span>
<span class="cm"> * go to ttyPTI1, but ttyPTI0 and ttyPTI1 do need to be distinct</span>
<span class="cm"> * master IDs.  These messages go through the PTI HW and out of</span>
<span class="cm"> * the handheld platform and to the Fido/Lauterbach device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pti_tty_driver_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * we actually want to allocate a new channel per open, per</span>
<span class="cm">	 * system arch.  HW gives more than plenty channels for a single</span>
<span class="cm">	 * system task to have its own channel to write trace data. This</span>
<span class="cm">	 * also removes a locking requirement for the actual write</span>
<span class="cm">	 * procedure.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">tty_port_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_tty_driver_close()- close tty device and release Application</span>
<span class="cm"> * master, channel aperture ID to the PTI device via tty device.</span>
<span class="cm"> *</span>
<span class="cm"> * @tty: tty interface.</span>
<span class="cm"> * @filp: filp interface pased to tty_port_close() call.</span>
<span class="cm"> *</span>
<span class="cm"> * The main purpose of using the tty device interface is to route</span>
<span class="cm"> * syslog daemon messages to the PTI HW and out of the handheld platform</span>
<span class="cm"> * and to the Fido/Lauterbach device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pti_tty_driver_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tty_port_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_tty_install()- Used to set up specific master-channels</span>
<span class="cm"> *		      to tty ports for organizational purposes when</span>
<span class="cm"> *		      tracing viewed from debuging tools.</span>
<span class="cm"> *</span>
<span class="cm"> * @driver: tty driver information.</span>
<span class="cm"> * @tty: tty struct containing pti information.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0 for success</span>
<span class="cm"> *	otherwise, error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pti_tty_install</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pti_tty</span> <span class="o">*</span><span class="n">pti_tty_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">tty_standard_install</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pti_tty_data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pti_tty</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pti_tty_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">PTITTY_MINOR_START</span><span class="p">)</span>
			<span class="n">pti_tty_data</span><span class="o">-&gt;</span><span class="n">mc</span> <span class="o">=</span> <span class="n">pti_request_masterchannel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pti_tty_data</span><span class="o">-&gt;</span><span class="n">mc</span> <span class="o">=</span> <span class="n">pti_request_masterchannel</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pti_tty_data</span><span class="o">-&gt;</span><span class="n">mc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">pti_tty_data</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">pti_tty_data</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_tty_cleanup()- Used to de-allocate master-channel resources</span>
<span class="cm"> *		      tied to tty&#39;s of this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * @tty: tty struct containing pti information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pti_tty_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pti_tty</span> <span class="o">*</span><span class="n">pti_tty_data</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pti_tty_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">pti_release_masterchannel</span><span class="p">(</span><span class="n">pti_tty_data</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pti_tty_data</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_tty_driver_write()-  Write trace debugging data through the char</span>
<span class="cm"> * interface to the PTI HW.  Part of the misc device implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * @filp: Contains private data which is used to obtain</span>
<span class="cm"> *        master, channel write ID.</span>
<span class="cm"> * @data: trace data to be written.</span>
<span class="cm"> * @len:  # of byte to write.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	int, # of bytes written</span>
<span class="cm"> *	otherwise, error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pti_tty_driver_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pti_tty</span> <span class="o">*</span><span class="n">pti_tty_data</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pti_tty_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pti_tty_data</span><span class="o">-&gt;</span><span class="n">mc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pti_write_to_aperture</span><span class="p">(</span><span class="n">pti_tty_data</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * we can&#39;t write to the pti hardware if the private driver_data</span>
<span class="cm">	 * and the mc address is not there.</span>
<span class="cm">	 */</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_tty_write_room()- Always returns 2048.</span>
<span class="cm"> *</span>
<span class="cm"> * @tty: contains tty info of the pti driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pti_tty_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">2048</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_char_open()- Open an Application master, channel aperture</span>
<span class="cm"> * ID to the PTI device. Part of the misc device implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * @inode: not used.</span>
<span class="cm"> * @filp:  Output- will have a masterchannel struct set containing</span>
<span class="cm"> *                 the allocated application PTI aperture write address.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	int, 0 for success</span>
<span class="cm"> *	otherwise, a fail value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pti_char_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="n">mc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We really do want to fail immediately if</span>
<span class="cm">	 * pti_request_masterchannel() fails,</span>
<span class="cm">	 * before assigning the value to filp-&gt;private_data.</span>
<span class="cm">	 * Slightly easier to debug if this driver needs debugging.</span>
<span class="cm">	 */</span>
	<span class="n">mc</span> <span class="o">=</span> <span class="n">pti_request_masterchannel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">mc</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_char_release()-  Close a char channel to the PTI device. Part</span>
<span class="cm"> * of the misc device implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * @inode: Not used in this implementaiton.</span>
<span class="cm"> * @filp:  Contains private_data that contains the master, channel</span>
<span class="cm"> *         ID to be released by the PTI device.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	always 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pti_char_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pti_release_masterchannel</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_char_write()-  Write trace debugging data through the char</span>
<span class="cm"> * interface to the PTI HW.  Part of the misc device implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * @filp:  Contains private data which is used to obtain</span>
<span class="cm"> *         master, channel write ID.</span>
<span class="cm"> * @data:  trace data to be written.</span>
<span class="cm"> * @len:   # of byte to write.</span>
<span class="cm"> * @ppose: Not used in this function implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	int, # of bytes written</span>
<span class="cm"> *	otherwise, error value</span>
<span class="cm"> *</span>
<span class="cm"> * Notes: From side discussions with Alan Cox and experimenting</span>
<span class="cm"> * with PTI debug HW like Nokia&#39;s Fido box and Lauterbach</span>
<span class="cm"> * devices, 8192 byte write buffer used by USER_COPY_SIZE was</span>
<span class="cm"> * deemed an appropriate size for this type of usage with</span>
<span class="cm"> * debugging HW.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pti_char_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppose</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="o">*</span><span class="n">mc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">kbuf</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">USER_COPY_SIZE</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">mc</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">kbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): buf allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">USER_COPY_SIZE</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">USER_COPY_SIZE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">n</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">kbuf</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">n</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pti_write_to_aperture</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">kbuf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">n</span>  <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">kbuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="n">pti_tty_driver_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">pti_tty_driver_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>		<span class="o">=</span> <span class="n">pti_tty_driver_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">pti_tty_driver_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_room</span>	<span class="o">=</span> <span class="n">pti_tty_write_room</span><span class="p">,</span>
	<span class="p">.</span><span class="n">install</span>	<span class="o">=</span> <span class="n">pti_tty_install</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="n">pti_tty_cleanup</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">pti_char_driver_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">pti_char_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">pti_char_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">pti_char_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">pti_char_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span>		<span class="o">=</span> <span class="n">MISC_DYNAMIC_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">CHARNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">pti_char_driver_ops</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pti_console_write()-  Write to the console that has been acquired.</span>
<span class="cm"> *</span>
<span class="cm"> * @c:   Not used in this implementaiton.</span>
<span class="cm"> * @buf: Data to be written.</span>
<span class="cm"> * @len: Length of buf.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pti_console_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">pti_masterchannel</span> <span class="n">mc</span> <span class="o">=</span> <span class="p">{.</span><span class="n">master</span>  <span class="o">=</span> <span class="n">CONSOLE_ID</span><span class="p">,</span>
					      <span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>

	<span class="n">mc</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">pti_console_channel</span><span class="p">;</span>
	<span class="n">pti_console_channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">pti_console_channel</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>

	<span class="n">pti_write_full_frame_to_aperture</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_console_device()-  Return the driver tty structure and set the</span>
<span class="cm"> *			  associated index implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * @c:     Console device of the driver.</span>
<span class="cm"> * @index: index associated with c.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	always value of pti_tty_driver structure when this function</span>
<span class="cm"> *	is called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="nf">pti_console_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pti_tty_driver</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_console_setup()-  Initialize console variables used by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * @c:     Not used.</span>
<span class="cm"> * @opts:  Not used.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	always 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pti_console_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pti_console_channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pti_control_channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pti_console struct, used to capture OS printk()&#39;s and shift</span>
<span class="cm"> * out to the PTI device for debugging.  This cannot be</span>
<span class="cm"> * enabled upon boot because of the possibility of eating</span>
<span class="cm"> * any serial console printk&#39;s (race condition discovered).</span>
<span class="cm"> * The console should be enabled upon when the tty port is</span>
<span class="cm"> * used for the first time.  Since the primary purpose for</span>
<span class="cm"> * the tty port is to hook up syslog to it, the tty port</span>
<span class="cm"> * will be open for a really long time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">console</span> <span class="n">pti_console</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">TTYNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">pti_console_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">device</span>		<span class="o">=</span> <span class="n">pti_console_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup</span>		<span class="o">=</span> <span class="n">pti_console_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">CON_PRINTBUFFER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">index</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pti_port_activate()- Used to start/initialize any items upon</span>
<span class="cm"> * first opening of tty_port().</span>
<span class="cm"> *</span>
<span class="cm"> * @port- The tty port number of the PTI device.</span>
<span class="cm"> * @tty-  The tty struct associated with this device.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	always returns 0</span>
<span class="cm"> *</span>
<span class="cm"> * Notes: The primary purpose of the PTI tty port 0 is to hook</span>
<span class="cm"> * the syslog daemon to it; thus this port will be open for a</span>
<span class="cm"> * very long time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pti_port_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">PTITTY_MINOR_START</span><span class="p">)</span>
		<span class="n">console_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pti_console</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_port_shutdown()- Used to stop/shutdown any items upon the</span>
<span class="cm"> * last tty port close.</span>
<span class="cm"> *</span>
<span class="cm"> * @port- The tty port number of the PTI device.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes: The primary purpose of the PTI tty port 0 is to hook</span>
<span class="cm"> * the syslog daemon to it; thus this port will be open for a</span>
<span class="cm"> * very long time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pti_port_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">PTITTY_MINOR_START</span><span class="p">)</span>
		<span class="n">console_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pti_console</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_port_operations</span> <span class="n">tty_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">activate</span> <span class="o">=</span> <span class="n">pti_port_activate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">pti_port_shutdown</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Note the _probe() call sets everything up and ties the char and tty</span>
<span class="cm"> * to successfully detecting the PTI device on the pci bus.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * pti_pci_probe()- Used to detect pti on the pci bus and set</span>
<span class="cm"> *		    things up in the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * @pdev- pci_dev struct values for pti.</span>
<span class="cm"> * @ent-  pci_device_id struct for pti driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0 for success</span>
<span class="cm"> *	otherwise, error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pti_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pci_bar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s %s(%d): PTI PCI ID %04x:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pti_char_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): CHAR registration failed of pti driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): Error value returned: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: pci_enable_device() returned error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">drv_data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">drv_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s(%d): kmalloc() returned NULL memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pti_addr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_bar</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_request_region</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_bar</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s(%d): pci_request_region() returned error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">aperture_base</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pti_addr</span><span class="o">+</span><span class="n">APERTURE_14</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pti_ioaddr</span> <span class="o">=</span>
		<span class="n">ioremap_nocache</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">aperture_base</span><span class="p">,</span>
		<span class="n">APERTURE_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pti_ioaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_release_region</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_bar</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">drv_data</span><span class="p">);</span>

	<span class="n">tty_port_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tty_port_ops</span><span class="p">;</span>

	<span class="n">tty_register_device</span><span class="p">(</span><span class="n">pti_tty_driver</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">tty_register_device</span><span class="p">(</span><span class="n">pti_tty_driver</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">register_console</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pti_console</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">pti_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">PCINAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">pci_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">pti_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">pti_pci_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * pti_init()- Overall entry/init call to the pti driver.</span>
<span class="cm"> *             It starts the registration process with the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	int __init, 0 for success</span>
<span class="cm"> *	otherwise value is an error</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pti_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* First register module as tty device */</span>

	<span class="n">pti_tty_driver</span> <span class="o">=</span> <span class="n">alloc_tty_driver</span><span class="p">(</span><span class="n">PTITTY_MINOR_NUM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pti_tty_driver</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): Memory allocation failed for ptiTTY driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pti_tty_driver</span><span class="o">-&gt;</span><span class="n">driver_name</span>		<span class="o">=</span> <span class="n">DRIVERNAME</span><span class="p">;</span>
	<span class="n">pti_tty_driver</span><span class="o">-&gt;</span><span class="n">name</span>			<span class="o">=</span> <span class="n">TTYNAME</span><span class="p">;</span>
	<span class="n">pti_tty_driver</span><span class="o">-&gt;</span><span class="n">major</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pti_tty_driver</span><span class="o">-&gt;</span><span class="n">minor_start</span>		<span class="o">=</span> <span class="n">PTITTY_MINOR_START</span><span class="p">;</span>
	<span class="n">pti_tty_driver</span><span class="o">-&gt;</span><span class="n">type</span>			<span class="o">=</span> <span class="n">TTY_DRIVER_TYPE_SYSTEM</span><span class="p">;</span>
	<span class="n">pti_tty_driver</span><span class="o">-&gt;</span><span class="n">subtype</span>			<span class="o">=</span> <span class="n">SYSTEM_TYPE_SYSCONS</span><span class="p">;</span>
	<span class="n">pti_tty_driver</span><span class="o">-&gt;</span><span class="n">flags</span>			<span class="o">=</span> <span class="n">TTY_DRIVER_REAL_RAW</span> <span class="o">|</span>
						  <span class="n">TTY_DRIVER_DYNAMIC_DEV</span><span class="p">;</span>
	<span class="n">pti_tty_driver</span><span class="o">-&gt;</span><span class="n">init_termios</span>		<span class="o">=</span> <span class="n">tty_std_termios</span><span class="p">;</span>

	<span class="n">tty_set_operations</span><span class="p">(</span><span class="n">pti_tty_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pti_tty_driver_ops</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_register_driver</span><span class="p">(</span><span class="n">pti_tty_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): TTY registration failed of pti driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): Error value returned: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

		<span class="n">pti_tty_driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pti_pci_driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): PCI registration failed of pti driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): Error value returned: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

		<span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">pti_tty_driver</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): Unregistering TTY part of pti driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">pti_tty_driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pti_exit()- Unregisters this module as a tty and pci driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">pti_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">tty_unregister_device</span><span class="p">(</span><span class="n">pti_tty_driver</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tty_unregister_device</span><span class="p">(</span><span class="n">pti_tty_driver</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">pti_tty_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): TTY unregistration failed of pti driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): Error value returned: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pti_pci_driver</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pti_char_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): CHAR unregistration failed of pti driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%d): Error value returned: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">unregister_console</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pti_console</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">pti_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">pti_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Ken Mills, Jay Freyensee&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;PTI Driver&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
