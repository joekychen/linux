<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › eeprom › at25.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>at25.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * at25.c -- support most SPI EEPROMs, such as Atmel AT25 models</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 David Brownell</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#include &lt;linux/spi/spi.h&gt;</span>
<span class="cp">#include &lt;linux/spi/eeprom.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * NOTE: this is an *EEPROM* driver.  The vagaries of product naming</span>
<span class="cm"> * mean that some AT25 products are EEPROMs, and others are FLASH.</span>
<span class="cm"> * Handle FLASH chips with the drivers/mtd/devices/m25p80.c driver,</span>
<span class="cm"> * not this one!</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">at25_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memory_accessor</span>	<span class="n">mem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_eeprom</span>	<span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bin_attribute</span>	<span class="n">bin</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">addrlen</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define	AT25_WREN	0x06		</span><span class="cm">/* latch the write enable */</span><span class="cp"></span>
<span class="cp">#define	AT25_WRDI	0x04		</span><span class="cm">/* reset the write enable */</span><span class="cp"></span>
<span class="cp">#define	AT25_RDSR	0x05		</span><span class="cm">/* read status register */</span><span class="cp"></span>
<span class="cp">#define	AT25_WRSR	0x01		</span><span class="cm">/* write status register */</span><span class="cp"></span>
<span class="cp">#define	AT25_READ	0x03		</span><span class="cm">/* read byte(s) */</span><span class="cp"></span>
<span class="cp">#define	AT25_WRITE	0x02		</span><span class="cm">/* write byte(s)/sector */</span><span class="cp"></span>

<span class="cp">#define	AT25_SR_nRDY	0x01		</span><span class="cm">/* nRDY = write-in-progress */</span><span class="cp"></span>
<span class="cp">#define	AT25_SR_WEN	0x02		</span><span class="cm">/* write enable (latched) */</span><span class="cp"></span>
<span class="cp">#define	AT25_SR_BP0	0x04		</span><span class="cm">/* BP for software writeprotect */</span><span class="cp"></span>
<span class="cp">#define	AT25_SR_BP1	0x08</span>
<span class="cp">#define	AT25_SR_WPEN	0x80		</span><span class="cm">/* writeprotect enable */</span><span class="cp"></span>

<span class="cp">#define	AT25_INSTR_BIT3	0x08		</span><span class="cm">/* Additional address bit in instr */</span><span class="cp"></span>

<span class="cp">#define EE_MAXADDRLEN	3		</span><span class="cm">/* 24 bit addresses, up to 2 MBytes */</span><span class="cp"></span>

<span class="cm">/* Specs often allow 5 msec for a page write, sometimes 20 msec;</span>
<span class="cm"> * it&#39;s important to recover from write timeouts.</span>
<span class="cm"> */</span>
<span class="cp">#define	EE_TIMEOUT	25</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#define	io_limit	PAGE_SIZE	</span><span class="cm">/* bytes */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">at25_ee_read</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">at25_data</span>	<span class="o">*</span><span class="n">at25</span><span class="p">,</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">offset</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">count</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>			<span class="n">command</span><span class="p">[</span><span class="n">EE_MAXADDRLEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">spi_message</span>	<span class="n">m</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">instr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">cp</span> <span class="o">=</span> <span class="n">command</span><span class="p">;</span>

	<span class="n">instr</span> <span class="o">=</span> <span class="n">AT25_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EE_INSTR_BIT3_IS_ADDR</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">addrlen</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)))</span>
			<span class="n">instr</span> <span class="o">|=</span> <span class="n">AT25_INSTR_BIT3</span><span class="p">;</span>
	<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">instr</span><span class="p">;</span>

	<span class="cm">/* 8/16/24-bit address is written MSB first */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>	<span class="cm">/* case 3 */</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="k">case</span> <span class="mi">0</span>:	<span class="cm">/* can&#39;t happen: for better codegen */</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spi_message_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">t</span><span class="p">);</span>

	<span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">command</span><span class="p">;</span>
	<span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">addrlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

	<span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Read it all at once.</span>
<span class="cm">	 *</span>
<span class="cm">	 * REVISIT that&#39;s potentially a problem with large chips, if</span>
<span class="cm">	 * other devices on the bus need to be accessed regularly or</span>
<span class="cm">	 * this chip is clocked very slowly</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_sync</span><span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;read %Zd bytes at %d --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">status</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span> <span class="o">?</span> <span class="n">status</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">at25_bin_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span>
	      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">at25_data</span>	<span class="o">*</span><span class="n">at25</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="n">at25</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">at25_ee_read</span><span class="p">(</span><span class="n">at25</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">at25_ee_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">at25_data</span> <span class="o">*</span><span class="n">at25</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span>
	      <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">buf_size</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="o">*</span><span class="n">bounce</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">off</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* Temp buffer starts with command and address */</span>
	<span class="n">buf_size</span> <span class="o">=</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">page_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_size</span> <span class="o">&gt;</span> <span class="n">io_limit</span><span class="p">)</span>
		<span class="n">buf_size</span> <span class="o">=</span> <span class="n">io_limit</span><span class="p">;</span>
	<span class="n">bounce</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">buf_size</span> <span class="o">+</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">addrlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bounce</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* For write, rollover is within the page ... so we write at</span>
<span class="cm">	 * most one page, then manually roll over to the next page.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">timeout</span><span class="p">,</span> <span class="n">retries</span><span class="p">;</span>
		<span class="kt">unsigned</span>	<span class="n">segment</span><span class="p">;</span>
		<span class="kt">unsigned</span>	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">off</span><span class="p">;</span>
		<span class="n">u8</span>		<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">bounce</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">sr</span><span class="p">;</span>
		<span class="n">u8</span>		<span class="n">instr</span><span class="p">;</span>

		<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">AT25_WREN</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">spi_write</span><span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WREN --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">instr</span> <span class="o">=</span> <span class="n">AT25_WRITE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EE_INSTR_BIT3_IS_ADDR</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">addrlen</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)))</span>
				<span class="n">instr</span> <span class="o">|=</span> <span class="n">AT25_INSTR_BIT3</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">instr</span><span class="p">;</span>

		<span class="cm">/* 8/16/24-bit address is written MSB first */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">default:</span>	<span class="cm">/* case 3 */</span>
			<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">case</span> <span class="mi">0</span>:	<span class="cm">/* can&#39;t happen: for better codegen */</span>
			<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Write as much of a page as we can */</span>
		<span class="n">segment</span> <span class="o">=</span> <span class="n">buf_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">offset</span> <span class="o">%</span> <span class="n">buf_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">segment</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">segment</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">segment</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">spi_write</span><span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="n">bounce</span><span class="p">,</span>
				<span class="n">segment</span> <span class="o">+</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">addrlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;write %u bytes at %u --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">segment</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* REVISIT this should detect (or prevent) failed writes</span>
<span class="cm">		 * to readonly sections of the EEPROM...</span>
<span class="cm">		 */</span>

		<span class="cm">/* Wait for non-busy status */</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">EE_TIMEOUT</span><span class="p">);</span>
		<span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>

			<span class="n">sr</span> <span class="o">=</span> <span class="n">spi_w8r8</span><span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="n">AT25_RDSR</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">sr</span> <span class="o">&amp;</span> <span class="n">AT25_SR_nRDY</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;rdsr --&gt; %d (%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sr</span><span class="p">);</span>
				<span class="cm">/* at HZ=100, this is sloooow */</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sr</span> <span class="o">&amp;</span> <span class="n">AT25_SR_nRDY</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retries</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">time_before_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">sr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sr</span> <span class="o">&amp;</span> <span class="n">AT25_SR_nRDY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;write %d bytes offset %d, &quot;</span>
				<span class="s">&quot;timeout after %u msecs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">segment</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span>
					<span class="p">(</span><span class="n">timeout</span> <span class="o">-</span> <span class="n">EE_TIMEOUT</span><span class="p">)));</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">off</span> <span class="o">+=</span> <span class="n">segment</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">segment</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">segment</span><span class="p">;</span>
		<span class="n">written</span> <span class="o">+=</span> <span class="n">segment</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">bounce</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">written</span> <span class="o">?</span> <span class="n">written</span> <span class="o">:</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">at25_bin_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span>
	       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">at25_data</span>	<span class="o">*</span><span class="n">at25</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="n">at25</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">at25_ee_write</span><span class="p">(</span><span class="n">at25</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Let in-kernel code access the eeprom data. */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">at25_mem_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">memory_accessor</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			 <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at25_data</span> <span class="o">*</span><span class="n">at25</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="k">struct</span> <span class="n">at25_data</span><span class="p">,</span> <span class="n">mem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">at25_ee_read</span><span class="p">(</span><span class="n">at25</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">at25_mem_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">memory_accessor</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			  <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at25_data</span> <span class="o">*</span><span class="n">at25</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="k">struct</span> <span class="n">at25_data</span><span class="p">,</span> <span class="n">mem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">at25_ee_write</span><span class="p">(</span><span class="n">at25</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">at25_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at25_data</span>	<span class="o">*</span><span class="n">at25</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_eeprom</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">addrlen</span><span class="p">;</span>

	<span class="cm">/* Chip description */</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no chip description</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* For now we only support 8/16/24 bit addressing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EE_ADDR1</span><span class="p">)</span>
		<span class="n">addrlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EE_ADDR2</span><span class="p">)</span>
		<span class="n">addrlen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EE_ADDR3</span><span class="p">)</span>
		<span class="n">addrlen</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported address type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Ping the chip ... the status register is pretty portable,</span>
<span class="cm">	 * unlike probing manufacturer IDs.  We do expect that system</span>
<span class="cm">	 * firmware didn&#39;t write it in the past few milliseconds!</span>
<span class="cm">	 */</span>
	<span class="n">sr</span> <span class="o">=</span> <span class="n">spi_w8r8</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">AT25_RDSR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sr</span> <span class="o">&amp;</span> <span class="n">AT25_SR_nRDY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rdsr --&gt; %d (%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sr</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">at25</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">at25</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">at25</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">=</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="n">at25</span><span class="o">-&gt;</span><span class="n">spi</span> <span class="o">=</span> <span class="n">spi_dev_get</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">at25</span><span class="p">);</span>
	<span class="n">at25</span><span class="o">-&gt;</span><span class="n">addrlen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>

	<span class="cm">/* Export the EEPROM bytes through sysfs, since that&#39;s convenient.</span>
<span class="cm">	 * And maybe to other kernel code; it might hold a board&#39;s Ethernet</span>
<span class="cm">	 * address, or board-specific calibration data generated on the</span>
<span class="cm">	 * manufacturing floor.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Default to root-only access to the data; EEPROMs often hold data</span>
<span class="cm">	 * that&#39;s sensitive for read and/or write, like ethernet addresses,</span>
<span class="cm">	 * security codes, board-specific manufacturing calibrations, etc.</span>
<span class="cm">	 */</span>
	<span class="n">sysfs_bin_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">);</span>
	<span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;eeprom&quot;</span><span class="p">;</span>
	<span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUSR</span><span class="p">;</span>
	<span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">at25_bin_read</span><span class="p">;</span>
	<span class="n">at25</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">at25_mem_read</span><span class="p">;</span>

	<span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">byte_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EE_READONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">at25_bin_write</span><span class="p">;</span>
		<span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">S_IWUSR</span><span class="p">;</span>
		<span class="n">at25</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">at25_mem_write</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%Zd %s %s eeprom%s, pagesize %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">)</span>
			<span class="o">?</span> <span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span>
			<span class="o">:</span> <span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">),</span>
		<span class="p">(</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Byte&quot;</span> <span class="o">:</span> <span class="s">&quot;KByte&quot;</span><span class="p">,</span>
		<span class="n">at25</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
		<span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EE_READONLY</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; (readonly)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="n">at25</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">page_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;probe err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">at25</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">at25_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at25_data</span>	<span class="o">*</span><span class="n">at25</span><span class="p">;</span>

	<span class="n">at25</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">at25</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">at25</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spi_driver</span> <span class="n">at25_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;at25&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">at25_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">at25_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="n">module_spi_driver</span><span class="p">(</span><span class="n">at25_driver</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for most SPI EEPROMs&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Brownell&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;spi:at25&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
