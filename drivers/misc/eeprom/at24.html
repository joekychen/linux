<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › eeprom › at24.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>at24.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * at24.c - handle most I2C EEPROMs</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2007 David Brownell</span>
<span class="cm"> * Copyright (C) 2008 Wolfram Sang, Pengutronix</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/i2c/at24.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * I2C EEPROMs from most vendors are inexpensive and mostly interchangeable.</span>
<span class="cm"> * Differences between different vendor product lines (like Atmel AT24C or</span>
<span class="cm"> * MicroChip 24LC, etc) won&#39;t much matter for typical read/write access.</span>
<span class="cm"> * There are also I2C RAM chips, likewise interchangeable. One example</span>
<span class="cm"> * would be the PCF8570, which acts like a 24c02 EEPROM (256 bytes).</span>
<span class="cm"> *</span>
<span class="cm"> * However, misconfiguration can lose data. &quot;Set 16-bit memory address&quot;</span>
<span class="cm"> * to a part with 8-bit addressing will overwrite data. Writing with too</span>
<span class="cm"> * big a page size also loses data. And it&#39;s not safe to assume that the</span>
<span class="cm"> * conventional addresses 0x50..0x57 only hold eeproms; a PCF8563 RTC</span>
<span class="cm"> * uses 0x51, for just one example.</span>
<span class="cm"> *</span>
<span class="cm"> * Accordingly, explicit board-specific configuration data should be used</span>
<span class="cm"> * in almost all cases. (One partial exception is an SMBus used to access</span>
<span class="cm"> * &quot;SPD&quot; data for DRAM sticks. Those only use 24c02 EEPROMs.)</span>
<span class="cm"> *</span>
<span class="cm"> * So this driver uses &quot;new style&quot; I2C driver binding, expecting to be</span>
<span class="cm"> * told what devices exist. That may be in arch/X/mach-Y/board-Z.c or</span>
<span class="cm"> * similar kernel-resident tables; or, configuration data coming from</span>
<span class="cm"> * a bootloader.</span>
<span class="cm"> *</span>
<span class="cm"> * Other than binding model, current differences from &quot;eeprom&quot; driver are</span>
<span class="cm"> * that this one handles write access and isn&#39;t restricted to 24c02 devices.</span>
<span class="cm"> * It also handles larger devices (32 kbit and up) with two-byte addresses,</span>
<span class="cm"> * which won&#39;t work on pure SMBus systems.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">at24_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">at24_platform_data</span> <span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memory_accessor</span> <span class="n">macc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_smbus</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lock protects against activities from other Linux tasks,</span>
<span class="cm">	 * but not from changes by other I2C masters.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">bin</span><span class="p">;</span>

	<span class="n">u8</span> <span class="o">*</span><span class="n">writebuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">write_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">num_addresses</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some chips tie up multiple I2C addresses; dummy devices reserve</span>
<span class="cm">	 * them for us, and we&#39;ll use them with SMBus calls.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This parameter is to help this driver avoid blocking other drivers out</span>
<span class="cm"> * of I2C for potentially troublesome amounts of time. With a 100 kHz I2C</span>
<span class="cm"> * clock, one 256 byte read takes about 1/43 second which is excessive;</span>
<span class="cm"> * but the 1/170 second it takes at 400 kHz may be quite reasonable; and</span>
<span class="cm"> * at 1 MHz (Fm+) a 1/430 second delay could easily be invisible.</span>
<span class="cm"> *</span>
<span class="cm"> * This value is forced to be a power of two so that writes align on pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">io_limit</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">io_limit</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">io_limit</span><span class="p">,</span> <span class="s">&quot;Maximum bytes per I/O (default 128)&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Specs often allow 5 msec for a page write, sometimes 20 msec;</span>
<span class="cm"> * it&#39;s important to recover from write timeouts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">write_timeout</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">write_timeout</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">write_timeout</span><span class="p">,</span> <span class="s">&quot;Time (in ms) to try writes (default 25)&quot;</span><span class="p">);</span>

<span class="cp">#define AT24_SIZE_BYTELEN 5</span>
<span class="cp">#define AT24_SIZE_FLAGS 8</span>

<span class="cp">#define AT24_BITMASK(x) (BIT(x) - 1)</span>

<span class="cm">/* create non-zero magic value for given eeprom parameters */</span>
<span class="cp">#define AT24_DEVICE_MAGIC(_len, _flags) 		\</span>
<span class="cp">	((1 &lt;&lt; AT24_SIZE_FLAGS | (_flags)) 		\</span>
<span class="cp">	    &lt;&lt; AT24_SIZE_BYTELEN | ilog2(_len))</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="n">at24_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* needs 8 addresses as A0-A2 are ignored */</span>
	<span class="p">{</span> <span class="s">&quot;24c00&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">128</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">AT24_FLAG_TAKE8ADDR</span><span class="p">)</span> <span class="p">},</span>
	<span class="cm">/* old variants can&#39;t be handled with this generic entry! */</span>
	<span class="p">{</span> <span class="s">&quot;24c01&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">1024</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;24c02&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">2048</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
	<span class="cm">/* spd is a 24c02 in memory DIMMs */</span>
	<span class="p">{</span> <span class="s">&quot;spd&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">2048</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span>
		<span class="n">AT24_FLAG_READONLY</span> <span class="o">|</span> <span class="n">AT24_FLAG_IRUGO</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;24c04&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">4096</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
	<span class="cm">/* 24rf08 quirk is handled at i2c-core */</span>
	<span class="p">{</span> <span class="s">&quot;24c08&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">8192</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;24c16&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">16384</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;24c32&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">32768</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;24c64&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">65536</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;24c128&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">131072</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;24c256&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">262144</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;24c512&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">524288</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;24c1024&quot;</span><span class="p">,</span> <span class="n">AT24_DEVICE_MAGIC</span><span class="p">(</span><span class="mi">1048576</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;at24&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* END OF LIST */</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">i2c</span><span class="p">,</span> <span class="n">at24_ids</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * This routine supports chips which consume multiple I2C addresses. It</span>
<span class="cm"> * computes the addressing information to be used for a given r/w request.</span>
<span class="cm"> * Assumes that sanity checks for offset happened at sysfs-layer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="nf">at24_translate_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="o">*</span><span class="n">offset</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="o">*</span><span class="n">offset</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">at24</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">at24_eeprom_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">msgbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">read_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * REVISIT some multi-address chips don&#39;t rollover page reads to</span>
<span class="cm">	 * the next slave address, so we may need to truncate the count.</span>
<span class="cm">	 * Those chips might need another quirk flag.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the real hardware used four adjacent 24c02 chips and that</span>
<span class="cm">	 * were misconfigured as one 24c08, that would be a similar effect:</span>
<span class="cm">	 * one &quot;eeprom&quot; file not four, but larger reads would fail when</span>
<span class="cm">	 * they crossed certain pages.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Slave address and byte offset derive from the offset. Always</span>
<span class="cm">	 * set the byte address; on a multi-master board, another master</span>
<span class="cm">	 * may have changed the chip&#39;s &quot;current&quot; address pointer.</span>
<span class="cm">	 */</span>
	<span class="n">client</span> <span class="o">=</span> <span class="n">at24_translate_offset</span><span class="p">(</span><span class="n">at24</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">io_limit</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">io_limit</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">use_smbus</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span>:
		<span class="cm">/* Smaller eeproms can work given some SMBus extension calls */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_WORD_DATA</span>:
		<span class="n">count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_BYTE_DATA</span>:
		<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * When we have a better choice than SMBus calls, use a</span>
<span class="cm">		 * combined I2C message. Write address; then read up to</span>
<span class="cm">		 * io_limit data bytes. Note that read page rollover helps us</span>
<span class="cm">		 * here (unlike writes). msgbuf is u8 and will cast to our</span>
<span class="cm">		 * needs.</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span>
			<span class="n">msgbuf</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">msgbuf</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">buf</span> <span class="o">=</span> <span class="n">msgbuf</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">I2C_M_RD</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reads fail if the previous write didn&#39;t complete yet. We may</span>
<span class="cm">	 * loop a few times until this one succeeds, waiting at least</span>
<span class="cm">	 * long enough for one entire page write to work.</span>
<span class="cm">	 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">write_timeout</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">read_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">use_smbus</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span>:
			<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_read_i2c_block_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					<span class="n">count</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">I2C_SMBUS_WORD_DATA</span>:
			<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_read_word_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
				<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">status</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">I2C_SMBUS_BYTE_DATA</span>:
			<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_read_byte_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_transfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;read %zu@%d --&gt; %d (%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">count</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

		<span class="cm">/* REVISIT: at HZ=100, this is sloooow */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">read_time</span><span class="p">,</span> <span class="n">timeout</span><span class="p">));</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">at24_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read data from chip, protecting against concurrent updates</span>
<span class="cm">	 * from this host, but not from other I2C masters.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">ssize_t</span>	<span class="n">status</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">at24_eeprom_read</span><span class="p">(</span><span class="n">at24</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">at24_bin_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span><span class="p">;</span>

	<span class="n">at24</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">at24_read</span><span class="p">(</span><span class="n">at24</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Note that if the hardware write-protect pin is pulled high, the whole</span>
<span class="cm"> * chip is normally write protected. But there are plenty of product</span>
<span class="cm"> * variants here, including OTP fuses and partial chip protect.</span>
<span class="cm"> *</span>
<span class="cm"> * We only use page mode writes; the alternative is sloooow. This routine</span>
<span class="cm"> * writes at most one page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">at24_eeprom_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="n">msg</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">write_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">next_page</span><span class="p">;</span>

	<span class="cm">/* Get corresponding I2C address and adjust offset */</span>
	<span class="n">client</span> <span class="o">=</span> <span class="n">at24_translate_offset</span><span class="p">(</span><span class="n">at24</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>

	<span class="cm">/* write_max is at most a page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">at24</span><span class="o">-&gt;</span><span class="n">write_max</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">at24</span><span class="o">-&gt;</span><span class="n">write_max</span><span class="p">;</span>

	<span class="cm">/* Never roll over backwards, to the start of this page */</span>
	<span class="n">next_page</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">at24</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">page_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">next_page</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">next_page</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/* If we&#39;ll use I2C calls for I/O, set up the message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">use_smbus</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">msg</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* msg.buf is u8 and casts will mask the values */</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">at24</span><span class="o">-&gt;</span><span class="n">writebuf</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span>
			<span class="n">msg</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>

		<span class="n">msg</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Writes fail if the previous one didn&#39;t complete yet. We may</span>
<span class="cm">	 * loop a few times until this one succeeds, waiting at least</span>
<span class="cm">	 * long enough for one entire page write to work.</span>
<span class="cm">	 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">write_timeout</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">write_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">use_smbus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_write_i2c_block_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span>
					<span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_transfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;write %zu@%d --&gt; %zd (%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">count</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

		<span class="cm">/* REVISIT: at HZ=100, this is sloooow */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">write_time</span><span class="p">,</span> <span class="n">timeout</span><span class="p">));</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">at24_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write data to chip, protecting against concurrent updates</span>
<span class="cm">	 * from this host, but not from other I2C masters.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">ssize_t</span>	<span class="n">status</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">at24_eeprom_write</span><span class="p">(</span><span class="n">at24</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">at24_bin_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span><span class="p">;</span>

	<span class="n">at24</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">at24_write</span><span class="p">(</span><span class="n">at24</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * This lets other kernel code access the eeprom data. For example, it</span>
<span class="cm"> * might hold a board&#39;s Ethernet address, or board-specific calibration</span>
<span class="cm"> * data generated on the manufacturing floor.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">at24_macc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">memory_accessor</span> <span class="o">*</span><span class="n">macc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			 <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">macc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">at24_data</span><span class="p">,</span> <span class="n">macc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">at24_read</span><span class="p">(</span><span class="n">at24</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">at24_macc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">memory_accessor</span> <span class="o">*</span><span class="n">macc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			  <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">macc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">at24_data</span><span class="p">,</span> <span class="n">macc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">at24_write</span><span class="p">(</span><span class="n">at24</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef CONFIG_OF</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">at24_get_ofdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">at24_platform_data</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;read-only&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AT24_FLAG_READONLY</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;pagesize&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">at24_get_ofdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">at24_platform_data</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_OF */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">at24_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at24_platform_data</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">writable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_smbus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_addresses</span><span class="p">;</span>
	<span class="n">kernel_ulong_t</span> <span class="n">magic</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">at24_platform_data</span> <span class="o">*</span><span class="p">)</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">magic</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
		<span class="n">chip</span><span class="p">.</span><span class="n">byte_len</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">magic</span> <span class="o">&amp;</span> <span class="n">AT24_BITMASK</span><span class="p">(</span><span class="n">AT24_SIZE_BYTELEN</span><span class="p">));</span>
		<span class="n">magic</span> <span class="o">&gt;&gt;=</span> <span class="n">AT24_SIZE_BYTELEN</span><span class="p">;</span>
		<span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">magic</span> <span class="o">&amp;</span> <span class="n">AT24_BITMASK</span><span class="p">(</span><span class="n">AT24_SIZE_FLAGS</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is slow, but we can&#39;t know all eeproms, so we better</span>
<span class="cm">		 * play safe. Specifying custom eeprom-types via platform_data</span>
<span class="cm">		 * is recommended anyhow.</span>
<span class="cm">		 */</span>
		<span class="n">chip</span><span class="p">.</span><span class="n">page_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* update chipdata if OF is present */</span>
		<span class="n">at24_get_ofdata</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="p">);</span>

		<span class="n">chip</span><span class="p">.</span><span class="n">setup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">chip</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">chip</span><span class="p">.</span><span class="n">byte_len</span><span class="p">))</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;byte_len looks suspicious (no power of 2)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">.</span><span class="n">page_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;page_size must not be 0!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">chip</span><span class="p">.</span><span class="n">page_size</span><span class="p">))</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;page_size looks suspicious (no power of 2)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Use I2C operations unless we&#39;re stuck with SMBus extensions. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2c_check_functionality</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">I2C_FUNC_I2C</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPFNOSUPPORT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2c_check_functionality</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span>
				<span class="n">I2C_FUNC_SMBUS_READ_I2C_BLOCK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">use_smbus</span> <span class="o">=</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i2c_check_functionality</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span>
				<span class="n">I2C_FUNC_SMBUS_READ_WORD_DATA</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">use_smbus</span> <span class="o">=</span> <span class="n">I2C_SMBUS_WORD_DATA</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i2c_check_functionality</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span>
				<span class="n">I2C_FUNC_SMBUS_READ_BYTE_DATA</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">use_smbus</span> <span class="o">=</span> <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPFNOSUPPORT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AT24_FLAG_TAKE8ADDR</span><span class="p">)</span>
		<span class="n">num_addresses</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">num_addresses</span> <span class="o">=</span>	<span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">chip</span><span class="p">.</span><span class="n">byte_len</span><span class="p">,</span>
			<span class="p">(</span><span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AT24_FLAG_ADDR16</span><span class="p">)</span> <span class="o">?</span> <span class="mi">65536</span> <span class="o">:</span> <span class="mi">256</span><span class="p">);</span>

	<span class="n">at24</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">at24_data</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">num_addresses</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">at24</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">at24</span><span class="o">-&gt;</span><span class="n">use_smbus</span> <span class="o">=</span> <span class="n">use_smbus</span><span class="p">;</span>
	<span class="n">at24</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">at24</span><span class="o">-&gt;</span><span class="n">num_addresses</span> <span class="o">=</span> <span class="n">num_addresses</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Export the EEPROM bytes through sysfs, since that&#39;s convenient.</span>
<span class="cm">	 * By default, only root should see the data (maybe passwords etc)</span>
<span class="cm">	 */</span>
	<span class="n">sysfs_bin_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">);</span>
	<span class="n">at24</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;eeprom&quot;</span><span class="p">;</span>
	<span class="n">at24</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AT24_FLAG_IRUGO</span> <span class="o">?</span> <span class="n">S_IRUGO</span> <span class="o">:</span> <span class="n">S_IRUSR</span><span class="p">;</span>
	<span class="n">at24</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">at24_bin_read</span><span class="p">;</span>
	<span class="n">at24</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">chip</span><span class="p">.</span><span class="n">byte_len</span><span class="p">;</span>

	<span class="n">at24</span><span class="o">-&gt;</span><span class="n">macc</span><span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">at24_macc_read</span><span class="p">;</span>

	<span class="n">writable</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">chip</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AT24_FLAG_READONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_smbus</span> <span class="o">||</span> <span class="n">i2c_check_functionality</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span>
				<span class="n">I2C_FUNC_SMBUS_WRITE_I2C_BLOCK</span><span class="p">))</span> <span class="p">{</span>

			<span class="kt">unsigned</span> <span class="n">write_max</span> <span class="o">=</span> <span class="n">chip</span><span class="p">.</span><span class="n">page_size</span><span class="p">;</span>

			<span class="n">at24</span><span class="o">-&gt;</span><span class="n">macc</span><span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">at24_macc_write</span><span class="p">;</span>

			<span class="n">at24</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">at24_bin_write</span><span class="p">;</span>
			<span class="n">at24</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">S_IWUSR</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">write_max</span> <span class="o">&gt;</span> <span class="n">io_limit</span><span class="p">)</span>
				<span class="n">write_max</span> <span class="o">=</span> <span class="n">io_limit</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">use_smbus</span> <span class="o">&amp;&amp;</span> <span class="n">write_max</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">)</span>
				<span class="n">write_max</span> <span class="o">=</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">;</span>
			<span class="n">at24</span><span class="o">-&gt;</span><span class="n">write_max</span> <span class="o">=</span> <span class="n">write_max</span><span class="p">;</span>

			<span class="cm">/* buffer (data + address at the beginning) */</span>
			<span class="n">at24</span><span class="o">-&gt;</span><span class="n">writebuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">write_max</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">writebuf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">err_struct</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;cannot write due to controller restrictions.&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">at24</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">client</span><span class="p">;</span>

	<span class="cm">/* use dummy devices for multiple-address chips */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_addresses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">at24</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2c_new_dummy</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span>
					<span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;address 0x%02x unavailable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_clients</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_clients</span><span class="p">;</span>

	<span class="n">i2c_set_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">at24</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%zu byte %s EEPROM, %s, %u bytes/write</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">at24</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">writable</span> <span class="o">?</span> <span class="s">&quot;writable&quot;</span> <span class="o">:</span> <span class="s">&quot;read-only&quot;</span><span class="p">,</span> <span class="n">at24</span><span class="o">-&gt;</span><span class="n">write_max</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_smbus</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WORD_DATA</span> <span class="o">||</span>
	    <span class="n">use_smbus</span> <span class="o">==</span> <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Falling back to %s reads, &quot;</span>
			   <span class="s">&quot;performance will suffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">use_smbus</span> <span class="o">==</span>
			   <span class="n">I2C_SMBUS_WORD_DATA</span> <span class="o">?</span> <span class="s">&quot;word&quot;</span> <span class="o">:</span> <span class="s">&quot;byte&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* export data to kernel code */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="p">.</span><span class="n">setup</span><span class="p">)</span>
		<span class="n">chip</span><span class="p">.</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">macc</span><span class="p">,</span> <span class="n">chip</span><span class="p">.</span><span class="n">context</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_clients:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_addresses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">i2c_unregister_device</span><span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">writebuf</span><span class="p">);</span>
<span class="nl">err_struct:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">at24</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;probe error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">at24_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at24_data</span> <span class="o">*</span><span class="n">at24</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">at24</span> <span class="o">=</span> <span class="n">i2c_get_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">bin</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">at24</span><span class="o">-&gt;</span><span class="n">num_addresses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">i2c_unregister_device</span><span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">at24</span><span class="o">-&gt;</span><span class="n">writebuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">at24</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_driver</span> <span class="n">at24_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;at24&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">at24_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">at24_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">at24_ids</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">at24_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;at24: io_limit must not be 0!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">io_limit</span> <span class="o">=</span> <span class="n">rounddown_pow_of_two</span><span class="p">(</span><span class="n">io_limit</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i2c_add_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at24_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">at24_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">at24_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2c_del_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at24_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">at24_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for most I2C EEPROMs&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Brownell and Wolfram Sang&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
