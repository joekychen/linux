<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › sgi-gru › grukservices.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>grukservices.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SN Platform GRU Driver</span>
<span class="cm"> *</span>
<span class="cm"> *              KERNEL SERVICES THAT USE THE GRU</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;asm/io_apic.h&gt;</span>
<span class="cp">#include &quot;gru.h&quot;</span>
<span class="cp">#include &quot;grulib.h&quot;</span>
<span class="cp">#include &quot;grutables.h&quot;</span>
<span class="cp">#include &quot;grukservices.h&quot;</span>
<span class="cp">#include &quot;gru_instructions.h&quot;</span>
<span class="cp">#include &lt;asm/uv/uv_hub.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Kernel GRU Usage</span>
<span class="cm"> *</span>
<span class="cm"> * The following is an interim algorithm for management of kernel GRU</span>
<span class="cm"> * resources. This will likely be replaced when we better understand the</span>
<span class="cm"> * kernel/user requirements.</span>
<span class="cm"> *</span>
<span class="cm"> * Blade percpu resources reserved for kernel use. These resources are</span>
<span class="cm"> * reserved whenever the the kernel context for the blade is loaded. Note</span>
<span class="cm"> * that the kernel context is not guaranteed to be always available. It is</span>
<span class="cm"> * loaded on demand &amp; can be stolen by a user if the user demand exceeds the</span>
<span class="cm"> * kernel demand. The kernel can always reload the kernel context but</span>
<span class="cm"> * a SLEEP may be required!!!.</span>
<span class="cm"> *</span>
<span class="cm"> * Async Overview:</span>
<span class="cm"> *</span>
<span class="cm"> * 	Each blade has one &quot;kernel context&quot; that owns GRU kernel resources</span>
<span class="cm"> * 	located on the blade. Kernel drivers use GRU resources in this context</span>
<span class="cm"> * 	for sending messages, zeroing memory, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * 	The kernel context is dynamically loaded on demand. If it is not in</span>
<span class="cm"> * 	use by the kernel, the kernel context can be unloaded &amp; given to a user.</span>
<span class="cm"> * 	The kernel context will be reloaded when needed. This may require that</span>
<span class="cm"> * 	a context be stolen from a user.</span>
<span class="cm"> * 		NOTE: frequent unloading/reloading of the kernel context is</span>
<span class="cm"> * 		expensive. We are depending on batch schedulers, cpusets, sane</span>
<span class="cm"> * 		drivers or some other mechanism to prevent the need for frequent</span>
<span class="cm"> *	 	stealing/reloading.</span>
<span class="cm"> *</span>
<span class="cm"> * 	The kernel context consists of two parts:</span>
<span class="cm"> * 		- 1 CB &amp; a few DSRs that are reserved for each cpu on the blade.</span>
<span class="cm"> * 		  Each cpu has it&#39;s own private resources &amp; does not share them</span>
<span class="cm"> * 		  with other cpus. These resources are used serially, ie,</span>
<span class="cm"> * 		  locked, used &amp; unlocked  on each call to a function in</span>
<span class="cm"> * 		  grukservices.</span>
<span class="cm"> * 		  	(Now that we have dynamic loading of kernel contexts, I</span>
<span class="cm"> * 		  	 may rethink this &amp; allow sharing between cpus....)</span>
<span class="cm"> *</span>
<span class="cm"> *		- Additional resources can be reserved long term &amp; used directly</span>
<span class="cm"> *		  by UV drivers located in the kernel. Drivers using these GRU</span>
<span class="cm"> *		  resources can use asynchronous GRU instructions that send</span>
<span class="cm"> *		  interrupts on completion.</span>
<span class="cm"> *		  	- these resources must be explicitly locked/unlocked</span>
<span class="cm"> *		  	- locked resources prevent (obviously) the kernel</span>
<span class="cm"> *		  	  context from being unloaded.</span>
<span class="cm"> *			- drivers using these resource directly issue their own</span>
<span class="cm"> *			  GRU instruction and must wait/check completion.</span>
<span class="cm"> *</span>
<span class="cm"> * 		  When these resources are reserved, the caller can optionally</span>
<span class="cm"> * 		  associate a wait_queue with the resources and use asynchronous</span>
<span class="cm"> * 		  GRU instructions. When an async GRU instruction completes, the</span>
<span class="cm"> * 		  driver will do a wakeup on the event.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>


<span class="cp">#define ASYNC_HAN_TO_BID(h)	((h) - 1)</span>
<span class="cp">#define ASYNC_BID_TO_HAN(b)	((b) + 1)</span>
<span class="cp">#define ASYNC_HAN_TO_BS(h)	gru_base[ASYNC_HAN_TO_BID(h)]</span>

<span class="cp">#define GRU_NUM_KERNEL_CBR	1</span>
<span class="cp">#define GRU_NUM_KERNEL_DSR_BYTES 256</span>
<span class="cp">#define GRU_NUM_KERNEL_DSR_CL	(GRU_NUM_KERNEL_DSR_BYTES /		\</span>
<span class="cp">					GRU_CACHE_LINE_BYTES)</span>

<span class="cm">/* GRU instruction attributes for all instructions */</span>
<span class="cp">#define IMA			IMA_CB_DELAY</span>

<span class="cm">/* GRU cacheline size is always 64 bytes - even on arches with 128 byte lines */</span>
<span class="cp">#define __gru_cacheline_aligned__                               \</span>
<span class="cp">	__attribute__((__aligned__(GRU_CACHE_LINE_BYTES)))</span>

<span class="cp">#define MAGIC	0x1234567887654321UL</span>

<span class="cm">/* Default retry count for GRU errors on kernel instructions */</span>
<span class="cp">#define EXCEPTION_RETRY_LIMIT	3</span>

<span class="cm">/* Status of message queue sections */</span>
<span class="cp">#define MQS_EMPTY		0</span>
<span class="cp">#define MQS_FULL		1</span>
<span class="cp">#define MQS_NOOP		2</span>

<span class="cm">/*----------------- RESOURCE MANAGEMENT -------------------------------------*/</span>
<span class="cm">/* optimized for x86_64 */</span>
<span class="k">struct</span> <span class="n">message_queue</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">gru_mesqhead</span>	<span class="n">head</span> <span class="n">__gru_cacheline_aligned__</span><span class="p">;</span>	<span class="cm">/* CL 0 */</span>
	<span class="kt">int</span>			<span class="n">qlines</span><span class="p">;</span>				<span class="cm">/* DW 1 */</span>
	<span class="kt">long</span> 			<span class="n">hstatus</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">void</span> 			<span class="o">*</span><span class="n">next</span> <span class="n">__gru_cacheline_aligned__</span><span class="p">;</span><span class="cm">/* CL 1 */</span>
	<span class="kt">void</span> 			<span class="o">*</span><span class="n">limit</span><span class="p">;</span>
	<span class="kt">void</span> 			<span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="kt">void</span> 			<span class="o">*</span><span class="n">start2</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">data</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>	<span class="cm">/* CL 2 */</span>
<span class="p">};</span>

<span class="cm">/* First word in every message - used by mesq interface */</span>
<span class="k">struct</span> <span class="n">message_header</span> <span class="p">{</span>
	<span class="kt">char</span>	<span class="n">present</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">present2</span><span class="p">;</span>
	<span class="kt">char</span> 	<span class="n">lines</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">fill</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define HSTATUS(mq, h)	((mq) + offsetof(struct message_queue, hstatus[h]))</span>

<span class="cm">/*</span>
<span class="cm"> * Reload the blade&#39;s kernel context into a GRU chiplet. Called holding</span>
<span class="cm"> * the bs_kgts_sema for READ. Will steal user contexts if necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_load_kernel_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blade_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">kgts</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxnum</span><span class="p">,</span> <span class="n">ncpus</span><span class="p">;</span>

	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts</span> <span class="o">=</span> <span class="n">gru_alloc_gts</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts</span><span class="o">-&gt;</span><span class="n">ts_user_blade_id</span> <span class="o">=</span> <span class="n">blade_id</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kgts</span> <span class="o">=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kgts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">load_kernel_context</span><span class="p">);</span>
		<span class="n">ncpus</span> <span class="o">=</span> <span class="n">uv_blade_nr_possible_cpus</span><span class="p">(</span><span class="n">blade_id</span><span class="p">);</span>
		<span class="n">kgts</span><span class="o">-&gt;</span><span class="n">ts_cbr_au_count</span> <span class="o">=</span> <span class="n">GRU_CB_COUNT_TO_AU</span><span class="p">(</span>
			<span class="n">GRU_NUM_KERNEL_CBR</span> <span class="o">*</span> <span class="n">ncpus</span> <span class="o">+</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_cbrs</span><span class="p">);</span>
		<span class="n">kgts</span><span class="o">-&gt;</span><span class="n">ts_dsr_au_count</span> <span class="o">=</span> <span class="n">GRU_DS_BYTES_TO_AU</span><span class="p">(</span>
			<span class="n">GRU_NUM_KERNEL_DSR_BYTES</span> <span class="o">*</span> <span class="n">ncpus</span> <span class="o">+</span>
				<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_dsr_bytes</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">gru_assign_gru_context</span><span class="p">(</span><span class="n">kgts</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">gru_steal_context</span><span class="p">(</span><span class="n">kgts</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">gru_load_context</span><span class="p">(</span><span class="n">kgts</span><span class="p">);</span>
		<span class="n">gru</span> <span class="o">=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">;</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_vaddr</span><span class="p">;</span>
		<span class="n">ctxnum</span> <span class="o">=</span> <span class="n">kgts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">;</span>
		<span class="n">bs</span><span class="o">-&gt;</span><span class="n">kernel_cb</span> <span class="o">=</span> <span class="n">get_gseg_base_address_cb</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">ctxnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bs</span><span class="o">-&gt;</span><span class="n">kernel_dsr</span> <span class="o">=</span> <span class="n">get_gseg_base_address_ds</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">ctxnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">downgrade_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free all kernel contexts that are not currently in use.</span>
<span class="cm"> *   Returns 0 if all freed, else number of inuse context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_free_kernel_contexts</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">kgts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bid</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bid</span> <span class="o">&lt;</span> <span class="n">GRU_MAX_BLADES</span><span class="p">;</span> <span class="n">bid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bs</span> <span class="o">=</span> <span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Ignore busy contexts. Don&#39;t want to block here.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">down_write_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kgts</span> <span class="o">=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kgts</span> <span class="o">&amp;&amp;</span> <span class="n">kgts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">)</span>
				<span class="n">gru_unload_context</span><span class="p">(</span><span class="n">kgts</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">kgts</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lock &amp; load the kernel context for the specified blade.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="nf">gru_lock_kernel_context</span><span class="p">(</span><span class="kt">int</span> <span class="n">blade_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bid</span><span class="p">;</span>

	<span class="n">STAT</span><span class="p">(</span><span class="n">lock_kernel_context</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">bid</span> <span class="o">=</span> <span class="n">blade_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">uv_numa_blade_id</span><span class="p">()</span> <span class="o">:</span> <span class="n">blade_id</span><span class="p">;</span>
	<span class="n">bs</span> <span class="o">=</span> <span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">];</span>

	<span class="cm">/* Handle the case where migration occurred while waiting for the sema */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blade_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bid</span> <span class="o">!=</span> <span class="n">uv_numa_blade_id</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts</span> <span class="o">||</span> <span class="o">!</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">)</span>
		<span class="n">gru_load_kernel_context</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">bid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bs</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unlock the kernel context for the specified blade. Context is not</span>
<span class="cm"> * unloaded but may be stolen before next use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_unlock_kernel_context</span><span class="p">(</span><span class="kt">int</span> <span class="n">blade_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>

	<span class="n">bs</span> <span class="o">=</span> <span class="n">gru_base</span><span class="p">[</span><span class="n">blade_id</span><span class="p">];</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
	<span class="n">STAT</span><span class="p">(</span><span class="n">unlock_kernel_context</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reserve &amp; get pointers to the DSR/CBRs reserved for the current cpu.</span>
<span class="cm"> * 	- returns with preemption disabled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_get_cpu_resources</span><span class="p">(</span><span class="kt">int</span> <span class="n">dsr_bytes</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">dsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lcpu</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dsr_bytes</span> <span class="o">&gt;</span> <span class="n">GRU_NUM_KERNEL_DSR_BYTES</span><span class="p">);</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">bs</span> <span class="o">=</span> <span class="n">gru_lock_kernel_context</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">lcpu</span> <span class="o">=</span> <span class="n">uv_blade_processor_id</span><span class="p">();</span>
	<span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">kernel_cb</span> <span class="o">+</span> <span class="n">lcpu</span> <span class="o">*</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dsr</span> <span class="o">=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">kernel_dsr</span> <span class="o">+</span> <span class="n">lcpu</span> <span class="o">*</span> <span class="n">GRU_NUM_KERNEL_DSR_BYTES</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free the current cpus reserved DSR/CBR resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_free_cpu_resources</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gru_unlock_kernel_context</span><span class="p">(</span><span class="n">uv_numa_blade_id</span><span class="p">());</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reserve GRU resources to be used asynchronously.</span>
<span class="cm"> *   Note: currently supports only 1 reservation per blade.</span>
<span class="cm"> *</span>
<span class="cm"> * 	input:</span>
<span class="cm"> * 		blade_id  - blade on which resources should be reserved</span>
<span class="cm"> * 		cbrs	  - number of CBRs</span>
<span class="cm"> * 		dsr_bytes - number of DSR bytes needed</span>
<span class="cm"> *	output:</span>
<span class="cm"> *		handle to identify resource</span>
<span class="cm"> *		(0 = async resources already reserved)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">gru_reserve_async_resources</span><span class="p">(</span><span class="kt">int</span> <span class="n">blade_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cbrs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dsr_bytes</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">cmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">kgts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bs</span> <span class="o">=</span> <span class="n">gru_base</span><span class="p">[</span><span class="n">blade_id</span><span class="p">];</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>

	<span class="cm">/* Verify no resources already reserved */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_dsr_bytes</span> <span class="o">+</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_cbrs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_dsr_bytes</span> <span class="o">=</span> <span class="n">dsr_bytes</span><span class="p">;</span>
	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_cbrs</span> <span class="o">=</span> <span class="n">cbrs</span><span class="p">;</span>
	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_wq</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">;</span>
	<span class="n">kgts</span> <span class="o">=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts</span><span class="p">;</span>

	<span class="cm">/* Resources changed. Unload context if already loaded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kgts</span> <span class="o">&amp;&amp;</span> <span class="n">kgts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">)</span>
		<span class="n">gru_unload_context</span><span class="p">(</span><span class="n">kgts</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ASYNC_BID_TO_HAN</span><span class="p">(</span><span class="n">blade_id</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release async resources previously reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *	input:</span>
<span class="cm"> *		han - handle to identify resources</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gru_release_async_resources</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">han</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span> <span class="o">=</span> <span class="n">ASYNC_HAN_TO_BS</span><span class="p">(</span><span class="n">han</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_dsr_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_cbrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for async GRU instructions to complete.</span>
<span class="cm"> *</span>
<span class="cm"> *	input:</span>
<span class="cm"> *		han - handle to identify resources</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gru_wait_async_cbr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">han</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span> <span class="o">=</span> <span class="n">ASYNC_HAN_TO_BS</span><span class="p">(</span><span class="n">han</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_async_wq</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lock previous reserved async GRU resources</span>
<span class="cm"> *</span>
<span class="cm"> *	input:</span>
<span class="cm"> *		han - handle to identify resources</span>
<span class="cm"> *	output:</span>
<span class="cm"> *		cb  - pointer to first CBR</span>
<span class="cm"> *		dsr - pointer to first DSR</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gru_lock_async_resource</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">han</span><span class="p">,</span>  <span class="kt">void</span> <span class="o">**</span><span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">dsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span> <span class="o">=</span> <span class="n">ASYNC_HAN_TO_BS</span><span class="p">(</span><span class="n">han</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">blade_id</span> <span class="o">=</span> <span class="n">ASYNC_HAN_TO_BID</span><span class="p">(</span><span class="n">han</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ncpus</span><span class="p">;</span>

	<span class="n">gru_lock_kernel_context</span><span class="p">(</span><span class="n">blade_id</span><span class="p">);</span>
	<span class="n">ncpus</span> <span class="o">=</span> <span class="n">uv_blade_nr_possible_cpus</span><span class="p">(</span><span class="n">blade_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">kernel_cb</span> <span class="o">+</span> <span class="n">ncpus</span> <span class="o">*</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dsr</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dsr</span> <span class="o">=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">kernel_dsr</span> <span class="o">+</span> <span class="n">ncpus</span> <span class="o">*</span> <span class="n">GRU_NUM_KERNEL_DSR_BYTES</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unlock previous reserved async GRU resources</span>
<span class="cm"> *</span>
<span class="cm"> *	input:</span>
<span class="cm"> *		han - handle to identify resources</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gru_unlock_async_resource</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">han</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blade_id</span> <span class="o">=</span> <span class="n">ASYNC_HAN_TO_BID</span><span class="p">(</span><span class="n">han</span><span class="p">);</span>

	<span class="n">gru_unlock_kernel_context</span><span class="p">(</span><span class="n">blade_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">gru_get_cb_exception_detail</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">control_block_extended_exc_detail</span> <span class="o">*</span><span class="n">excdet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_control_block_extended</span> <span class="o">*</span><span class="n">cbe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">kgts</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cbrnum</span><span class="p">,</span> <span class="n">bid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Locate kgts for cb. This algorithm is SLOW but</span>
<span class="cm">	 * this function is rarely called (ie., almost never).</span>
<span class="cm">	 * Performance does not matter.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_possible_blade</span><span class="p">(</span><span class="n">bid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">kgts</span> <span class="o">=</span> <span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bs_kgts</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kgts</span> <span class="o">||</span> <span class="o">!</span><span class="n">kgts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">cb</span> <span class="o">-</span> <span class="n">kgts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_vaddr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&lt;</span> <span class="n">GRU_SIZE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">kgts</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kgts</span><span class="p">);</span>
	<span class="n">cbrnum</span> <span class="o">=</span> <span class="n">thread_cbr_number</span><span class="p">(</span><span class="n">kgts</span><span class="p">,</span> <span class="n">get_cb_number</span><span class="p">(</span><span class="n">cb</span><span class="p">));</span>
	<span class="n">cbe</span> <span class="o">=</span> <span class="n">get_cbe</span><span class="p">(</span><span class="n">GRUBASE</span><span class="p">(</span><span class="n">cb</span><span class="p">),</span> <span class="n">cbrnum</span><span class="p">);</span>
	<span class="n">gru_flush_cache</span><span class="p">(</span><span class="n">cbe</span><span class="p">);</span>	<span class="cm">/* CBE not coherent */</span>
	<span class="n">sync_core</span><span class="p">();</span>
	<span class="n">excdet</span><span class="o">-&gt;</span><span class="n">opc</span> <span class="o">=</span> <span class="n">cbe</span><span class="o">-&gt;</span><span class="n">opccpy</span><span class="p">;</span>
	<span class="n">excdet</span><span class="o">-&gt;</span><span class="n">exopc</span> <span class="o">=</span> <span class="n">cbe</span><span class="o">-&gt;</span><span class="n">exopccpy</span><span class="p">;</span>
	<span class="n">excdet</span><span class="o">-&gt;</span><span class="n">ecause</span> <span class="o">=</span> <span class="n">cbe</span><span class="o">-&gt;</span><span class="n">ecause</span><span class="p">;</span>
	<span class="n">excdet</span><span class="o">-&gt;</span><span class="n">exceptdet0</span> <span class="o">=</span> <span class="n">cbe</span><span class="o">-&gt;</span><span class="n">idef1upd</span><span class="p">;</span>
	<span class="n">excdet</span><span class="o">-&gt;</span><span class="n">exceptdet1</span> <span class="o">=</span> <span class="n">cbe</span><span class="o">-&gt;</span><span class="n">idef3upd</span><span class="p">;</span>
	<span class="n">gru_flush_cache</span><span class="p">(</span><span class="n">cbe</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">gru_get_cb_exception_detail_str</span><span class="p">(</span><span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_control_block_status</span> <span class="o">*</span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">control_block_extended_exc_detail</span> <span class="n">excdet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">gen</span><span class="o">-&gt;</span><span class="n">istatus</span> <span class="o">==</span> <span class="n">CBS_EXCEPTION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gru_get_cb_exception_detail</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">excdet</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="s">&quot;GRU:%d exception: cb %p, opc %d, exopc %d, ecause 0x%x,&quot;</span>
			<span class="s">&quot;excdet0 0x%lx, excdet1 0x%x&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span>
			<span class="n">gen</span><span class="p">,</span> <span class="n">excdet</span><span class="p">.</span><span class="n">opc</span><span class="p">,</span> <span class="n">excdet</span><span class="p">.</span><span class="n">exopc</span><span class="p">,</span> <span class="n">excdet</span><span class="p">.</span><span class="n">ecause</span><span class="p">,</span>
			<span class="n">excdet</span><span class="p">.</span><span class="n">exceptdet0</span><span class="p">,</span> <span class="n">excdet</span><span class="p">.</span><span class="n">exceptdet1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;No exception&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_wait_idle_or_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_control_block_status</span> <span class="o">*</span><span class="n">gen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">gen</span><span class="o">-&gt;</span><span class="n">istatus</span> <span class="o">&gt;=</span> <span class="n">CBS_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">gen</span><span class="o">-&gt;</span><span class="n">istatus</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_retry_exception</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_control_block_status</span> <span class="o">*</span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">control_block_extended_exc_detail</span> <span class="n">excdet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retry</span> <span class="o">=</span> <span class="n">EXCEPTION_RETRY_LIMIT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gru_wait_idle_or_exception</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="o">==</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">CBS_IDLE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gru_get_cb_message_queue_substatus</span><span class="p">(</span><span class="n">cb</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">CBS_EXCEPTION</span><span class="p">;</span>
		<span class="n">gru_get_cb_exception_detail</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">excdet</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">excdet</span><span class="p">.</span><span class="n">ecause</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EXCEPTION_RETRY_BITS</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">excdet</span><span class="p">.</span><span class="n">cbrexecstatus</span> <span class="o">&amp;</span> <span class="n">CBR_EXS_ABORT_OCC</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retry</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">gen</span><span class="o">-&gt;</span><span class="n">icmd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">gru_flush_cache</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">CBS_EXCEPTION</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gru_check_status_proc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_control_block_status</span> <span class="o">*</span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gen</span><span class="o">-&gt;</span><span class="n">istatus</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">CBS_EXCEPTION</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_retry_exception</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
	<span class="n">rmb</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gru_wait_proc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_control_block_status</span> <span class="o">*</span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_wait_idle_or_exception</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">CBS_EXCEPTION</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_retry_exception</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
	<span class="n">rmb</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gru_abort</span><span class="p">(</span><span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">GRU_EXC_STR_SIZE</span><span class="p">];</span>

	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;GRU FATAL ERROR: %s - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span>
	      <span class="n">gru_get_cb_exception_detail_str</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gru_wait_abort_proc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_wait_proc</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">gru_abort</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="s">&quot;gru_wait_abort&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*------------------------------ MESSAGE QUEUES -----------------------------*/</span>

<span class="cm">/* Internal status . These are NOT returned to the user. */</span>
<span class="cp">#define MQIE_AGAIN		-1	</span><span class="cm">/* try again */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Save/restore the &quot;present&quot; flag that is in the second line of 2-line</span>
<span class="cm"> * messages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_present2</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">message_header</span> <span class="o">*</span><span class="n">mhdr</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_present2</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">message_header</span> <span class="o">*</span><span class="n">mhdr</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">;</span>
	<span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a message queue.</span>
<span class="cm"> * 	qlines - message queue size in cache lines. Includes 2-line header.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gru_create_message_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_message_queue_desc</span> <span class="o">*</span><span class="n">mqd</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nasid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">message_queue</span> <span class="o">*</span><span class="n">mq</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qlines</span><span class="p">;</span>

	<span class="n">qlines</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">/</span> <span class="n">GRU_CACHE_LINE_BYTES</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">mq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">start2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="p">(</span><span class="n">qlines</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="p">(</span><span class="n">qlines</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">qlines</span> <span class="o">=</span> <span class="n">qlines</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">hstatus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">hstatus</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">gru_mesq_head</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">qlines</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq</span> <span class="o">=</span> <span class="n">mq</span><span class="p">;</span>
	<span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq_gpa</span> <span class="o">=</span> <span class="n">uv_gpa</span><span class="p">(</span><span class="n">mq</span><span class="p">);</span>
	<span class="n">mqd</span><span class="o">-&gt;</span><span class="n">qlines</span> <span class="o">=</span> <span class="n">qlines</span><span class="p">;</span>
	<span class="n">mqd</span><span class="o">-&gt;</span><span class="n">interrupt_pnode</span> <span class="o">=</span> <span class="n">nasid</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mqd</span><span class="o">-&gt;</span><span class="n">interrupt_vector</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>
	<span class="n">mqd</span><span class="o">-&gt;</span><span class="n">interrupt_apicid</span> <span class="o">=</span> <span class="n">apicid</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gru_create_message_queue</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Send a NOOP message to a message queue</span>
<span class="cm"> * 	Returns:</span>
<span class="cm"> * 		 0 - if queue is full after the send. This is the normal case</span>
<span class="cm"> * 		     but various races can change this.</span>
<span class="cm"> *		-1 - if mesq sent successfully but queue not full</span>
<span class="cm"> *		&gt;0 - unexpected error. MQE_xxx returned</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_noop_message</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gru_message_queue_desc</span> <span class="o">*</span><span class="n">mqd</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">message_header</span> <span class="n">noop_header</span> <span class="o">=</span> <span class="p">{</span>
					<span class="p">.</span><span class="n">present</span> <span class="o">=</span> <span class="n">MQS_NOOP</span><span class="p">,</span> <span class="p">.</span><span class="n">lines</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">substatus</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">message_header</span> <span class="n">save_mhdr</span><span class="p">,</span> <span class="o">*</span><span class="n">mhdr</span> <span class="o">=</span> <span class="n">mesg</span><span class="p">;</span>

	<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_noop</span><span class="p">);</span>
	<span class="n">save_mhdr</span> <span class="o">=</span> <span class="o">*</span><span class="n">mhdr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">mhdr</span> <span class="o">=</span> <span class="n">noop_header</span><span class="p">;</span>
	<span class="n">gru_mesq</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq_gpa</span><span class="p">,</span> <span class="n">gru_get_tri</span><span class="p">(</span><span class="n">mhdr</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">substatus</span> <span class="o">=</span> <span class="n">gru_get_cb_message_queue_substatus</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">substatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CBSS_NO_ERROR</span>:
			<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_noop_unexpected_error</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">MQE_UNEXPECTED_CB_ERR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CBSS_LB_OVERFLOWED</span>:
			<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_noop_lb_overflow</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">MQE_CONGESTION</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CBSS_QLIMIT_REACHED</span>:
			<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_noop_qlimit_reached</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CBSS_AMO_NACKED</span>:
			<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_noop_amo_nacked</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">MQE_CONGESTION</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CBSS_PUT_NACKED</span>:
			<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_noop_put_nacked</span><span class="p">);</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq_gpa</span> <span class="o">+</span> <span class="p">(</span><span class="n">gru_get_amo_value_head</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
			<span class="n">gru_vstore</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">gru_get_tri</span><span class="p">(</span><span class="n">mesg</span><span class="p">),</span> <span class="n">XTYPE_CL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">IMA</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">==</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">MQIE_AGAIN</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">MQE_UNEXPECTED_CB_ERR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CBSS_PAGE_OVERFLOW</span>:
			<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_noop_page_overflow</span><span class="p">);</span>
			<span class="cm">/* fallthru */</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">mhdr</span> <span class="o">=</span> <span class="n">save_mhdr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a gru_mesq full.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_message_queue_full</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gru_message_queue_desc</span> <span class="o">*</span><span class="n">mqd</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">mesg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lines</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">gru_mesqhead</span> <span class="n">mqh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">,</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avalue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">half</span><span class="p">,</span> <span class="n">qlines</span><span class="p">;</span>

	<span class="cm">/* Determine if switching to first/second half of q */</span>
	<span class="n">avalue</span> <span class="o">=</span> <span class="n">gru_get_amo_value</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">gru_get_amo_value_head</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">gru_get_amo_value_limit</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>

	<span class="n">qlines</span> <span class="o">=</span> <span class="n">mqd</span><span class="o">-&gt;</span><span class="n">qlines</span><span class="p">;</span>
	<span class="n">half</span> <span class="o">=</span> <span class="p">(</span><span class="n">limit</span> <span class="o">!=</span> <span class="n">qlines</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">half</span><span class="p">)</span>
		<span class="n">mqh</span> <span class="o">=</span> <span class="n">gru_mesq_head</span><span class="p">(</span><span class="n">qlines</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">qlines</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mqh</span> <span class="o">=</span> <span class="n">gru_mesq_head</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">qlines</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Try to get lock for switching head pointer */</span>
	<span class="n">gru_gamir</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">EOP_IR_CLR</span><span class="p">,</span> <span class="n">HSTATUS</span><span class="p">(</span><span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq_gpa</span><span class="p">,</span> <span class="n">half</span><span class="p">),</span> <span class="n">XTYPE_DW</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cberr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gru_get_amo_value</span><span class="p">(</span><span class="n">cb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_qf_locked</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">MQE_QUEUE_FULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Got the lock. Send optional NOP if queue not full, */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">send_noop_message</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">mqd</span><span class="p">,</span> <span class="n">mesg</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">gru_gamir</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">EOP_IR_INC</span><span class="p">,</span> <span class="n">HSTATUS</span><span class="p">(</span><span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq_gpa</span><span class="p">,</span> <span class="n">half</span><span class="p">),</span>
					<span class="n">XTYPE_DW</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cberr</span><span class="p">;</span>
			<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_qf_noop_not_full</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">MQIE_AGAIN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">avalue</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Then flip queuehead to other half of queue. */</span>
	<span class="n">gru_gamer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">EOP_ERR_CSWAP</span><span class="p">,</span> <span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq_gpa</span><span class="p">,</span> <span class="n">XTYPE_DW</span><span class="p">,</span> <span class="n">mqh</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">avalue</span><span class="p">,</span>
							<span class="n">IMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cberr</span><span class="p">;</span>

	<span class="cm">/* If not successfully in swapping queue head, clear the hstatus lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru_get_amo_value</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">avalue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_qf_switch_head_failed</span><span class="p">);</span>
		<span class="n">gru_gamir</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">EOP_IR_INC</span><span class="p">,</span> <span class="n">HSTATUS</span><span class="p">(</span><span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq_gpa</span><span class="p">,</span> <span class="n">half</span><span class="p">),</span> <span class="n">XTYPE_DW</span><span class="p">,</span>
							<span class="n">IMA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cberr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">MQIE_AGAIN</span><span class="p">;</span>
<span class="nl">cberr:</span>
	<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_qf_unexpected_error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">MQE_UNEXPECTED_CB_ERR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a PUT failure. Note: if message was a 2-line message, one of the</span>
<span class="cm"> * lines might have successfully have been written. Before sending the</span>
<span class="cm"> * message, &quot;present&quot; must be cleared in BOTH lines to prevent the receiver</span>
<span class="cm"> * from prematurely seeing the full message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_message_put_nacked</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gru_message_queue_desc</span> <span class="o">*</span><span class="n">mqd</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">mesg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lines</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">save</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq_gpa</span> <span class="o">+</span> <span class="p">(</span><span class="n">gru_get_amo_value_head</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lines</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gru_vset</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XTYPE_CL</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">MQE_UNEXPECTED_CB_ERR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gru_vstore</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">gru_get_tri</span><span class="p">(</span><span class="n">mesg</span><span class="p">),</span> <span class="n">XTYPE_CL</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">MQE_UNEXPECTED_CB_ERR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mqd</span><span class="o">-&gt;</span><span class="n">interrupt_vector</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">MQE_OK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send a cross-partition interrupt to the SSI that contains the target</span>
<span class="cm">	 * message queue. Normally, the interrupt is automatically delivered by</span>
<span class="cm">	 * hardware but some error conditions require explicit delivery.</span>
<span class="cm">	 * Use the GRU to deliver the interrupt. Otherwise partition failures</span>
<span class="cm">	 * could cause unrecovered errors.</span>
<span class="cm">	 */</span>
	<span class="n">gpa</span> <span class="o">=</span> <span class="n">uv_global_gru_mmr_address</span><span class="p">(</span><span class="n">mqd</span><span class="o">-&gt;</span><span class="n">interrupt_pnode</span><span class="p">,</span> <span class="n">UVH_IPI_INT</span><span class="p">);</span>
	<span class="n">save</span> <span class="o">=</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">uv_hub_ipi_value</span><span class="p">(</span><span class="n">mqd</span><span class="o">-&gt;</span><span class="n">interrupt_apicid</span><span class="p">,</span> <span class="n">mqd</span><span class="o">-&gt;</span><span class="n">interrupt_vector</span><span class="p">,</span>
				<span class="n">dest_Fixed</span><span class="p">);</span>
	<span class="n">gru_vstore_phys</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">gru_get_tri</span><span class="p">(</span><span class="n">mesg</span><span class="p">),</span> <span class="n">IAA_REGISTER</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">save</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">MQE_UNEXPECTED_CB_ERR</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">MQE_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a gru_mesq failure. Some of these failures are software recoverable</span>
<span class="cm"> * or retryable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_message_failure</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gru_message_queue_desc</span> <span class="o">*</span><span class="n">mqd</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">mesg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lines</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">substatus</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">substatus</span> <span class="o">=</span> <span class="n">gru_get_cb_message_queue_substatus</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">substatus</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CBSS_NO_ERROR</span>:
		<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_send_unexpected_error</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MQE_UNEXPECTED_CB_ERR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CBSS_LB_OVERFLOWED</span>:
		<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_send_lb_overflow</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MQE_CONGESTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CBSS_QLIMIT_REACHED</span>:
		<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_send_qlimit_reached</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">send_message_queue_full</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">mqd</span><span class="p">,</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">lines</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CBSS_AMO_NACKED</span>:
		<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_send_amo_nacked</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MQE_CONGESTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CBSS_PUT_NACKED</span>:
		<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_send_put_nacked</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">send_message_put_nacked</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">mqd</span><span class="p">,</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">lines</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CBSS_PAGE_OVERFLOW</span>:
		<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_page_overflow</span><span class="p">);</span>
		<span class="cm">/* fallthru */</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send a message to a message queue</span>
<span class="cm"> * 	mqd	message queue descriptor</span>
<span class="cm"> * 	mesg	message. ust be vaddr within a GSEG</span>
<span class="cm"> * 	bytes	message size (&lt;= 2 CL)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gru_send_message_gpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_message_queue_desc</span> <span class="o">*</span><span class="n">mqd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mesg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">message_header</span> <span class="o">*</span><span class="n">mhdr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dsr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">istatus</span><span class="p">,</span> <span class="n">clines</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_send</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">||</span> <span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">);</span>

	<span class="n">clines</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru_get_cpu_resources</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MQE_BUG_NO_RESOURCES</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dsr</span><span class="p">,</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="n">mhdr</span> <span class="o">=</span> <span class="n">dsr</span><span class="p">;</span>
	<span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">=</span> <span class="n">MQS_FULL</span><span class="p">;</span>
	<span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">lines</span> <span class="o">=</span> <span class="n">clines</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clines</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">present2</span> <span class="o">=</span> <span class="n">get_present2</span><span class="p">(</span><span class="n">mhdr</span><span class="p">);</span>
		<span class="n">restore_present2</span><span class="p">(</span><span class="n">mhdr</span><span class="p">,</span> <span class="n">MQS_FULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MQE_OK</span><span class="p">;</span>
		<span class="n">gru_mesq</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq_gpa</span><span class="p">,</span> <span class="n">gru_get_tri</span><span class="p">(</span><span class="n">mhdr</span><span class="p">),</span> <span class="n">clines</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
		<span class="n">istatus</span> <span class="o">=</span> <span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">istatus</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">send_message_failure</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">mqd</span><span class="p">,</span> <span class="n">dsr</span><span class="p">,</span> <span class="n">clines</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">MQIE_AGAIN</span><span class="p">);</span>
	<span class="n">gru_free_cpu_resources</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">dsr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_send_failed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gru_send_message_gpa</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Advance the receive pointer for the queue to the next message.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gru_free_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_message_queue_desc</span> <span class="o">*</span><span class="n">mqd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">message_queue</span> <span class="o">*</span><span class="n">mq</span> <span class="o">=</span> <span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">message_header</span> <span class="o">*</span><span class="n">mhdr</span> <span class="o">=</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">pnext</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">lines</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lines</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">restore_present2</span><span class="p">(</span><span class="n">mhdr</span><span class="p">,</span> <span class="n">MQS_EMPTY</span><span class="p">);</span>
	<span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">=</span> <span class="n">MQS_EMPTY</span><span class="p">;</span>

	<span class="n">pnext</span> <span class="o">=</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">pnext</span> <span class="o">+</span> <span class="n">GRU_CACHE_LINE_BYTES</span> <span class="o">*</span> <span class="n">lines</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="n">half</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pnext</span> <span class="o">&lt;</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">start2</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">&gt;=</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">start2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">half</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">half</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mq</span><span class="o">-&gt;</span><span class="n">hstatus</span><span class="p">[</span><span class="n">half</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gru_free_message</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Get next message from message queue. Return NULL if no message</span>
<span class="cm"> * present. User must call next_message() to move to next message.</span>
<span class="cm"> * 	rmq	message queue</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">gru_get_next_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_message_queue_desc</span> <span class="o">*</span><span class="n">mqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">message_queue</span> <span class="o">*</span><span class="n">mq</span> <span class="o">=</span> <span class="n">mqd</span><span class="o">-&gt;</span><span class="n">mq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">message_header</span> <span class="o">*</span><span class="n">mhdr</span> <span class="o">=</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">present</span> <span class="o">=</span> <span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">;</span>

	<span class="cm">/* skip NOOP messages */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">present</span> <span class="o">==</span> <span class="n">MQS_NOOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gru_free_message</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">mhdr</span><span class="p">);</span>
		<span class="n">mhdr</span> <span class="o">=</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">present</span> <span class="o">=</span> <span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for both halves of 2 line messages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">present</span> <span class="o">==</span> <span class="n">MQS_FULL</span> <span class="o">&amp;&amp;</span> <span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">lines</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
				<span class="n">get_present2</span><span class="p">(</span><span class="n">mhdr</span><span class="p">)</span> <span class="o">==</span> <span class="n">MQS_EMPTY</span><span class="p">)</span>
		<span class="n">present</span> <span class="o">=</span> <span class="n">MQS_EMPTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">present</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_receive_none</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">lines</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">restore_present2</span><span class="p">(</span><span class="n">mhdr</span><span class="p">,</span> <span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">present2</span><span class="p">);</span>

	<span class="n">STAT</span><span class="p">(</span><span class="n">mesq_receive</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mhdr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gru_get_next_message</span><span class="p">);</span>

<span class="cm">/* ---------------------- GRU DATA COPY FUNCTIONS ---------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Load a DW from a global GPA. The GPA can be a memory or MMR address.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gru_read_gpa</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dsr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">iaa</span><span class="p">;</span>

	<span class="n">STAT</span><span class="p">(</span><span class="n">read_gpa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru_get_cpu_resources</span><span class="p">(</span><span class="n">GRU_NUM_KERNEL_DSR_BYTES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MQE_BUG_NO_RESOURCES</span><span class="p">;</span>
	<span class="n">iaa</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="mi">62</span><span class="p">;</span>
	<span class="n">gru_vload_phys</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">gru_get_tri</span><span class="p">(</span><span class="n">dsr</span><span class="p">),</span> <span class="n">iaa</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">CBS_IDLE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">dsr</span><span class="p">;</span>
	<span class="n">gru_free_cpu_resources</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">dsr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gru_read_gpa</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Copy a block of data using the GRU resources</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gru_copy_gpa</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dest_gpa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src_gpa</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dsr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">STAT</span><span class="p">(</span><span class="n">copy_gpa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru_get_cpu_resources</span><span class="p">(</span><span class="n">GRU_NUM_KERNEL_DSR_BYTES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MQE_BUG_NO_RESOURCES</span><span class="p">;</span>
	<span class="n">gru_bcopy</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">src_gpa</span><span class="p">,</span> <span class="n">dest_gpa</span><span class="p">,</span> <span class="n">gru_get_tri</span><span class="p">(</span><span class="n">dsr</span><span class="p">),</span>
		  <span class="n">XTYPE_B</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">GRU_NUM_KERNEL_DSR_CL</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
	<span class="n">gru_free_cpu_resources</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">dsr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gru_copy_gpa</span><span class="p">);</span>

<span class="cm">/* ------------------- KERNEL QUICKTESTS RUN AT STARTUP ----------------*/</span>
<span class="cm">/* 	Temp - will delete after we gain confidence in the GRU		*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">quicktest0</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word1</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dsr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gru_get_cpu_resources</span><span class="p">(</span><span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MQE_BUG_NO_RESOURCES</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">dsr</span><span class="p">;</span>
	<span class="n">word0</span> <span class="o">=</span> <span class="n">MAGIC</span><span class="p">;</span>
	<span class="n">word1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">gru_vload</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">uv_gpa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word0</span><span class="p">),</span> <span class="n">gru_get_tri</span><span class="p">(</span><span class="n">dsr</span><span class="p">),</span> <span class="n">XTYPE_DW</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;GRU:%d quicktest0: CBR failure 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="n">MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;GRU:%d quicktest0 bad magic 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gru_vstore</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">uv_gpa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word1</span><span class="p">),</span> <span class="n">gru_get_tri</span><span class="p">(</span><span class="n">dsr</span><span class="p">),</span> <span class="n">XTYPE_DW</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru_wait</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;GRU:%d quicktest0: CBR failure 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">word0</span> <span class="o">!=</span> <span class="n">word1</span> <span class="o">||</span> <span class="n">word1</span> <span class="o">!=</span> <span class="n">MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
		       <span class="s">&quot;GRU:%d quicktest0 err: found 0x%lx, expected 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">word1</span><span class="p">,</span> <span class="n">MAGIC</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">gru_free_cpu_resources</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">dsr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ALIGNUP(p, q)	((void *)(((unsigned long)(p) + (q) - 1) &amp; ~(q - 1)))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">quicktest1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_message_queue_desc</span> <span class="n">mqd</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">mq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">mes</span><span class="p">[</span><span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">],</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

	<span class="cm">/* Need  1K cacheline aligned that does not cross page boundary */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">mq</span> <span class="o">=</span> <span class="n">ALIGNUP</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">mes</span><span class="p">,</span> <span class="mh">0xee</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mes</span><span class="p">));</span>
	<span class="n">dw</span> <span class="o">=</span> <span class="n">mq</span><span class="p">;</span>

	<span class="n">gru_create_message_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mqd</span><span class="p">,</span> <span class="n">mq</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mes</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_send_message_gpa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mqd</span><span class="p">,</span> <span class="n">mes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mes</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">MQE_CONGESTION</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">MQE_QUEUE_FULL</span> <span class="o">||</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;GRU:%d quicktest1: unexpect status %d, i %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">gru_get_next_message</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mqd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span> <span class="o">||</span> <span class="n">m</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">gru_free_message</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mqd</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;GRU:%d quicktest2: bad message, i %d, m %p, m8 %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span> <span class="o">?</span> <span class="n">m</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">quicktest2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">DECLARE_COMPLETION</span><span class="p">(</span><span class="n">cmp</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">han</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blade_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numcb</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cb0</span><span class="p">,</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_control_block_status</span> <span class="o">*</span><span class="n">gen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">istatus</span><span class="p">,</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">numcb</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="n">han</span> <span class="o">=</span> <span class="n">gru_reserve_async_resources</span><span class="p">(</span><span class="n">blade_id</span><span class="p">,</span> <span class="n">numcb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">han</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">gru_lock_async_resource</span><span class="p">(</span><span class="n">han</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xee</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numcb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">gru_vset</span><span class="p">(</span><span class="n">cb0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">,</span> <span class="n">uv_gpa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">XTYPE_DW</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IMA_INTERRUPT</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">numcb</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">gru_wait_async_cbr</span><span class="p">(</span><span class="n">han</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numcb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cb</span> <span class="o">=</span> <span class="n">cb0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">;</span>
			<span class="n">istatus</span> <span class="o">=</span> <span class="n">gru_check_status</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">istatus</span> <span class="o">!=</span> <span class="n">CBS_ACTIVE</span> <span class="o">&amp;&amp;</span> <span class="n">istatus</span> <span class="o">!=</span> <span class="n">CBS_CALL_OS</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">numcb</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">istatus</span> <span class="o">!=</span> <span class="n">CBS_IDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;GRU:%d quicktest2: cb %d, exception</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">||</span>
				<span class="n">buf</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;GRU:%d quicktest2:cb %d,  buf 0x%lx, 0x%lx, 0x%lx, 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">i</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">k</span><span class="o">--</span><span class="p">;</span>
		<span class="n">gen</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
		<span class="n">gen</span><span class="o">-&gt;</span><span class="n">istatus</span> <span class="o">=</span> <span class="n">CBS_CALL_OS</span><span class="p">;</span> <span class="cm">/* don&#39;t handle this CBR again */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">k</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cmp</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>

	<span class="n">gru_unlock_async_resource</span><span class="p">(</span><span class="n">han</span><span class="p">);</span>
	<span class="n">gru_release_async_resources</span><span class="p">(</span><span class="n">han</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define BUFSIZE 200</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">quicktest3</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf1</span><span class="p">[</span><span class="n">BUFSIZE</span><span class="p">],</span> <span class="n">buf2</span><span class="p">[</span><span class="n">BUFSIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf2</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buf1</span><span class="p">,</span> <span class="n">get_cycles</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf1</span><span class="p">));</span>
	<span class="n">gru_copy_gpa</span><span class="p">(</span><span class="n">uv_gpa</span><span class="p">(</span><span class="n">buf2</span><span class="p">),</span> <span class="n">uv_gpa</span><span class="p">(</span><span class="n">buf1</span><span class="p">),</span> <span class="n">BUFSIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buf1</span><span class="p">,</span> <span class="n">buf2</span><span class="p">,</span> <span class="n">BUFSIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;GRU:%d quicktest3 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Debugging only. User hook for various kernel tests</span>
<span class="cm"> * of driver &amp; gru.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gru_ktest</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">quicktest0</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">quicktest1</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">quicktest2</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">quicktest3</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">99</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_free_kernel_contexts</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gru_kservices_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gru_kservices_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru_free_kernel_contexts</span><span class="p">())</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
