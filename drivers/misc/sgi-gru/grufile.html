<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › sgi-gru › grufile.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>grufile.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SN Platform GRU Driver</span>
<span class="cm"> *</span>
<span class="cm"> *              FILE OPERATIONS &amp; DRIVER INITIALIZATION</span>
<span class="cm"> *</span>
<span class="cm"> * This file supports the user system call for file open, close, mmap, etc.</span>
<span class="cm"> * This also incudes the driver initialization code.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="cp">#include &lt;asm/uv/uv_irq.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;asm/uv/uv.h&gt;</span>
<span class="cp">#include &quot;gru.h&quot;</span>
<span class="cp">#include &quot;grulib.h&quot;</span>
<span class="cp">#include &quot;grutables.h&quot;</span>

<span class="cp">#include &lt;asm/uv/uv_hub.h&gt;</span>
<span class="cp">#include &lt;asm/uv/uv_mmrs.h&gt;</span>

<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">gru_base</span><span class="p">[</span><span class="n">GRU_MAX_BLADES</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gru_start_paddr</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">gru_start_vaddr</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gru_end_paddr</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gru_max_gids</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">gru_stats_s</span> <span class="n">gru_stats</span><span class="p">;</span>

<span class="cm">/* Guaranteed user available resources on each node */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_user_cbrs</span><span class="p">,</span> <span class="n">max_user_dsr_bytes</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">gru_miscdev</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * gru_vma_close</span>
<span class="cm"> *</span>
<span class="cm"> * Called when unmapping a device mapping. Frees all gru resources</span>
<span class="cm"> * and tables belonging to the vma.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_vma_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_vma_data</span> <span class="o">*</span><span class="n">vdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vdata</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;vma %p, file %p, vdata %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span>
				<span class="n">vdata</span><span class="p">);</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gts</span> <span class="o">=</span>
		    <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gru_thread_state</span><span class="p">,</span> <span class="n">ts_next</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_next</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">)</span>
			<span class="n">gru_unload_context</span><span class="p">(</span><span class="n">gts</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxlock</span><span class="p">);</span>
		<span class="n">gts_drop</span><span class="p">(</span><span class="n">gts</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vdata</span><span class="p">);</span>
	<span class="n">STAT</span><span class="p">(</span><span class="n">vdata_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * gru_file_mmap</span>
<span class="cm"> *</span>
<span class="cm"> * Called when mmapping the device.  Initializes the vma with a fault handler</span>
<span class="cm"> * and private data structure necessary to allocate, track, and free the</span>
<span class="cm"> * underlying pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_file_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_SHARED</span> <span class="o">|</span> <span class="n">VM_WRITE</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="n">VM_SHARED</span> <span class="o">|</span> <span class="n">VM_WRITE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">GRU_GSEG_PAGESIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">GRU_GSEG_PAGESIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span>
	    <span class="p">(</span><span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_DONTCOPY</span> <span class="o">|</span> <span class="n">VM_LOCKED</span> <span class="o">|</span> <span class="n">VM_DONTEXPAND</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span> <span class="o">|</span>
			<span class="n">VM_RESERVED</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">PAGE_SHARED</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gru_vm_ops</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span> <span class="o">=</span> <span class="n">gru_alloc_vma_data</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;file %p, vaddr 0x%lx, vma %p, vdata %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">file</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a new GRU context</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_create_new_context</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_create_context_req</span> <span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_vma_data</span> <span class="o">*</span><span class="n">vdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">data_segment_bytes</span> <span class="o">&gt;</span> <span class="n">max_user_dsr_bytes</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">control_blocks</span> <span class="o">&gt;</span> <span class="n">max_user_cbrs</span> <span class="o">||</span> <span class="o">!</span><span class="n">req</span><span class="p">.</span><span class="n">maximum_thread_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">GRU_OPT_MISS_MASK</span><span class="p">))</span>
		<span class="n">req</span><span class="p">.</span><span class="n">options</span> <span class="o">|=</span> <span class="n">GRU_OPT_MISS_FMM_INTR</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">gru_find_vma</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">gseg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vdata</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">;</span>
		<span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_user_options</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">options</span><span class="p">;</span>
		<span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_dsr_au_count</span> <span class="o">=</span>
		    <span class="n">GRU_DS_BYTES_TO_AU</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">data_segment_bytes</span><span class="p">);</span>
		<span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_cbr_au_count</span> <span class="o">=</span> <span class="n">GRU_CB_COUNT_TO_AU</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">control_blocks</span><span class="p">);</span>
		<span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_tlb_preload_count</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">tlb_preload_count</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get GRU configuration info (temp - for emulator testing)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">gru_get_config_info</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_config_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nodesperblade</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_online_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">uv_node_to_blade_id</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">uv_node_to_blade_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
		<span class="n">nodesperblade</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">nodesperblade</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">cpus</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">();</span>
	<span class="n">info</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">num_online_nodes</span><span class="p">();</span>
	<span class="n">info</span><span class="p">.</span><span class="n">blades</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">nodes</span> <span class="o">/</span> <span class="n">nodesperblade</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">chiplets</span> <span class="o">=</span> <span class="n">GRU_CHIPLETS_PER_BLADE</span> <span class="o">*</span> <span class="n">info</span><span class="p">.</span><span class="n">blades</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * gru_file_unlocked_ioctl</span>
<span class="cm"> *</span>
<span class="cm"> * Called to update file attributes via IOCTL calls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">gru_file_unlocked_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">req</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADRQC</span><span class="p">;</span>

	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;file %p, req 0x%x, 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GRU_CREATE_CONTEXT</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">gru_create_new_context</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GRU_SET_CONTEXT_OPTION</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">gru_set_context_option</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GRU_USER_GET_EXCEPTION_DETAIL</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">gru_get_exception_detail</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GRU_USER_UNLOAD_CONTEXT</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">gru_user_unload_context</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GRU_USER_FLUSH_TLB</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">gru_user_flush_tlb</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GRU_USER_CALL_OS</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">gru_handle_user_call_os</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GRU_GET_GSEG_STATISTICS</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">gru_get_gseg_statistics</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GRU_KTEST</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">gru_ktest</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GRU_GET_CONFIG_INFO</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">gru_get_config_info</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GRU_DUMP_CHIPLET_STATE</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">gru_dump_chiplet_request</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called at init time to build tables for all GRUs that are present in the</span>
<span class="cm"> * system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_init_chiplet</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blade_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chiplet_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_lock</span><span class="p">);</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_paddr</span> <span class="o">=</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_vaddr</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span> <span class="o">=</span> <span class="n">blade_id</span> <span class="o">*</span> <span class="n">GRU_CHIPLETS_PER_BLADE</span> <span class="o">+</span> <span class="n">chiplet_id</span><span class="p">;</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_blade</span> <span class="o">=</span> <span class="n">gru_base</span><span class="p">[</span><span class="n">blade_id</span><span class="p">];</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_blade_id</span> <span class="o">=</span> <span class="n">blade_id</span><span class="p">;</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_chiplet_id</span> <span class="o">=</span> <span class="n">chiplet_id</span><span class="p">;</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_cbr_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">GRU_CBR_AU</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span> <span class="o">?</span> <span class="o">~</span><span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">GRU_CBR_AU</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_dsr_map</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">GRU_DSR_AU</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_limit</span> <span class="o">=</span> <span class="n">MAX_ASID</span><span class="p">;</span>
	<span class="n">gru_tgh_flush_init</span><span class="p">(</span><span class="n">gru</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span> <span class="o">&gt;=</span> <span class="n">gru_max_gids</span><span class="p">)</span>
		<span class="n">gru_max_gids</span> <span class="o">=</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;bid %d, gid %d, vaddr %p (0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">blade_id</span><span class="p">,</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_vaddr</span><span class="p">,</span>
		<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_paddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_init_tables</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gru_base_paddr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">gru_base_vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">bid</span><span class="p">,</span> <span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cbrs</span><span class="p">,</span> <span class="n">dsrbytes</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_blade_state</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

	<span class="n">max_user_cbrs</span> <span class="o">=</span> <span class="n">GRU_NUM_CB</span><span class="p">;</span>
	<span class="n">max_user_dsr_bytes</span> <span class="o">=</span> <span class="n">GRU_NUM_DSR_BYTES</span><span class="p">;</span>
	<span class="n">for_each_possible_blade</span><span class="p">(</span><span class="n">bid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pnode</span> <span class="o">=</span> <span class="n">uv_blade_to_pnode</span><span class="p">(</span><span class="n">bid</span><span class="p">);</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">uv_blade_to_memory_nid</span><span class="p">(</span><span class="n">bid</span><span class="p">);</span><span class="cm">/* -1 if no memory on blade */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_blade_state</span><span class="p">));</span>
		<span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bs_lru_gru</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bs_grus</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bs_lock</span><span class="p">);</span>
		<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>

		<span class="n">dsrbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cbrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">gru</span> <span class="o">=</span> <span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bs_grus</span><span class="p">,</span> <span class="n">chip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">chip</span> <span class="o">&lt;</span> <span class="n">GRU_CHIPLETS_PER_BLADE</span><span class="p">;</span>
				<span class="n">chip</span><span class="o">++</span><span class="p">,</span> <span class="n">gru</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">paddr</span> <span class="o">=</span> <span class="n">gru_chiplet_paddr</span><span class="p">(</span><span class="n">gru_base_paddr</span><span class="p">,</span> <span class="n">pnode</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
			<span class="n">vaddr</span> <span class="o">=</span> <span class="n">gru_chiplet_vaddr</span><span class="p">(</span><span class="n">gru_base_vaddr</span><span class="p">,</span> <span class="n">pnode</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
			<span class="n">gru_init_chiplet</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">bid</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">hweight64</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_cbr_map</span><span class="p">)</span> <span class="o">*</span> <span class="n">GRU_CBR_AU_SIZE</span><span class="p">;</span>
			<span class="n">cbrs</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cbrs</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">hweight64</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_dsr_map</span><span class="p">)</span> <span class="o">*</span> <span class="n">GRU_DSR_AU_BYTES</span><span class="p">;</span>
			<span class="n">dsrbytes</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dsrbytes</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">max_user_cbrs</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max_user_cbrs</span><span class="p">,</span> <span class="n">cbrs</span><span class="p">);</span>
		<span class="n">max_user_dsr_bytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max_user_dsr_bytes</span><span class="p">,</span> <span class="n">dsrbytes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bid</span><span class="o">--</span><span class="p">;</span> <span class="n">bid</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bid</span><span class="o">--</span><span class="p">)</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">],</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_free_tables</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span><span class="p">)</span> <span class="o">*</span>
			      <span class="n">GRU_CHIPLETS_PER_BLADE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bid</span> <span class="o">&lt;</span> <span class="n">GRU_MAX_BLADES</span><span class="p">;</span> <span class="n">bid</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">gru_base</span><span class="p">[</span><span class="n">bid</span><span class="p">],</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">gru_chiplet_cpu_to_mmr</span><span class="p">(</span><span class="kt">int</span> <span class="n">chiplet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">corep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">core</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We target the cores of a blade and not the hyperthreads themselves.</span>
<span class="cm">	 * There is a max of 8 cores per socket and 2 sockets per blade,</span>
<span class="cm">	 * making for a max total of 16 cores (i.e., 16 CPUs without</span>
<span class="cm">	 * hyperthreading and 32 CPUs with hyperthreading).</span>
<span class="cm">	 */</span>
	<span class="n">core</span> <span class="o">=</span> <span class="n">uv_cpu_core_number</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">UV_MAX_INT_CORES</span> <span class="o">*</span> <span class="n">uv_cpu_socket_number</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">core</span> <span class="o">&gt;=</span> <span class="n">GRU_NUM_TFM</span> <span class="o">||</span> <span class="n">uv_cpu_ht_number</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chiplet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmr</span> <span class="o">=</span> <span class="n">UVH_GR0_TLB_INT0_CONFIG</span> <span class="o">+</span>
		    <span class="n">core</span> <span class="o">*</span> <span class="p">(</span><span class="n">UVH_GR0_TLB_INT1_CONFIG</span> <span class="o">-</span> <span class="n">UVH_GR0_TLB_INT0_CONFIG</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chiplet</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmr</span> <span class="o">=</span> <span class="n">UVH_GR1_TLB_INT0_CONFIG</span> <span class="o">+</span>
		    <span class="n">core</span> <span class="o">*</span> <span class="p">(</span><span class="n">UVH_GR1_TLB_INT1_CONFIG</span> <span class="o">-</span> <span class="n">UVH_GR1_TLB_INT0_CONFIG</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">corep</span> <span class="o">=</span> <span class="n">core</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mmr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IA64</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">gru_irq_count</span><span class="p">[</span><span class="n">GRU_CHIPLETS_PER_BLADE</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_noop</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">gru_chip</span><span class="p">[</span><span class="n">GRU_CHIPLETS_PER_BLADE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">GRU_CHIPLETS_PER_BLADE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">irq_mask</span>	<span class="o">=</span> <span class="n">gru_noop</span><span class="p">,</span>
		<span class="p">.</span><span class="n">irq_unmask</span>	<span class="o">=</span> <span class="n">gru_noop</span><span class="p">,</span>
		<span class="p">.</span><span class="n">irq_ack</span>	<span class="o">=</span> <span class="n">gru_noop</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_chiplet_setup_tlb_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">chiplet</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">irq_name</span><span class="p">,</span>
			<span class="n">irq_handler_t</span> <span class="n">irq_handler</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blade</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">IRQ_GRU</span> <span class="o">+</span> <span class="n">chiplet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">core</span><span class="p">;</span>

	<span class="n">mmr</span> <span class="o">=</span> <span class="n">gru_chiplet_cpu_to_mmr</span><span class="p">(</span><span class="n">chiplet</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">core</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gru_irq_count</span><span class="p">[</span><span class="n">chiplet</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gru_chip</span><span class="p">[</span><span class="n">chiplet</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="n">irq_name</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">irq_set_chip</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gru_chip</span><span class="p">[</span><span class="n">chiplet</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: set_irq_chip failed, errno=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">GRU_DRIVER_ID_STR</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">irq_name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: request_irq failed, errno=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">GRU_DRIVER_ID_STR</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">gru_irq_count</span><span class="p">[</span><span class="n">chiplet</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_chiplet_teardown_tlb_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">chiplet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blade</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">core</span><span class="p">,</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">IRQ_GRU</span> <span class="o">+</span> <span class="n">chiplet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gru_irq_count</span><span class="p">[</span><span class="n">chiplet</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mmr</span> <span class="o">=</span> <span class="n">gru_chiplet_cpu_to_mmr</span><span class="p">(</span><span class="n">chiplet</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">core</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">gru_irq_count</span><span class="p">[</span><span class="n">chiplet</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#elif defined CONFIG_X86_64</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_chiplet_setup_tlb_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">chiplet</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">irq_name</span><span class="p">,</span>
			<span class="n">irq_handler_t</span> <span class="n">irq_handler</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blade</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">core</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mmr</span> <span class="o">=</span> <span class="n">gru_chiplet_cpu_to_mmr</span><span class="p">(</span><span class="n">chiplet</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">core</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">uv_setup_irq</span><span class="p">(</span><span class="n">irq_name</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">blade</span><span class="p">,</span> <span class="n">mmr</span><span class="p">,</span> <span class="n">UV_AFFINITY_CPU</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: uv_setup_irq failed, errno=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">GRU_DRIVER_ID_STR</span><span class="p">,</span> <span class="o">-</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">irq_name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uv_teardown_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: request_irq failed, errno=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">GRU_DRIVER_ID_STR</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gru_base</span><span class="p">[</span><span class="n">blade</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bs_grus</span><span class="p">[</span><span class="n">chiplet</span><span class="p">].</span><span class="n">gs_irq</span><span class="p">[</span><span class="n">core</span><span class="p">]</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_chiplet_teardown_tlb_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">chiplet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blade</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">core</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr</span><span class="p">;</span>

	<span class="n">mmr</span> <span class="o">=</span> <span class="n">gru_chiplet_cpu_to_mmr</span><span class="p">(</span><span class="n">chiplet</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">core</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">gru_base</span><span class="p">[</span><span class="n">blade</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bs_grus</span><span class="p">[</span><span class="n">chiplet</span><span class="p">].</span><span class="n">gs_irq</span><span class="p">[</span><span class="n">core</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">uv_teardown_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_teardown_tlb_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blade</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blade</span> <span class="o">=</span> <span class="n">uv_cpu_to_blade_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">gru_chiplet_teardown_tlb_irq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">blade</span><span class="p">);</span>
		<span class="n">gru_chiplet_teardown_tlb_irq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">blade</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">for_each_possible_blade</span><span class="p">(</span><span class="n">blade</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uv_blade_nr_possible_cpus</span><span class="p">(</span><span class="n">blade</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">gru_chiplet_teardown_tlb_irq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blade</span><span class="p">);</span>
		<span class="n">gru_chiplet_teardown_tlb_irq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blade</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_setup_tlb_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blade</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blade</span> <span class="o">=</span> <span class="n">uv_cpu_to_blade_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_chiplet_setup_tlb_irq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;GRU0_TLB&quot;</span><span class="p">,</span> <span class="n">gru0_intr</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">blade</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_chiplet_setup_tlb_irq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;GRU1_TLB&quot;</span><span class="p">,</span> <span class="n">gru1_intr</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">blade</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">for_each_possible_blade</span><span class="p">(</span><span class="n">blade</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uv_blade_nr_possible_cpus</span><span class="p">(</span><span class="n">blade</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_chiplet_setup_tlb_irq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;GRU0_TLB&quot;</span><span class="p">,</span> <span class="n">gru_intr_mblade</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blade</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_chiplet_setup_tlb_irq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;GRU1_TLB&quot;</span><span class="p">,</span> <span class="n">gru_intr_mblade</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blade</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">exit1:</span>
	<span class="n">gru_teardown_tlb_irqs</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * gru_init</span>
<span class="cm"> *</span>
<span class="cm"> * Called at boot or module load time to initialize the GRUs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">gru_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_uv_system</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if defined CONFIG_IA64</span>
	<span class="n">gru_start_paddr</span> <span class="o">=</span> <span class="mh">0xd000000000UL</span><span class="p">;</span> <span class="cm">/* ZZZZZZZZZZZZZZZZZZZ fixme */</span>
<span class="cp">#else</span>
	<span class="n">gru_start_paddr</span> <span class="o">=</span> <span class="n">uv_read_local_mmr</span><span class="p">(</span><span class="n">UVH_RH_GAM_GRU_OVERLAY_CONFIG_MMR</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="mh">0x7fffffffffffUL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">gru_start_vaddr</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">gru_start_paddr</span><span class="p">);</span>
	<span class="n">gru_end_paddr</span> <span class="o">=</span> <span class="n">gru_start_paddr</span> <span class="o">+</span> <span class="n">GRU_MAX_BLADES</span> <span class="o">*</span> <span class="n">GRU_SIZE</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;GRU space: 0x%lx - 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">gru_start_paddr</span><span class="p">,</span> <span class="n">gru_end_paddr</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru_miscdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: misc_register failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">GRU_DRIVER_ID_STR</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_proc_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: proc init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GRU_DRIVER_ID_STR</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_init_tables</span><span class="p">(</span><span class="n">gru_start_paddr</span><span class="p">,</span> <span class="n">gru_start_vaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: init tables failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GRU_DRIVER_ID_STR</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gru_setup_tlb_irqs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit3</span><span class="p">;</span>

	<span class="n">gru_kservices_init</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: v%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GRU_DRIVER_ID_STR</span><span class="p">,</span>
	       <span class="n">GRU_DRIVER_VERSION_STR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">exit3:</span>
	<span class="n">gru_free_tables</span><span class="p">();</span>
<span class="nl">exit2:</span>
	<span class="n">gru_proc_exit</span><span class="p">();</span>
<span class="nl">exit1:</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru_miscdev</span><span class="p">);</span>
<span class="nl">exit0:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">gru_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_uv_system</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">gru_teardown_tlb_irqs</span><span class="p">();</span>
	<span class="n">gru_kservices_exit</span><span class="p">();</span>
	<span class="n">gru_free_tables</span><span class="p">();</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru_miscdev</span><span class="p">);</span>
	<span class="n">gru_proc_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">gru_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">gru_file_unlocked_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">gru_file_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">gru_miscdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span>		<span class="o">=</span> <span class="n">MISC_DYNAMIC_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;gru&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">gru_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">gru_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">close</span>		<span class="o">=</span> <span class="n">gru_vma_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fault</span>		<span class="o">=</span> <span class="n">gru_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifndef MODULE</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">gru_init</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">gru_init</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">gru_exit</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">gru_options</span><span class="p">,</span> <span class="n">ulong</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">gru_options</span><span class="p">,</span> <span class="s">&quot;Various debug options&quot;</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Silicon Graphics, Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">GRU_DRIVER_ID_STR</span> <span class="n">GRU_DRIVER_VERSION_STR</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">GRU_DRIVER_VERSION_STR</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
