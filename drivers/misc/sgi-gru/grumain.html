<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › sgi-gru › grumain.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>grumain.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SN Platform GRU Driver</span>
<span class="cm"> *</span>
<span class="cm"> *            DRIVER TABLE MANAGER + GRU CONTEXT LOAD/UNLOAD</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;asm/uv/uv_hub.h&gt;</span>
<span class="cp">#include &quot;gru.h&quot;</span>
<span class="cp">#include &quot;grutables.h&quot;</span>
<span class="cp">#include &quot;gruhandles.h&quot;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gru_options</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="n">gru_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;gru&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="n">gru_device</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init_name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gru_driver</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">grudev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gru_device</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Select a gru fault map to be used by the current cpu. Note that</span>
<span class="cm"> * multiple cpus may be using the same map.</span>
<span class="cm"> *	ZZZ should be inline but did not work on emulator</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gru_cpu_fault_map_id</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_IA64</span>
	<span class="k">return</span> <span class="n">uv_blade_processor_id</span><span class="p">()</span> <span class="o">%</span> <span class="n">GRU_NUM_TFM</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">core</span><span class="p">;</span>

	<span class="n">core</span> <span class="o">=</span> <span class="n">uv_cpu_core_number</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">id</span> <span class="o">=</span> <span class="n">core</span> <span class="o">+</span> <span class="n">UV_MAX_INT_CORES</span> <span class="o">*</span> <span class="n">uv_cpu_socket_number</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*--------- ASID Management -------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *  Initially, assign asids sequentially from MIN_ASID .. MAX_ASID.</span>
<span class="cm"> *  Once MAX is reached, flush the TLB &amp; start over. However,</span>
<span class="cm"> *  some asids may still be in use. There won&#39;t be many (percentage wise) still</span>
<span class="cm"> *  in use. Search active contexts &amp; determine the value of the first</span>
<span class="cm"> *  asid in use (&quot;x&quot;s below). Set &quot;limit&quot; to this value.</span>
<span class="cm"> *  This defines a block of assignable asids.</span>
<span class="cm"> *</span>
<span class="cm"> *  When &quot;limit&quot; is reached, search forward from limit+1 and determine the</span>
<span class="cm"> *  next block of assignable asids.</span>
<span class="cm"> *</span>
<span class="cm"> *  Repeat until MAX_ASID is reached, then start over again.</span>
<span class="cm"> *</span>
<span class="cm"> *  Each time MAX_ASID is reached, increment the asid generation. Since</span>
<span class="cm"> *  the search for in-use asids only checks contexts with GRUs currently</span>
<span class="cm"> *  assigned, asids in some contexts will be missed. Prior to loading</span>
<span class="cm"> *  a context, the asid generation of the GTS asid is rechecked. If it</span>
<span class="cm"> *  doesn&#39;t match the current generation, a new asid will be assigned.</span>
<span class="cm"> *</span>
<span class="cm"> *   	0---------------x------------x---------------------x----|</span>
<span class="cm"> *	  ^-next	^-limit	   				^-MAX_ASID</span>
<span class="cm"> *</span>
<span class="cm"> * All asid manipulation &amp; context loading/unloading is protected by the</span>
<span class="cm"> * gs_lock.</span>
<span class="cm"> */</span>

<span class="cm">/* Hit the asid limit. Start over */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_wrap_asid</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;gid %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">);</span>
	<span class="n">STAT</span><span class="p">(</span><span class="n">asid_wrap</span><span class="p">);</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_gen</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">MIN_ASID</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find the next chunk of unused asids */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_reset_asid_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span> <span class="kt">int</span> <span class="n">asid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="n">inuse_asid</span><span class="p">,</span> <span class="n">limit</span><span class="p">;</span>

	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;gid %d, asid 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">asid</span><span class="p">);</span>
	<span class="n">STAT</span><span class="p">(</span><span class="n">asid_next</span><span class="p">);</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">MAX_ASID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asid</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span>
		<span class="n">asid</span> <span class="o">=</span> <span class="n">gru_wrap_asid</span><span class="p">(</span><span class="n">gru</span><span class="p">);</span>
	<span class="n">gru_flush_all_tlb</span><span class="p">(</span><span class="n">gru</span><span class="p">);</span>
	<span class="n">gid</span> <span class="o">=</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GRU_NUM_CCH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">is_kernel_context</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">inuse_asid</span> <span class="o">=</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ts_gms</span><span class="o">-&gt;</span><span class="n">ms_asids</span><span class="p">[</span><span class="n">gid</span><span class="p">].</span><span class="n">mt_asid</span><span class="p">;</span>
		<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;gid %d, gts %p, gms %p, inuse 0x%x, cxt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ts_gms</span><span class="p">,</span>
			<span class="n">inuse_asid</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inuse_asid</span> <span class="o">==</span> <span class="n">asid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asid</span> <span class="o">+=</span> <span class="n">ASID_INC</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asid</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * empty range: reset the range limit and</span>
<span class="cm">				 * start over</span>
<span class="cm">				 */</span>
				<span class="n">limit</span> <span class="o">=</span> <span class="n">MAX_ASID</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">asid</span> <span class="o">&gt;=</span> <span class="n">MAX_ASID</span><span class="p">)</span>
					<span class="n">asid</span> <span class="o">=</span> <span class="n">gru_wrap_asid</span><span class="p">(</span><span class="n">gru</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">inuse_asid</span> <span class="o">&gt;</span> <span class="n">asid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inuse_asid</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">))</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">inuse_asid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid</span> <span class="o">=</span> <span class="n">asid</span><span class="p">;</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;gid %d, new asid 0x%x, new_limit 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span>
					<span class="n">asid</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">asid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Assign a new ASID to a thread context.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_assign_asid</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">asid</span><span class="p">;</span>

	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid</span> <span class="o">+=</span> <span class="n">ASID_INC</span><span class="p">;</span>
	<span class="n">asid</span> <span class="o">=</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asid</span> <span class="o">&gt;=</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_limit</span><span class="p">)</span>
		<span class="n">asid</span> <span class="o">=</span> <span class="n">gru_reset_asid_limit</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">asid</span><span class="p">);</span>

	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;gid %d, asid 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">asid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">asid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear n bits in a word. Return a word indicating the bits that were cleared.</span>
<span class="cm"> * Optionally, build an array of chars that contain the bit numbers allocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">reserve_resources</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mmax</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="o">*</span><span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mmax</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">mmax</span><span class="p">)</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span>
			<span class="o">*</span><span class="n">idx</span><span class="o">++</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">gru_reserve_cb_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cbr_au_count</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="o">*</span><span class="n">cbmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">reserve_resources</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_cbr_map</span><span class="p">,</span> <span class="n">cbr_au_count</span><span class="p">,</span> <span class="n">GRU_CBR_AU</span><span class="p">,</span>
				 <span class="n">cbmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">gru_reserve_ds_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dsr_au_count</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="o">*</span><span class="n">dsmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">reserve_resources</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_dsr_map</span><span class="p">,</span> <span class="n">dsr_au_count</span><span class="p">,</span> <span class="n">GRU_DSR_AU</span><span class="p">,</span>
				 <span class="n">dsmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reserve_gru_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_active_contexts</span><span class="o">++</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_map</span> <span class="o">=</span>
	    <span class="n">gru_reserve_cb_resources</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_au_count</span><span class="p">,</span>
				     <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_idx</span><span class="p">);</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_map</span> <span class="o">=</span>
	    <span class="n">gru_reserve_ds_resources</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_au_count</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_gru_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_active_contexts</span><span class="o">--</span><span class="p">;</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_cbr_map</span> <span class="o">|=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_map</span><span class="p">;</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_dsr_map</span> <span class="o">|=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_map</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if a GRU has sufficient free resources to satisfy an allocation</span>
<span class="cm"> * request. Note: GRU locks may or may not be held when this is called. If</span>
<span class="cm"> * not held, recheck after acquiring the appropriate locks.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if sufficient resources, 0 if not</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_gru_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cbr_au_count</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">dsr_au_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_active_contexts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hweight64</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_cbr_map</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cbr_au_count</span>
		<span class="o">&amp;&amp;</span> <span class="n">hweight64</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_dsr_map</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">dsr_au_count</span>
		<span class="o">&amp;&amp;</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_active_contexts</span> <span class="o">&lt;</span> <span class="n">max_active_contexts</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TLB manangment requires tracking all GRU chiplets that have loaded a GSEG</span>
<span class="cm"> * context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_load_mm_tracker</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_mm_struct</span> <span class="o">*</span><span class="n">gms</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_mm_tracker</span> <span class="o">*</span><span class="n">asids</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gms</span><span class="o">-&gt;</span><span class="n">ms_asids</span><span class="p">[</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ctxbitmap</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">asid</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gms</span><span class="o">-&gt;</span><span class="n">ms_asid_lock</span><span class="p">);</span>
	<span class="n">asid</span> <span class="o">=</span> <span class="n">asids</span><span class="o">-&gt;</span><span class="n">mt_asid</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asid</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">asids</span><span class="o">-&gt;</span><span class="n">mt_ctxbitmap</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">asids</span><span class="o">-&gt;</span><span class="n">mt_asid_gen</span> <span class="o">!=</span>
			  <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_gen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asid</span> <span class="o">=</span> <span class="n">gru_assign_asid</span><span class="p">(</span><span class="n">gru</span><span class="p">);</span>
		<span class="n">asids</span><span class="o">-&gt;</span><span class="n">mt_asid</span> <span class="o">=</span> <span class="n">asid</span><span class="p">;</span>
		<span class="n">asids</span><span class="o">-&gt;</span><span class="n">mt_asid_gen</span> <span class="o">=</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_gen</span><span class="p">;</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">asid_new</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">asid_reuse</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_lock</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">asids</span><span class="o">-&gt;</span><span class="n">mt_ctxbitmap</span> <span class="o">&amp;</span> <span class="n">ctxbitmap</span><span class="p">);</span>
	<span class="n">asids</span><span class="o">-&gt;</span><span class="n">mt_ctxbitmap</span> <span class="o">|=</span> <span class="n">ctxbitmap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">gms</span><span class="o">-&gt;</span><span class="n">ms_asidmap</span><span class="p">))</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">gms</span><span class="o">-&gt;</span><span class="n">ms_asidmap</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gms</span><span class="o">-&gt;</span><span class="n">ms_asid_lock</span><span class="p">);</span>

	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span>
		<span class="s">&quot;gid %d, gts %p, gms %p, ctxnum %d, asid 0x%x, asidmap 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">gts</span><span class="p">,</span> <span class="n">gms</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">,</span> <span class="n">asid</span><span class="p">,</span>
		<span class="n">gms</span><span class="o">-&gt;</span><span class="n">ms_asidmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">asid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_unload_mm_tracker</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_mm_struct</span> <span class="o">*</span><span class="n">gms</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_mm_tracker</span> <span class="o">*</span><span class="n">asids</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ctxbitmap</span><span class="p">;</span>

	<span class="n">asids</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gms</span><span class="o">-&gt;</span><span class="n">ms_asids</span><span class="p">[</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">];</span>
	<span class="n">ctxbitmap</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gms</span><span class="o">-&gt;</span><span class="n">ms_asid_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">asids</span><span class="o">-&gt;</span><span class="n">mt_ctxbitmap</span> <span class="o">&amp;</span> <span class="n">ctxbitmap</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ctxbitmap</span><span class="p">);</span>
	<span class="n">asids</span><span class="o">-&gt;</span><span class="n">mt_ctxbitmap</span> <span class="o">^=</span> <span class="n">ctxbitmap</span><span class="p">;</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;gid %d, gts %p, gms %p, ctxnum 0x%d, asidmap 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">gts</span><span class="p">,</span> <span class="n">gms</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">,</span> <span class="n">gms</span><span class="o">-&gt;</span><span class="n">ms_asidmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_asid_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gms</span><span class="o">-&gt;</span><span class="n">ms_asid_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decrement the reference count on a GTS structure. Free the structure</span>
<span class="cm"> * if the reference count goes to zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gts_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gts</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_refcnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gms</span><span class="p">)</span>
			<span class="n">gru_drop_mmu_notifier</span><span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gms</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">gts</span><span class="p">);</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">gts_free</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Locate the GTS structure for the current thread.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="nf">gru_find_current_gts_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_vma_data</span>
			    <span class="o">*</span><span class="n">vdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tsid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">gts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_head</span><span class="p">,</span> <span class="n">ts_next</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tsid</span> <span class="o">==</span> <span class="n">tsid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">gts</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a thread state structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="nf">gru_alloc_gts</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">cbr_au_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dsr_au_count</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tlb_preload_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tsid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_mm_struct</span> <span class="o">*</span><span class="n">gms</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">DSR_BYTES</span><span class="p">(</span><span class="n">dsr_au_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">CBR_BYTES</span><span class="p">(</span><span class="n">cbr_au_count</span><span class="p">);</span>
	<span class="n">bytes</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span><span class="p">);</span>
	<span class="n">gts</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gts</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">STAT</span><span class="p">(</span><span class="n">gts_alloc</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span><span class="p">));</span> <span class="cm">/* zero out header */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxlock</span><span class="p">);</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_au_count</span> <span class="o">=</span> <span class="n">cbr_au_count</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_au_count</span> <span class="o">=</span> <span class="n">dsr_au_count</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tlb_preload_count</span> <span class="o">=</span> <span class="n">tlb_preload_count</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_options</span> <span class="o">=</span> <span class="n">options</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_blade_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_chiplet_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tsid</span> <span class="o">=</span> <span class="n">tsid</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span> <span class="o">=</span> <span class="n">NULLCTX</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tlb_int_select</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cch_req_slice</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_sizeavail</span> <span class="o">=</span> <span class="n">GRU_SIZEAVAIL</span><span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
		<span class="n">gms</span> <span class="o">=</span> <span class="n">gru_register_mmu_notifier</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">gms</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gms</span> <span class="o">=</span> <span class="n">gms</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;alloc gts %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gts</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">gts</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">gts_drop</span><span class="p">(</span><span class="n">gts</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">gms</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a vma private data structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_vma_data</span> <span class="o">*</span><span class="nf">gru_alloc_vma_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tsid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_vma_data</span> <span class="o">*</span><span class="n">vdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">vdata</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vdata</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vdata</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">STAT</span><span class="p">(</span><span class="n">vdata_alloc</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_head</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_lock</span><span class="p">);</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;alloc vdata %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vdata</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the thread state structure for the current thread.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="nf">gru_find_thread_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">tsid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_vma_data</span> <span class="o">*</span><span class="n">vdata</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_lock</span><span class="p">);</span>
	<span class="n">gts</span> <span class="o">=</span> <span class="n">gru_find_current_gts_nolock</span><span class="p">(</span><span class="n">vdata</span><span class="p">,</span> <span class="n">tsid</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_lock</span><span class="p">);</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;vma %p, gts %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">gts</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">gts</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new thread state for a GSEG. Note that races may allow</span>
<span class="cm"> * another thread to race to create a gts.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="nf">gru_alloc_thread_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">tsid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_vma_data</span> <span class="o">*</span><span class="n">vdata</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">,</span> <span class="o">*</span><span class="n">ngts</span><span class="p">;</span>

	<span class="n">gts</span> <span class="o">=</span> <span class="n">gru_alloc_gts</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_cbr_au_count</span><span class="p">,</span>
			    <span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_dsr_au_count</span><span class="p">,</span>
			    <span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_tlb_preload_count</span><span class="p">,</span>
			    <span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_user_options</span><span class="p">,</span> <span class="n">tsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">gts</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">gts</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_lock</span><span class="p">);</span>
	<span class="n">ngts</span> <span class="o">=</span> <span class="n">gru_find_current_gts_nolock</span><span class="p">(</span><span class="n">vdata</span><span class="p">,</span> <span class="n">tsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ngts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gts_drop</span><span class="p">(</span><span class="n">gts</span><span class="p">);</span>
		<span class="n">gts</span> <span class="o">=</span> <span class="n">ngts</span><span class="p">;</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">gts_double_allocate</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_head</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vd_lock</span><span class="p">);</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;vma %p, gts %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">gts</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">gts</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free the GRU context assigned to the thread state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_free_gru_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">;</span>

	<span class="n">gru</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">;</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;gts %p, gid %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gts</span><span class="p">,</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_lock</span><span class="p">);</span>
	<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gts</span><span class="p">[</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">free_gru_resources</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">gts</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_context_map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_context_map</span><span class="p">);</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span> <span class="o">=</span> <span class="n">NULLCTX</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_blade</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_lock</span><span class="p">);</span>

	<span class="n">gts_drop</span><span class="p">(</span><span class="n">gts</span><span class="p">);</span>
	<span class="n">STAT</span><span class="p">(</span><span class="n">free_context</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prefetching cachelines help hardware performance.</span>
<span class="cm"> * (Strictly a performance enhancement. Not functionally required).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">prefetch_data</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stride</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prefetchw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">stride</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">gru_copy_handle</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">GRU_HANDLE_BYTES</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">GRU_HANDLE_BYTES</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_prefetch_context</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">gseg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cbe</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cbrmap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">scr</span><span class="p">;</span>

	<span class="n">prefetch_data</span><span class="p">(</span><span class="n">gseg</span> <span class="o">+</span> <span class="n">GRU_DS_BASE</span><span class="p">,</span> <span class="n">length</span> <span class="o">/</span> <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">,</span>
		      <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">);</span>

	<span class="n">for_each_cbr_in_allocation_map</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbrmap</span><span class="p">,</span> <span class="n">scr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prefetch_data</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">);</span>
		<span class="n">prefetch_data</span><span class="p">(</span><span class="n">cbe</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			      <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">);</span>
		<span class="n">cb</span> <span class="o">+=</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_load_context_data</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">save</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">grubase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctxnum</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cbrmap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dsrmap</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">data_valid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">gseg</span><span class="p">,</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="o">*</span><span class="n">cbe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">scr</span><span class="p">;</span>

	<span class="n">gseg</span> <span class="o">=</span> <span class="n">grubase</span> <span class="o">+</span> <span class="n">ctxnum</span> <span class="o">*</span> <span class="n">GRU_GSEG_STRIDE</span><span class="p">;</span>
	<span class="n">cb</span> <span class="o">=</span> <span class="n">gseg</span> <span class="o">+</span> <span class="n">GRU_CB_BASE</span><span class="p">;</span>
	<span class="n">cbe</span> <span class="o">=</span> <span class="n">grubase</span> <span class="o">+</span> <span class="n">GRU_CBE_BASE</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">hweight64</span><span class="p">(</span><span class="n">dsrmap</span><span class="p">)</span> <span class="o">*</span> <span class="n">GRU_DSR_AU_BYTES</span><span class="p">;</span>
	<span class="n">gru_prefetch_context</span><span class="p">(</span><span class="n">gseg</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">cbe</span><span class="p">,</span> <span class="n">cbrmap</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">for_each_cbr_in_allocation_map</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbrmap</span><span class="p">,</span> <span class="n">scr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">save</span> <span class="o">+=</span> <span class="n">gru_copy_handle</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">save</span><span class="p">);</span>
			<span class="n">save</span> <span class="o">+=</span> <span class="n">gru_copy_handle</span><span class="p">(</span><span class="n">cbe</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">,</span>
						<span class="n">save</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">cbe</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">GRU_CACHE_LINE_BYTES</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Flush CBE to hide race in context restart */</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">gru_flush_cache</span><span class="p">(</span><span class="n">cbe</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">);</span>
		<span class="n">cb</span> <span class="o">+=</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_valid</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">gseg</span> <span class="o">+</span> <span class="n">GRU_DS_BASE</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">gseg</span> <span class="o">+</span> <span class="n">GRU_DS_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gru_unload_context_data</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">save</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">grubase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctxnum</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cbrmap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dsrmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">gseg</span><span class="p">,</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="o">*</span><span class="n">cbe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">scr</span><span class="p">;</span>

	<span class="n">gseg</span> <span class="o">=</span> <span class="n">grubase</span> <span class="o">+</span> <span class="n">ctxnum</span> <span class="o">*</span> <span class="n">GRU_GSEG_STRIDE</span><span class="p">;</span>
	<span class="n">cb</span> <span class="o">=</span> <span class="n">gseg</span> <span class="o">+</span> <span class="n">GRU_CB_BASE</span><span class="p">;</span>
	<span class="n">cbe</span> <span class="o">=</span> <span class="n">grubase</span> <span class="o">+</span> <span class="n">GRU_CBE_BASE</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">hweight64</span><span class="p">(</span><span class="n">dsrmap</span><span class="p">)</span> <span class="o">*</span> <span class="n">GRU_DSR_AU_BYTES</span><span class="p">;</span>

	<span class="cm">/* CBEs may not be coherent. Flush them from cache */</span>
	<span class="n">for_each_cbr_in_allocation_map</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbrmap</span><span class="p">,</span> <span class="n">scr</span><span class="p">)</span>
		<span class="n">gru_flush_cache</span><span class="p">(</span><span class="n">cbe</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>		<span class="cm">/* Let the CL flush complete */</span>

	<span class="n">gru_prefetch_context</span><span class="p">(</span><span class="n">gseg</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">cbe</span><span class="p">,</span> <span class="n">cbrmap</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">for_each_cbr_in_allocation_map</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbrmap</span><span class="p">,</span> <span class="n">scr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">save</span> <span class="o">+=</span> <span class="n">gru_copy_handle</span><span class="p">(</span><span class="n">save</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
		<span class="n">save</span> <span class="o">+=</span> <span class="n">gru_copy_handle</span><span class="p">(</span><span class="n">save</span><span class="p">,</span> <span class="n">cbe</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">);</span>
		<span class="n">cb</span> <span class="o">+=</span> <span class="n">GRU_HANDLE_STRIDE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">save</span><span class="p">,</span> <span class="n">gseg</span> <span class="o">+</span> <span class="n">GRU_DS_BASE</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gru_unload_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">,</span> <span class="kt">int</span> <span class="n">savestate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_context_configuration_handle</span> <span class="o">*</span><span class="n">cch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxnum</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_kernel_context</span><span class="p">(</span><span class="n">gts</span><span class="p">))</span>
		<span class="n">zap_vma_ptes</span><span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_vma</span><span class="p">,</span> <span class="n">UGRUADDR</span><span class="p">(</span><span class="n">gts</span><span class="p">),</span> <span class="n">GRU_GSEG_PAGESIZE</span><span class="p">);</span>
	<span class="n">cch</span> <span class="o">=</span> <span class="n">get_cch</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_vaddr</span><span class="p">,</span> <span class="n">ctxnum</span><span class="p">);</span>

	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;gts %p, cbrmap 0x%lx, dsrmap 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">gts</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_map</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_map</span><span class="p">);</span>
	<span class="n">lock_cch_handle</span><span class="p">(</span><span class="n">cch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cch_interrupt_sync</span><span class="p">(</span><span class="n">cch</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_kernel_context</span><span class="p">(</span><span class="n">gts</span><span class="p">))</span>
		<span class="n">gru_unload_mm_tracker</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">gts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">savestate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gru_unload_context_data</span><span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gdata</span><span class="p">,</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_vaddr</span><span class="p">,</span>
					<span class="n">ctxnum</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_map</span><span class="p">,</span>
					<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_map</span><span class="p">);</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_data_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cch_deallocate</span><span class="p">(</span><span class="n">cch</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">unlock_cch_handle</span><span class="p">(</span><span class="n">cch</span><span class="p">);</span>

	<span class="n">gru_free_gru_context</span><span class="p">(</span><span class="n">gts</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Load a GRU context by copying it from the thread data structure in memory</span>
<span class="cm"> * to the GRU.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gru_load_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_context_configuration_handle</span> <span class="o">*</span><span class="n">cch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">asid</span><span class="p">,</span> <span class="n">ctxnum</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">;</span>

	<span class="n">cch</span> <span class="o">=</span> <span class="n">get_cch</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_vaddr</span><span class="p">,</span> <span class="n">ctxnum</span><span class="p">);</span>
	<span class="n">lock_cch_handle</span><span class="p">(</span><span class="n">cch</span><span class="p">);</span>
	<span class="n">cch</span><span class="o">-&gt;</span><span class="n">tfm_fault_bit_enable</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_options</span> <span class="o">==</span> <span class="n">GRU_OPT_MISS_FMM_POLL</span>
	     <span class="o">||</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_options</span> <span class="o">==</span> <span class="n">GRU_OPT_MISS_FMM_INTR</span><span class="p">);</span>
	<span class="n">cch</span><span class="o">-&gt;</span><span class="n">tlb_int_enable</span> <span class="o">=</span> <span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_options</span> <span class="o">==</span> <span class="n">GRU_OPT_MISS_FMM_INTR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cch</span><span class="o">-&gt;</span><span class="n">tlb_int_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tlb_int_select</span> <span class="o">=</span> <span class="n">gru_cpu_fault_map_id</span><span class="p">();</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">tlb_int_select</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tlb_int_select</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cch_req_slice</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">req_slice_set_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">req_slice</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cch_req_slice</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">req_slice_set_enable</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cch</span><span class="o">-&gt;</span><span class="n">tfm_done_bit_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cch</span><span class="o">-&gt;</span><span class="n">dsr_allocation_map</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_map</span><span class="p">;</span>
	<span class="n">cch</span><span class="o">-&gt;</span><span class="n">cbr_allocation_map</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_map</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_kernel_context</span><span class="p">(</span><span class="n">gts</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">unmap_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">tfm_done_bit_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">cb_int_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">tlb_int_select</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* For now, ints go to cpu 0 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">unmap_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">tfm_done_bit_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">cb_int_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">asid</span> <span class="o">=</span> <span class="n">gru_load_mm_tracker</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">gts</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cch</span><span class="o">-&gt;</span><span class="n">asid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">asid</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">cch</span><span class="o">-&gt;</span><span class="n">sizeavail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_sizeavail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">cch_allocate</span><span class="p">(</span><span class="n">cch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span>
			<span class="s">&quot;err %d: cch %p, gts %p, cbr 0x%lx, dsr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">err</span><span class="p">,</span> <span class="n">cch</span><span class="p">,</span> <span class="n">gts</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_map</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_map</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">gru_load_context_data</span><span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gdata</span><span class="p">,</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_vaddr</span><span class="p">,</span> <span class="n">ctxnum</span><span class="p">,</span>
			<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_map</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_map</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_data_valid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cch_start</span><span class="p">(</span><span class="n">cch</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">unlock_cch_handle</span><span class="p">(</span><span class="n">cch</span><span class="p">);</span>

	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;gid %d, gts %p, cbrmap 0x%lx, dsrmap 0x%lx, tie %d, tis %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">gts</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_map</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_map</span><span class="p">,</span>
		<span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_options</span> <span class="o">==</span> <span class="n">GRU_OPT_MISS_FMM_INTR</span><span class="p">),</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tlb_int_select</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update fields in an active CCH:</span>
<span class="cm"> * 	- retarget interrupts on local blade</span>
<span class="cm"> * 	- update sizeavail mask</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gru_update_cch</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_context_configuration_handle</span> <span class="o">*</span><span class="n">cch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctxnum</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cch</span> <span class="o">=</span> <span class="n">get_cch</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gru_base_vaddr</span><span class="p">,</span> <span class="n">ctxnum</span><span class="p">);</span>

	<span class="n">lock_cch_handle</span><span class="p">(</span><span class="n">cch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cch</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">CCHSTATE_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gts</span><span class="p">[</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">]</span> <span class="o">!=</span> <span class="n">gts</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cch_interrupt</span><span class="p">(</span><span class="n">cch</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">cch</span><span class="o">-&gt;</span><span class="n">sizeavail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_sizeavail</span><span class="p">;</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tlb_int_select</span> <span class="o">=</span> <span class="n">gru_cpu_fault_map_id</span><span class="p">();</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">tlb_int_select</span> <span class="o">=</span> <span class="n">gru_cpu_fault_map_id</span><span class="p">();</span>
		<span class="n">cch</span><span class="o">-&gt;</span><span class="n">tfm_fault_bit_enable</span> <span class="o">=</span>
		  <span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_options</span> <span class="o">==</span> <span class="n">GRU_OPT_MISS_FMM_POLL</span>
		    <span class="o">||</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_options</span> <span class="o">==</span> <span class="n">GRU_OPT_MISS_FMM_INTR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cch_start</span><span class="p">(</span><span class="n">cch</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="n">unlock_cch_handle</span><span class="p">(</span><span class="n">cch</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update CCH tlb interrupt select. Required when all the following is true:</span>
<span class="cm"> * 	- task&#39;s GRU context is loaded into a GRU</span>
<span class="cm"> * 	- task is using interrupt notification for TLB faults</span>
<span class="cm"> * 	- task has migrated to a different cpu on the same blade where</span>
<span class="cm"> * 	  it was previously running.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_retarget_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tlb_int_select</span> <span class="o">&lt;</span> <span class="mi">0</span>
	    <span class="o">||</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tlb_int_select</span> <span class="o">==</span> <span class="n">gru_cpu_fault_map_id</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;retarget from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tlb_int_select</span><span class="p">,</span>
		<span class="n">gru_cpu_fault_map_id</span><span class="p">());</span>
	<span class="k">return</span> <span class="n">gru_update_cch</span><span class="p">(</span><span class="n">gts</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if a GRU context is allowed to use a specific chiplet. By default</span>
<span class="cm"> * a context is assigned to any blade-local chiplet. However, users can</span>
<span class="cm"> * override this.</span>
<span class="cm"> * 	Returns 1 if assignment allowed, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_check_chiplet_assignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blade_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chiplet_id</span><span class="p">;</span>

	<span class="n">blade_id</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_blade_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blade_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">blade_id</span> <span class="o">=</span> <span class="n">uv_numa_blade_id</span><span class="p">();</span>

	<span class="n">chiplet_id</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_chiplet_id</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_blade_id</span> <span class="o">==</span> <span class="n">blade_id</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">chiplet_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">chiplet_id</span> <span class="o">==</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_chiplet_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unload the gru context if it is not assigned to the correct blade or</span>
<span class="cm"> * chiplet. Misassignment can occur if the process migrates to a different</span>
<span class="cm"> * blade or if the user changes the selected blade/chiplet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gru_check_context_placement</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the current task is the context owner, verify that the</span>
<span class="cm">	 * context is correctly placed. This test is skipped for non-owner</span>
<span class="cm">	 * references. Pthread apps use non-owner references to the CBRs.</span>
<span class="cm">	 */</span>
	<span class="n">gru</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gru</span> <span class="o">||</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_tgid_owner</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gru_check_chiplet_assignment</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">gts</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">check_context_unload</span><span class="p">);</span>
		<span class="n">gru_unload_context</span><span class="p">(</span><span class="n">gts</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gru_retarget_intr</span><span class="p">(</span><span class="n">gts</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">check_context_retarget_intr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Insufficient GRU resources available on the local blade. Steal a context from</span>
<span class="cm"> * a process. This is a hack until a _real_ resource scheduler is written....</span>
<span class="cm"> */</span>
<span class="cp">#define next_ctxnum(n)	((n) &lt;  GRU_NUM_CCH - 2 ? (n) + 1 : 0)</span>
<span class="cp">#define next_gru(b, g)	(((g) &lt; &amp;(b)-&gt;bs_grus[GRU_CHIPLETS_PER_BLADE - 1]) ?  \</span>
<span class="cp">				 ((g)+1) : &amp;(b)-&gt;bs_grus[0])</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_gts_stealable</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_kernel_context</span><span class="p">(</span><span class="n">gts</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">down_write_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gts_stolen</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_kernel_context</span><span class="p">(</span><span class="n">gts</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_kgts_sema</span><span class="p">);</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">steal_kernel_context</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxlock</span><span class="p">);</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">steal_user_context</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gru_steal_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">blade</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span> <span class="o">*</span><span class="n">gru0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">ngts</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxnum</span><span class="p">,</span> <span class="n">ctxnum0</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cbr</span><span class="p">,</span> <span class="n">dsr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blade_id</span><span class="p">;</span>

	<span class="n">blade_id</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_blade_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blade_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">blade_id</span> <span class="o">=</span> <span class="n">uv_numa_blade_id</span><span class="p">();</span>
	<span class="n">cbr</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_au_count</span><span class="p">;</span>
	<span class="n">dsr</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_au_count</span><span class="p">;</span>

	<span class="n">blade</span> <span class="o">=</span> <span class="n">gru_base</span><span class="p">[</span><span class="n">blade_id</span><span class="p">];</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blade</span><span class="o">-&gt;</span><span class="n">bs_lock</span><span class="p">);</span>

	<span class="n">ctxnum</span> <span class="o">=</span> <span class="n">next_ctxnum</span><span class="p">(</span><span class="n">blade</span><span class="o">-&gt;</span><span class="n">bs_lru_ctxnum</span><span class="p">);</span>
	<span class="n">gru</span> <span class="o">=</span> <span class="n">blade</span><span class="o">-&gt;</span><span class="n">bs_lru_gru</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctxnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">gru</span> <span class="o">=</span> <span class="n">next_gru</span><span class="p">(</span><span class="n">blade</span><span class="p">,</span> <span class="n">gru</span><span class="p">);</span>
	<span class="n">blade</span><span class="o">-&gt;</span><span class="n">bs_lru_gru</span> <span class="o">=</span> <span class="n">gru</span><span class="p">;</span>
	<span class="n">blade</span><span class="o">-&gt;</span><span class="n">bs_lru_ctxnum</span> <span class="o">=</span> <span class="n">ctxnum</span><span class="p">;</span>
	<span class="n">ctxnum0</span> <span class="o">=</span> <span class="n">ctxnum</span><span class="p">;</span>
	<span class="n">gru0</span> <span class="o">=</span> <span class="n">gru</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gru_check_chiplet_assignment</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">gts</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">check_gru_resources</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">cbr</span><span class="p">,</span> <span class="n">dsr</span><span class="p">,</span> <span class="n">GRU_NUM_CCH</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_lock</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">ctxnum</span> <span class="o">&lt;</span> <span class="n">GRU_NUM_CCH</span><span class="p">;</span> <span class="n">ctxnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;&amp;</span> <span class="n">gru</span> <span class="o">==</span> <span class="n">gru0</span> <span class="o">&amp;&amp;</span> <span class="n">ctxnum</span> <span class="o">==</span> <span class="n">ctxnum0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">ngts</span> <span class="o">=</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gts</span><span class="p">[</span><span class="n">ctxnum</span><span class="p">];</span>
				<span class="cm">/*</span>
<span class="cm">			 	* We are grabbing locks out of order, so trylock is</span>
<span class="cm">			 	* needed. GTSs are usually not locked, so the odds of</span>
<span class="cm">			 	* success are high. If trylock fails, try to steal a</span>
<span class="cm">			 	* different GSEG.</span>
<span class="cm">			 	*/</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ngts</span> <span class="o">&amp;&amp;</span> <span class="n">is_gts_stealable</span><span class="p">(</span><span class="n">ngts</span><span class="p">,</span> <span class="n">blade</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">ngts</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ngts</span> <span class="o">||</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;&amp;</span> <span class="n">gru</span> <span class="o">==</span> <span class="n">gru0</span> <span class="o">&amp;&amp;</span> <span class="n">ctxnum</span> <span class="o">==</span> <span class="n">ctxnum0</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;&amp;</span> <span class="n">gru</span> <span class="o">==</span> <span class="n">gru0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ctxnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">gru</span> <span class="o">=</span> <span class="n">next_gru</span><span class="p">(</span><span class="n">blade</span><span class="p">,</span> <span class="n">gru</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blade</span><span class="o">-&gt;</span><span class="n">bs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ngts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">context_stolen</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ngts</span><span class="o">-&gt;</span><span class="n">ts_steal_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">gru_unload_context</span><span class="p">(</span><span class="n">ngts</span><span class="p">,</span> <span class="n">is_kernel_context</span><span class="p">(</span><span class="n">ngts</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">gts_stolen</span><span class="p">(</span><span class="n">ngts</span><span class="p">,</span> <span class="n">blade</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">steal_context_failed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span>
		<span class="s">&quot;stole gid %d, ctxnum %d from gts %p. Need cb %d, ds %d;&quot;</span>
		<span class="s">&quot; avail cb %ld, ds %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">ctxnum</span><span class="p">,</span> <span class="n">ngts</span><span class="p">,</span> <span class="n">cbr</span><span class="p">,</span> <span class="n">dsr</span><span class="p">,</span> <span class="n">hweight64</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_cbr_map</span><span class="p">),</span>
		<span class="n">hweight64</span><span class="p">(</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_dsr_map</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Assign a gru context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gru_assign_context_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctxnum</span><span class="p">;</span>

	<span class="n">ctxnum</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_context_map</span><span class="p">,</span> <span class="n">GRU_NUM_CCH</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">ctxnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_context_map</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ctxnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan the GRUs on the local blade &amp; assign a GRU context.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="nf">gru_assign_gru_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span> <span class="o">*</span><span class="n">grux</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">max_active_contexts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blade_id</span> <span class="o">=</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_user_blade_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blade_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">blade_id</span> <span class="o">=</span> <span class="n">uv_numa_blade_id</span><span class="p">();</span>
<span class="nl">again:</span>
	<span class="n">gru</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">max_active_contexts</span> <span class="o">=</span> <span class="n">GRU_NUM_CCH</span><span class="p">;</span>
	<span class="n">for_each_gru_on_blade</span><span class="p">(</span><span class="n">grux</span><span class="p">,</span> <span class="n">blade_id</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gru_check_chiplet_assignment</span><span class="p">(</span><span class="n">grux</span><span class="p">,</span> <span class="n">gts</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_gru_resources</span><span class="p">(</span><span class="n">grux</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_au_count</span><span class="p">,</span>
					<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_au_count</span><span class="p">,</span>
					<span class="n">max_active_contexts</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">gru</span> <span class="o">=</span> <span class="n">grux</span><span class="p">;</span>
			<span class="n">max_active_contexts</span> <span class="o">=</span> <span class="n">grux</span><span class="o">-&gt;</span><span class="n">gs_active_contexts</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">max_active_contexts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_gru_resources</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_au_count</span><span class="p">,</span>
					 <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_au_count</span><span class="p">,</span> <span class="n">GRU_NUM_CCH</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">reserve_gru_resources</span><span class="p">(</span><span class="n">gru</span><span class="p">,</span> <span class="n">gts</span><span class="p">);</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span> <span class="o">=</span> <span class="n">gru</span><span class="p">;</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_blade</span> <span class="o">=</span> <span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_blade_id</span><span class="p">;</span>
		<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span> <span class="o">=</span> <span class="n">gru_assign_context_number</span><span class="p">(</span><span class="n">gru</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_refcnt</span><span class="p">);</span>
		<span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_gts</span><span class="p">[</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">gts</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gru</span><span class="o">-&gt;</span><span class="n">gs_lock</span><span class="p">);</span>

		<span class="n">STAT</span><span class="p">(</span><span class="n">assign_context</span><span class="p">);</span>
		<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span>
			<span class="s">&quot;gseg %p, gts %p, gid %d, ctx %d, cbr %d, dsr %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">gseg_virtual_address</span><span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">),</span> <span class="n">gts</span><span class="p">,</span>
			<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="o">-&gt;</span><span class="n">gs_gid</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">,</span>
			<span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_cbr_au_count</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_dsr_au_count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;failed to allocate a GTS %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">assign_context_failed</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">gru</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * gru_nopage</span>
<span class="cm"> *</span>
<span class="cm"> * Map the user&#39;s GRU segment</span>
<span class="cm"> *</span>
<span class="cm"> * 	Note: gru segments alway mmaped on GRU_GSEG_PAGESIZE boundaries.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gru_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">virtual_address</span><span class="p">;</span>
	<span class="n">gru_dbg</span><span class="p">(</span><span class="n">grudev</span><span class="p">,</span> <span class="s">&quot;vma %p, vaddr 0x%lx (0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">vma</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">GSEG_BASE</span><span class="p">(</span><span class="n">vaddr</span><span class="p">));</span>
	<span class="n">STAT</span><span class="p">(</span><span class="n">nopfn</span><span class="p">);</span>

	<span class="cm">/* The following check ensures vaddr is a valid address in the VMA */</span>
	<span class="n">gts</span> <span class="o">=</span> <span class="n">gru_find_thread_state</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">TSID</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">vma</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gts</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxlock</span><span class="p">);</span>
	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">gru_check_context_placement</span><span class="p">(</span><span class="n">gts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">STAT</span><span class="p">(</span><span class="n">load_user_context</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gru_assign_gru_context</span><span class="p">(</span><span class="n">gts</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">preempt_enable</span><span class="p">();</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxlock</span><span class="p">);</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">GRU_ASSIGN_DELAY</span><span class="p">);</span>  <span class="cm">/* true hack ZZZ */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_steal_jiffies</span> <span class="o">+</span> <span class="n">GRU_STEAL_DELAY</span> <span class="o">&lt;</span> <span class="n">jiffies</span><span class="p">)</span>
				<span class="n">gru_steal_context</span><span class="p">(</span><span class="n">gts</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">gru_load_context</span><span class="p">(</span><span class="n">gts</span><span class="p">);</span>
		<span class="n">paddr</span> <span class="o">=</span> <span class="n">gseg_physical_address</span><span class="p">(</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_gru</span><span class="p">,</span> <span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxnum</span><span class="p">);</span>
		<span class="n">remap_pfn_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">GRU_GSEG_PAGESIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">GRU_GSEG_PAGESIZE</span><span class="p">,</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_ctxlock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">VM_FAULT_NOPAGE</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
