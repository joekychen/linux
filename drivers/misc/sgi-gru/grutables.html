<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › sgi-gru › grutables.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>grutables.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SN Platform GRU Driver</span>
<span class="cm"> *</span>
<span class="cm"> *            GRU DRIVER TABLES, MACROS, externs, etc</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __GRUTABLES_H__</span>
<span class="cp">#define __GRUTABLES_H__</span>

<span class="cm">/*</span>
<span class="cm"> * GRU Chiplet:</span>
<span class="cm"> *   The GRU is a user addressible memory accelerator. It provides</span>
<span class="cm"> *   several forms of load, store, memset, bcopy instructions. In addition, it</span>
<span class="cm"> *   contains special instructions for AMOs, sending messages to message</span>
<span class="cm"> *   queues, etc.</span>
<span class="cm"> *</span>
<span class="cm"> *   The GRU is an integral part of the node controller. It connects</span>
<span class="cm"> *   directly to the cpu socket. In its current implementation, there are 2</span>
<span class="cm"> *   GRU chiplets in the node controller on each blade (~node).</span>
<span class="cm"> *</span>
<span class="cm"> *   The entire GRU memory space is fully coherent and cacheable by the cpus.</span>
<span class="cm"> *</span>
<span class="cm"> *   Each GRU chiplet has a physical memory map that looks like the following:</span>
<span class="cm"> *</span>
<span class="cm"> *   	+-----------------+</span>
<span class="cm"> *   	|/////////////////|</span>
<span class="cm"> *   	|/////////////////|</span>
<span class="cm"> *   	|/////////////////|</span>
<span class="cm"> *   	|/////////////////|</span>
<span class="cm"> *   	|/////////////////|</span>
<span class="cm"> *   	|/////////////////|</span>
<span class="cm"> *   	|/////////////////|</span>
<span class="cm"> *   	|/////////////////|</span>
<span class="cm"> *   	+-----------------+</span>
<span class="cm"> *   	|  system control |</span>
<span class="cm"> *   	+-----------------+        _______ +-------------+</span>
<span class="cm"> *   	|/////////////////|       /        |             |</span>
<span class="cm"> *   	|/////////////////|      /         |             |</span>
<span class="cm"> *   	|/////////////////|     /          | instructions|</span>
<span class="cm"> *   	|/////////////////|    /           |             |</span>
<span class="cm"> *   	|/////////////////|   /            |             |</span>
<span class="cm"> *   	|/////////////////|  /             |-------------|</span>
<span class="cm"> *   	|/////////////////| /              |             |</span>
<span class="cm"> *   	+-----------------+                |             |</span>
<span class="cm"> *   	|   context 15    |                |  data       |</span>
<span class="cm"> *   	+-----------------+                |             |</span>
<span class="cm"> *   	|    ......       | \              |             |</span>
<span class="cm"> *   	+-----------------+  \____________ +-------------+</span>
<span class="cm"> *   	|   context 1     |</span>
<span class="cm"> *   	+-----------------+</span>
<span class="cm"> *   	|   context 0     |</span>
<span class="cm"> *   	+-----------------+</span>
<span class="cm"> *</span>
<span class="cm"> *   Each of the &quot;contexts&quot; is a chunk of memory that can be mmaped into user</span>
<span class="cm"> *   space. The context consists of 2 parts:</span>
<span class="cm"> *</span>
<span class="cm"> *  	- an instruction space that can be directly accessed by the user</span>
<span class="cm"> *  	  to issue GRU instructions and to check instruction status.</span>
<span class="cm"> *</span>
<span class="cm"> *  	- a data area that acts as normal RAM.</span>
<span class="cm"> *</span>
<span class="cm"> *   User instructions contain virtual addresses of data to be accessed by the</span>
<span class="cm"> *   GRU. The GRU contains a TLB that is used to convert these user virtual</span>
<span class="cm"> *   addresses to physical addresses.</span>
<span class="cm"> *</span>
<span class="cm"> *   The &quot;system control&quot; area of the GRU chiplet is used by the kernel driver</span>
<span class="cm"> *   to manage user contexts and to perform functions such as TLB dropin and</span>
<span class="cm"> *   purging.</span>
<span class="cm"> *</span>
<span class="cm"> *   One context may be reserved for the kernel and used for cross-partition</span>
<span class="cm"> *   communication. The GRU will also be used to asynchronously zero out</span>
<span class="cm"> *   large blocks of memory (not currently implemented).</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Tables:</span>
<span class="cm"> *</span>
<span class="cm"> * 	VDATA-VMA Data		- Holds a few parameters. Head of linked list of</span>
<span class="cm"> * 				  GTS tables for threads using the GSEG</span>
<span class="cm"> * 	GTS - Gru Thread State  - contains info for managing a GSEG context. A</span>
<span class="cm"> * 				  GTS is allocated for each thread accessing a</span>
<span class="cm"> * 				  GSEG.</span>
<span class="cm"> *     	GTD - GRU Thread Data   - contains shadow copy of GRU data when GSEG is</span>
<span class="cm"> *     				  not loaded into a GRU</span>
<span class="cm"> *	GMS - GRU Memory Struct - Used to manage TLB shootdowns. Tracks GRUs</span>
<span class="cm"> *				  where a GSEG has been loaded. Similar to</span>
<span class="cm"> *				  an mm_struct but for GRU.</span>
<span class="cm"> *</span>
<span class="cm"> *	GS  - GRU State 	- Used to manage the state of a GRU chiplet</span>
<span class="cm"> *	BS  - Blade State	- Used to manage state of all GRU chiplets</span>
<span class="cm"> *				  on a blade</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  Normal task tables for task using GRU.</span>
<span class="cm"> *  		- 2 threads in process</span>
<span class="cm"> *  		- 2 GSEGs open in process</span>
<span class="cm"> *  		- GSEG1 is being used by both threads</span>
<span class="cm"> *  		- GSEG2 is used only by thread 2</span>
<span class="cm"> *</span>
<span class="cm"> *       task --&gt;|</span>
<span class="cm"> *       task ---+---&gt; mm -&gt;------ (notifier) -------+-&gt; gms</span>
<span class="cm"> *                     |                             |</span>
<span class="cm"> *                     |--&gt; vma -&gt; vdata ---&gt; gts---&gt;|		GSEG1 (thread1)</span>
<span class="cm"> *                     |                  |          |</span>
<span class="cm"> *                     |                  +-&gt; gts---&gt;|		GSEG1 (thread2)</span>
<span class="cm"> *                     |                             |</span>
<span class="cm"> *                     |--&gt; vma -&gt; vdata ---&gt; gts---&gt;|		GSEG2 (thread2)</span>
<span class="cm"> *                     .</span>
<span class="cm"> *                     .</span>
<span class="cm"> *</span>
<span class="cm"> *  GSEGs are marked DONTCOPY on fork</span>
<span class="cm"> *</span>
<span class="cm"> * At open</span>
<span class="cm"> * 	file.private_data -&gt; NULL</span>
<span class="cm"> *</span>
<span class="cm"> * At mmap,</span>
<span class="cm"> * 	vma -&gt; vdata</span>
<span class="cm"> *</span>
<span class="cm"> * After gseg reference</span>
<span class="cm"> * 	vma -&gt; vdata -&gt;gts</span>
<span class="cm"> *</span>
<span class="cm"> * After fork</span>
<span class="cm"> *   parent</span>
<span class="cm"> * 	vma -&gt; vdata -&gt; gts</span>
<span class="cm"> *   child</span>
<span class="cm"> * 	(vma is not copied)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_notifier.h&gt;</span>
<span class="cp">#include &quot;gru.h&quot;</span>
<span class="cp">#include &quot;grulib.h&quot;</span>
<span class="cp">#include &quot;gruhandles.h&quot;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">gru_stats_s</span> <span class="n">gru_stats</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="o">*</span><span class="n">gru_base</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gru_start_paddr</span><span class="p">,</span> <span class="n">gru_end_paddr</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">gru_start_vaddr</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gru_max_gids</span><span class="p">;</span>

<span class="cp">#define GRU_MAX_BLADES		MAX_NUMNODES</span>
<span class="cp">#define GRU_MAX_GRUS		(GRU_MAX_BLADES * GRU_CHIPLETS_PER_BLADE)</span>

<span class="cp">#define GRU_DRIVER_ID_STR	&quot;SGI GRU Device Driver&quot;</span>
<span class="cp">#define GRU_DRIVER_VERSION_STR	&quot;0.85&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * GRU statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_stats_s</span> <span class="p">{</span>
	<span class="n">atomic_long_t</span> <span class="n">vdata_alloc</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">vdata_free</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">gts_alloc</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">gts_free</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">gms_alloc</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">gms_free</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">gts_double_allocate</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">assign_context</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">assign_context_failed</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">free_context</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">load_user_context</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">load_kernel_context</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">lock_kernel_context</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">unlock_kernel_context</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">steal_user_context</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">steal_kernel_context</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">steal_context_failed</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">nopfn</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">asid_new</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">asid_next</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">asid_wrap</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">asid_reuse</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">intr</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">intr_cbr</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">intr_tfh</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">intr_spurious</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">intr_mm_lock_failed</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">call_os</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">call_os_wait_queue</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">user_flush_tlb</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">user_unload_context</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">user_exception</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">set_context_option</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">check_context_retarget_intr</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">check_context_unload</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">tlb_dropin</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">tlb_preload_page</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">tlb_dropin_fail_no_asid</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">tlb_dropin_fail_upm</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">tlb_dropin_fail_invalid</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">tlb_dropin_fail_range_active</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">tlb_dropin_fail_idle</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">tlb_dropin_fail_fmm</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">tlb_dropin_fail_no_exception</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">tfh_stale_on_fault</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mmu_invalidate_range</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mmu_invalidate_page</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">flush_tlb</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">flush_tlb_gru</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">flush_tlb_gru_tgh</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">flush_tlb_gru_zero_asid</span><span class="p">;</span>

	<span class="n">atomic_long_t</span> <span class="n">copy_gpa</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">read_gpa</span><span class="p">;</span>

	<span class="n">atomic_long_t</span> <span class="n">mesq_receive</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_receive_none</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_send</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_send_failed</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_noop</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_send_unexpected_error</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_send_lb_overflow</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_send_qlimit_reached</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_send_amo_nacked</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_send_put_nacked</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_page_overflow</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_qf_locked</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_qf_noop_not_full</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_qf_switch_head_failed</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_qf_unexpected_error</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_noop_unexpected_error</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_noop_lb_overflow</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_noop_qlimit_reached</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_noop_amo_nacked</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_noop_put_nacked</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">mesq_noop_page_overflow</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">enum</span> <span class="n">mcs_op</span> <span class="p">{</span><span class="n">cchop_allocate</span><span class="p">,</span> <span class="n">cchop_start</span><span class="p">,</span> <span class="n">cchop_interrupt</span><span class="p">,</span> <span class="n">cchop_interrupt_sync</span><span class="p">,</span>
	<span class="n">cchop_deallocate</span><span class="p">,</span> <span class="n">tfhop_write_only</span><span class="p">,</span> <span class="n">tfhop_write_restart</span><span class="p">,</span>
	<span class="n">tghop_invalidate</span><span class="p">,</span> <span class="n">mcsop_last</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">mcs_op_statistic</span> <span class="p">{</span>
	<span class="n">atomic_long_t</span>	<span class="n">count</span><span class="p">;</span>
	<span class="n">atomic_long_t</span>	<span class="n">total</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">max</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mcs_op_statistic</span> <span class="n">mcs_op_statistics</span><span class="p">[</span><span class="n">mcsop_last</span><span class="p">];</span>

<span class="cp">#define OPT_DPRINT		1</span>
<span class="cp">#define OPT_STATS		2</span>


<span class="cp">#define IRQ_GRU			110	</span><span class="cm">/* Starting IRQ number for interrupts */</span><span class="cp"></span>

<span class="cm">/* Delay in jiffies between attempts to assign a GRU context */</span>
<span class="cp">#define GRU_ASSIGN_DELAY	((HZ * 20) / 1000)</span>

<span class="cm">/*</span>
<span class="cm"> * If a process has it&#39;s context stolen, min delay in jiffies before trying to</span>
<span class="cm"> * steal a context from another process.</span>
<span class="cm"> */</span>
<span class="cp">#define GRU_STEAL_DELAY		((HZ * 200) / 1000)</span>

<span class="cp">#define STAT(id)	do {						\</span>
<span class="cp">				if (gru_options &amp; OPT_STATS)		\</span>
<span class="cp">					atomic_long_inc(&amp;gru_stats.id);	\</span>
<span class="cp">			} while (0)</span>

<span class="cp">#ifdef CONFIG_SGI_GRU_DEBUG</span>
<span class="cp">#define gru_dbg(dev, fmt, x...)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (gru_options &amp; OPT_DPRINT)				\</span>
<span class="cp">			printk(KERN_DEBUG &quot;GRU:%d %s: &quot; fmt, smp_processor_id(), __func__, x);\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define gru_dbg(x...)</span>
<span class="cp">#endif</span>

<span class="cm">/*-----------------------------------------------------------------------------</span>
<span class="cm"> * ASID management</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_ASID	0xfffff0</span>
<span class="cp">#define MIN_ASID	8</span>
<span class="cp">#define ASID_INC	8	</span><span class="cm">/* number of regions */</span><span class="cp"></span>

<span class="cm">/* Generate a GRU asid value from a GRU base asid &amp; a virtual address. */</span>
<span class="cp">#define VADDR_HI_BIT		64</span>
<span class="cp">#define GRUREGION(addr)		((addr) &gt;&gt; (VADDR_HI_BIT - 3) &amp; 3)</span>
<span class="cp">#define GRUASID(asid, addr)	((asid) + GRUREGION(addr))</span>

<span class="cm">/*------------------------------------------------------------------------------</span>
<span class="cm"> *  File &amp; VMS Tables</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">gru_state</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is pointed to from the mmstruct via the notifier pointer.</span>
<span class="cm"> * There is one of these per address space.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_mm_tracker</span> <span class="p">{</span>				<span class="cm">/* pack to reduce size */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">mt_asid_gen</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>	<span class="cm">/* ASID wrap count */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">mt_asid</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>	<span class="cm">/* current base ASID for gru */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">mt_ctxbitmap</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span><span class="cm">/* bitmap of contexts using</span>
<span class="cm">						   asid */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">gru_mm_struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_notifier</span>	<span class="n">ms_notifier</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">ms_refcnt</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">ms_asid_lock</span><span class="p">;</span>	<span class="cm">/* protects ASID assignment */</span>
	<span class="n">atomic_t</span>		<span class="n">ms_range_active</span><span class="p">;</span><span class="cm">/* num range_invals active */</span>
	<span class="kt">char</span>			<span class="n">ms_released</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">ms_wait_queue</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">ms_asidmap</span><span class="p">,</span> <span class="n">GRU_MAX_GRUS</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gru_mm_tracker</span>	<span class="n">ms_asids</span><span class="p">[</span><span class="n">GRU_MAX_GRUS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * One of these structures is allocated when a GSEG is mmaped. The</span>
<span class="cm"> * structure is pointed to by the vma-&gt;vm_private_data field in the vma struct.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_vma_data</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">vd_lock</span><span class="p">;</span>	<span class="cm">/* Serialize access to vma */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">vd_head</span><span class="p">;</span>	<span class="cm">/* head of linked list of gts */</span>
	<span class="kt">long</span>			<span class="n">vd_user_options</span><span class="p">;</span><span class="cm">/* misc user option flags */</span>
	<span class="kt">int</span>			<span class="n">vd_cbr_au_count</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">vd_dsr_au_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">vd_tlb_preload_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * One of these is allocated for each thread accessing a mmaped GRU. A linked</span>
<span class="cm"> * list of these structure is hung off the struct gru_vma_data in the mm_struct.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ts_next</span><span class="p">;</span>	<span class="cm">/* list - head at vma-private */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">ts_ctxlock</span><span class="p">;</span>	<span class="cm">/* load/unload CTX lock */</span>
	<span class="k">struct</span> <span class="n">mm_struct</span>	<span class="o">*</span><span class="n">ts_mm</span><span class="p">;</span>		<span class="cm">/* mm currently mapped to</span>
<span class="cm">						   context */</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span>	<span class="o">*</span><span class="n">ts_vma</span><span class="p">;</span>	<span class="cm">/* vma of GRU context */</span>
	<span class="k">struct</span> <span class="n">gru_state</span>	<span class="o">*</span><span class="n">ts_gru</span><span class="p">;</span>	<span class="cm">/* GRU where the context is</span>
<span class="cm">						   loaded */</span>
	<span class="k">struct</span> <span class="n">gru_mm_struct</span>	<span class="o">*</span><span class="n">ts_gms</span><span class="p">;</span>	<span class="cm">/* asid &amp; ioproc struct */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">ts_tlb_preload_count</span><span class="p">;</span> <span class="cm">/* TLB preload pages */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ts_cbr_map</span><span class="p">;</span>	<span class="cm">/* map of allocated CBRs */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ts_dsr_map</span><span class="p">;</span>	<span class="cm">/* map of allocated DATA</span>
<span class="cm">						   resources */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ts_steal_jiffies</span><span class="p">;</span><span class="cm">/* jiffies when context last</span>
<span class="cm">						    stolen */</span>
	<span class="kt">long</span>			<span class="n">ts_user_options</span><span class="p">;</span><span class="cm">/* misc user option flags */</span>
	<span class="n">pid_t</span>			<span class="n">ts_tgid_owner</span><span class="p">;</span>	<span class="cm">/* task that is using the</span>
<span class="cm">						   context - for migration */</span>
	<span class="kt">short</span>			<span class="n">ts_user_blade_id</span><span class="p">;</span><span class="cm">/* user selected blade */</span>
	<span class="kt">char</span>			<span class="n">ts_user_chiplet_id</span><span class="p">;</span><span class="cm">/* user selected chiplet */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">ts_sizeavail</span><span class="p">;</span>	<span class="cm">/* Pagesizes in use */</span>
	<span class="kt">int</span>			<span class="n">ts_tsid</span><span class="p">;</span>	<span class="cm">/* thread that owns the</span>
<span class="cm">						   structure */</span>
	<span class="kt">int</span>			<span class="n">ts_tlb_int_select</span><span class="p">;</span><span class="cm">/* target cpu if interrupts</span>
<span class="cm">						     enabled */</span>
	<span class="kt">int</span>			<span class="n">ts_ctxnum</span><span class="p">;</span>	<span class="cm">/* context number where the</span>
<span class="cm">						   context is loaded */</span>
	<span class="n">atomic_t</span>		<span class="n">ts_refcnt</span><span class="p">;</span>	<span class="cm">/* reference count GTS */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">ts_dsr_au_count</span><span class="p">;</span><span class="cm">/* Number of DSR resources</span>
<span class="cm">						   required for contest */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">ts_cbr_au_count</span><span class="p">;</span><span class="cm">/* Number of CBR resources</span>
<span class="cm">						   required for contest */</span>
	<span class="kt">char</span>			<span class="n">ts_cch_req_slice</span><span class="p">;</span><span class="cm">/* CCH packet slice */</span>
	<span class="kt">char</span>			<span class="n">ts_blade</span><span class="p">;</span>	<span class="cm">/* If &gt;= 0, migrate context if</span>
<span class="cm">						   ref from different blade */</span>
	<span class="kt">char</span>			<span class="n">ts_force_cch_reload</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">ts_cbr_idx</span><span class="p">[</span><span class="n">GRU_CBR_AU</span><span class="p">];</span><span class="cm">/* CBR numbers of each</span>
<span class="cm">							  allocated CB */</span>
	<span class="kt">int</span>			<span class="n">ts_data_valid</span><span class="p">;</span>	<span class="cm">/* Indicates if ts_gdata has</span>
<span class="cm">						   valid data */</span>
	<span class="k">struct</span> <span class="n">gru_gseg_statistics</span> <span class="n">ustats</span><span class="p">;</span>	<span class="cm">/* User statistics */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ts_gdata</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* save area for GRU data (CB,</span>
<span class="cm">						   DS, CBE) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Threaded programs actually allocate an array of GSEGs when a context is</span>
<span class="cm"> * created. Each thread uses a separate GSEG. TSID is the index into the GSEG</span>
<span class="cm"> * array.</span>
<span class="cm"> */</span>
<span class="cp">#define TSID(a, v)		(((a) - (v)-&gt;vm_start) / GRU_GSEG_PAGESIZE)</span>
<span class="cp">#define UGRUADDR(gts)		((gts)-&gt;ts_vma-&gt;vm_start +		\</span>
<span class="cp">					(gts)-&gt;ts_tsid * GRU_GSEG_PAGESIZE)</span>

<span class="cp">#define NULLCTX			(-1)	</span><span class="cm">/* if context not loaded into GRU */</span><span class="cp"></span>

<span class="cm">/*-----------------------------------------------------------------------------</span>
<span class="cm"> *  GRU State Tables</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * One of these exists for each GRU chiplet.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">gru_blade_state</span>	<span class="o">*</span><span class="n">gs_blade</span><span class="p">;</span>		<span class="cm">/* GRU state for entire</span>
<span class="cm">							   blade */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">gs_gru_base_paddr</span><span class="p">;</span>	<span class="cm">/* Physical address of</span>
<span class="cm">							   gru segments (64) */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">gs_gru_base_vaddr</span><span class="p">;</span>	<span class="cm">/* Virtual address of</span>
<span class="cm">							   gru segments (64) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">gs_gid</span><span class="p">;</span>			<span class="cm">/* unique GRU number */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">gs_blade_id</span><span class="p">;</span>		<span class="cm">/* blade of GRU */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">gs_chiplet_id</span><span class="p">;</span>		<span class="cm">/* blade chiplet of GRU */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">gs_tgh_local_shift</span><span class="p">;</span>	<span class="cm">/* used to pick TGH for</span>
<span class="cm">							   local flush */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">gs_tgh_first_remote</span><span class="p">;</span>	<span class="cm">/* starting TGH# for</span>
<span class="cm">							   remote flush */</span>
	<span class="n">spinlock_t</span>		<span class="n">gs_asid_lock</span><span class="p">;</span>		<span class="cm">/* lock used for</span>
<span class="cm">							   assigning asids */</span>
	<span class="n">spinlock_t</span>		<span class="n">gs_lock</span><span class="p">;</span>		<span class="cm">/* lock used for</span>
<span class="cm">							   assigning contexts */</span>

	<span class="cm">/* -- the following are protected by the gs_asid_lock spinlock ---- */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">gs_asid</span><span class="p">;</span>		<span class="cm">/* Next availe ASID */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">gs_asid_limit</span><span class="p">;</span>		<span class="cm">/* Limit of available</span>
<span class="cm">							   ASIDs */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">gs_asid_gen</span><span class="p">;</span>		<span class="cm">/* asid generation.</span>
<span class="cm">							   Inc on wrap */</span>

	<span class="cm">/* --- the following fields are protected by the gs_lock spinlock --- */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">gs_context_map</span><span class="p">;</span>		<span class="cm">/* bitmap to manage</span>
<span class="cm">							   contexts in use */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">gs_cbr_map</span><span class="p">;</span>		<span class="cm">/* bitmap to manage CB</span>
<span class="cm">							   resources */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">gs_dsr_map</span><span class="p">;</span>		<span class="cm">/* bitmap used to manage</span>
<span class="cm">							   DATA resources */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">gs_reserved_cbrs</span><span class="p">;</span>	<span class="cm">/* Number of kernel-</span>
<span class="cm">							   reserved cbrs */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">gs_reserved_dsr_bytes</span><span class="p">;</span>	<span class="cm">/* Bytes of kernel-</span>
<span class="cm">							   reserved dsrs */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">gs_active_contexts</span><span class="p">;</span>	<span class="cm">/* number of contexts</span>
<span class="cm">							   in use */</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span>	<span class="o">*</span><span class="n">gs_gts</span><span class="p">[</span><span class="n">GRU_NUM_CCH</span><span class="p">];</span>	<span class="cm">/* GTS currently using</span>
<span class="cm">							   the context */</span>
	<span class="kt">int</span>			<span class="n">gs_irq</span><span class="p">[</span><span class="n">GRU_NUM_TFM</span><span class="p">];</span>	<span class="cm">/* Interrupt irqs */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This structure contains the GRU state for all the GRUs on a blade.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_blade_state</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">kernel_cb</span><span class="p">;</span>		<span class="cm">/* First kernel</span>
<span class="cm">							   reserved cb */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">kernel_dsr</span><span class="p">;</span>		<span class="cm">/* First kernel</span>
<span class="cm">							   reserved DSR */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">bs_kgts_sema</span><span class="p">;</span>		<span class="cm">/* lock for kgts */</span>
	<span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">bs_kgts</span><span class="p">;</span>		<span class="cm">/* GTS for kernel use */</span>

	<span class="cm">/* ---- the following are used for managing kernel async GRU CBRs --- */</span>
	<span class="kt">int</span>			<span class="n">bs_async_dsr_bytes</span><span class="p">;</span>	<span class="cm">/* DSRs for async */</span>
	<span class="kt">int</span>			<span class="n">bs_async_cbrs</span><span class="p">;</span>		<span class="cm">/* CBRs AU for async */</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="o">*</span><span class="n">bs_async_wq</span><span class="p">;</span>

	<span class="cm">/* ---- the following are protected by the bs_lock spinlock ---- */</span>
	<span class="n">spinlock_t</span>		<span class="n">bs_lock</span><span class="p">;</span>		<span class="cm">/* lock used for</span>
<span class="cm">							   stealing contexts */</span>
	<span class="kt">int</span>			<span class="n">bs_lru_ctxnum</span><span class="p">;</span>		<span class="cm">/* STEAL - last context</span>
<span class="cm">							   stolen */</span>
	<span class="k">struct</span> <span class="n">gru_state</span>	<span class="o">*</span><span class="n">bs_lru_gru</span><span class="p">;</span>		<span class="cm">/* STEAL - last gru</span>
<span class="cm">							   stolen */</span>

	<span class="k">struct</span> <span class="n">gru_state</span>	<span class="n">bs_grus</span><span class="p">[</span><span class="n">GRU_CHIPLETS_PER_BLADE</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*-----------------------------------------------------------------------------</span>
<span class="cm"> * Address Primitives</span>
<span class="cm"> */</span>
<span class="cp">#define get_tfm_for_cpu(g, c)						\</span>
<span class="cp">	((struct gru_tlb_fault_map *)get_tfm((g)-&gt;gs_gru_base_vaddr, (c)))</span>
<span class="cp">#define get_tfh_by_index(g, i)						\</span>
<span class="cp">	((struct gru_tlb_fault_handle *)get_tfh((g)-&gt;gs_gru_base_vaddr, (i)))</span>
<span class="cp">#define get_tgh_by_index(g, i)						\</span>
<span class="cp">	((struct gru_tlb_global_handle *)get_tgh((g)-&gt;gs_gru_base_vaddr, (i)))</span>
<span class="cp">#define get_cbe_by_index(g, i)						\</span>
<span class="cp">	((struct gru_control_block_extended *)get_cbe((g)-&gt;gs_gru_base_vaddr,\</span>
<span class="cp">			(i)))</span>

<span class="cm">/*-----------------------------------------------------------------------------</span>
<span class="cm"> * Useful Macros</span>
<span class="cm"> */</span>

<span class="cm">/* Given a blade# &amp; chiplet#, get a pointer to the GRU */</span>
<span class="cp">#define get_gru(b, c)		(&amp;gru_base[b]-&gt;bs_grus[c])</span>

<span class="cm">/* Number of bytes to save/restore when unloading/loading GRU contexts */</span>
<span class="cp">#define DSR_BYTES(dsr)		((dsr) * GRU_DSR_AU_BYTES)</span>
<span class="cp">#define CBR_BYTES(cbr)		((cbr) * GRU_HANDLE_BYTES * GRU_CBR_AU_SIZE * 2)</span>

<span class="cm">/* Convert a user CB number to the actual CBRNUM */</span>
<span class="cp">#define thread_cbr_number(gts, n) ((gts)-&gt;ts_cbr_idx[(n) / GRU_CBR_AU_SIZE] \</span>
<span class="cp">				  * GRU_CBR_AU_SIZE + (n) % GRU_CBR_AU_SIZE)</span>

<span class="cm">/* Convert a gid to a pointer to the GRU */</span>
<span class="cp">#define GID_TO_GRU(gid)							\</span>
<span class="cp">	(gru_base[(gid) / GRU_CHIPLETS_PER_BLADE] ?			\</span>
<span class="cp">		(&amp;gru_base[(gid) / GRU_CHIPLETS_PER_BLADE]-&gt;		\</span>
<span class="cp">			bs_grus[(gid) % GRU_CHIPLETS_PER_BLADE]) :	\</span>
<span class="cp">	 NULL)</span>

<span class="cm">/* Scan all active GRUs in a GRU bitmap */</span>
<span class="cp">#define for_each_gru_in_bitmap(gid, map)				\</span>
<span class="cp">	for_each_set_bit((gid), (map), GRU_MAX_GRUS)</span>

<span class="cm">/* Scan all active GRUs on a specific blade */</span>
<span class="cp">#define for_each_gru_on_blade(gru, nid, i)				\</span>
<span class="cp">	for ((gru) = gru_base[nid]-&gt;bs_grus, (i) = 0;			\</span>
<span class="cp">			(i) &lt; GRU_CHIPLETS_PER_BLADE;			\</span>
<span class="cp">			(i)++, (gru)++)</span>

<span class="cm">/* Scan all GRUs */</span>
<span class="cp">#define foreach_gid(gid)						\</span>
<span class="cp">	for ((gid) = 0; (gid) &lt; gru_max_gids; (gid)++)</span>

<span class="cm">/* Scan all active GTSs on a gru. Note: must hold ss_lock to use this macro. */</span>
<span class="cp">#define for_each_gts_on_gru(gts, gru, ctxnum)				\</span>
<span class="cp">	for ((ctxnum) = 0; (ctxnum) &lt; GRU_NUM_CCH; (ctxnum)++)		\</span>
<span class="cp">		if (((gts) = (gru)-&gt;gs_gts[ctxnum]))</span>

<span class="cm">/* Scan each CBR whose bit is set in a TFM (or copy of) */</span>
<span class="cp">#define for_each_cbr_in_tfm(i, map)					\</span>
<span class="cp">	for_each_set_bit((i), (map), GRU_NUM_CBE)</span>

<span class="cm">/* Scan each CBR in a CBR bitmap. Note: multiple CBRs in an allocation unit */</span>
<span class="cp">#define for_each_cbr_in_allocation_map(i, map, k)			\</span>
<span class="cp">	for_each_set_bit((k), (map), GRU_CBR_AU)			\</span>
<span class="cp">		for ((i) = (k)*GRU_CBR_AU_SIZE;				\</span>
<span class="cp">				(i) &lt; ((k) + 1) * GRU_CBR_AU_SIZE; (i)++)</span>

<span class="cm">/* Scan each DSR in a DSR bitmap. Note: multiple DSRs in an allocation unit */</span>
<span class="cp">#define for_each_dsr_in_allocation_map(i, map, k)			\</span>
<span class="cp">	for_each_set_bit((k), (const unsigned long *)(map), GRU_DSR_AU)	\</span>
<span class="cp">		for ((i) = (k) * GRU_DSR_AU_CL;				\</span>
<span class="cp">				(i) &lt; ((k) + 1) * GRU_DSR_AU_CL; (i)++)</span>

<span class="cp">#define gseg_physical_address(gru, ctxnum)				\</span>
<span class="cp">		((gru)-&gt;gs_gru_base_paddr + ctxnum * GRU_GSEG_STRIDE)</span>
<span class="cp">#define gseg_virtual_address(gru, ctxnum)				\</span>
<span class="cp">		((gru)-&gt;gs_gru_base_vaddr + ctxnum * GRU_GSEG_STRIDE)</span>

<span class="cm">/*-----------------------------------------------------------------------------</span>
<span class="cm"> * Lock / Unlock GRU handles</span>
<span class="cm"> * 	Use the &quot;delresp&quot; bit in the handle as a &quot;lock&quot; bit.</span>
<span class="cm"> */</span>

<span class="cm">/* Lock hierarchy checking enabled only in emulator */</span>

<span class="cm">/* 0 = lock failed, 1 = locked */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__trylock_handle</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__lock_handle</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__unlock_handle</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">trylock_cch_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_context_configuration_handle</span> <span class="o">*</span><span class="n">cch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__trylock_handle</span><span class="p">(</span><span class="n">cch</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_cch_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_context_configuration_handle</span> <span class="o">*</span><span class="n">cch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__lock_handle</span><span class="p">(</span><span class="n">cch</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_cch_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_context_configuration_handle</span>
				     <span class="o">*</span><span class="n">cch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__unlock_handle</span><span class="p">(</span><span class="n">cch</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_tgh_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_tlb_global_handle</span> <span class="o">*</span><span class="n">tgh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__lock_handle</span><span class="p">(</span><span class="n">tgh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_tgh_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_tlb_global_handle</span> <span class="o">*</span><span class="n">tgh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__unlock_handle</span><span class="p">(</span><span class="n">tgh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_kernel_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">gts</span><span class="o">-&gt;</span><span class="n">ts_mm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following are for Nehelem-EX. A more general scheme is needed for</span>
<span class="cm"> * future processors.</span>
<span class="cm"> */</span>
<span class="cp">#define UV_MAX_INT_CORES		8</span>
<span class="cp">#define uv_cpu_socket_number(p)		((cpu_physical_id(p) &gt;&gt; 5) &amp; 1)</span>
<span class="cp">#define uv_cpu_ht_number(p)		(cpu_physical_id(p) &amp; 1)</span>
<span class="cp">#define uv_cpu_core_number(p)		(((cpu_physical_id(p) &gt;&gt; 2) &amp; 4) |	\</span>
<span class="cp">					((cpu_physical_id(p) &gt;&gt; 1) &amp; 3))</span>
<span class="cm">/*-----------------------------------------------------------------------------</span>
<span class="cm"> * Function prototypes &amp; externs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gru_unload_context_req</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">gru_vm_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">grudev</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">gru_vma_data</span> <span class="o">*</span><span class="n">gru_alloc_vma_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">tsid</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gru_find_thread_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span>
				<span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tsid</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gru_alloc_thread_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span>
				<span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tsid</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru_assign_gru_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gru_load_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gru_steal_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gru_unload_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">,</span> <span class="kt">int</span> <span class="n">savestate</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_update_cch</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gts_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gru_tgh_flush_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_kservices_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gru_kservices_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">irqreturn_t</span> <span class="n">gru0_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">irqreturn_t</span> <span class="n">gru1_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">irqreturn_t</span> <span class="n">gru_intr_mblade</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_dump_chiplet_request</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">gru_get_gseg_statistics</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_handle_user_call_os</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_user_flush_tlb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_user_unload_context</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_get_exception_detail</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_set_context_option</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gru_check_context_placement</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_cpu_fault_map_id</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">gru_find_vma</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gru_flush_all_tlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gru_proc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">gru_thread_state</span> <span class="o">*</span><span class="n">gru_alloc_gts</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">cbr_au_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dsr_au_count</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tlb_preload_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tsid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gru_reserve_cb_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">cbr_au_count</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cbmap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gru_reserve_ds_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_state</span> <span class="o">*</span><span class="n">gru</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">dsr_au_count</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dsmap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">gru_mm_struct</span> <span class="o">*</span><span class="n">gru_register_mmu_notifier</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gru_drop_mmu_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_mm_struct</span> <span class="o">*</span><span class="n">gms</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">gru_ktest</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gru_flush_tlb_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">gru_mm_struct</span> <span class="o">*</span><span class="n">gms</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gru_options</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __GRUTABLES_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
