<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › misc › vmw_balloon.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>vmw_balloon.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * VMware Balloon driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000-2010, VMware, Inc. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; version 2 of the License and no later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> * NON INFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained by: Dmitry Torokhov &lt;dtor@vmware.com&gt;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This is VMware physical memory management driver for Linux. The driver</span>
<span class="cm"> * acts like a &quot;balloon&quot; that can be inflated to reclaim physical pages by</span>
<span class="cm"> * reserving them in the guest and invalidating them in the monitor,</span>
<span class="cm"> * freeing up the underlying machine pages so they can be allocated to</span>
<span class="cm"> * other guests.  The balloon can also be deflated to allow the guest to</span>
<span class="cm"> * use more physical memory. Higher level policies can control the sizes</span>
<span class="cm"> * of balloons in VMs in order to manage physical memory resources.</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><h1>define DEBUG</h1></td><td class="code"><div class="highlight"><pre><span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;asm/hypervisor.h&gt;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;VMware, Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;VMware Memory Control (Balloon) Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">&quot;1.2.1.3-k&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;dmi:*:svnVMware*:*&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;vmware_vmmemctl&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Various constants controlling rate of inflaint/deflating balloon,</span>
<span class="cm"> * measured in pages.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Rate of allocating memory when there is no memory pressure</span>
<span class="cm"> * (driver performs non-sleeping allocations).</span>
<span class="cm"> */</span>
<span class="cp">#define VMW_BALLOON_NOSLEEP_ALLOC_MAX	16384U</span>

<span class="cm">/*</span>
<span class="cm"> * Rates of memory allocaton when guest experiences memory pressure</span>
<span class="cm"> * (driver performs sleeping allocations).</span>
<span class="cm"> */</span>
<span class="cp">#define VMW_BALLOON_RATE_ALLOC_MIN	512U</span>
<span class="cp">#define VMW_BALLOON_RATE_ALLOC_MAX	2048U</span>
<span class="cp">#define VMW_BALLOON_RATE_ALLOC_INC	16U</span>

<span class="cm">/*</span>
<span class="cm"> * Rates for releasing pages while deflating balloon.</span>
<span class="cm"> */</span>
<span class="cp">#define VMW_BALLOON_RATE_FREE_MIN	512U</span>
<span class="cp">#define VMW_BALLOON_RATE_FREE_MAX	16384U</span>
<span class="cp">#define VMW_BALLOON_RATE_FREE_INC	16U</span>

<span class="cm">/*</span>
<span class="cm"> * When guest is under memory pressure, use a reduced page allocation</span>
<span class="cm"> * rate for next several cycles.</span>
<span class="cm"> */</span>
<span class="cp">#define VMW_BALLOON_SLOW_CYCLES		4</span>

<span class="cm">/*</span>
<span class="cm"> * Use __GFP_HIGHMEM to allow pages from HIGHMEM zone. We don&#39;t</span>
<span class="cm"> * allow wait (__GFP_WAIT) for NOSLEEP page allocations. Use</span>
<span class="cm"> * __GFP_NOWARN, to suppress page allocation failure warnings.</span>
<span class="cm"> */</span>
<span class="cp">#define VMW_PAGE_ALLOC_NOSLEEP		(__GFP_HIGHMEM|__GFP_NOWARN)</span>

<span class="cm">/*</span>
<span class="cm"> * Use GFP_HIGHUSER when executing in a separate kernel thread</span>
<span class="cm"> * context and allocation can sleep.  This is less stressful to</span>
<span class="cm"> * the guest memory system, since it allows the thread to block</span>
<span class="cm"> * while memory is reclaimed, and won&#39;t take pages from emergency</span>
<span class="cm"> * low-memory pools.</span>
<span class="cm"> */</span>
<span class="cp">#define VMW_PAGE_ALLOC_CANSLEEP		(GFP_HIGHUSER)</span>

<span class="cm">/* Maximum number of page allocations without yielding processor */</span>
<span class="cp">#define VMW_BALLOON_YIELD_THRESHOLD	1024</span>

<span class="cm">/* Maximum number of refused pages we accumulate during inflation cycle */</span>
<span class="cp">#define VMW_BALLOON_MAX_REFUSED		16</span>

<span class="cm">/*</span>
<span class="cm"> * Hypervisor communication port definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define VMW_BALLOON_HV_PORT		0x5670</span>
<span class="cp">#define VMW_BALLOON_HV_MAGIC		0x456c6d6f</span>
<span class="cp">#define VMW_BALLOON_PROTOCOL_VERSION	2</span>
<span class="cp">#define VMW_BALLOON_GUEST_ID		1	</span><span class="cm">/* Linux */</span><span class="cp"></span>

<span class="cp">#define VMW_BALLOON_CMD_START		0</span>
<span class="cp">#define VMW_BALLOON_CMD_GET_TARGET	1</span>
<span class="cp">#define VMW_BALLOON_CMD_LOCK		2</span>
<span class="cp">#define VMW_BALLOON_CMD_UNLOCK		3</span>
<span class="cp">#define VMW_BALLOON_CMD_GUEST_ID	4</span>

<span class="cm">/* error codes */</span>
<span class="cp">#define VMW_BALLOON_SUCCESS		0</span>
<span class="cp">#define VMW_BALLOON_FAILURE		-1</span>
<span class="cp">#define VMW_BALLOON_ERROR_CMD_INVALID	1</span>
<span class="cp">#define VMW_BALLOON_ERROR_PPN_INVALID	2</span>
<span class="cp">#define VMW_BALLOON_ERROR_PPN_LOCKED	3</span>
<span class="cp">#define VMW_BALLOON_ERROR_PPN_UNLOCKED	4</span>
<span class="cp">#define VMW_BALLOON_ERROR_PPN_PINNED	5</span>
<span class="cp">#define VMW_BALLOON_ERROR_PPN_NOTNEEDED	6</span>
<span class="cp">#define VMW_BALLOON_ERROR_RESET		7</span>
<span class="cp">#define VMW_BALLOON_ERROR_BUSY		8</span>

<span class="cp">#define VMWARE_BALLOON_CMD(cmd, data, result)		\</span>
<span class="cp">({							\</span>
<span class="cp">	unsigned long __stat, __dummy1, __dummy2;	\</span>
<span class="cp">	__asm__ __volatile__ (&quot;inl (%%dx)&quot; :		\</span>
<span class="cp">		&quot;=a&quot;(__stat),				\</span>
<span class="cp">		&quot;=c&quot;(__dummy1),				\</span>
<span class="cp">		&quot;=d&quot;(__dummy2),				\</span>
<span class="cp">		&quot;=b&quot;(result) :				\</span>
<span class="cp">		&quot;0&quot;(VMW_BALLOON_HV_MAGIC),		\</span>
<span class="cp">		&quot;1&quot;(VMW_BALLOON_CMD_##cmd),		\</span>
<span class="cp">		&quot;2&quot;(VMW_BALLOON_HV_PORT),		\</span>
<span class="cp">		&quot;3&quot;(data) :				\</span>
<span class="cp">		&quot;memory&quot;);				\</span>
<span class="cp">	result &amp;= -1UL;					\</span>
<span class="cp">	__stat &amp; -1UL;					\</span>
<span class="cp">})</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="k">struct</span> <span class="n">vmballoon_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer</span><span class="p">;</span>

	<span class="cm">/* allocation statistics */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_fail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sleep_alloc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sleep_alloc_fail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">refused_alloc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">refused_free</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">free</span><span class="p">;</span>

	<span class="cm">/* monitor operations */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lock_fail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unlock_fail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target_fail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start_fail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">guest_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">guest_type_fail</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define STATS_INC(stat) (stat)++</span>
<span class="cp">#else</span>
<span class="cp">#define STATS_INC(stat)</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">vmballoon</span> <span class="p">{</span>

	<span class="cm">/* list of reserved physical pages */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pages</span><span class="p">;</span>

	<span class="cm">/* transient list of non-balloonable pages */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">refused_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_refused_pages</span><span class="p">;</span>

	<span class="cm">/* balloon size in pages */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target</span><span class="p">;</span>

	<span class="cm">/* reset flag */</span>
	<span class="n">bool</span> <span class="n">reset_required</span><span class="p">;</span>

	<span class="cm">/* adjustment rates (pages per second) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate_alloc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate_free</span><span class="p">;</span>

	<span class="cm">/* slowdown page allocations for next few cycles */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slow_allocation_cycles</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="cm">/* statistics */</span>
	<span class="k">struct</span> <span class="n">vmballoon_stats</span> <span class="n">stats</span><span class="p">;</span>

	<span class="cm">/* debugfs file exporting statistics */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dbg_entry</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">sysinfo</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">dwork</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vmballoon</span> <span class="n">balloon</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Send &quot;start&quot; command to the host, communicating supported version</span>
<span class="cm"> * of the protocol.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">vmballoon_send_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">,</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">VMWARE_BALLOON_CMD</span><span class="p">(</span><span class="n">START</span><span class="p">,</span> <span class="n">VMW_BALLOON_PROTOCOL_VERSION</span><span class="p">,</span> <span class="n">dummy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">VMW_BALLOON_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s - failed, hv returns %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">start_fail</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">vmballoon_check_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VMW_BALLOON_SUCCESS</span>:
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">VMW_BALLOON_ERROR_RESET</span>:
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">reset_required</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Communicate guest type to the host so that it can adjust ballooning</span>
<span class="cm"> * algorithm to the one most appropriate for the guest. This command</span>
<span class="cm"> * is normally issued after sending &quot;start&quot; command and is part of</span>
<span class="cm"> * standard reset sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">vmballoon_send_guest_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">,</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">VMWARE_BALLOON_CMD</span><span class="p">(</span><span class="n">GUEST_ID</span><span class="p">,</span> <span class="n">VMW_BALLOON_GUEST_ID</span><span class="p">,</span> <span class="n">dummy</span><span class="p">);</span>

	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">guest_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmballoon_check_status</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s - failed, hv returns %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">guest_type_fail</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieve desired balloon size from the host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">vmballoon_send_get_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">new_target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">target</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">limit32</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * si_meminfo() is cheap. Moreover, we want to provide dynamic</span>
<span class="cm">	 * max balloon size later. So let us call si_meminfo() every</span>
<span class="cm">	 * iteration.</span>
<span class="cm">	 */</span>
	<span class="n">si_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sysinfo</span><span class="p">);</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">sysinfo</span><span class="p">.</span><span class="n">totalram</span><span class="p">;</span>

	<span class="cm">/* Ensure limit fits in 32-bits */</span>
	<span class="n">limit32</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">limit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">!=</span> <span class="n">limit32</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* update stats */</span>
	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">target</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">VMWARE_BALLOON_CMD</span><span class="p">(</span><span class="n">GET_TARGET</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmballoon_check_status</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">new_target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s - failed, hv returns %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">target_fail</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Notify the host about allocated page so that host can use it without</span>
<span class="cm"> * fear that guest will need it. Host may reject some pages, we need to</span>
<span class="cm"> * check the return value and maybe submit a different page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmballoon_send_lock_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hv_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">,</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pfn32</span><span class="p">;</span>

	<span class="n">pfn32</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">pfn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfn32</span> <span class="o">!=</span> <span class="n">pfn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="o">*</span><span class="n">hv_status</span> <span class="o">=</span> <span class="n">status</span> <span class="o">=</span> <span class="n">VMWARE_BALLOON_CMD</span><span class="p">(</span><span class="n">LOCK</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">dummy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmballoon_check_status</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s - ppn %lx, hv returns %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">lock_fail</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Notify the host that guest intends to release given page back into</span>
<span class="cm"> * the pool of available (to the guest) pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">vmballoon_send_unlock_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">,</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pfn32</span><span class="p">;</span>

	<span class="n">pfn32</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">pfn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfn32</span> <span class="o">!=</span> <span class="n">pfn</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">unlock</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">VMWARE_BALLOON_CMD</span><span class="p">(</span><span class="n">UNLOCK</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">dummy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmballoon_check_status</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s - ppn %lx, hv returns %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">unlock_fail</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Quickly release all pages allocated for the balloon. This function is</span>
<span class="cm"> * called when host decides to &quot;reset&quot; balloon for one reason or another.</span>
<span class="cm"> * Unlike normal &quot;deflate&quot; we do not (shall not) notify host of the pages</span>
<span class="cm"> * being released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmballoon_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">free</span><span class="p">);</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_free</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform standard reset sequence by popping the balloon (in case it</span>
<span class="cm"> * is not  empty) and then restarting protocol. This operation normally</span>
<span class="cm"> * happens when host responds with VMW_BALLOON_ERROR_RESET to a command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmballoon_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* free all pages, skipping monitor unlock */</span>
	<span class="n">vmballoon_pop</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmballoon_send_start</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">reset_required</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmballoon_send_guest_id</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed to send guest ID to the host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate (or reserve) a page for the balloon and notify the host.  If host</span>
<span class="cm"> * refuses the page put it on &quot;refuse&quot; list and allocate another one until host</span>
<span class="cm"> * is satisfied. &quot;Refused&quot; pages are released at the end of inflation cycle</span>
<span class="cm"> * (when we allocate b-&gt;rate_alloc pages).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmballoon_reserve_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">bool</span> <span class="n">can_sleep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hv_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">locked</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">can_sleep</span> <span class="o">?</span> <span class="n">VMW_PAGE_ALLOC_CANSLEEP</span> <span class="o">:</span> <span class="n">VMW_PAGE_ALLOC_NOSLEEP</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_sleep</span><span class="p">)</span>
			<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">alloc</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sleep_alloc</span><span class="p">);</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_sleep</span><span class="p">)</span>
				<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">alloc_fail</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sleep_alloc_fail</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* inform monitor */</span>
		<span class="n">locked</span> <span class="o">=</span> <span class="n">vmballoon_send_lock_page</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">hv_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">locked</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">refused_alloc</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">hv_status</span> <span class="o">==</span> <span class="n">VMW_BALLOON_ERROR_RESET</span> <span class="o">||</span>
			    <span class="n">hv_status</span> <span class="o">==</span> <span class="n">VMW_BALLOON_ERROR_PPN_NOTNEEDED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Place page on the list of non-balloonable pages</span>
<span class="cm">			 * and retry allocation, unless we already accumulated</span>
<span class="cm">			 * too many of them, in which case take a breather.</span>
<span class="cm">			 */</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refused_pages</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">n_refused_pages</span> <span class="o">&gt;=</span> <span class="n">VMW_BALLOON_MAX_REFUSED</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">locked</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* track allocated page */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>

	<span class="cm">/* update balloon size */</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release the page allocated for the balloon. Note that we first notify</span>
<span class="cm"> * the host so it can make sure the page will be available for the guest</span>
<span class="cm"> * to use, if needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmballoon_release_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmballoon_send_unlock_page</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>

	<span class="cm">/* deallocate page */</span>
	<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">free</span><span class="p">);</span>

	<span class="cm">/* update balloon size */</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release pages that were allocated while attempting to inflate the</span>
<span class="cm"> * balloon but were refused by the host for one reason or another.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmballoon_release_refused_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refused_pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">refused_free</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">b</span><span class="o">-&gt;</span><span class="n">n_refused_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Inflate the balloon towards its target size. Note that we try to limit</span>
<span class="cm"> * the rate of allocation to make sure we are not choking the rest of the</span>
<span class="cm"> * system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmballoon_inflate</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">goal</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">allocations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">alloc_can_sleep</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s - size: %d, target %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * First try NOSLEEP page allocations to inflate balloon.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we do not throttle nosleep allocations, we can drain all</span>
<span class="cm">	 * free pages in the guest quickly (if the balloon target is high).</span>
<span class="cm">	 * As a side-effect, draining free pages helps to inform (force)</span>
<span class="cm">	 * the guest to start swapping if balloon target is not met yet,</span>
<span class="cm">	 * which is a desired behavior. However, balloon driver can consume</span>
<span class="cm">	 * all available CPU cycles if too many pages are allocated in a</span>
<span class="cm">	 * second. Therefore, we throttle nosleep allocations even when</span>
<span class="cm">	 * the guest is not under memory pressure. OTOH, if we have already</span>
<span class="cm">	 * predicted that the guest is under memory pressure, then we</span>
<span class="cm">	 * slowdown page allocations considerably.</span>
<span class="cm">	 */</span>

	<span class="n">goal</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Start with no sleep allocation rate which may be higher</span>
<span class="cm">	 * than sleeping allocation rate.</span>
<span class="cm">	 */</span>
	<span class="n">rate</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">slow_allocation_cycles</span> <span class="o">?</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span> <span class="o">:</span> <span class="n">VMW_BALLOON_NOSLEEP_ALLOC_MAX</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s - goal: %d, no-sleep rate: %d, sleep rate: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">goal</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">vmballoon_reserve_page</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">alloc_can_sleep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Not a page allocation failure, stop this</span>
<span class="cm">				 * cycle. Maybe we&#39;ll get new target from</span>
<span class="cm">				 * the host soon.</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">alloc_can_sleep</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * CANSLEEP page allocation failed, so guest</span>
<span class="cm">				 * is under severe memory pressure. Quickly</span>
<span class="cm">				 * decrease allocation rate.</span>
<span class="cm">				 */</span>
				<span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
						    <span class="n">VMW_BALLOON_RATE_ALLOC_MIN</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * NOSLEEP page allocation failed, so the guest is</span>
<span class="cm">			 * under memory pressure. Let us slow down page</span>
<span class="cm">			 * allocations for next few cycles so that the guest</span>
<span class="cm">			 * gets out of memory pressure. Also, if we already</span>
<span class="cm">			 * allocated b-&gt;rate_alloc pages, let&#39;s pause,</span>
<span class="cm">			 * otherwise switch to sleeping allocations.</span>
<span class="cm">			 */</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">slow_allocation_cycles</span> <span class="o">=</span> <span class="n">VMW_BALLOON_SLOW_CYCLES</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">alloc_can_sleep</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="cm">/* Lower rate for sleeping allocations. */</span>
			<span class="n">rate</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">allocations</span> <span class="o">&gt;</span> <span class="n">VMW_BALLOON_YIELD_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">allocations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We allocated enough pages, let&#39;s take a break. */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We reached our goal without failures so try increasing</span>
<span class="cm">	 * allocation rate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mult</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span><span class="p">;</span>

		<span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span> <span class="o">=</span>
			<span class="n">min</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span> <span class="o">+</span> <span class="n">mult</span> <span class="o">*</span> <span class="n">VMW_BALLOON_RATE_ALLOC_INC</span><span class="p">,</span>
			    <span class="n">VMW_BALLOON_RATE_ALLOC_MAX</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vmballoon_release_refused_pages</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decrease the size of the balloon allowing guest to use more memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmballoon_deflate</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">goal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s - size: %d, target %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">);</span>

	<span class="cm">/* limit deallocation rate */</span>
	<span class="n">goal</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_free</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s - goal: %d, rate: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_free</span><span class="p">);</span>

	<span class="cm">/* free pages to reach target */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vmballoon_release_page</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* quickly decrease rate in case of error */</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_free</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_free</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
					   <span class="n">VMW_BALLOON_RATE_FREE_MIN</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">goal</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* slowly increase rate if there were no errors */</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_free</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_free</span> <span class="o">+</span> <span class="n">VMW_BALLOON_RATE_FREE_INC</span><span class="p">,</span>
			   <span class="n">VMW_BALLOON_RATE_FREE_MAX</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Balloon work function: reset protocol, if needed, get the new size and</span>
<span class="cm"> * adjust balloon as needed. Repeat in 1 sec.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmballoon_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span> <span class="o">=</span> <span class="n">to_delayed_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dwork</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmballoon</span><span class="p">,</span> <span class="n">dwork</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target</span><span class="p">;</span>

	<span class="n">STATS_INC</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">reset_required</span><span class="p">)</span>
		<span class="n">vmballoon_reset</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">slow_allocation_cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">slow_allocation_cycles</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmballoon_send_get_target</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* update target, adjust size */</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span>
			<span class="n">vmballoon_inflate</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
			<span class="n">vmballoon_deflate</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are using a freezable workqueue so that balloon operations are</span>
<span class="cm">	 * stopped while the system transitions to/from sleep/hibernation.</span>
<span class="cm">	 */</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_freezable_wq</span><span class="p">,</span>
			   <span class="n">dwork</span><span class="p">,</span> <span class="n">round_jiffies_relative</span><span class="p">(</span><span class="n">HZ</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * DEBUGFS Interface</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_DEBUG_FS</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmballoon_debug_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmballoon_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="cm">/* format size info */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span>
		   <span class="s">&quot;target:             %8d pages</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;current:            %8d pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">b</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/* format rate info */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span>
		   <span class="s">&quot;rateNoSleepAlloc:   %8d pages/sec</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;rateSleepAlloc:     %8d pages/sec</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;rateFree:           %8d pages/sec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">VMW_BALLOON_NOSLEEP_ALLOC_MAX</span><span class="p">,</span>
		   <span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_alloc</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rate_free</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span>
		   <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;timer:              %8u</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;start:              %8u (%4u failed)</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;guestType:          %8u (%4u failed)</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;lock:               %8u (%4u failed)</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;unlock:             %8u (%4u failed)</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;target:             %8u (%4u failed)</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;primNoSleepAlloc:   %8u (%4u failed)</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;primCanSleepAlloc:  %8u (%4u failed)</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;primFree:           %8u</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;errAlloc:           %8u</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;errFree:            %8u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">start_fail</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">guest_type</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">guest_type_fail</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>  <span class="n">stats</span><span class="o">-&gt;</span><span class="n">lock_fail</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">unlock_fail</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">target_fail</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">alloc_fail</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">sleep_alloc</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">sleep_alloc_fail</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">refused_alloc</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">refused_free</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmballoon_debug_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">vmballoon_debug_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">vmballoon_debug_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">vmballoon_debug_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">vmballoon_debugfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">b</span><span class="o">-&gt;</span><span class="n">dbg_entry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;vmmemctl&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">vmballoon_debug_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dbg_entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dbg_entry</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed to create debugfs entry, error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">vmballoon_debugfs_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dbg_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vmballoon_debugfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vmballoon_debugfs_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmballoon</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_DEBUG_FS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">vmballoon_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we are running on VMware&#39;s hypervisor and bail out</span>
<span class="cm">	 * if we are not.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x86_hyper</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">x86_hyper_vmware</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balloon</span><span class="p">.</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balloon</span><span class="p">.</span><span class="n">refused_pages</span><span class="p">);</span>

	<span class="cm">/* initialize rates */</span>
	<span class="n">balloon</span><span class="p">.</span><span class="n">rate_alloc</span> <span class="o">=</span> <span class="n">VMW_BALLOON_RATE_ALLOC_MAX</span><span class="p">;</span>
	<span class="n">balloon</span><span class="p">.</span><span class="n">rate_free</span> <span class="o">=</span> <span class="n">VMW_BALLOON_RATE_FREE_MAX</span><span class="p">;</span>

	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balloon</span><span class="p">.</span><span class="n">dwork</span><span class="p">,</span> <span class="n">vmballoon_work</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start balloon.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmballoon_send_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balloon</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed to send start command to the host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmballoon_send_guest_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balloon</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed to send guest ID to the host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">vmballoon_debugfs_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balloon</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_freezable_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">balloon</span><span class="p">.</span><span class="n">dwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">vmballoon_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">vmballoon_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balloon</span><span class="p">.</span><span class="n">dwork</span><span class="p">);</span>

	<span class="n">vmballoon_debugfs_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balloon</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Deallocate all reserved memory, and reset connection with monitor.</span>
<span class="cm">	 * Reset connection before deallocating memory to avoid potential for</span>
<span class="cm">	 * additional spurious resets from guest touching deallocated pages.</span>
<span class="cm">	 */</span>
	<span class="n">vmballoon_send_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balloon</span><span class="p">);</span>
	<span class="n">vmballoon_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balloon</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">vmballoon_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
