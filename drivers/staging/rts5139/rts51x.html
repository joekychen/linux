<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › rts5139 › rts51x.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>rts51x.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Driver for Realtek RTS51xx USB card reader</span>
<span class="cm"> * Header file</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2009 Realtek Semiconductor Corp. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * Author:</span>
<span class="cm"> *   wwang (wei_wang@realsil.com.cn)</span>
<span class="cm"> *   No. 450, Shenhu Road, Suzhou Industry Park, Suzhou, China</span>
<span class="cm"> * Maintainer:</span>
<span class="cm"> *   Edwin Rong (edwin_rong@realsil.com.cn)</span>
<span class="cm"> *   No. 450, Shenhu Road, Suzhou Industry Park, Suzhou, China</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __RTS51X_H</span>
<span class="cp">#define __RTS51X_H</span>

<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb_usual.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/cdrom.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_devinfo.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>

<span class="cp">#define DRIVER_VERSION		&quot;v1.04&quot;</span>

<span class="cp">#define RTS51X_DESC		&quot;Realtek RTS5139/29 USB card reader driver&quot;</span>
<span class="cp">#define RTS51X_NAME		&quot;rts5139&quot;</span>
<span class="cp">#define RTS51X_CTL_THREAD	&quot;rts5139-control&quot;</span>
<span class="cp">#define RTS51X_POLLING_THREAD	&quot;rts5139-polling&quot;</span>

<span class="cp">#define POLLING_IN_THREAD</span>
<span class="cp">#define SUPPORT_FILE_OP</span>

<span class="cp">#define wait_timeout_x(task_state, msecs)	\</span>
<span class="cp">do {						\</span>
<span class="cp">	set_current_state((task_state));	\</span>
<span class="cp">	schedule_timeout((msecs) * HZ / 1000);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define wait_timeout(msecs)	wait_timeout_x(TASK_INTERRUPTIBLE, (msecs))</span>

<span class="cp">#define SCSI_LUN(srb)		((srb)-&gt;device-&gt;lun)</span>

<span class="cm">/* Size of the DMA-mapped I/O buffer */</span>
<span class="cp">#define RTS51X_IOBUF_SIZE	1024</span>

<span class="cm">/* Dynamic bitflag definitions (dflags): used in set_bit() etc. */</span>
<span class="cp">#define FLIDX_URB_ACTIVE	0	</span><span class="cm">/* current_urb is in use    */</span><span class="cp"></span>
<span class="cp">#define FLIDX_SG_ACTIVE		1	</span><span class="cm">/* current_sg is in use     */</span><span class="cp"></span>
<span class="cp">#define FLIDX_ABORTING		2	</span><span class="cm">/* abort is in progress     */</span><span class="cp"></span>
<span class="cp">#define FLIDX_DISCONNECTING	3	</span><span class="cm">/* disconnect in progress   */</span><span class="cp"></span>
<span class="cp">#define FLIDX_RESETTING		4	</span><span class="cm">/* device reset in progress */</span><span class="cp"></span>
<span class="cp">#define FLIDX_TIMED_OUT		5	</span><span class="cm">/* SCSI midlayer timed out  */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">rts51x_chip</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">rts51x_usb</span> <span class="p">{</span>
	<span class="cm">/* The device we&#39;re working with</span>
<span class="cm">	 * It&#39;s important to note:</span>
<span class="cm">	 *    (o) you must hold dev_mutex to change pusb_dev</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">dev_mutex</span><span class="p">;</span>	<span class="cm">/* protect pusb_dev */</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">pusb_dev</span><span class="p">;</span>	<span class="cm">/* this usb_device */</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">pusb_intf</span><span class="p">;</span>	<span class="cm">/* this interface */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dflags</span><span class="p">;</span>	<span class="cm">/* dynamic atomic bitflags */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">send_bulk_pipe</span><span class="p">;</span>	<span class="cm">/* cached pipe values */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">recv_bulk_pipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">send_ctrl_pipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">recv_ctrl_pipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">recv_intr_pipe</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">ifnum</span><span class="p">;</span>		<span class="cm">/* interface number   */</span>
	<span class="n">u8</span> <span class="n">ep_bInterval</span><span class="p">;</span>	<span class="cm">/* interrupt interval */</span>

	<span class="cm">/* control and bulk communications data */</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">current_urb</span><span class="p">;</span>	<span class="cm">/* USB requests         */</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">intr_urb</span><span class="p">;</span>	<span class="cm">/* Interrupt USB request */</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">cr</span><span class="p">;</span>	<span class="cm">/* control requests     */</span>
	<span class="k">struct</span> <span class="n">usb_sg_request</span> <span class="n">current_sg</span><span class="p">;</span>	<span class="cm">/* scatter-gather req.  */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">iobuf</span><span class="p">;</span>	<span class="cm">/* I/O buffer           */</span>
	<span class="n">dma_addr_t</span> <span class="n">cr_dma</span><span class="p">;</span>	<span class="cm">/* buffer DMA addresses */</span>
	<span class="n">dma_addr_t</span> <span class="n">iobuf_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ctl_thread</span><span class="p">;</span>	<span class="cm">/* the control thread   */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">polling_thread</span><span class="p">;</span>	<span class="cm">/* the polling thread   */</span>

	<span class="cm">/* mutual exclusion and synchronization structures */</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">cmnd_ready</span><span class="p">;</span>	<span class="cm">/* to sleep thread on      */</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">control_exit</span><span class="p">;</span>	<span class="cm">/* control thread exit     */</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">polling_exit</span><span class="p">;</span>	<span class="cm">/* polling thread exit     */</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">notify</span><span class="p">;</span>	<span class="cm">/* thread begin/end        */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">rts51x_driver</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_current_time</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">timeval_buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buf_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeval_buf</span> <span class="o">||</span> <span class="p">(</span><span class="n">buf_len</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>

	<span class="n">timeval_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="n">timeval_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">timeval_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">timeval_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">timeval_buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="n">timeval_buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">timeval_buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">timeval_buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SND_CTRL_PIPE(chip)	((chip)-&gt;usb-&gt;send_ctrl_pipe)</span>
<span class="cp">#define RCV_CTRL_PIPE(chip)	((chip)-&gt;usb-&gt;recv_ctrl_pipe)</span>
<span class="cp">#define SND_BULK_PIPE(chip)	((chip)-&gt;usb-&gt;send_bulk_pipe)</span>
<span class="cp">#define RCV_BULK_PIPE(chip)	((chip)-&gt;usb-&gt;recv_bulk_pipe)</span>
<span class="cp">#define RCV_INTR_PIPE(chip)	((chip)-&gt;usb-&gt;recv_intr_pipe)</span>

<span class="cm">/* The scsi_lock() and scsi_unlock() macros protect the sm_state and the</span>
<span class="cm"> * single queue element srb for write access */</span>
<span class="cp">#define scsi_unlock(host)	spin_unlock_irq(host-&gt;host_lock)</span>
<span class="cp">#define scsi_lock(host)		spin_lock_irq(host-&gt;host_lock)</span>

<span class="cp">#define GET_PM_USAGE_CNT(chip)	\</span>
<span class="cp">	atomic_read(&amp;((chip)-&gt;usb-&gt;pusb_intf-&gt;pm_usage_cnt))</span>
<span class="cp">#define SET_PM_USAGE_CNT(chip, cnt)	\</span>
<span class="cp">	atomic_set(&amp;((chip)-&gt;usb-&gt;pusb_intf-&gt;pm_usage_cnt), (cnt))</span>

<span class="cm">/* Compatible macros while we switch over */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">usb_buffer_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				     <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_buffer_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Convert between us_data and the corresponding Scsi_Host */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="nf">rts51x_to_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span><span class="p">,</span> <span class="n">hostdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="nf">host_to_rts51x</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="p">)(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* struct scsi_cmnd transfer buffer access utilities */</span>
<span class="k">enum</span> <span class="n">xfer_buf_dir</span> <span class="p">{</span> <span class="n">TO_XFER_BUF</span><span class="p">,</span> <span class="n">FROM_XFER_BUF</span> <span class="p">};</span>

<span class="cm">/* General routines provided by the usb-storage standard core */</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">void</span> <span class="n">rts51x_try_to_exit_ss</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rts51x_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rts51x_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rts51x_reset_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define rts51x_suspend		NULL</span>
<span class="cp">#define rts51x_resume		NULL</span>
<span class="cp">#define rts51x_reset_resume	NULL</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">rts51x_host_template</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __RTS51X_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
oid</span> <span class="nf">rts51x_try_to_enter_ss</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rts51x_try_to_exit_ss</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The next two routines get called just before and just after</span>
<span class="cm"> * a USB port reset, whether from this driver or a different one.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">rts51x_pre_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>

	<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Make sure no command runs during the reset */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">rts51x_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>

	<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Report the reset to the SCSI core */</span>
	<span class="cm">/* usb_stor_report_bus_reset(us); */</span>

	<span class="cm">/* FIXME: Notify the subdrivers that they need to reinitialize</span>
<span class="cm">	 * the device */</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rts51x_control_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="p">)</span><span class="n">__chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">rts51x_to_host</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_completion_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">cmnd_ready</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- exiting from rts51x-control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* lock the device pointers */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">));</span>

		<span class="cm">/* lock access to the state */</span>
		<span class="n">scsi_lock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

		<span class="cm">/* When we are called with no command pending, we&#39;re done */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
			<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- exiting from control thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* has the command timed out *already* ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLIDX_TIMED_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">SkipForAbort</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

		<span class="cm">/* reject the command if the direction indicator</span>
<span class="cm">		 * is UNKNOWN</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;UNKNOWN data direction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* reject if target != 0 or if LUN is higher than</span>
<span class="cm">		 * the maximum known LUN</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bad target number (%d:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
				       <span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&gt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bad LUN (%d:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
				       <span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we&#39;ve got a command, let&#39;s do it! */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">RTS51X_DEBUG</span><span class="p">(</span><span class="n">scsi_show_command</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">));</span>
			<span class="n">rts51x_invoke_transport</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* lock access to the state */</span>
		<span class="n">scsi_lock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

		<span class="cm">/* indicate that the command is done */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">!=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">);</span>
		<span class="k">else</span>
<span class="n">SkipForAbort</span> <span class="o">:</span>
			<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;scsi command aborted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* If an abort request was received we need to signal that</span>
<span class="cm">		 * the abort has finished.  The proper test for this is</span>
<span class="cm">		 * the TIMED_OUT flag, not srb-&gt;result == DID_ABORT, because</span>
<span class="cm">		 * the timeout might have occurred after the command had</span>
<span class="cm">		 * already completed with a different result code. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLIDX_TIMED_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">));</span>

			<span class="cm">/* Allow USB transfers to resume */</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLIDX_ABORTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLIDX_TIMED_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* finished working on this command */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">srb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

		<span class="cm">/* unlock the device pointers */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="p">}</span>			<span class="cm">/* for (;;) */</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">control_exit</span><span class="p">);</span>

	<span class="cm">/* Wait until we are told to stop */</span>
<span class="cm">/*	for (;;) {</span>
<span class="cm">		set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="cm">		if (kthread_should_stop())</span>
<span class="cm">			break;</span>
<span class="cm">		schedule();</span>
<span class="cm">	}</span>
<span class="cm">	__set_current_state(TASK_RUNNING);*/</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rts51x_polling_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="p">)</span><span class="n">__chip</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">wait_timeout</span><span class="p">(</span><span class="n">POLLING_INTERVAL</span><span class="p">);</span>

		<span class="cm">/* if the device has disconnected, we are free to exit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- exiting from rts51x-polling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* if the device has disconnected, we are free to exit */</span>
		<span class="cm">/* if (kthread_should_stop()) {</span>
<span class="cm">			printk(KERN_INFO &quot;Stop polling thread!\n&quot;);</span>
<span class="cm">			break;</span>
<span class="cm">		} */</span>

<span class="cp">#ifdef CONFIG_PM</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RTS51X_CHK_STAT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STAT_SS</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">RTS51X_CHK_STAT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STAT_SS_PRE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">RTS51X_CHK_STAT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STAT_SUSPEND</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ss_en</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">RTS51X_CHK_STAT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STAT_IDLE</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ss_counter</span> <span class="o">&lt;</span>
				    <span class="p">(</span><span class="n">ss_delay</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">POLLING_INTERVAL</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ss_counter</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* Prepare SS state */</span>
					<span class="n">RTS51X_SET_STAT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STAT_SS_PRE</span><span class="p">);</span>
					<span class="n">rts51x_try_to_enter_ss</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ss_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

		<span class="n">mspro_polling_format_status</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

		<span class="cm">/* lock the device pointers */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">));</span>

		<span class="n">rts51x_polling_func</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

		<span class="cm">/* unlock the device pointers */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="p">}</span>			<span class="cm">/* for (;;) */</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">polling_exit</span><span class="p">);</span>

	<span class="cm">/* Wait until we are told to stop */</span>
	<span class="cm">/* for (;;) {</span>
<span class="cm">		set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="cm">		if (kthread_should_stop())</span>
<span class="cm">		break;</span>
<span class="cm">		schedule();</span>
<span class="cm">		}</span>
<span class="cm">	__set_current_state(TASK_RUNNING); */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Associate our private data with the USB device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">associate_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_usb</span> <span class="o">*</span><span class="n">rts51x</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">;</span>
<span class="cp">#ifdef SUPPORT_FILE_OP</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Fill in the device-related fields */</span>
	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_intf</span> <span class="o">=</span> <span class="n">intf</span><span class="p">;</span>
	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">ifnum</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>
	<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;Vendor: 0x%04x, Product: 0x%04x, Revision: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
		       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">),</span>
		       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">));</span>
	<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;Interface Subclass: 0x%02x, Protocol: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceSubClass</span><span class="p">,</span>
		       <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span><span class="p">);</span>

	<span class="cm">/* Store our private data in the interface */</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>

<span class="cp">#ifdef SUPPORT_FILE_OP</span>
	<span class="cm">/* we can register the device now, as it is ready */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_register_dev</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rts51x_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* something prevented us from registering this driver */</span>
		<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;Not able to get a minor for this device.&quot;</span><span class="p">);</span>
		<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Allocate the device-related DMA-mapped buffers */</span>
	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">usb_buffer_alloc</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">),</span>
				      <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">cr_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;usb_ctrlrequest allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">iobuf</span> <span class="o">=</span> <span class="n">usb_buffer_alloc</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">RTS51X_IOBUF_SIZE</span><span class="p">,</span>
					 <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">iobuf_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;I/O buffer allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rts51x_init_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_option</span> <span class="o">*</span><span class="n">option</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">option</span><span class="p">);</span>

	<span class="n">option</span><span class="o">-&gt;</span><span class="n">mspro_formatter_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">option</span><span class="o">-&gt;</span><span class="n">fpga_sd_sdr104_clk</span> <span class="o">=</span> <span class="n">CLK_100</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">fpga_sd_sdr50_clk</span> <span class="o">=</span> <span class="n">CLK_100</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">fpga_sd_ddr50_clk</span> <span class="o">=</span> <span class="n">CLK_100</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">fpga_sd_hs_clk</span> <span class="o">=</span> <span class="n">CLK_100</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">fpga_mmc_52m_clk</span> <span class="o">=</span> <span class="n">CLK_80</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">fpga_ms_hg_clk</span> <span class="o">=</span> <span class="n">CLK_80</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">fpga_ms_4bit_clk</span> <span class="o">=</span> <span class="n">CLK_80</span><span class="p">;</span>

	<span class="n">option</span><span class="o">-&gt;</span><span class="n">asic_sd_sdr104_clk</span> <span class="o">=</span> <span class="mi">98</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">asic_sd_sdr50_clk</span> <span class="o">=</span> <span class="mi">98</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">asic_sd_ddr50_clk</span> <span class="o">=</span> <span class="mi">98</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">asic_sd_hs_clk</span> <span class="o">=</span> <span class="mi">97</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">asic_mmc_52m_clk</span> <span class="o">=</span> <span class="mi">95</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">asic_ms_hg_clk</span> <span class="o">=</span> <span class="mi">116</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">asic_ms_4bit_clk</span> <span class="o">=</span> <span class="mi">77</span><span class="p">;</span>

	<span class="n">option</span><span class="o">-&gt;</span><span class="n">sd_ddr_tx_phase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">mmc_ddr_tx_phase</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">option</span><span class="o">-&gt;</span><span class="n">sd_speed_prior</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">sd_ctl</span> <span class="o">=</span>
	    <span class="n">SD_PUSH_POINT_AUTO</span> <span class="o">|</span> <span class="n">SD_SAMPLE_POINT_AUTO</span> <span class="o">|</span> <span class="n">SUPPORT_UHS50_MMC44</span><span class="p">;</span>

	<span class="n">option</span><span class="o">-&gt;</span><span class="n">ss_en</span> <span class="o">=</span> <span class="n">ss_en</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">ss_delay</span> <span class="o">=</span> <span class="n">ss_delay</span><span class="p">;</span>

	<span class="n">option</span><span class="o">-&gt;</span><span class="n">auto_delink_en</span> <span class="o">=</span> <span class="n">auto_delink_en</span><span class="p">;</span>

	<span class="n">option</span><span class="o">-&gt;</span><span class="n">FT2_fast_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">pwr_delay</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">xd_rw_step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">D3318_off_delay</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">delink_delay</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">rts5129_D3318_off_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">sd20_pad_drive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">reset_or_rw_fail_set_pad_drive</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">debounce_num</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">led_toggle_interval</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">xd_rwn_step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">sd_send_status_en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">sdr50_tx_phase</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">sdr50_rx_phase</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">ddr50_tx_phase</span> <span class="o">=</span> <span class="mh">0x09</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">ddr50_rx_phase</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">sdr50_phase_sel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">sd30_pad_drive</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">ms_errreg_fix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">reset_mmc_first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">speed_mmc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">option</span><span class="o">-&gt;</span><span class="n">led_always_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the pipe settings */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_pipes</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_usb</span> <span class="o">*</span><span class="n">rts51x</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">altsetting</span> <span class="o">=</span>
	    <span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep_in</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep_out</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep_int</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the first endpoint of each type we need.</span>
<span class="cm">	 * We are expecting a minimum of 2 endpoints - in and out (bulk).</span>
<span class="cm">	 * An optional interrupt-in is OK (necessary for CBI protocol).</span>
<span class="cm">	 * We will ignore any others.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_bulk</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_in</span><span class="p">)</span>
					<span class="n">ep_in</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_out</span><span class="p">)</span>
					<span class="n">ep_out</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_is_int_in</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_int</span><span class="p">)</span>
				<span class="n">ep_int</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_in</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;Endpoint sanity check failed!&quot;</span>
					<span class="s">&quot;Rejecting dev.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate and store the pipe values */</span>
	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span> <span class="o">=</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">recv_ctrl_pipe</span> <span class="o">=</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span> <span class="o">=</span> <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span>
						 <span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">ep_out</span><span class="p">));</span>
	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span> <span class="o">=</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span>
						 <span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">ep_in</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_int</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">recv_intr_pipe</span> <span class="o">=</span> <span class="n">usb_rcvintpipe</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span>
							<span class="n">usb_endpoint_num</span>
							<span class="p">(</span><span class="n">ep_int</span><span class="p">));</span>
		<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">ep_bInterval</span> <span class="o">=</span> <span class="n">ep_int</span><span class="o">-&gt;</span><span class="n">bInterval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize all the dynamic resources we need */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rts51x_acquire_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_usb</span> <span class="o">*</span><span class="n">rts51x</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">current_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;URB allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">intr_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">intr_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;URB allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmd_buf</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rsp_buf</span> <span class="o">=</span> <span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="n">rts51x_init_options</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* Init rts51xx device */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">rts51x_init_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">STATUS_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Release all our dynamic resources */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rts51x_release_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Tell the control thread to exit.  The SCSI host must</span>
<span class="cm">	 * already have been removed and the DISCONNECTING flag set</span>
<span class="cm">	 * so that we won&#39;t accept any more commands.</span>
<span class="cm">	 */</span>
	<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- sending exit command to thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">cmnd_ready</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">ctl_thread</span><span class="p">)</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">control_exit</span><span class="p">);</span>
		<span class="cm">/* kthread_stop(chip-&gt;usb-&gt;ctl_thread); */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">polling_thread</span><span class="p">)</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">polling_exit</span><span class="p">);</span>

	<span class="cm">/* if (chip-&gt;usb-&gt;polling_thread)</span>
<span class="cm">		kthread_stop(chip-&gt;usb-&gt;polling_thread); */</span>

	<span class="n">wait_timeout</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

	<span class="cm">/* Release rts51xx device here */</span>
	<span class="n">rts51x_release_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">intr_urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Dissociate from the USB device */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dissociate_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_usb</span> <span class="o">*</span><span class="n">rts51x</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">;</span>

	<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Free the device-related DMA-mapped buffers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">)</span>
		<span class="n">usb_buffer_free</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">),</span>
				<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">,</span> <span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">cr_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">)</span>
		<span class="n">usb_buffer_free</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">RTS51X_IOBUF_SIZE</span><span class="p">,</span>
				<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">,</span> <span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">iobuf_dma</span><span class="p">);</span>

	<span class="cm">/* Remove our private data from the interface */</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cp">#ifdef SUPPORT_FILE_OP</span>
	<span class="cm">/* give back our minor */</span>
	<span class="n">usb_deregister_dev</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rts51x_class</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rts51x</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* First stage of disconnect processing: stop SCSI scanning,</span>
<span class="cm"> * remove the host, and stop accepting new commands</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quiesce_and_remove_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_usb</span> <span class="o">*</span><span class="n">rts51x</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">rts51x_to_host</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* If the device is really gone, cut short reset delays */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>

	<span class="cm">/* Removing the host will perform an orderly shutdown: caches</span>
<span class="cm">	 * synchronized, disks spun down, etc.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* Prevent any new commands from being accepted and cut short</span>
<span class="cm">	 * reset delays.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_lock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
	<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Second stage of disconnect processing: deallocate all resources */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_everything</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rts51x_release_resources</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">dissociate_dev</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* Drop our reference to the host; the SCSI core will free it</span>
<span class="cm">	 * (and &quot;chip&quot; along with it) when the refcount becomes 0. */</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">rts51x_to_host</span><span class="p">(</span><span class="n">chip</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rts51x_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rts51x_usb</span> <span class="o">*</span><span class="n">rts51x</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>

	<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">RTS51X_NAME</span><span class="p">);</span>

	<span class="n">rts51x</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_usb</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rts51x</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">RTS51X_TIP</span>
		       <span class="s">&quot;Unable to allocate rts51x_usb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ask the SCSI layer to allocate a host structure, with extra</span>
<span class="cm">	 * space at the end for our private us_data structure.</span>
<span class="cm">	 */</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rts51x_host_template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chip</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">RTS51X_TIP</span>
		       <span class="s">&quot;Unable to allocate the scsi host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rts51x</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow 16-byte CDBs and thus &gt; 2TB</span>
<span class="cm">	 */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">host_to_rts51x</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span><span class="p">));</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">idVendor</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">product_id</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">idProduct</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">));</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">cmnd_ready</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">control_exit</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">polling_exit</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">));</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span> <span class="o">=</span> <span class="n">rts51x</span><span class="p">;</span>

	<span class="cm">/* Associate the us_data structure with the USB device */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">associate_dev</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">intf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>

	<span class="cm">/* Find the endpoints and calculate pipe values */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">get_pipes</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>

	<span class="cm">/* Acquire all the other resources and add the host */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">rts51x_acquire_resources</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>

	<span class="cm">/* Start up our control thread */</span>
	<span class="n">th</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rts51x_control_thread</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">RTS51X_CTL_THREAD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">th</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">RTS51X_TIP</span>
		       <span class="s">&quot;Unable to start control thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">ctl_thread</span> <span class="o">=</span> <span class="n">th</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">rts51x_to_host</span><span class="p">(</span><span class="n">chip</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">RTS51X_TIP</span> <span class="s">&quot;Unable to add the scsi host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">rts51x_to_host</span><span class="p">(</span><span class="n">chip</span><span class="p">));</span>

	<span class="cm">/* Start up our polling thread */</span>
	<span class="n">th</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rts51x_polling_thread</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">RTS51X_POLLING_THREAD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">th</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">RTS51X_TIP</span>
		       <span class="s">&quot;Unable to start polling thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">polling_thread</span> <span class="o">=</span> <span class="n">th</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss_en</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rts51x</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="o">-&gt;</span><span class="n">needs_remote_wakeup</span> <span class="o">=</span> <span class="n">needs_remote_wakeup</span><span class="p">;</span>
		<span class="n">SET_PM_USAGE_CNT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;pm_usage_cnt = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GET_PM_USAGE_CNT</span><span class="p">(</span><span class="n">chip</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We come here if there are any problems */</span>
<span class="nl">BadDevice:</span>
	<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;rts51x_probe() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">release_everything</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rts51x_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rts51x_chip</span> <span class="o">*</span><span class="p">)</span><span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">RTS51X_DEBUGP</span><span class="p">(</span><span class="s">&quot;rts51x_disconnect() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">quiesce_and_remove_host</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">release_everything</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Initialization and registration</span>
<span class="cm"> ***********************************************************************/</span>

<span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">rts5139_usb_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0BDA</span><span class="p">,</span> <span class="mh">0x0139</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0BDA</span><span class="p">,</span> <span class="mh">0x0129</span><span class="p">)},</span>
	<span class="p">{}</span>			<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rts5139_usb_ids</span><span class="p">);</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">rts5139_usb_ids</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">rts51x_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">RTS51X_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">rts51x_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span> <span class="n">rts51x_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">rts51x_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">rts51x_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_resume</span> <span class="o">=</span> <span class="n">rts51x_reset_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_reset</span> <span class="o">=</span> <span class="n">rts51x_pre_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_reset</span> <span class="o">=</span> <span class="n">rts51x_post_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">rts5139_usb_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">soft_unbind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">rts51x_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
