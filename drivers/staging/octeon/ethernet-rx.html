<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › octeon › ethernet-rx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ethernet-rx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**********************************************************************</span>
<span class="cm"> * Author: Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * Contact: support@caviumnetworks.com</span>
<span class="cm"> * This file is part of the OCTEON SDK</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2010 Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * This file is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License, Version 2, as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is distributed in the hope that it will be useful, but</span>
<span class="cm"> * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or</span>
<span class="cm"> * NONINFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this file; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> * or visit http://www.gnu.org/licenses/.</span>
<span class="cm"> *</span>
<span class="cm"> * This file may also be available under a different license from Cavium.</span>
<span class="cm"> * Contact Cavium Networks for more information</span>
<span class="cm">**********************************************************************/</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;net/dst.h&gt;</span>
<span class="cp">#ifdef CONFIG_XFRM</span>
<span class="cp">#include &lt;linux/xfrm.h&gt;</span>
<span class="cp">#include &lt;net/xfrm.h&gt;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_XFRM */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#include &lt;asm/octeon/octeon.h&gt;</span>

<span class="cp">#include &quot;ethernet-defines.h&quot;</span>
<span class="cp">#include &quot;ethernet-mem.h&quot;</span>
<span class="cp">#include &quot;ethernet-rx.h&quot;</span>
<span class="cp">#include &quot;octeon-ethernet.h&quot;</span>
<span class="cp">#include &quot;ethernet-util.h&quot;</span>

<span class="cp">#include &lt;asm/octeon/cvmx-helper.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-wqe.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-fau.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-pow.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-pip.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-scratch.h&gt;</span>

<span class="cp">#include &lt;asm/octeon/cvmx-gmxx-defs.h&gt;</span>

<span class="k">struct</span> <span class="n">cvm_napi_wrapper</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cvm_napi_wrapper</span> <span class="n">cvm_oct_napi</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="n">__cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">cvm_oct_core_state</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">baseline_cores</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The number of additional cores that could be processing</span>
<span class="cm">	 * input packtes.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">available_cores</span><span class="p">;</span>
	<span class="n">cpumask_t</span> <span class="n">cpu_state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cvm_oct_core_state</span> <span class="n">core_state</span> <span class="n">__cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cvm_oct_enable_napi</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cvm_oct_napi</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cvm_oct_enable_one_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* Check to see if more CPUs are available for receive processing... */</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">atomic_sub_if_positive</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">core_state</span><span class="p">.</span><span class="n">available_cores</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* ... if a CPU is available, Turn on NAPI polling for that CPU.  */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_test_and_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">core_state</span><span class="p">.</span><span class="n">cpu_state</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cvm_oct_enable_napi</span><span class="p">,</span>
						     <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
				<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Can&#39;t enable NAPI.&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cvm_oct_no_more_work</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * CPU zero is special.  It always has the irq enabled when</span>
<span class="cm">	 * waiting for incoming packets.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">OCTEON_IRQ_WORKQ0</span> <span class="o">+</span> <span class="n">pow_receive_group</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cpu_clear</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">core_state</span><span class="p">.</span><span class="n">cpu_state</span><span class="p">);</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">core_state</span><span class="p">.</span><span class="n">available_cores</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cvm_oct_do_interrupt - interrupt handler.</span>
<span class="cm"> *</span>
<span class="cm"> * The interrupt occurs whenever the POW has packets in our group.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">cvm_oct_do_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable the IRQ and start napi_poll. */</span>
	<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">OCTEON_IRQ_WORKQ0</span> <span class="o">+</span> <span class="n">pow_receive_group</span><span class="p">);</span>
	<span class="n">cvm_oct_enable_napi</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cvm_oct_check_rcv_error - process receive errors</span>
<span class="cm"> * @work: Work queue entry pointing to the packet.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Non-zero if the packet can be dropped, zero otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cvm_oct_check_rcv_error</span><span class="p">(</span><span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">snoip</span><span class="p">.</span><span class="n">err_code</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ignore length errors on min size packets. Some</span>
<span class="cm">		 * equipment incorrectly pads packets to 64+4FCS</span>
<span class="cm">		 * instead of 60+4FCS.  Note these packets still get</span>
<span class="cm">		 * counted as frame errors.</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="k">else</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">USE_10MBPS_PREAMBLE_WORKAROUND</span>
		<span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">snoip</span><span class="p">.</span><span class="n">err_code</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">snoip</span><span class="p">.</span><span class="n">err_code</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * We received a packet with either an alignment error</span>
<span class="cm">		 * or a FCS error. This may be signalling that we are</span>
<span class="cm">		 * running 10Mbps with GMXX_RXX_FRM_CTL[PRE_CHK]</span>
<span class="cm">		 * off. If this is the case we need to parse the</span>
<span class="cm">		 * packet to determine if we can remove a non spec</span>
<span class="cm">		 * preamble and generate a correct packet.</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">interface</span> <span class="o">=</span> <span class="n">cvmx_helper_get_interface_num</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">cvmx_helper_get_interface_index_num</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span><span class="p">);</span>
		<span class="k">union</span> <span class="n">cvmx_gmxx_rxx_frm_ctl</span> <span class="n">gmxx_rxx_frm_ctl</span><span class="p">;</span>
		<span class="n">gmxx_rxx_frm_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span>
		    <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_GMXX_RXX_FRM_CTL</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">interface</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gmxx_rxx_frm_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pre_chk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span>
			    <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">packet_ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">!=</span> <span class="mh">0x55</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="mh">0xd5</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				  printk_ratelimited(&quot;Port %d received 0xd5 preamble\n&quot;, work-&gt;ipprt);</span>
<span class="cm">				 */</span>
				<span class="n">work</span><span class="o">-&gt;</span><span class="n">packet_ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">work</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xd</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				  printk_ratelimited(&quot;Port %d received 0x?d preamble\n&quot;, work-&gt;ipprt);</span>
<span class="cm">				 */</span>
				<span class="n">work</span><span class="o">-&gt;</span><span class="n">packet_ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">work</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span>
					    <span class="p">((</span><span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
					    <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
					<span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">printk_ratelimited</span><span class="p">(</span><span class="s">&quot;Port %d unknown preamble, packet &quot;</span>
						   <span class="s">&quot;dropped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						   <span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				   cvmx_helper_dump_packet(work);</span>
<span class="cm">				 */</span>
				<span class="n">cvm_oct_free_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="s">&quot;Port %d receive error code %d, packet dropped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span><span class="p">,</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">snoip</span><span class="p">.</span><span class="n">err_code</span><span class="p">);</span>
		<span class="n">cvm_oct_free_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cvm_oct_napi_poll - the NAPI poll function.</span>
<span class="cm"> * @napi: The NAPI instance, or null if called from cvm_oct_poll_controller</span>
<span class="cm"> * @budget: Maximum number of packets to receive.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of packets processed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cvm_oct_napi_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span>	<span class="n">coreid</span> <span class="o">=</span> <span class="n">cvmx_get_core_num</span><span class="p">();</span>
	<span class="kt">uint64_t</span>	<span class="n">old_group_mask</span><span class="p">;</span>
	<span class="kt">uint64_t</span>	<span class="n">old_scratch</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rx_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">did_work_request</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">packet_not_copied</span><span class="p">;</span>

	<span class="cm">/* Prefetch cvm_oct_device since we know we need it soon */</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="n">cvm_oct_device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">USE_ASYNC_IOBDMA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Save scratch in case userspace is using it */</span>
		<span class="n">CVMX_SYNCIOBDMA</span><span class="p">;</span>
		<span class="n">old_scratch</span> <span class="o">=</span> <span class="n">cvmx_scratch_read64</span><span class="p">(</span><span class="n">CVMX_SCR_SCRATCH</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Only allow work for our group (and preserve priorities) */</span>
	<span class="n">old_group_mask</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_POW_PP_GRP_MSKX</span><span class="p">(</span><span class="n">coreid</span><span class="p">));</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_POW_PP_GRP_MSKX</span><span class="p">(</span><span class="n">coreid</span><span class="p">),</span>
		       <span class="p">(</span><span class="n">old_group_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xFFFFull</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pow_receive_group</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">USE_ASYNC_IOBDMA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_pow_work_request_async</span><span class="p">(</span><span class="n">CVMX_SCR_SCRATCH</span><span class="p">,</span> <span class="n">CVMX_POW_NO_WAIT</span><span class="p">);</span>
		<span class="n">did_work_request</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rx_count</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">pskb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">skb_in_hw</span><span class="p">;</span>
		<span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">USE_ASYNC_IOBDMA</span> <span class="o">&amp;&amp;</span> <span class="n">did_work_request</span><span class="p">)</span>
			<span class="n">work</span> <span class="o">=</span> <span class="n">cvmx_pow_work_response_async</span><span class="p">(</span><span class="n">CVMX_SCR_SCRATCH</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">work</span> <span class="o">=</span> <span class="n">cvmx_pow_work_request_sync</span><span class="p">(</span><span class="n">CVMX_POW_NO_WAIT</span><span class="p">);</span>

		<span class="n">prefetch</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
		<span class="n">did_work_request</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">union</span> <span class="n">cvmx_pow_wq_int</span> <span class="n">wq_int</span><span class="p">;</span>
			<span class="n">wq_int</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">wq_int</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">iq_dis</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pow_receive_group</span><span class="p">;</span>
			<span class="n">wq_int</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">wq_int</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pow_receive_group</span><span class="p">;</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_POW_WQ_INT</span><span class="p">,</span> <span class="n">wq_int</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pskb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="p">)(</span><span class="n">cvm_oct_get_buffer_ptr</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">packet_ptr</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">pskb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">USE_ASYNC_IOBDMA</span> <span class="o">&amp;&amp;</span> <span class="n">rx_count</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">budget</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cvmx_pow_work_request_async_nocheck</span><span class="p">(</span><span class="n">CVMX_SCR_SCRATCH</span><span class="p">,</span> <span class="n">CVMX_POW_NO_WAIT</span><span class="p">);</span>
			<span class="n">did_work_request</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rx_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * First time through, see if there is enough</span>
<span class="cm">			 * work waiting to merit waking another</span>
<span class="cm">			 * CPU.</span>
<span class="cm">			 */</span>
			<span class="k">union</span> <span class="n">cvmx_pow_wq_int_cntx</span> <span class="n">counts</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">backlog</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">cores_in_use</span> <span class="o">=</span> <span class="n">core_state</span><span class="p">.</span><span class="n">baseline_cores</span> <span class="o">-</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_state</span><span class="p">.</span><span class="n">available_cores</span><span class="p">);</span>
			<span class="n">counts</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_POW_WQ_INT_CNTX</span><span class="p">(</span><span class="n">pow_receive_group</span><span class="p">));</span>
			<span class="n">backlog</span> <span class="o">=</span> <span class="n">counts</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">iq_cnt</span> <span class="o">+</span> <span class="n">counts</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ds_cnt</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">backlog</span> <span class="o">&gt;</span> <span class="n">budget</span> <span class="o">*</span> <span class="n">cores_in_use</span> <span class="o">&amp;&amp;</span> <span class="n">napi</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">cvm_oct_enable_one_cpu</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="n">skb_in_hw</span> <span class="o">=</span> <span class="n">USE_SKBUFFS_IN_HW</span> <span class="o">&amp;&amp;</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bufs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb_in_hw</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="o">*</span><span class="n">pskb</span><span class="p">;</span>
			<span class="n">prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
			<span class="n">prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">cvm_oct_device</span><span class="p">[</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span><span class="p">]);</span>

		<span class="cm">/* Immediately throw away all packets with receive errors */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">snoip</span><span class="p">.</span><span class="n">rcv_error</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cvm_oct_check_rcv_error</span><span class="p">(</span><span class="n">work</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We can only use the zero copy path if skbuffs are</span>
<span class="cm">		 * in the FPA pool and the packet fits in a single</span>
<span class="cm">		 * buffer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb_in_hw</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">packet_ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span> <span class="o">-</span> <span class="n">cvmx_ptr_to_phys</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
			<span class="n">prefetch</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="n">skb_set_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">packet_not_copied</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We have to copy the packet. First allocate</span>
<span class="cm">			 * an skbuff for it.</span>
<span class="cm">			 */</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk_ratelimited</span><span class="p">(</span><span class="s">&quot;Port %d failed to allocate &quot;</span>
						   <span class="s">&quot;skbuff, packet dropped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						   <span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span><span class="p">);</span>
				<span class="n">cvm_oct_free_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Check if we&#39;ve received a packet that was</span>
<span class="cm">			 * entirely stored in the work entry.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bufs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">packet_data</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">not_IP</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * The beginning of the packet</span>
<span class="cm">					 * moves for IP packets.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">is_v6</span><span class="p">)</span>
						<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
					<span class="k">else</span>
						<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">),</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
				<span class="cm">/* No packet buffers to free */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">segments</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bufs</span><span class="p">;</span>
				<span class="k">union</span> <span class="n">cvmx_buf_ptr</span> <span class="n">segment_ptr</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">packet_ptr</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

				<span class="k">while</span> <span class="p">(</span><span class="n">segments</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">union</span> <span class="n">cvmx_buf_ptr</span> <span class="n">next_ptr</span> <span class="o">=</span>
					    <span class="o">*</span><span class="p">(</span><span class="k">union</span> <span class="n">cvmx_buf_ptr</span> <span class="o">*</span><span class="p">)</span><span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">segment_ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Octeon Errata PKI-100: The segment size is</span>
<span class="cm">			 * wrong. Until it is fixed, calculate the</span>
<span class="cm">			 * segment size based on the packet pool</span>
<span class="cm">			 * buffer size. When it is fixed, the</span>
<span class="cm">			 * following line should be replaced with this</span>
<span class="cm">			 * one: int segment_size =</span>
<span class="cm">			 * segment_ptr.s.size;</span>
<span class="cm">			 */</span>
					<span class="kt">int</span> <span class="n">segment_size</span> <span class="o">=</span> <span class="n">CVMX_FPA_PACKET_POOL_SIZE</span> <span class="o">-</span>
						<span class="p">(</span><span class="n">segment_ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span> <span class="o">-</span> <span class="p">(((</span><span class="n">segment_ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">-</span> <span class="n">segment_ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">back</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">));</span>
					<span class="cm">/*</span>
<span class="cm">					 * Don&#39;t copy more than what</span>
<span class="cm">					 * is left in the packet.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">segment_size</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
						<span class="n">segment_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
					<span class="cm">/* Copy the data into the packet */</span>
					<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">),</span>
					       <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">segment_ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span><span class="p">),</span>
					       <span class="n">segment_size</span><span class="p">);</span>
					<span class="n">len</span> <span class="o">-=</span> <span class="n">segment_size</span><span class="p">;</span>
					<span class="n">segment_ptr</span> <span class="o">=</span> <span class="n">next_ptr</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">packet_not_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span> <span class="o">&lt;</span> <span class="n">TOTAL_NUMBER_OF_PORTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="n">cvm_oct_device</span><span class="p">[</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span><span class="p">]))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cvm_oct_device</span><span class="p">[</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">octeon_ethernet</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Only accept packets for devices that are</span>
<span class="cm">			 * currently up.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">not_IP</span> <span class="o">||</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">IP_exc</span> <span class="o">||</span>
					<span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">L4_error</span> <span class="o">||</span> <span class="o">!</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcp_or_udp</span><span class="p">))</span>
					<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>

				<span class="cm">/* Increment RX stats for virtual ports */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span> <span class="o">&gt;=</span> <span class="n">CVMX_PIP_NUM_INPUT_PORTS</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
					<span class="n">atomic64_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">atomic64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="p">);</span>
					<span class="n">atomic64_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="n">atomic64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span><span class="p">);</span>
<span class="cp">#else</span>
					<span class="n">atomic_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="p">);</span>
					<span class="n">atomic_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="p">}</span>
				<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">rx_count</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Drop any packet received for a device that isn&#39;t up */</span>
				<span class="cm">/*</span>
<span class="cm">				  printk_ratelimited(&quot;%s: Device not up, packet dropped\n&quot;,</span>
<span class="cm">					   dev-&gt;name);</span>
<span class="cm">				*/</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
				<span class="n">atomic64_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">atomic64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="p">);</span>
<span class="cp">#else</span>
				<span class="n">atomic_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Drop any packet received for a device that</span>
<span class="cm">			 * doesn&#39;t exist.</span>
<span class="cm">			 */</span>
			<span class="n">printk_ratelimited</span><span class="p">(</span><span class="s">&quot;Port %d not controlled by Linux, packet dropped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">work</span><span class="o">-&gt;</span><span class="n">ipprt</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check to see if the skbuff and work share the same</span>
<span class="cm">		 * packet buffer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">USE_SKBUFFS_IN_HW</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="n">packet_not_copied</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This buffer needs to be replaced, increment</span>
<span class="cm">			 * the number of buffers we need to free by</span>
<span class="cm">			 * one.</span>
<span class="cm">			 */</span>
			<span class="n">cvmx_fau_atomic_add32</span><span class="p">(</span><span class="n">FAU_NUM_PACKET_BUFFERS_TO_FREE</span><span class="p">,</span>
					      <span class="mi">1</span><span class="p">);</span>

			<span class="n">cvmx_fpa_free</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">CVMX_FPA_WQE_POOL</span><span class="p">,</span>
				      <span class="n">DONT_WRITEBACK</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cvm_oct_free_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Restore the original POW group mask */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_POW_PP_GRP_MSKX</span><span class="p">(</span><span class="n">coreid</span><span class="p">),</span> <span class="n">old_group_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">USE_ASYNC_IOBDMA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Restore the scratch area */</span>
		<span class="n">cvmx_scratch_write64</span><span class="p">(</span><span class="n">CVMX_SCR_SCRATCH</span><span class="p">,</span> <span class="n">old_scratch</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cvm_oct_rx_refill_pool</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rx_count</span> <span class="o">&lt;</span> <span class="n">budget</span> <span class="o">&amp;&amp;</span> <span class="n">napi</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No more work */</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">cvm_oct_no_more_work</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rx_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/**</span>
<span class="cm"> * cvm_oct_poll_controller - poll for receive packets</span>
<span class="cm"> * device.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev:    Device to poll. Unused</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cvm_oct_poll_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvm_oct_napi_poll</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">cvm_oct_rx_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev_for_napi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pow_wq_int_thrx</span> <span class="n">int_thr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pow_wq_int_pc</span> <span class="n">int_pc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TOTAL_NUMBER_OF_PORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cvm_oct_device</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_for_napi</span> <span class="o">=</span> <span class="n">cvm_oct_device</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">dev_for_napi</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;No net_devices were allocated.&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_rx_cpus</span> <span class="o">&gt;</span> <span class="mi">1</span>  <span class="o">&amp;&amp;</span> <span class="n">max_rx_cpus</span> <span class="o">&lt;</span> <span class="n">num_online_cpus</span><span class="p">())</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_state</span><span class="p">.</span><span class="n">available_cores</span><span class="p">,</span> <span class="n">max_rx_cpus</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_state</span><span class="p">.</span><span class="n">available_cores</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">());</span>
	<span class="n">core_state</span><span class="p">.</span><span class="n">baseline_cores</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_state</span><span class="p">.</span><span class="n">available_cores</span><span class="p">);</span>

	<span class="n">core_state</span><span class="p">.</span><span class="n">cpu_state</span> <span class="o">=</span> <span class="n">CPU_MASK_NONE</span><span class="p">;</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">dev_for_napi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cvm_oct_napi</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">,</span>
			       <span class="n">cvm_oct_napi_poll</span><span class="p">,</span> <span class="n">rx_napi_weight</span><span class="p">);</span>
		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cvm_oct_napi</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Register an IRQ hander for to receive POW interrupts */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">OCTEON_IRQ_WORKQ0</span> <span class="o">+</span> <span class="n">pow_receive_group</span><span class="p">,</span>
			<span class="n">cvm_oct_do_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Ethernet&quot;</span><span class="p">,</span> <span class="n">cvm_oct_device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Could not acquire Ethernet IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">OCTEON_IRQ_WORKQ0</span> <span class="o">+</span> <span class="n">pow_receive_group</span><span class="p">);</span>

	<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">OCTEON_IRQ_WORKQ0</span> <span class="o">+</span> <span class="n">pow_receive_group</span><span class="p">);</span>

	<span class="n">int_thr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">int_thr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tc_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">int_thr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tc_thr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Enable POW interrupt when our port has at least one packet */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_POW_WQ_INT_THRX</span><span class="p">(</span><span class="n">pow_receive_group</span><span class="p">),</span> <span class="n">int_thr</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="n">int_pc</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">int_pc</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pc_thr</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_POW_WQ_INT_PC</span><span class="p">,</span> <span class="n">int_pc</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>


	<span class="cm">/* Scheduld NAPI now.  This will indirectly enable interrupts. */</span>
	<span class="n">cvm_oct_enable_one_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cvm_oct_rx_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* Shutdown all of the NAPIs */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">netif_napi_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cvm_oct_napi</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
