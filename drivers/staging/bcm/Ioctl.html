<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › bcm › Ioctl.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>Ioctl.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _IOCTL_H_</span>
<span class="cp">#define _IOCTL_H_</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">rdmbuffer</span>
<span class="p">{</span>
	<span class="n">ULONG</span>	<span class="n">Register</span><span class="p">;</span>
	<span class="n">ULONG</span>	<span class="n">Length</span><span class="p">;</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">RDM_BUFFER</span><span class="p">,</span> <span class="o">*</span><span class="n">PRDM_BUFFER</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wrmbuffer</span>
<span class="p">{</span>
	<span class="n">ULONG</span>	<span class="n">Register</span><span class="p">;</span>
	<span class="n">ULONG</span>	<span class="n">Length</span><span class="p">;</span>
	<span class="n">UCHAR</span>	<span class="n">Data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">WRM_BUFFER</span><span class="p">,</span> <span class="o">*</span><span class="n">PWRM_BUFFER</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ioctlbuffer</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">InputBuffer</span><span class="p">;</span>
	<span class="n">ULONG</span>	<span class="n">InputLength</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">OutputBuffer</span><span class="p">;</span>
	<span class="n">ULONG</span>	<span class="n">OutputLength</span><span class="p">;</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">IOCTL_BUFFER</span><span class="p">,</span> <span class="o">*</span><span class="n">PIOCTL_BUFFER</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">stGPIOInfo</span>
<span class="p">{</span>
	<span class="n">UINT</span>  <span class="n">uiGpioNumber</span> <span class="p">;</span> <span class="cm">/* valid numbers 0-15 */</span>
	<span class="n">UINT</span> <span class="n">uiGpioValue</span><span class="p">;</span> <span class="cm">/* 1 set ; 0 not  set */</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span><span class="n">GPIO_INFO</span><span class="p">,</span><span class="o">*</span><span class="n">PGPIO_INFO</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">stUserThreadReq</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>0->Inactivate LED thread.
1->Activate the LED thread</p></td><td class="code"><div class="highlight"><pre>	<span class="n">UINT</span> <span class="n">ThreadState</span><span class="p">;</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span><span class="n">USER_THREAD_REQ</span><span class="p">,</span><span class="o">*</span><span class="n">PUSER_THREAD_REQ</span><span class="p">;</span>
<span class="cp">#define LED_THREAD_ACTIVATION_REQ  1</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>//<strong><em>*</em><em>*</em></strong> ioctl codes <strong><em>*</em><em>*</em>*</strong>////</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define BCM_IOCTL 				&#39;k&#39;</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>1.Control code for CONTROL MESSAGES</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_SEND_CONTROL_MESSAGE 			_IOW(BCM_IOCTL,	0x801,int)</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>2.Control code to write a particular value to a particular register</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_BCM_REGISTER_WRITE            _IOW(BCM_IOCTL, 0x802, int) </span><span class="c1">//</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>3.</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_BCM_REGISTER_READ             _IOR(BCM_IOCTL, 0x803, int) </span><span class="c1">//</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>4.Control code to write x number of bytes to common memory
starting from address y</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_BCM_COMMON_MEMORY_WRITE  	    _IOW(BCM_IOCTL, 0x804, int)</span><span class="c1">//</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>5.Control code to write x number of bytes to common memory
starting from address y</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_BCM_COMMON_MEMORY_READ 	    _IOR(BCM_IOCTL, 0x805, int)</span><span class="c1">//</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>6.Control code for CONTROL MESSAGES</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_GET_CONTROL_MESSAGE 			_IOR(BCM_IOCTL,	0x806, int)</span><span class="c1">//</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>7.Control code for FIRMWARE DOWNLOAD</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_BCM_FIRMWARE_DOWNLOAD 		_IOW(BCM_IOCTL, 0x807, int)</span><span class="c1">//</span>

<span class="cp">#define IOCTL_BCM_SET_SEND_VCID 	        _IOW(BCM_IOCTL,	0x808, int)</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>9.Control code for TRANSFER MODE SWITCHING</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_BCM_SWITCH_TRANSFER_MODE 		_IOW(BCM_IOCTL, 0x809, int)</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>10.Control code for LINK UP</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_LINK_REQ 						_IOW(BCM_IOCTL, 0x80A, int)</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>11.Control code for RSSI Level Request</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_RSSI_LEVEL_REQ				_IOW(BCM_IOCTL, 0x80B, int)</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>12.Control code for IDLE MODE CONTROL</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_IDLE_REQ						_IOW(BCM_IOCTL, 0x80C, int)</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>13.Control code for SS/BS info</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOCTL_SS_INFO_REQ					_IOW(BCM_IOCTL, 0x80D, int)</span>

<span class="cp">#define IOCTL_GET_STATISTICS_POINTER		_IOW(BCM_IOCTL, 0x80E, int)</span>

<span class="cp">#define IOCTL_CM_REQUEST    				_IOW(BCM_IOCTL, 0x80F, int)</span>

<span class="cp">#define IOCTL_INIT_PARAM_REQ 				_IOW(BCM_IOCTL, 0x810, int)</span>

<span class="cp">#define IOCTL_MAC_ADDR_REQ				_IOW(BCM_IOCTL, 0x811, int)</span>

<span class="cp">#define IOCTL_MAC_ADDR_RESP				_IOWR(BCM_IOCTL, 0x812, int)</span>

<span class="cp">#define IOCTL_CLASSIFICATION_RULE	  	_IOW(BCM_IOCTL, 0x813, char)</span>

<span class="cp">#define IOCTL_CLOSE_NOTIFICATION		_IO(BCM_IOCTL, 0x814)</span>

<span class="cp">#define IOCTL_LINK_UP					_IO(BCM_IOCTL, 0x815)</span>

<span class="cp">#define IOCTL_LINK_DOWN					_IO(BCM_IOCTL, 0x816, IOCTL_BUFFER)</span>

<span class="cp">#define IOCTL_CHIP_RESET                _IO(BCM_IOCTL, 0x816)</span>

<span class="cp">#define IOCTL_CINR_LEVEL_REQ			_IOW(BCM_IOCTL, 0x817, char)</span>

<span class="cp">#define IOCTL_WTM_CONTROL_REQ			_IOW(BCM_IOCTL, 0x817,char)</span>

<span class="cp">#define IOCTL_BE_BUCKET_SIZE			_IOW(BCM_IOCTL, 0x818, unsigned long)</span>

<span class="cp">#define IOCTL_RTPS_BUCKET_SIZE			_IOW(BCM_IOCTL, 0x819, unsigned long)</span>

<span class="cp">#define IOCTL_QOS_THRESHOLD				_IOW(BCM_IOCTL, 0x820, unsigned long)</span>

<span class="cp">#define IOCTL_DUMP_PACKET_INFO				_IO(BCM_IOCTL, 0x821)</span>

<span class="cp">#define IOCTL_GET_PACK_INFO					_IOR(BCM_IOCTL, 0x823, int)</span>

<span class="cp">#define IOCTL_BCM_GET_DRIVER_VERSION		_IOR(BCM_IOCTL, 0x829, int)</span>

<span class="cp">#define IOCTL_BCM_GET_CURRENT_STATUS 		_IOW(BCM_IOCTL, 0x828, int)</span>

<span class="cp">#define IOCTL_BCM_GPIO_SET_REQUEST	  		_IOW(BCM_IOCTL, 0x82A, int)</span>

<span class="cp">#define IOCTL_BCM_GPIO_STATUS_REQUEST 		_IOW(BCM_IOCTL, 0x82b, int)</span>

<span class="cp">#define IOCTL_BCM_GET_DSX_INDICATION 		_IOR(BCM_IOCTL, 0x854, int)</span>

<span class="cp">#define IOCTL_BCM_BUFFER_DOWNLOAD_START 	_IOW(BCM_IOCTL, 0x855, int)</span>

<span class="cp">#define IOCTL_BCM_BUFFER_DOWNLOAD 			_IOW(BCM_IOCTL, 0x856, int)</span>

<span class="cp">#define IOCTL_BCM_BUFFER_DOWNLOAD_STOP 		_IOW(BCM_IOCTL, 0x857, int)</span>

<span class="cp">#define IOCTL_BCM_REGISTER_WRITE_PRIVATE 	_IOW(BCM_IOCTL, 0x826, char)</span>

<span class="cp">#define IOCTL_BCM_REGISTER_READ_PRIVATE		_IOW(BCM_IOCTL, 0x827, char)</span>

<span class="cp">#define IOCTL_BCM_SET_DEBUG                 _IOW(BCM_IOCTL, 0x824, IOCTL_BUFFER)</span>

<span class="cp">#define IOCTL_BCM_EEPROM_REGISTER_WRITE  	_IOW(BCM_IOCTL, 0x858, int)</span>

<span class="cp">#define IOCTL_BCM_EEPROM_REGISTER_READ     	_IOR(BCM_IOCTL, 0x859, int)</span>

<span class="cp">#define IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE	_IOR(BCM_IOCTL, 0x860, int)</span>

<span class="cp">#define IOCTL_BCM_SET_MAC_TRACING     		_IOW(BCM_IOCTL, 0x82c, int)</span>

<span class="cp">#define IOCTL_BCM_GET_HOST_MIBS 		  	_IOW(BCM_IOCTL, 0x853, int)</span>

<span class="cp">#define IOCTL_BCM_NVM_READ 					_IOR(BCM_IOCTL, 0x861, int)</span>

<span class="cp">#define IOCTL_BCM_NVM_WRITE					_IOW(BCM_IOCTL, 0x862, int)</span>

<span class="cp">#define IOCTL_BCM_GET_NVM_SIZE				_IOR(BCM_IOCTL, 0x863, int)</span>

<span class="cp">#define IOCTL_BCM_CAL_INIT					_IOR(BCM_IOCTL, 0x864, int)</span>

<span class="cp">#define IOCTL_BCM_BULK_WRM 					_IOW(BCM_IOCTL, 0x90B, int)</span>

<span class="cp">#define IOCTL_BCM_FLASH2X_SECTION_READ 		_IOR(BCM_IOCTL, 0x865, int)</span>

<span class="cp">#define IOCTL_BCM_FLASH2X_SECTION_WRITE		_IOW(BCM_IOCTL, 0x866, int)</span>

<span class="cp">#define IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP _IOR(BCM_IOCTL,0x867, int)</span>

<span class="cp">#define IOCTL_BCM_SET_ACTIVE_SECTION 		_IOW(BCM_IOCTL,0x868, int)</span>

<span class="cp">#define	IOCTL_BCM_IDENTIFY_ACTIVE_SECTION 	_IO(BCM_IOCTL,0x869)</span>

<span class="cp">#define IOCTL_BCM_COPY_SECTION 				_IOW(BCM_IOCTL, 0x870,int)</span>

<span class="cp">#define	IOCTL_BCM_GET_FLASH_CS_INFO 		_IOR(BCM_IOCTL, 0x871, int)</span>

<span class="cp">#define IOCTL_BCM_SELECT_DSD 				_IOW(BCM_IOCTL, 0x872, int)</span>

<span class="cp">#define IOCTL_BCM_NVM_RAW_READ  			_IOR(BCM_IOCTL, 0x875, int)</span>

<span class="cp">#define IOCTL_BCM_CNTRLMSG_MASK  			_IOW(BCM_IOCTL, 0x874, int)</span>

<span class="cp">#define IOCTL_BCM_GET_DEVICE_DRIVER_INFO  _IOR(BCM_IOCTL, 0x877, int)</span>

<span class="cp">#define IOCTL_BCM_TIME_SINCE_NET_ENTRY  _IOR(BCM_IOCTL, 0x876, int)</span>

<span class="cp">#define BCM_LED_THREAD_STATE_CHANGE_REQ	  _IOW(BCM_IOCTL, 0x878, int)</span>

<span class="cp">#define IOCTL_BCM_GPIO_MULTI_REQUEST		_IOW(BCM_IOCTL, 0x82D, IOCTL_BUFFER)</span>
<span class="cp">#define IOCTL_BCM_GPIO_MODE_REQUEST			_IOW(BCM_IOCTL, 0x82E, IOCTL_BUFFER)</span>



<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_BCM_INTERFACE_TYPE</span>
<span class="p">{</span>
        <span class="n">BCM_MII</span><span class="p">,</span>
        <span class="n">BCM_CARDBUS</span><span class="p">,</span>
        <span class="n">BCM_USB</span><span class="p">,</span>
        <span class="n">BCM_SDIO</span><span class="p">,</span>
        <span class="n">BCM_PCMCIA</span>
<span class="p">}</span><span class="n">BCM_INTERFACE_TYPE</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_DEVICE_DRIVER_INFO</span>
<span class="p">{</span>
	<span class="n">NVM_TYPE</span> 			<span class="n">u32NVMType</span><span class="p">;</span>
	<span class="n">UINT</span> 				<span class="n">MaxRDMBufferSize</span><span class="p">;</span>
	<span class="n">BCM_INTERFACE_TYPE</span> 	<span class="n">u32InterfaceType</span><span class="p">;</span>
	<span class="n">UINT</span> 				<span class="n">u32DSDStartOffset</span><span class="p">;</span>
	<span class="n">UINT</span>				<span class="n">u32RxAlignmentCorrection</span><span class="p">;</span>
	<span class="n">UINT</span> 				<span class="n">u32Reserved</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span> <span class="n">DEVICE_DRIVER_INFO</span><span class="p">;</span>

<span class="k">typedef</span>  <span class="k">struct</span> <span class="n">_NVM_READWRITE</span>
<span class="p">{</span>

	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pBuffer</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>Data to be written from|read to. Memory should be allocated by the caller.</p></td><td class="code"><div class="highlight"><pre>	<span class="kt">uint32_t</span>  <span class="n">uiOffset</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>offset at which data should be written to or read from.</p></td><td class="code"><div class="highlight"><pre>	<span class="kt">uint32_t</span>  <span class="n">uiNumBytes</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>No. of bytes to be written or read.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">bool</span>  <span class="n">bVerify</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>Applicable only for write. If set verification of written data will be done.</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span> <span class="n">NVM_READWRITE</span><span class="p">,</span><span class="o">*</span><span class="n">PNVM_READWRITE</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">bulkwrmbuffer</span>
<span class="p">{</span>
	<span class="n">ULONG</span>	<span class="n">Register</span><span class="p">;</span>
	<span class="n">ULONG</span>	<span class="n">SwapEndian</span><span class="p">;</span>
	<span class="n">ULONG</span>	<span class="n">Values</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="p">}</span><span class="n">BULKWRM_BUFFER</span><span class="p">,</span><span class="o">*</span><span class="n">PBULKWRM_BUFFER</span><span class="p">;</span>


<span class="cm">/***********Structure used for FlashMap2.x *******************************/</span>

<span class="cm">/*</span>
<span class="cm">*	These are Sction present inside the Flash.</span>
<span class="cm">*	There is sectional RD/WR for flash Map 2.x.</span>
<span class="cm">*	hence these section will be used in read/write API.</span>
<span class="cm">*/</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_FLASH2X_SECTION_VAL</span>
<span class="p">{</span>
	<span class="n">NO_SECTION_VAL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">//no section is chosen when absolute offset is given for RD/WR</span>
	<span class="n">ISO_IMAGE1</span><span class="p">,</span>
	<span class="n">ISO_IMAGE2</span><span class="p">,</span>
	<span class="n">DSD0</span><span class="p">,</span>
	<span class="n">DSD1</span><span class="p">,</span>
	<span class="n">DSD2</span><span class="p">,</span>
	<span class="n">VSA0</span><span class="p">,</span>
	<span class="n">VSA1</span><span class="p">,</span>
	<span class="n">VSA2</span><span class="p">,</span>
	<span class="n">SCSI</span><span class="p">,</span>
	<span class="n">CONTROL_SECTION</span><span class="p">,</span>
	<span class="n">ISO_IMAGE1_PART2</span><span class="p">,</span>
	<span class="n">ISO_IMAGE1_PART3</span><span class="p">,</span>
	<span class="n">ISO_IMAGE2_PART2</span><span class="p">,</span>
	<span class="n">ISO_IMAGE2_PART3</span><span class="p">,</span>
	<span class="n">TOTAL_SECTIONS</span>
<span class="p">}</span><span class="n">FLASH2X_SECTION_VAL</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">*	Structure used for READ/WRITE Flash  Map2.x</span>
<span class="cm">*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_FLASH2X_READWRITE</span>
<span class="p">{</span>

	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">Section</span><span class="p">;</span> <span class="c1">//which section has to be read/written</span>
	<span class="n">B_UINT32</span> <span class="n">offset</span><span class="p">;</span>		<span class="c1">//Offset within Section.</span>
	<span class="n">B_UINT32</span> <span class="n">numOfBytes</span><span class="p">;</span>	<span class="c1">//NOB from the offset</span>
	<span class="n">B_UINT32</span>  <span class="n">bVerify</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pDataBuff</span><span class="p">;</span>	<span class="c1">//Buffer for reading/writing</span>

<span class="p">}</span><span class="n">FLASH2X_READWRITE</span><span class="p">,</span> <span class="o">*</span><span class="n">PFLASH2X_READWRITE</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm">*	This structure is used for coping one section to other.</span>
<span class="cm">*	there are two ways to copy one section to other.</span>
<span class="cm">*	it NOB =0, complete section will be copied on to other.</span>
<span class="cm">*	if NOB !=0, only NOB will be copied from the given offset.</span>
<span class="cm">*/</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_FLASH2X_COPY_SECTION</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>Src Section from which Data has to be copied to DstSection</p></td><td class="code"><div class="highlight"><pre>	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">SrcSection</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>Destination Section from where Data has to be coppied.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">DstSection</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>Offset within Section. if NOB =0 it will be ignored and data will be coped from offset 0.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">B_UINT32</span> <span class="n">offset</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>NOB from the offset. if NOB = 0 complete src section will be copied to Destination section.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">B_UINT32</span> <span class="n">numOfBytes</span><span class="p">;</span>
<span class="p">}</span> <span class="n">FLASH2X_COPY_SECTION</span><span class="p">,</span> <span class="o">*</span><span class="n">PFLASH2X_COPY_SECTION</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_SECTION_TYPE</span>
<span class="p">{</span>
	<span class="n">ISO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VSA</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DSD</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">}</span> <span class="n">SECTION_TYPE</span><span class="p">,</span> <span class="o">*</span><span class="n">PSECTION_TYPE</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">*	This section provide the complete bitmap of the Flash.</span>
<span class="cm">*	using this map lib/APP will isssue read/write command.</span>
<span class="cm">	Fields are defined as :</span>
<span class="cm">	Bit [0] = section is present  //1:present, 0: Not present</span>
<span class="cm">*      Bit [1] = section is valid  //1: valid, 0: not valid</span>
<span class="cm">*      Bit [2] = Section is R/W  //0: RW, 1: RO</span>
<span class="cm">*	Bit [3] = Section is Active or not 1 means Active, 0-&gt;inactive</span>
<span class="cm">*      Bit [7...3] = Reserved</span>
<span class="cm">*/</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_FLASH2X_BITMAP</span>
<span class="p">{</span>
	<span class="n">UCHAR</span> <span class="n">ISO_IMAGE1</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">ISO_IMAGE2</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">DSD0</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">DSD1</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">DSD2</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">VSA0</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">VSA1</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">VSA2</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">SCSI</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">CONTROL_SECTION</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>Reserved for future use</p></td><td class="code"><div class="highlight"><pre>	<span class="n">UCHAR</span> <span class="n">Reserved0</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">Reserved1</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">Reserved2</span><span class="p">;</span>
<span class="p">}</span><span class="n">FLASH2X_BITMAP</span><span class="p">,</span> <span class="o">*</span><span class="n">PFLASH2X_BITMAP</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>for net entry time check</p></td><td class="code"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_ST_TIME_ELAPSED_</span>
<span class="p">{</span>
	<span class="n">ULONG64</span>	<span class="n">ul64TimeElapsedSinceNetEntry</span><span class="p">;</span>
	<span class="n">UINT32</span>   <span class="n">uiReserved</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">//By chance if required for future proofing</span>
<span class="p">}</span><span class="n">ST_TIME_ELAPSED</span><span class="p">,</span><span class="o">*</span><span class="n">PST_TIME_ELAPSED</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
  <span class="n">WIMAX_IDX</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*To access WiMAX chip GPIO&#39;s for GPIO_MULTI_INFO or GPIO_MULTI_MODE*/</span>
  <span class="n">HOST_IDX</span><span class="p">,</span>    <span class="cm">/*To access Host chip GPIO&#39;s for GPIO_MULTI_INFO or GPIO_MULTI_MODE*/</span>
  <span class="n">MAX_IDX</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">stGPIOMultiInfo</span>
<span class="p">{</span>
  <span class="n">UINT</span> <span class="n">uiGPIOCommand</span><span class="p">;</span> <span class="cm">/* 1 for set and 0 for get*/</span>
  <span class="n">UINT</span> <span class="n">uiGPIOMask</span><span class="p">;</span>    <span class="cm">/* set the correspondig bit to 1 to access GPIO*/</span>
  <span class="n">UINT</span> <span class="n">uiGPIOValue</span><span class="p">;</span>   <span class="cm">/* 0 or 1; value to be set when command is 1.*/</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span><span class="n">GPIO_MULTI_INFO</span> <span class="p">,</span> <span class="o">*</span><span class="n">PGPIO_MULTI_INFO</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">stGPIOMultiMode</span>
<span class="p">{</span>
  <span class="n">UINT</span> <span class="n">uiGPIOMode</span><span class="p">;</span>    <span class="cm">/* 1 for OUT mode, 0 for IN mode*/</span>
  <span class="n">UINT</span> <span class="n">uiGPIOMask</span><span class="p">;</span>    <span class="cm">/* GPIO mask to set mode*/</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span><span class="n">GPIO_MULTI_MODE</span><span class="p">,</span> <span class="o">*</span><span class="n">PGPIO_MULTI_MODE</span><span class="p">;</span>


<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
