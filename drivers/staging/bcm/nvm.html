<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › bcm › nvm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>nvm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &quot;headers.h&quot;</span>

<span class="cp">#define DWORD unsigned int</span>

<span class="k">static</span> <span class="n">INT</span> <span class="n">BcmDoChipSelect</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">offset</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">BcmGetActiveDSD</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">BcmGetActiveISO</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="n">UINT</span> <span class="n">BcmGetEEPROMSize</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">BcmGetFlashCSInfo</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="n">UINT</span> <span class="n">BcmGetFlashSectorSize</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">FlashSectorSizeSig</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">FlashSectorSize</span><span class="p">);</span>

<span class="k">static</span> <span class="n">VOID</span> <span class="n">BcmValidateNvmType</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">BcmGetNvmSize</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="n">UINT</span> <span class="n">BcmGetFlashSize</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="n">NVM_TYPE</span> <span class="n">BcmGetNvmType</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>

<span class="k">static</span> <span class="n">INT</span> <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectionVal</span><span class="p">);</span>

<span class="k">static</span> <span class="n">B_UINT8</span> <span class="n">IsOffsetWritable</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">Section</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">IsSectionExistInVendorInfo</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">section</span><span class="p">);</span>

<span class="k">static</span> <span class="n">INT</span> <span class="n">ReadDSDPriority</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">dsd</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">ReadDSDSignature</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">dsd</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">ReadISOPriority</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">iso</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">ReadISOSignature</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">iso</span><span class="p">);</span>

<span class="k">static</span> <span class="n">INT</span> <span class="n">CorruptDSDSig</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectionVal</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">CorruptISOSig</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectionVal</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">SaveHeaderIfPresent</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">PUCHAR</span> <span class="n">pBuff</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">uiSectAlignAddr</span><span class="p">);</span>
<span class="k">static</span> <span class="n">INT</span> <span class="n">WriteToFlashWithoutSectorErase</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">PUINT</span> <span class="n">pBuff</span><span class="p">,</span>
					  <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectionVal</span><span class="p">,</span>
					  <span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">);</span>
<span class="k">static</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">getHighestPriDSD</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">getHighestPriISO</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>

<span class="k">static</span> <span class="n">INT</span> <span class="n">BeceemFlashBulkRead</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">);</span>

<span class="k">static</span> <span class="n">INT</span> <span class="n">BeceemFlashBulkWrite</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">,</span>
	<span class="n">BOOLEAN</span> <span class="n">bVerify</span><span class="p">);</span>

<span class="k">static</span> <span class="n">INT</span> <span class="n">GetFlashBaseAddr</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">);</span>

<span class="k">static</span> <span class="n">INT</span> <span class="n">ReadBeceemEEPROMBulk</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span><span class="n">UINT</span> <span class="n">dwAddress</span><span class="p">,</span> <span class="n">UINT</span> <span class="o">*</span><span class="n">pdwData</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">dwNumData</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Procedure:    ReadEEPROMStatusRegister</p>

<p>Description: Reads the standard EEPROM Status Register.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">UCHAR</span> <span class="nf">ReadEEPROMStatusRegister</span><span class="p">(</span> <span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">UCHAR</span> <span class="n">uiData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dwRetries</span> <span class="o">=</span> <span class="n">MAX_EEPROM_RETRIES</span><span class="o">*</span><span class="n">RETRIES_PER_DELAY</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Read the EEPROM status register */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">EEPROM_READ_STATUS_REGISTER</span> <span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_CMDQ_SPI_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">(</span> <span class="n">dwRetries</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiStatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiStatus</span><span class="p">));</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Modem has got removed hence exiting....&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait for Avail bit to be set. */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="n">EEPROM_READ_DATA_AVAIL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="cm">/* Clear the Avail/Full bits - which ever is set. */</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EEPROM_READ_DATA_AVAIL</span> <span class="o">|</span> <span class="n">EEPROM_READ_DATA_FULL</span><span class="p">);</span>
			<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

			<span class="n">value</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
			<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_READ_DATAQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
			<span class="n">uiData</span> <span class="o">=</span> <span class="p">(</span><span class="n">UCHAR</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dwRetries</span><span class="o">--</span> <span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">dwRetries</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="p">{</span>
			 <span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
			 <span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value1</span><span class="p">));</span>
			 <span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;0x3004 = %x 0x3008 = %x, retries = %d failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">value1</span><span class="p">,</span>  <span class="n">MAX_EEPROM_RETRIES</span><span class="o">*</span><span class="n">RETRIES_PER_DELAY</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">uiData</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">dwRetries</span><span class="o">%</span><span class="n">RETRIES_PER_DELAY</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">uiData</span><span class="p">;</span>
<span class="p">}</span> <span class="cm">/* ReadEEPROMStatusRegister */</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><hr />

<p>Procedure:    ReadBeceemEEPROMBulk</p>

<p>Description: This routine reads 16Byte data from EEPROM</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
     dwAddress   - EEPROM Offset to read the data from.
     pdwData     - Pointer to double word where data needs to be stored in.  //        dwNumWords  - Number of words.  Valid values are 4 ONLY.</p>

<p>Returns:</p>

<h2>    OSAL<em>STATUS</em>CODE:</h2></td><td class="code"><div class="highlight"><pre><span class="n">INT</span> <span class="nf">ReadBeceemEEPROMBulk</span><span class="p">(</span> <span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
									   <span class="n">DWORD</span> <span class="n">dwAddress</span><span class="p">,</span>
									   <span class="n">DWORD</span> <span class="o">*</span><span class="n">pdwData</span><span class="p">,</span>
									   <span class="n">DWORD</span> <span class="n">dwNumWords</span>
									 <span class="p">)</span>
<span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">dwIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dwRetries</span> <span class="o">=</span> <span class="n">MAX_EEPROM_RETRIES</span><span class="o">*</span><span class="n">RETRIES_PER_DELAY</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiStatus</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">;</span>

	<span class="cm">/* Flush the read and cmd queue. */</span>
	<span class="n">value</span><span class="o">=</span><span class="p">(</span> <span class="n">EEPROM_READ_QUEUE_FLUSH</span> <span class="o">|</span> <span class="n">EEPROM_CMD_QUEUE_FLUSH</span> <span class="p">);</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">SPI_FLUSH_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">);</span>
	<span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">SPI_FLUSH_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="cm">/* Clear the Avail/Full bits. */</span>
	<span class="n">value</span><span class="o">=</span><span class="p">(</span> <span class="n">EEPROM_READ_DATA_AVAIL</span> <span class="o">|</span> <span class="n">EEPROM_READ_DATA_FULL</span> <span class="p">);</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="n">value</span><span class="o">=</span> <span class="n">dwAddress</span> <span class="o">|</span> <span class="p">(</span> <span class="p">(</span><span class="n">dwNumWords</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">?</span> <span class="n">EEPROM_16_BYTE_PAGE_READ</span> <span class="o">:</span> <span class="n">EEPROM_4_BYTE_PAGE_READ</span> <span class="p">);</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_CMDQ_SPI_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">(</span> <span class="n">dwRetries</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="p">{</span>

		<span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiStatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiStatus</span><span class="p">));</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Modem has got Removed.hence exiting from loop...&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If we are reading 16 bytes we want to be sure that the queue</span>
<span class="cm">		 * is full before we read.  In the other cases we are ok if the</span>
<span class="cm">		 * queue has data available */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">dwNumWords</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="n">EEPROM_READ_DATA_FULL</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
			<span class="p">{</span>
				<span class="cm">/* Clear the Avail/Full bits - which ever is set. */</span>
				<span class="n">value</span> <span class="o">=</span> <span class="p">(</span> <span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EEPROM_READ_DATA_AVAIL</span> <span class="o">|</span> <span class="n">EEPROM_READ_DATA_FULL</span><span class="p">)</span> <span class="p">)</span> <span class="p">;</span>
				<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">dwNumWords</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
		<span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="n">EEPROM_READ_DATA_AVAIL</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
			<span class="p">{</span>
				<span class="cm">/* We just got Avail and we have to read 32bits so we</span>
<span class="cm">				 * need this sleep for Cardbus kind of devices. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">chip_id</span> <span class="o">==</span> <span class="mh">0xBECE0210</span> <span class="p">)</span>
	  					<span class="n">udelay</span><span class="p">(</span><span class="mi">800</span><span class="p">);</span>

				<span class="cm">/* Clear the Avail/Full bits - which ever is set. */</span>
				<span class="n">value</span><span class="o">=</span><span class="p">(</span> <span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EEPROM_READ_DATA_AVAIL</span> <span class="o">|</span> <span class="n">EEPROM_READ_DATA_FULL</span><span class="p">)</span> <span class="p">);</span>
				<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">dwRetries</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">dwRetries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
			<span class="n">value1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
			<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
			<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value1</span><span class="p">));</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dwNumWords %d 0x3004 = %x 0x3008 = %x  retries = %d failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dwNumWords</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>  <span class="n">value1</span><span class="p">,</span>  <span class="n">MAX_EEPROM_RETRIES</span><span class="o">*</span><span class="n">RETRIES_PER_DELAY</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">dwRetries</span><span class="o">%</span><span class="n">RETRIES_PER_DELAY</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">dwIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dwIndex</span> <span class="o">&lt;</span> <span class="n">dwNumWords</span> <span class="p">;</span> <span class="n">dwIndex</span><span class="o">++</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* We get only a byte at a time - from LSB to MSB. We shift it into an integer. */</span>
		<span class="n">pvalue</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)(</span><span class="n">pdwData</span> <span class="o">+</span> <span class="n">dwIndex</span><span class="p">);</span>

		<span class="n">value</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_READ_DATAQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

		<span class="n">pvalue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

		<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_READ_DATAQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

		<span class="n">pvalue</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

		<span class="n">value</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_READ_DATAQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

		<span class="n">pvalue</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

		<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_READ_DATAQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

		<span class="n">pvalue</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span> <span class="cm">/* ReadBeceemEEPROMBulk() */</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><hr />

<p>Procedure:    ReadBeceemEEPROM</p>

<p>Description: This routine reads 4 data from EEPROM.  It uses 1 or 2 page
            reads to do this operation.</p>

<p>Arguments:
    Adapter     - ptr to Adapter object instance
     uiOffset    - EEPROM Offset to read the data from.
     pBuffer        - Pointer to word where data needs to be stored in.</p>

<p>Returns:</p>

<h2>    OSAL<em>STATUS</em>CODE:</h2></td><td class="code"><div class="highlight"><pre><span class="n">INT</span> <span class="nf">ReadBeceemEEPROM</span><span class="p">(</span> <span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
								   <span class="n">DWORD</span> <span class="n">uiOffset</span><span class="p">,</span>
								   <span class="n">DWORD</span> <span class="o">*</span><span class="n">pBuffer</span>
								 <span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiData</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>	 	<span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">UINT</span> <span class="n">uiByteOffset</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiTempOffset</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot; ====&gt; &quot;</span><span class="p">);</span>

	<span class="n">uiTempOffset</span> <span class="o">=</span> <span class="n">uiOffset</span> <span class="o">-</span> <span class="p">(</span><span class="n">uiOffset</span> <span class="o">%</span> <span class="n">MAX_RW_SIZE</span><span class="p">);</span>
	<span class="n">uiByteOffset</span> <span class="o">=</span> <span class="n">uiOffset</span> <span class="o">-</span> <span class="n">uiTempOffset</span><span class="p">;</span>

	<span class="n">ReadBeceemEEPROMBulk</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">uiTempOffset</span><span class="p">,</span> <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* A word can overlap at most over 2 pages. In that case we read the</span>
<span class="cm">	 * next page too. */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">uiByteOffset</span> <span class="o">&gt;</span> <span class="mi">12</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ReadBeceemEEPROMBulk</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">uiTempOffset</span> <span class="o">+</span> <span class="n">MAX_RW_SIZE</span><span class="p">,</span> <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span> <span class="n">pBuffer</span><span class="p">,</span> <span class="p">(</span> <span class="p">((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">uiByteOffset</span> <span class="p">),</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span> <span class="cm">/* ReadBeceemEEPROM() */</span>



<span class="n">INT</span> <span class="nf">ReadMacAddressFromNVM</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INT</span> <span class="n">Status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">puMacAddr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="n">Status</span> <span class="o">=</span> <span class="n">BeceemNVMRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
			<span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="o">&amp;</span><span class="n">puMacAddr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">INIT_PARAMS_1_MACADDRESS_ADDRESS</span><span class="p">,</span>
			<span class="n">MAC_ADDRESS_SIZE</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Status</span> <span class="o">==</span> <span class="n">STATUS_SUCCESS</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">puMacAddr</span><span class="p">,</span> <span class="n">MAC_ADDRESS_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><hr />

<p>Procedure:    BeceemEEPROMBulkRead</p>

<p>Description: Reads the EEPROM and returns the Data.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
    pBuffer    - Buffer to store the data read from EEPROM
    uiOffset   - Offset of EEPROM from where data should be read
    uiNumBytes - Number of bytes to be read from the EEPROM.</p>

<p>Returns:
    OSAL<em>STATUS</em>SUCCESS - if EEPROM read is successful.</p>

<h2>    <FAILURE>           - if failed.</h2></td><td class="code"><div class="highlight"><pre><span class="n">INT</span> <span class="nf">BeceemEEPROMBulkRead</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiData</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>		  <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>UINT uiAddress           = 0;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">UINT</span> <span class="n">uiBytesRemaining</span> <span class="o">=</span> <span class="n">uiNumBytes</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiIndex</span> 		  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiTempOffset</span>  	  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiExtraBytes</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiFailureRetries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">PUCHAR</span> <span class="n">pcBuff</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">;</span>


	<span class="k">if</span><span class="p">(</span><span class="n">uiOffset</span><span class="o">%</span><span class="n">MAX_RW_SIZE</span><span class="o">&amp;&amp;</span> <span class="n">uiBytesRemaining</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">uiTempOffset</span> <span class="o">=</span> <span class="n">uiOffset</span> <span class="o">-</span> <span class="p">(</span><span class="n">uiOffset</span><span class="o">%</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>
		<span class="n">uiExtraBytes</span> <span class="o">=</span> <span class="n">uiOffset</span><span class="o">-</span><span class="n">uiTempOffset</span><span class="p">;</span>
		<span class="n">ReadBeceemEEPROMBulk</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiTempOffset</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">uiBytesRemaining</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MAX_RW_SIZE</span> <span class="o">-</span> <span class="n">uiExtraBytes</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">pBuffer</span><span class="p">,(((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">uiExtraBytes</span><span class="p">),</span><span class="n">MAX_RW_SIZE</span> <span class="o">-</span> <span class="n">uiExtraBytes</span><span class="p">);</span>

			<span class="n">uiBytesRemaining</span> <span class="o">-=</span> <span class="p">(</span><span class="n">MAX_RW_SIZE</span> <span class="o">-</span> <span class="n">uiExtraBytes</span><span class="p">);</span>
			<span class="n">uiIndex</span> <span class="o">+=</span> <span class="p">(</span><span class="n">MAX_RW_SIZE</span> <span class="o">-</span> <span class="n">uiExtraBytes</span><span class="p">);</span>
			<span class="n">uiOffset</span> <span class="o">+=</span> <span class="p">(</span><span class="n">MAX_RW_SIZE</span> <span class="o">-</span> <span class="n">uiExtraBytes</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">pBuffer</span><span class="p">,(((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">uiExtraBytes</span><span class="p">),</span><span class="n">uiBytesRemaining</span><span class="p">);</span>
			<span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">uiBytesRemaining</span><span class="p">;</span>
			<span class="n">uiOffset</span> <span class="o">+=</span> <span class="n">uiBytesRemaining</span><span class="p">;</span>
			<span class="n">uiBytesRemaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>


	<span class="p">}</span>


	<span class="k">while</span><span class="p">(</span><span class="n">uiBytesRemaining</span> <span class="o">&amp;&amp;</span> <span class="n">uiFailureRetries</span> <span class="o">!=</span> <span class="mi">128</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiBytesRemaining</span> <span class="o">&gt;=</span> <span class="n">MAX_RW_SIZE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="cm">/* For the requests more than or equal to 16 bytes, use bulk</span>
<span class="cm">			 * read function to make the access faster.</span>
<span class="cm">			 * We read 4 Dwords of data */</span>
			<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ReadBeceemEEPROMBulk</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">4</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">pcBuff</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>
				<span class="n">uiOffset</span> <span class="o">+=</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span>
				<span class="n">uiBytesRemaining</span> <span class="o">-=</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span>
				<span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">uiFailureRetries</span><span class="o">++</span><span class="p">;</span>
				<span class="n">mdelay</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="c1">//sleep for a while before retry...</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">uiBytesRemaining</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ReadBeceemEEPROM</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
			<span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">pcBuff</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">4</span><span class="p">);</span>
				<span class="n">uiOffset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">uiBytesRemaining</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">uiIndex</span> <span class="o">+=</span><span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">uiFailureRetries</span><span class="o">++</span><span class="p">;</span>
				<span class="n">mdelay</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="c1">//sleep for a while before retry...</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span> <span class="c1">// Handle the reads less than 4 bytes...</span>
			<span class="n">PUCHAR</span> <span class="n">pCharBuff</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">;</span>
			<span class="n">pCharBuff</span> <span class="o">+=</span> <span class="n">uiIndex</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ReadBeceemEEPROM</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
			<span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">pCharBuff</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uiBytesRemaining</span><span class="p">);</span><span class="c1">//copy only bytes requested.</span>
				<span class="n">uiBytesRemaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">uiFailureRetries</span><span class="o">++</span><span class="p">;</span>
				<span class="n">mdelay</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="c1">//sleep for a while before retry...</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><hr />

<p>Procedure:    BeceemFlashBulkRead</p>

<p>Description: Reads the FLASH and returns the Data.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
    pBuffer    - Buffer to store the data read from FLASH
    uiOffset   - Offset of FLASH from where data should be read
    uiNumBytes - Number of bytes to be read from the FLASH.</p>

<p>Returns:
    OSAL<em>STATUS</em>SUCCESS - if FLASH read is successful.</p>

<h2>    <FAILURE>           - if failed.</h2></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">BeceemFlashBulkRead</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiBytesToRead</span> <span class="o">=</span> <span class="n">uiNumBytes</span><span class="p">;</span>
	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiPartOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Device Got Removed &quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Adding flash Base address
uiOffset = uiOffset + GetFlashBaseAddr(Adapter);</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if defined(BCM_SHM_INTERFACE) &amp;&amp; !defined(FLASH_DIRECT_ACCESS)</span>
  <span class="n">Status</span> <span class="o">=</span> <span class="n">bcmflash_raw_read</span><span class="p">((</span><span class="n">uiOffset</span><span class="o">/</span><span class="n">FLASH_PART_SIZE</span><span class="p">),(</span><span class="n">uiOffset</span> <span class="o">%</span> <span class="n">FLASH_PART_SIZE</span><span class="p">),(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">=</span> <span class="n">RESET_CHIP_SELECT</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">uiOffset</span> <span class="o">%</span> <span class="n">MAX_RW_SIZE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BcmDoChipSelect</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">);</span>
		<span class="n">uiPartOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FLASH_PART_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">GetFlashBaseAddr</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

		<span class="n">uiBytesToRead</span> <span class="o">=</span> <span class="n">MAX_RW_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">uiOffset</span><span class="o">%</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>
		<span class="n">uiBytesToRead</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">uiNumBytes</span><span class="p">,</span><span class="n">uiBytesToRead</span><span class="p">);</span>

		<span class="n">bytes</span> <span class="o">=</span> <span class="n">rdm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">uiPartOffset</span><span class="p">,</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,</span> <span class="n">uiBytesToRead</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">=</span> <span class="n">RESET_CHIP_SELECT</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">uiBytesToRead</span><span class="p">;</span>
		<span class="n">uiOffset</span> <span class="o">+=</span> <span class="n">uiBytesToRead</span><span class="p">;</span>
		<span class="n">uiNumBytes</span> <span class="o">-=</span> <span class="n">uiBytesToRead</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span><span class="p">(</span><span class="n">uiNumBytes</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BcmDoChipSelect</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">);</span>
		<span class="n">uiPartOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FLASH_PART_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">GetFlashBaseAddr</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

		<span class="n">uiBytesToRead</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">uiNumBytes</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>

		<span class="n">bytes</span> <span class="o">=</span> <span class="n">rdm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">uiPartOffset</span><span class="p">,</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,</span> <span class="n">uiBytesToRead</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">uiBytesToRead</span><span class="p">;</span>
		<span class="n">uiOffset</span> <span class="o">+=</span> <span class="n">uiBytesToRead</span><span class="p">;</span>
		<span class="n">uiNumBytes</span> <span class="o">-=</span> <span class="n">uiBytesToRead</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">=</span> <span class="n">RESET_CHIP_SELECT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><hr />

<p>Procedure:    BcmGetFlashSize</p>

<p>Description: Finds the size of FLASH.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance</p>

<p>Returns:
    UINT - size of the FLASH Storage.</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">UINT</span> <span class="nf">BcmGetFlashSize</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">IsFlash2x</span><span class="p">(</span><span class="n">Adapter</span><span class="p">))</span>
		<span class="k">return</span> 	<span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DSD_HEADER</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">32</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>


<span class="p">}</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><hr />

<p>Procedure:    BcmGetEEPROMSize</p>

<p>Description: Finds the size of EEPROM.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance</p>

<p>Returns:
    UINT - size of the EEPROM Storage.</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">UINT</span> <span class="nf">BcmGetEEPROMSize</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>if EEPROM is present and already Calibrated,it will have
'BECM' string at 0th offset.
To find the EEPROM size read the possible boundaries of the
EEPROM like 4K,8K etc..accessing the EEPROM beyond its size will
result in wrap around. So when we get the End of the EEPROM we will
get 'BECM' string which is indeed at offset 0.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">,</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">uiData</span> <span class="o">==</span> <span class="n">BECM</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">uiIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="n">uiIndex</span> <span class="o">&lt;=</span><span class="mi">256</span><span class="p">;</span> <span class="n">uiIndex</span><span class="o">*=</span><span class="mi">2</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">,</span><span class="n">uiIndex</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">uiData</span> <span class="o">==</span> <span class="n">BECM</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">return</span> <span class="n">uiIndex</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>EEPROM may not be present or not programmed</p></td><td class="code"><div class="highlight"><pre>        <span class="n">uiData</span> <span class="o">=</span> <span class="mh">0xBABEFACE</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">BeceemEEPROMBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">TRUE</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">uiData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="n">uiIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="n">uiIndex</span> <span class="o">&lt;=</span><span class="mi">256</span><span class="p">;</span> <span class="n">uiIndex</span><span class="o">*=</span><span class="mi">2</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">,</span><span class="n">uiIndex</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">uiData</span> <span class="o">==</span> <span class="mh">0xBABEFACE</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">return</span> <span class="n">uiIndex</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><hr />

<p>Procedure:    FlashSectorErase</p>

<p>Description: Finds the sector size of the FLASH.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
    addr       - sector start address
    numOfSectors - number of sectors to  be erased.</p>

<p>Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">FlashSectorErase</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">addr</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">numOfSectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">iIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iRetries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="n">iIndex</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">iIndex</span><span class="o">&lt;</span><span class="n">numOfSectors</span><span class="p">;</span><span class="n">iIndex</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">value</span> <span class="o">=</span> <span class="mh">0x06000000</span><span class="p">;</span>
		<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0xd8000000</span> <span class="o">|</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF</span><span class="p">));</span>
		<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
		<span class="n">iRetries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">do</span>
		<span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_STATUS_REG_READ</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Programing of FLASH_SPI_CMDQ_REG fails&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">bytes</span> <span class="o">=</span> <span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_READQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiStatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiStatus</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">uiStatus</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Reading status of FLASH_SPI_READQ_REG fails&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">uiStatus</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">iRetries</span><span class="o">++</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>After every try lets make the CPU free for 10 ms. generally time taken by the
the sector erase cycle is 500 ms to 40000 msec. hence sleeping 10 ms
won't hamper performance in any case.</p></td><td class="code"><div class="highlight"><pre>			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span><span class="k">while</span><span class="p">((</span><span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iRetries</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">));</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;iRetries crossing the limit of 80000</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">addr</span> <span class="o">+=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><hr />

<p>Procedure:    flashByteWrite</p>

<p>Description: Performs Byte by Byte write to flash</p>

<p>Arguments:
    Adapter   - ptr to Adapter object instance
    uiOffset   - Offset of the flash where data needs to be written to.
    pData   - Address of Data to be written.
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">flashByteWrite</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">PVOID</span> <span class="n">pData</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">UINT</span> <span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INT</span>  <span class="n">iRetries</span> <span class="o">=</span> <span class="n">MAX_FLASH_RETRIES</span> <span class="o">*</span> <span class="n">FLASH_PER_RETRIES_DELAY</span><span class="p">;</span> <span class="c1">//3</span>

	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">ulData</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pData</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>need not write 0xFF because write requires an erase and erase will
make whole sector 0xFF.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="mh">0xFF</span> <span class="o">==</span> <span class="n">ulData</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>DumpDebug(NVM_RW,("flashWrite ====>\n"));</p></td><td class="code"><div class="highlight"><pre>	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_WRITE_ENABLE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Write enable in FLASH_SPI_CMDQ_REG register fails&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">wrm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">FLASH_SPI_WRITEQ_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ulData</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;DATA Write on FLASH_SPI_WRITEQ_REG fails&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x02000000</span> <span class="o">|</span> <span class="p">(</span><span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Programming of FLASH_SPI_CMDQ_REG fails&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>__udelay(950);</p></td><td class="code"><div class="highlight"><pre>	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_STATUS_REG_READ</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	  	<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	  	<span class="p">{</span>
	  		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Programing of FLASH_SPI_CMDQ_REG fails&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	  	<span class="p">}</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>__udelay(1);</p></td><td class="code"><div class="highlight"><pre>		<span class="n">bytes</span> <span class="o">=</span> <span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_READQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiStatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiStatus</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uiStatus</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Reading status of FLASH_SPI_READQ_REG fails&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">uiStatus</span><span class="p">;</span>
		<span class="p">}</span>
	  	<span class="n">iRetries</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">iRetries</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">iRetries</span> <span class="o">%</span> <span class="n">FLASH_PER_RETRIES_DELAY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			 <span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="p">}</span><span class="k">while</span><span class="p">((</span><span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iRetries</span>  <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Flash Write fails even after checking status for 200 times.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><hr />

<p>Procedure:    flashWrite</p>

<p>Description: Performs write to flash</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
    uiOffset   - Offset of the flash where data needs to be written to.
    pData   - Address of Data to be written.
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">flashWrite</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">PVOID</span> <span class="n">pData</span><span class="p">)</span>

<span class="p">{</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>UINT uiStatus = 0;
INT  iRetries = 0;
UINT uiReadBack = 0;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">UINT</span> <span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INT</span>  <span class="n">iRetries</span> <span class="o">=</span> <span class="n">MAX_FLASH_RETRIES</span> <span class="o">*</span> <span class="n">FLASH_PER_RETRIES_DELAY</span><span class="p">;</span> <span class="c1">//3</span>

	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiErasePattern</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span><span class="mh">0xFFFFFFFF</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>need not write 0xFFFFFFFF because write requires an erase and erase will
make whole sector 0xFFFFFFFF.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">pData</span><span class="p">,</span> <span class="n">uiErasePattern</span><span class="p">,</span> <span class="n">MAX_RW_SIZE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_WRITE_ENABLE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Write Enable of FLASH_SPI_CMDQ_REG fails&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">wrm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">uiOffset</span><span class="p">,</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">pData</span><span class="p">,</span> <span class="n">MAX_RW_SIZE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Data write fails...&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>__udelay(950);</p></td><td class="code"><div class="highlight"><pre>	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_STATUS_REG_READ</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	  	<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	  	<span class="p">{</span>
	  		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Programing of FLASH_SPI_CMDQ_REG fails&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	  	<span class="p">}</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>__udelay(1);</p></td><td class="code"><div class="highlight"><pre>		<span class="n">bytes</span> <span class="o">=</span> <span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_READQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiStatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiStatus</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uiStatus</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Reading status of FLASH_SPI_READQ_REG fails&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">uiStatus</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">iRetries</span><span class="o">--</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>this will ensure that in there will be no changes in the current path.
currently one rdm/wrm takes 125 us.
Hence  125 *2 * FLASH<em>PER</em>RETRIES_DELAY > 3 ms(worst case delay)
Hence current implementation cycle will intoduce no delay in current path</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">iRetries</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">iRetries</span> <span class="o">%</span> <span class="n">FLASH_PER_RETRIES_DELAY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span><span class="k">while</span><span class="p">((</span><span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iRetries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span><span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Flash Write fails even after checking status for 200 times.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><hr />

<p>Procedure:    flashByteWriteStatus</p>

<p>Description: Performs byte by byte write to flash with write done status check</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
    uiOffset    - Offset of the flash where data needs to be written to.
    pData    - Address of the Data to be written.
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">flashByteWriteStatus</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">PVOID</span> <span class="n">pData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INT</span>  <span class="n">iRetries</span> <span class="o">=</span> <span class="n">MAX_FLASH_RETRIES</span> <span class="o">*</span> <span class="n">FLASH_PER_RETRIES_DELAY</span><span class="p">;</span> <span class="c1">//3</span>
	<span class="n">ULONG</span> <span class="n">ulData</span>  <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pData</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>need not write 0xFFFFFFFF because write requires an erase and erase will
make whole sector 0xFFFFFFFF.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="mh">0xFF</span> <span class="o">==</span> <span class="n">ulData</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>DumpDebug(NVM_RW,("flashWrite ====>\n"));</p></td><td class="code"><div class="highlight"><pre>	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_WRITE_ENABLE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Write enable in FLASH_SPI_CMDQ_REG register fails&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">wrm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">FLASH_SPI_WRITEQ_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ulData</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;DATA Write on FLASH_SPI_WRITEQ_REG fails&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x02000000</span> <span class="o">|</span> <span class="p">(</span><span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Programming of FLASH_SPI_CMDQ_REG fails&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>msleep(1);</p></td><td class="code"><div class="highlight"><pre>	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_STATUS_REG_READ</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Programing of FLASH_SPI_CMDQ_REG fails&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>__udelay(1);</p></td><td class="code"><div class="highlight"><pre>		<span class="n">bytes</span> <span class="o">=</span> <span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_READQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiStatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiStatus</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uiStatus</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Reading status of FLASH_SPI_READQ_REG fails&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">uiStatus</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">iRetries</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">iRetries</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">iRetries</span> <span class="o">%</span> <span class="n">FLASH_PER_RETRIES_DELAY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span><span class="k">while</span><span class="p">((</span><span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iRetries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span><span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Flash Write fails even after checking status for 200 times.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>

<span class="p">}</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><hr />

<p>Procedure:    flashWriteStatus</p>

<p>Description: Performs write to flash with write done status check</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
    uiOffset    - Offset of the flash where data needs to be written to.
    pData    - Address of the Data to be written.
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">flashWriteStatus</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">PVOID</span> <span class="n">pData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INT</span>  <span class="n">iRetries</span> <span class="o">=</span> <span class="n">MAX_FLASH_RETRIES</span> <span class="o">*</span> <span class="n">FLASH_PER_RETRIES_DELAY</span><span class="p">;</span> <span class="c1">//3</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>UINT uiReadBack = 0;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiErasePattern</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span><span class="mh">0xFFFFFFFF</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>need not write 0xFFFFFFFF because write requires an erase and erase will
make whole sector 0xFFFFFFFF.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">pData</span><span class="p">,</span><span class="n">uiErasePattern</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_WRITE_ENABLE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Write Enable of FLASH_SPI_CMDQ_REG fails&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">wrm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">uiOffset</span><span class="p">,</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">pData</span><span class="p">,</span> <span class="n">MAX_RW_SIZE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Data write fails...&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>__udelay(1);</p></td><td class="code"><div class="highlight"><pre>	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_STATUS_REG_READ</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	  	<span class="k">if</span><span class="p">(</span><span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	  	<span class="p">{</span>
	  		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Programing of FLASH_SPI_CMDQ_REG fails&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	  	<span class="p">}</span></pre></div></td></tr>


<tr id="section-35"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-35">&#182;</a></div><p>__udelay(1);</p></td><td class="code"><div class="highlight"><pre>		<span class="n">bytes</span> <span class="o">=</span> <span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_READQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiStatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiStatus</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uiStatus</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Reading status of FLASH_SPI_READQ_REG fails&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">uiStatus</span><span class="p">;</span>
		<span class="p">}</span>
	  	<span class="n">iRetries</span><span class="o">--</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-36"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-36">&#182;</a></div><p>this will ensure that in there will be no changes in the current path.
currently one rdm/wrm takes 125 us.
Hence  125 *2  * FLASH<em>PER</em>RETRIES_DELAY  >3 ms(worst case delay)
Hence current implementation cycle will intoduce no delay in current path</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">iRetries</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">iRetries</span> <span class="o">%</span> <span class="n">FLASH_PER_RETRIES_DELAY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span><span class="k">while</span><span class="p">((</span><span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iRetries</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span><span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Flash Write fails even after checking status for 200 times.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-37"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-37">&#182;</a></div><hr />

<p>Procedure:    BcmRestoreBlockProtectStatus</p>

<p>Description: Restores the original block protection status.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
    ulWriteStatus   -Original status
Returns:
    <VOID></p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">VOID</span> <span class="nf">BcmRestoreBlockProtectStatus</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span><span class="n">ULONG</span> <span class="n">ulWriteStatus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_WRITE_ENABLE</span><span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_STATUS_REG_WRITE</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">ulWriteStatus</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-38"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-38">&#182;</a></div><hr />

<p>Procedure:    BcmFlashUnProtectBlock</p>

<p>Description: UnProtects appropriate blocks for writing.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
    uiOffset   - Offset of the flash where data needs to be written to. This should be Sector aligned.
Returns:
    ULONG   - Status value before UnProtect.</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">ULONG</span> <span class="nf">BcmFlashUnProtectBlock</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span><span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">uiLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONG</span> <span class="n">ulStatus</span>      <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">ulWriteStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">uiOffset</span> <span class="o">=</span> <span class="n">uiOffset</span><span class="o">&amp;</span><span class="mh">0x000FFFFF</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-39"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-39">&#182;</a></div><p>Implemented only for 1MB Flash parts.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">FLASH_PART_SST25VF080B</span> <span class="o">==</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashID</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-40"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-40">&#182;</a></div><p>Get Current BP status.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_STATUS_REG_READ</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
		<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-41"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-41">&#182;</a></div><p>Read status will be WWXXYYZZ. We have to take only WW.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_READQ_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ulStatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ulStatus</span><span class="p">));</span>
		<span class="n">ulStatus</span> <span class="o">&gt;&gt;=</span> <span class="mi">24</span><span class="p">;</span>
		<span class="n">ulWriteStatus</span> <span class="o">=</span> <span class="n">ulStatus</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-42"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-42">&#182;</a></div><p>Bits [5-2] give current block level protection status.
Bit5: BP3 - DONT CARE
BP2-BP0: 0 - NO PROTECTION, 1 - UPPER 1/16, 2 - UPPER 1/8, 3 - UPPER 1/4
               4 - UPPER 1/2. 5 to 7 - ALL BLOCKS</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">ulStatus</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">((</span><span class="n">uiOffset</span><span class="o">+</span><span class="n">uiLength</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0x80000</span><span class="p">)</span>
			<span class="p">{</span></pre></div></td></tr>


<tr id="section-43"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-43">&#182;</a></div><p>Offset comes in lower half of 1MB. Protect the upper half.
Clear BP1 and BP0 and set BP2.</p></td><td class="code"><div class="highlight"><pre>				<span class="n">ulWriteStatus</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x4</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>
				<span class="n">ulWriteStatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">uiOffset</span><span class="o">+</span><span class="n">uiLength</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0xC0000</span><span class="p">)</span>
			<span class="p">{</span></pre></div></td></tr>


<tr id="section-44"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-44">&#182;</a></div><p>Offset comes below Upper 1/4. Upper 1/4 can be protected.
 Clear BP2 and set BP1 and BP0.</p></td><td class="code"><div class="highlight"><pre>				<span class="n">ulWriteStatus</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x3</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>
				<span class="n">ulWriteStatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">uiOffset</span><span class="o">+</span><span class="n">uiLength</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0xE0000</span><span class="p">)</span>
		    <span class="p">{</span></pre></div></td></tr>


<tr id="section-45"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-45">&#182;</a></div><p>Offset comes below Upper 1/8. Upper 1/8 can be protected.
Clear BP2 and BP0  and set BP1</p></td><td class="code"><div class="highlight"><pre>		    	<span class="n">ulWriteStatus</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>
		    	<span class="n">ulWriteStatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x5</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>

		    <span class="p">}</span>
		    <span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">uiOffset</span><span class="o">+</span><span class="n">uiLength</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0xF0000</span><span class="p">)</span>
		    <span class="p">{</span></pre></div></td></tr>


<tr id="section-46"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-46">&#182;</a></div><p>Offset comes below Upper 1/16. Only upper 1/16 can be protected.
Set BP0 and Clear BP2,BP1.</p></td><td class="code"><div class="highlight"><pre>		    	<span class="n">ulWriteStatus</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>
		    	<span class="n">ulWriteStatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>
		    <span class="p">}</span>
		    <span class="k">else</span>
		    <span class="p">{</span></pre></div></td></tr>


<tr id="section-47"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-47">&#182;</a></div><p>Unblock all.
Clear BP2,BP1 and BP0.</p></td><td class="code"><div class="highlight"><pre>		    	<span class="n">ulWriteStatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x7</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>
		    <span class="p">}</span>

			<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_WRITE_ENABLE</span><span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
			<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
			<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_STATUS_REG_WRITE</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">ulWriteStatus</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ulStatus</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-48"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-48">&#182;</a></div><hr />

<p>Procedure:    BeceemFlashBulkWrite</p>

<p>Description: Performs write to the flash</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
    pBuffer     - Data to be written.
    uiOffset   - Offset of the flash where data needs to be written to.
    uiNumBytes - Number of bytes to be written.
    bVerify    - read verify flag.
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">BeceemFlashBulkWrite</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">,</span>
	<span class="n">BOOLEAN</span> <span class="n">bVerify</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PCHAR</span>  <span class="n">pTempBuff</span> 			<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">PUCHAR</span> <span class="n">pcBuffer</span>             <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiIndex</span>				<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiOffsetFromSectStart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiSectAlignAddr</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiCurrSectOffsetAddr</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiSectBoundary</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiNumSectTobeRead</span> 	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">ucReadBk</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>       	<span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">ULONG</span> <span class="n">ulStatus</span>              <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INT</span> <span class="n">Status</span> 					<span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiTemp</span> 				<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">index</span> 					<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiPartOffset</span> 			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if defined(BCM_SHM_INTERFACE) &amp;&amp; !defined(FLASH_DIRECT_ACCESS)</span>
  <span class="n">Status</span> <span class="o">=</span> <span class="n">bcmflash_raw_write</span><span class="p">((</span><span class="n">uiOffset</span><span class="o">/</span><span class="n">FLASH_PART_SIZE</span><span class="p">),(</span><span class="n">uiOffset</span> <span class="o">%</span> <span class="n">FLASH_PART_SIZE</span><span class="p">),(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">uiOffsetFromSectStart</span> 	<span class="o">=</span> <span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-49"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-49">&#182;</a></div><p>Adding flash Base address
uiOffset = uiOffset + GetFlashBaseAddr(Adapter);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">uiSectAlignAddr</span>   		<span class="o">=</span> <span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">uiCurrSectOffsetAddr</span>	<span class="o">=</span> <span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">uiSectBoundary</span>	  		<span class="o">=</span> <span class="n">uiSectAlignAddr</span> <span class="o">+</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>

	<span class="n">pTempBuff</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pTempBuff</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">BeceemFlashBulkWrite_EXIT</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-50"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-50">&#182;</a></div><p>check if the data to be written is overlapped across sectors</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">uiOffset</span><span class="o">+</span><span class="n">uiNumBytes</span> <span class="o">&lt;</span> <span class="n">uiSectBoundary</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">uiNumSectTobeRead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-51"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-51">&#182;</a></div><pre><code> Number of sectors  = Last sector start address/First sector start address
</code></pre></td><td class="code"><div class="highlight"><pre>		<span class="n">uiNumSectTobeRead</span> <span class="o">=</span>  <span class="p">(</span><span class="n">uiCurrSectOffsetAddr</span><span class="o">+</span><span class="n">uiNumBytes</span><span class="p">)</span><span class="o">/</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
		<span class="k">if</span><span class="p">((</span><span class="n">uiCurrSectOffsetAddr</span><span class="o">+</span><span class="n">uiNumBytes</span><span class="p">)</span><span class="o">%</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">uiNumSectTobeRead</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-52"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-52">&#182;</a></div><p>Check whether Requested sector is writable or not in case of flash2x write. But if  write call is
for DSD calibration, allow it without checking of sector permission</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">IsFlash2x</span><span class="p">(</span><span class="n">Adapter</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bAllDSDWriteAllow</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">uiTemp</span> <span class="o">=</span> <span class="n">uiNumSectTobeRead</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">)</span>
		<span class="p">{</span>
			 <span class="k">if</span><span class="p">(</span><span class="n">IsOffsetWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">uiOffsetFromSectStart</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
			 <span class="p">{</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Sector Starting at offset &lt;0X%X&gt; is not writable&quot;</span><span class="p">,</span>
											<span class="p">(</span><span class="n">uiOffsetFromSectStart</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">));</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="n">SECTOR_IS_NOT_WRITABLE</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">BeceemFlashBulkWrite_EXIT</span><span class="p">;</span>
			 <span class="p">}</span>
			 <span class="n">uiTemp</span> <span class="o">=</span> <span class="n">uiTemp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			 <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">=</span> <span class="n">RESET_CHIP_SELECT</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">uiNumSectTobeRead</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-53"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-53">&#182;</a></div><p>do<em>gettimeofday(&amp;tv1);
BCM</em>DEBUG<em>PRINT(Adapter,DBG</em>TYPE<em>PRINTK, 0, 0, "\nTime In start of write :%ld ms\n",(tv1.tv</em>sec *1000 + tv1.tv_usec /1000));</p></td><td class="code"><div class="highlight"><pre>		<span class="n">uiPartOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">uiSectAlignAddr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FLASH_PART_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">GetFlashBaseAddr</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

		<span class="n">BcmDoChipSelect</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiSectAlignAddr</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
						<span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pTempBuff</span><span class="p">,</span>
						<span class="n">uiOffsetFromSectStart</span><span class="p">,</span>
						<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">BeceemFlashBulkWrite_EXIT</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-54"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-54">&#182;</a></div><p>do<em>gettimeofday(&amp;tr);
BCM</em>DEBUG<em>PRINT(Adapter,DBG</em>TYPE<em>PRINTK, 0, 0, "Total time taken by Read :%ld ms\n", (tr.tv</em>sec *1000 + tr.tv<em>usec/1000) - (tv1.tv</em>sec *1000 + tv1.tv_usec/1000));</p></td><td class="code"><div class="highlight"><pre>		<span class="n">ulStatus</span> <span class="o">=</span> <span class="n">BcmFlashUnProtectBlock</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiSectAlignAddr</span><span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">);</span>


		<span class="k">if</span><span class="p">(</span><span class="n">uiNumSectTobeRead</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiCurrSectOffsetAddr</span><span class="p">],</span><span class="n">pcBuffer</span><span class="p">,</span><span class="n">uiSectBoundary</span><span class="o">-</span><span class="p">(</span><span class="n">uiSectAlignAddr</span><span class="o">+</span><span class="n">uiCurrSectOffsetAddr</span><span class="p">));</span>
			<span class="n">pcBuffer</span> <span class="o">+=</span> <span class="p">((</span><span class="n">uiSectBoundary</span><span class="o">-</span><span class="p">(</span><span class="n">uiSectAlignAddr</span><span class="o">+</span><span class="n">uiCurrSectOffsetAddr</span><span class="p">)));</span>
			<span class="n">uiNumBytes</span> <span class="o">-=</span> <span class="p">(</span><span class="n">uiSectBoundary</span><span class="o">-</span><span class="p">(</span><span class="n">uiSectAlignAddr</span><span class="o">+</span><span class="n">uiCurrSectOffsetAddr</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiCurrSectOffsetAddr</span><span class="p">],</span><span class="n">pcBuffer</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span><span class="n">IsFlash2x</span><span class="p">(</span><span class="n">Adapter</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">SaveHeaderIfPresent</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pTempBuff</span><span class="p">,</span><span class="n">uiOffsetFromSectStart</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">FlashSectorErase</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiPartOffset</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-55"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-55">&#182;</a></div><p>do<em>gettimeofday(&amp;te);
BCM</em>DEBUG<em>PRINT(Adapter,DBG</em>TYPE<em>PRINTK, 0, 0, "Total time taken by Erase :%ld ms\n", (te.tv</em>sec *1000 + te.tv<em>usec/1000) - (tr.tv</em>sec *1000 + tr.tv_usec/1000));</p></td><td class="code"><div class="highlight"><pre>		<span class="k">for</span><span class="p">(</span><span class="n">uiIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uiIndex</span> <span class="o">&lt;</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span> <span class="n">uiIndex</span> <span class="o">+=</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">BeceemFlashBulkWrite_EXIT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span><span class="p">(</span><span class="n">STATUS_SUCCESS</span> <span class="o">!=</span> <span class="p">(</span><span class="o">*</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWrite</span><span class="p">)(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiPartOffset</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,(</span><span class="o">&amp;</span><span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiIndex</span><span class="p">])))</span>
			<span class="p">{</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">BeceemFlashBulkWrite_EXIT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-56"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-56">&#182;</a></div><p>do<em>gettimeofday(&amp;tw);
BCM</em>DEBUG<em>PRINT(Adapter,DBG</em>TYPE<em>PRINTK, 0, 0, "Total time taken in Write  to Flash :%ld ms\n", (tw.tv</em>sec *1000 + tw.tv<em>usec/1000) - (te.tv</em>sec *1000 + te.tv_usec/1000));</p></td><td class="code"><div class="highlight"><pre>		<span class="k">for</span><span class="p">(</span><span class="n">uiIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">uiIndex</span> <span class="o">&lt;</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span><span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">MAX_RW_SIZE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">STATUS_SUCCESS</span> <span class="o">==</span> <span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">ucReadBk</span><span class="p">,</span><span class="n">uiOffsetFromSectStart</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">UINT</span> <span class="n">uiReadIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">for</span><span class="p">(</span><span class="n">uiReadIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uiReadIndex</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">uiReadIndex</span><span class="o">++</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="k">if</span><span class="p">(</span><span class="n">ucReadBk</span><span class="p">[</span><span class="n">uiReadIndex</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiIndex</span><span class="o">+</span><span class="n">uiReadIndex</span><span class="p">])</span>
						<span class="p">{</span>
							<span class="k">if</span><span class="p">(</span><span class="n">STATUS_SUCCESS</span> <span class="o">!=</span> <span class="p">(</span><span class="o">*</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWriteWithStatusCheck</span><span class="p">)(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiPartOffset</span><span class="o">+</span><span class="n">uiIndex</span><span class="o">+</span><span class="n">uiReadIndex</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiIndex</span><span class="o">+</span><span class="n">uiReadIndex</span><span class="p">]))</span>
							<span class="p">{</span>
								<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
								<span class="k">goto</span> <span class="n">BeceemFlashBulkWrite_EXIT</span><span class="p">;</span>
							<span class="p">}</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">else</span>
				<span class="p">{</span>
					<span class="k">if</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">ucReadBk</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiIndex</span><span class="p">],</span><span class="n">MAX_RW_SIZE</span><span class="p">))</span>
					<span class="p">{</span>
						<span class="k">if</span><span class="p">(</span><span class="n">STATUS_SUCCESS</span> <span class="o">!=</span> <span class="p">(</span><span class="o">*</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWriteWithStatusCheck</span><span class="p">)(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiPartOffset</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiIndex</span><span class="p">]))</span>
						<span class="p">{</span>
							<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
							<span class="k">goto</span> <span class="n">BeceemFlashBulkWrite_EXIT</span><span class="p">;</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-57"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-57">&#182;</a></div><p>do<em>gettimeofday(&amp;twv);
BCM</em>DEBUG<em>PRINT(Adapter,DBG</em>TYPE<em>PRINTK, 0, 0, "Total time taken in Write  to Flash verification :%ld ms\n", (twv.tv</em>sec *1000 + twv.tv<em>usec/1000) - (tw.tv</em>sec *1000 + tw.tv_usec/1000));</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">ulStatus</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BcmRestoreBlockProtectStatus</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ulStatus</span><span class="p">);</span>
			<span class="n">ulStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uiCurrSectOffsetAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">uiSectAlignAddr</span> <span class="o">=</span> <span class="n">uiSectBoundary</span><span class="p">;</span>
		<span class="n">uiSectBoundary</span> <span class="o">+=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
		<span class="n">uiOffsetFromSectStart</span> <span class="o">+=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
		<span class="n">uiNumSectTobeRead</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-58"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-58">&#182;</a></div><p>do<em>gettimeofday(&amp;tv2);
BCM</em>DEBUG<em>PRINT(Adapter,DBG</em>TYPE<em>PRINTK, 0, 0, "Time after Write :%ld ms\n",(tv2.tv</em>sec *1000 + tv2.tv<em>usec/1000));
BCM</em>DEBUG<em>PRINT(Adapter,DBG</em>TYPE<em>PRINTK, 0, 0, "Total time taken by in Write is :%ld ms\n", (tv2.tv</em>sec *1000 + tv2.tv<em>usec/1000) - (tv1.tv</em>sec *1000 + tv1.tv_usec/1000));</p>

<p>Cleanup.</p></td><td class="code"><div class="highlight"><pre><span class="nl">BeceemFlashBulkWrite_EXIT:</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ulStatus</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BcmRestoreBlockProtectStatus</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ulStatus</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">kfree</span><span class="p">(</span><span class="n">pTempBuff</span><span class="p">);</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">=</span> <span class="n">RESET_CHIP_SELECT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-59"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-59">&#182;</a></div><hr />

<p>Procedure:    BeceemFlashBulkWriteStatus</p>

<p>Description: Writes to Flash. Checks the SPI status after each write.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
    pBuffer     - Data to be written.
    uiOffset   - Offset of the flash where data needs to be written to.
    uiNumBytes - Number of bytes to be written.
    bVerify    - read verify flag.
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">BeceemFlashBulkWriteStatus</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">,</span>
	<span class="n">BOOLEAN</span> <span class="n">bVerify</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PCHAR</span>  <span class="n">pTempBuff</span> 			<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">PUCHAR</span> <span class="n">pcBuffer</span>             <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiIndex</span>				<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiOffsetFromSectStart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiSectAlignAddr</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiCurrSectOffsetAddr</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiSectBoundary</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiNumSectTobeRead</span> 	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">ucReadBk</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>			<span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">ULONG</span> <span class="n">ulStatus</span>              <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">Status</span>				<span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiTemp</span> 				<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">index</span> 					<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiPartOffset</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">uiOffsetFromSectStart</span> 	<span class="o">=</span> <span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-60"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-60">&#182;</a></div><p>uiOffset += Adapter->ulFlashCalStart;
Adding flash Base address
uiOffset = uiOffset + GetFlashBaseAddr(Adapter);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">uiSectAlignAddr</span> 		<span class="o">=</span> <span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">uiCurrSectOffsetAddr</span>	<span class="o">=</span> <span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">uiSectBoundary</span>			<span class="o">=</span> <span class="n">uiSectAlignAddr</span> <span class="o">+</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>

	<span class="n">pTempBuff</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pTempBuff</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">BeceemFlashBulkWriteStatus_EXIT</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-61"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-61">&#182;</a></div><p>check if the data to be written is overlapped across sectors</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">uiOffset</span><span class="o">+</span><span class="n">uiNumBytes</span> <span class="o">&lt;</span> <span class="n">uiSectBoundary</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">uiNumSectTobeRead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-62"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-62">&#182;</a></div><pre><code> Number of sectors  = Last sector start address/First sector start address
</code></pre></td><td class="code"><div class="highlight"><pre>		<span class="n">uiNumSectTobeRead</span> <span class="o">=</span>  <span class="p">(</span><span class="n">uiCurrSectOffsetAddr</span><span class="o">+</span><span class="n">uiNumBytes</span><span class="p">)</span><span class="o">/</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
		<span class="k">if</span><span class="p">((</span><span class="n">uiCurrSectOffsetAddr</span><span class="o">+</span><span class="n">uiNumBytes</span><span class="p">)</span><span class="o">%</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">uiNumSectTobeRead</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">IsFlash2x</span><span class="p">(</span><span class="n">Adapter</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bAllDSDWriteAllow</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">uiTemp</span> <span class="o">=</span> <span class="n">uiNumSectTobeRead</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">)</span>
		<span class="p">{</span>
			 <span class="k">if</span><span class="p">(</span><span class="n">IsOffsetWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiOffsetFromSectStart</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
			 <span class="p">{</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Sector Starting at offset &lt;0X%x&gt; is not writable&quot;</span><span class="p">,</span>
											<span class="p">(</span><span class="n">uiOffsetFromSectStart</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">));</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="n">SECTOR_IS_NOT_WRITABLE</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">BeceemFlashBulkWriteStatus_EXIT</span><span class="p">;</span>
			 <span class="p">}</span>
			 <span class="n">uiTemp</span> <span class="o">=</span> <span class="n">uiTemp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			 <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">=</span> <span class="n">RESET_CHIP_SELECT</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">uiNumSectTobeRead</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">uiPartOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">uiSectAlignAddr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FLASH_PART_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">GetFlashBaseAddr</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

		<span class="n">BcmDoChipSelect</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiSectAlignAddr</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
						<span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pTempBuff</span><span class="p">,</span>
						<span class="n">uiOffsetFromSectStart</span><span class="p">,</span>
						<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">BeceemFlashBulkWriteStatus_EXIT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ulStatus</span> <span class="o">=</span> <span class="n">BcmFlashUnProtectBlock</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiOffsetFromSectStart</span><span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiNumSectTobeRead</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiCurrSectOffsetAddr</span><span class="p">],</span><span class="n">pcBuffer</span><span class="p">,</span><span class="n">uiSectBoundary</span><span class="o">-</span><span class="p">(</span><span class="n">uiSectAlignAddr</span><span class="o">+</span><span class="n">uiCurrSectOffsetAddr</span><span class="p">));</span>
			<span class="n">pcBuffer</span> <span class="o">+=</span> <span class="p">((</span><span class="n">uiSectBoundary</span><span class="o">-</span><span class="p">(</span><span class="n">uiSectAlignAddr</span><span class="o">+</span><span class="n">uiCurrSectOffsetAddr</span><span class="p">)));</span>
			<span class="n">uiNumBytes</span> <span class="o">-=</span> <span class="p">(</span><span class="n">uiSectBoundary</span><span class="o">-</span><span class="p">(</span><span class="n">uiSectAlignAddr</span><span class="o">+</span><span class="n">uiCurrSectOffsetAddr</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiCurrSectOffsetAddr</span><span class="p">],</span><span class="n">pcBuffer</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span><span class="n">IsFlash2x</span><span class="p">(</span><span class="n">Adapter</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">SaveHeaderIfPresent</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pTempBuff</span><span class="p">,</span><span class="n">uiOffsetFromSectStart</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">FlashSectorErase</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiPartOffset</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

		<span class="k">for</span><span class="p">(</span><span class="n">uiIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uiIndex</span> <span class="o">&lt;</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span> <span class="n">uiIndex</span> <span class="o">+=</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span><span class="p">)</span>

		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">BeceemFlashBulkWriteStatus_EXIT</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span><span class="p">(</span><span class="n">STATUS_SUCCESS</span> <span class="o">!=</span> <span class="p">(</span><span class="o">*</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWriteWithStatusCheck</span><span class="p">)(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiPartOffset</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiIndex</span><span class="p">]))</span>
			<span class="p">{</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">BeceemFlashBulkWriteStatus_EXIT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span><span class="n">bVerify</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span><span class="p">(</span><span class="n">uiIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">uiIndex</span> <span class="o">&lt;</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span><span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">MAX_RW_SIZE</span><span class="p">)</span>
			<span class="p">{</span>

				<span class="k">if</span><span class="p">(</span><span class="n">STATUS_SUCCESS</span> <span class="o">==</span> <span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">ucReadBk</span><span class="p">,</span><span class="n">uiOffsetFromSectStart</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">))</span>
				<span class="p">{</span>
					<span class="k">if</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">ucReadBk</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pTempBuff</span><span class="p">[</span><span class="n">uiIndex</span><span class="p">],</span><span class="n">MAX_RW_SIZE</span><span class="p">))</span>
					<span class="p">{</span>
						<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
						<span class="k">goto</span> <span class="n">BeceemFlashBulkWriteStatus_EXIT</span><span class="p">;</span>
					<span class="p">}</span>

				<span class="p">}</span>

			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span><span class="n">ulStatus</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BcmRestoreBlockProtectStatus</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ulStatus</span><span class="p">);</span>
			<span class="n">ulStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uiCurrSectOffsetAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">uiSectAlignAddr</span> <span class="o">=</span> <span class="n">uiSectBoundary</span><span class="p">;</span>
		<span class="n">uiSectBoundary</span> <span class="o">+=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
		<span class="n">uiOffsetFromSectStart</span> <span class="o">+=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
		<span class="n">uiNumSectTobeRead</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-63"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-63">&#182;</a></div><p>Cleanup.</p></td><td class="code"><div class="highlight"><pre><span class="nl">BeceemFlashBulkWriteStatus_EXIT:</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ulStatus</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BcmRestoreBlockProtectStatus</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ulStatus</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pTempBuff</span><span class="p">);</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">=</span> <span class="n">RESET_CHIP_SELECT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>

<span class="p">}</span></pre></div></td></tr>


<tr id="section-64"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-64">&#182;</a></div><hr />

<p>Procedure:    PropagateCalParamsFromEEPROMToMemory</p>

<p>Description: Dumps the calibration section of EEPROM to DDR.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="n">INT</span> <span class="nf">PropagateCalParamsFromEEPROMToMemory</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PCHAR</span> <span class="n">pBuff</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">BUFFER_4K</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">UINT</span> <span class="n">uiEepromSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiBytesToCopy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiCalStartAddr</span> <span class="o">=</span> <span class="n">EEPROM_CALPARAM_START</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiMemoryLoc</span> <span class="o">=</span> <span class="n">EEPROM_CAL_DATA_INTERNAL_LOC</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pBuff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiEepromSize</span><span class="p">,</span><span class="n">EEPROM_SIZE_OFFSET</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
	<span class="p">{</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">pBuff</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uiEepromSize</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">uiEepromSize</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pBuff</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">uiBytesToCopy</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">BUFFER_4K</span><span class="p">,</span><span class="n">uiEepromSize</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="n">uiBytesToCopy</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pBuff</span><span class="p">,</span><span class="n">uiCalStartAddr</span><span class="p">,</span><span class="n">uiBytesToCopy</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wrm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiMemoryLoc</span><span class="p">,(</span><span class="n">PCHAR</span><span class="p">)(((</span><span class="n">PULONG</span><span class="p">)</span><span class="n">pBuff</span><span class="p">)</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">),</span><span class="n">uiBytesToCopy</span><span class="p">);</span>
		<span class="n">uiMemoryLoc</span> <span class="o">+=</span> <span class="n">uiBytesToCopy</span><span class="p">;</span>
		<span class="n">uiEepromSize</span> <span class="o">-=</span> <span class="n">uiBytesToCopy</span><span class="p">;</span>
		<span class="n">uiCalStartAddr</span> <span class="o">+=</span> <span class="n">uiBytesToCopy</span><span class="p">;</span>
		<span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">uiBytesToCopy</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">uiBytesToCopy</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">BUFFER_4K</span><span class="p">,</span><span class="n">uiEepromSize</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="n">value</span> <span class="o">=</span> <span class="mh">0xbeadbead</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_CAL_DATA_INTERNAL_LOC</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
	<span class="n">value</span> <span class="o">=</span> <span class="mh">0xbeadbead</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_CAL_DATA_INTERNAL_LOC</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pBuff</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>

<span class="p">}</span></pre></div></td></tr>


<tr id="section-65"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-65">&#182;</a></div><hr />

<p>Procedure:    PropagateCalParamsFromFlashToMemory</p>

<p>Description: Dumps the calibration section of EEPROM to DDR.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="n">INT</span> <span class="nf">PropagateCalParamsFromFlashToMemory</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PCHAR</span> <span class="n">pBuff</span><span class="p">,</span> <span class="n">pPtr</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiEepromSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiBytesToCopy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-66"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-66">&#182;</a></div><p>UINT uiIndex = 0;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">UINT</span> <span class="n">uiCalStartAddr</span> <span class="o">=</span> <span class="n">EEPROM_CALPARAM_START</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiMemoryLoc</span> <span class="o">=</span> <span class="n">EEPROM_CAL_DATA_INTERNAL_LOC</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-67"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-67">&#182;</a></div><p>Write the signature first. This will ensure firmware does not access EEPROM.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">value</span> <span class="o">=</span> <span class="mh">0xbeadbead</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_CAL_DATA_INTERNAL_LOC</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
	<span class="n">value</span> <span class="o">=</span> <span class="mh">0xbeadbead</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_CAL_DATA_INTERNAL_LOC</span> <span class="o">-</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">BeceemNVMRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiEepromSize</span><span class="p">,</span><span class="n">EEPROM_SIZE_OFFSET</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">uiEepromSize</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">uiEepromSize</span><span class="p">);</span>
	<span class="n">uiEepromSize</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-68"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-68">&#182;</a></div><p>subtract the auto init section size</p></td><td class="code"><div class="highlight"><pre>	<span class="n">uiEepromSize</span> <span class="o">-=</span> <span class="n">EEPROM_CALPARAM_START</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">uiEepromSize</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pBuff</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">uiEepromSize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">pBuff</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">BeceemNVMRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pBuff</span><span class="p">,</span><span class="n">uiCalStartAddr</span><span class="p">,</span> <span class="n">uiEepromSize</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pBuff</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pPtr</span> <span class="o">=</span> <span class="n">pBuff</span><span class="p">;</span>

	<span class="n">uiBytesToCopy</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">BUFFER_4K</span><span class="p">,</span><span class="n">uiEepromSize</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="n">uiBytesToCopy</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="n">wrm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiMemoryLoc</span><span class="p">,(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">pPtr</span><span class="p">,</span><span class="n">uiBytesToCopy</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;wrm failed with status :%d&quot;</span><span class="p">,</span><span class="n">Status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pPtr</span> <span class="o">+=</span> <span class="n">uiBytesToCopy</span><span class="p">;</span>
		<span class="n">uiEepromSize</span> <span class="o">-=</span> <span class="n">uiBytesToCopy</span><span class="p">;</span>
		<span class="n">uiMemoryLoc</span> <span class="o">+=</span> <span class="n">uiBytesToCopy</span><span class="p">;</span>
		<span class="n">uiBytesToCopy</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">BUFFER_4K</span><span class="p">,</span><span class="n">uiEepromSize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pBuff</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>

<span class="p">}</span></pre></div></td></tr>


<tr id="section-69"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-69">&#182;</a></div><hr />

<p>Procedure:    BeceemEEPROMReadBackandVerify</p>

<p>Description: Read back the data written and verifies.</p>

<p>Arguments:
    Adapter       - ptr to Adapter object instance
    pBuffer         - Data to be written.
    uiOffset       - Offset of the flash where data needs to be written to.
    uiNumBytes - Number of bytes to be written.
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">BeceemEEPROMReadBackandVerify</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiRdbk</span>  	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiIndex</span> 	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiData</span>  	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">auiData</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

	<span class="k">while</span><span class="p">(</span><span class="n">uiNumBytes</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiNumBytes</span> <span class="o">&gt;=</span> <span class="n">MAX_RW_SIZE</span><span class="p">)</span>
		<span class="p">{</span><span class="c1">// for the requests more than or equal to MAX_RW_SIZE bytes, use bulk read function to make the access faster.</span>
			<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">auiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uiOffset</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>

			<span class="k">if</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">[</span><span class="n">uiIndex</span><span class="p">],</span><span class="o">&amp;</span><span class="n">auiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">MAX_RW_SIZE</span><span class="p">))</span>
			<span class="p">{</span></pre></div></td></tr>


<tr id="section-70"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-70">&#182;</a></div><p>re-write</p></td><td class="code"><div class="highlight"><pre>				<span class="n">BeceemEEPROMBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUCHAR</span><span class="p">)(</span><span class="n">pBuffer</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">),</span><span class="n">uiOffset</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">,</span><span class="n">FALSE</span><span class="p">);</span>
				<span class="n">mdelay</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
				<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">auiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uiOffset</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>

				<span class="k">if</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">[</span><span class="n">uiIndex</span><span class="p">],</span><span class="o">&amp;</span><span class="n">auiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">MAX_RW_SIZE</span><span class="p">))</span>
				<span class="p">{</span>
					<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">uiOffset</span> <span class="o">+=</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span>
			<span class="n">uiNumBytes</span> <span class="o">-=</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span>
			<span class="n">uiIndex</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">uiNumBytes</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">uiData</span> <span class="o">!=</span> <span class="n">pBuffer</span><span class="p">[</span><span class="n">uiIndex</span><span class="p">])</span>
			<span class="p">{</span></pre></div></td></tr>


<tr id="section-71"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-71">&#182;</a></div><p>re-write</p></td><td class="code"><div class="highlight"><pre>				<span class="n">BeceemEEPROMBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUCHAR</span><span class="p">)(</span><span class="n">pBuffer</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">),</span><span class="n">uiOffset</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">FALSE</span><span class="p">);</span>
				<span class="n">mdelay</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
				<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">uiData</span> <span class="o">!=</span> <span class="n">pBuffer</span><span class="p">[</span><span class="n">uiIndex</span><span class="p">])</span>
				<span class="p">{</span>
					<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">uiOffset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">uiNumBytes</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">uiIndex</span><span class="o">++</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span> <span class="c1">// Handle the reads less than 4 bytes...</span>
			<span class="n">uiData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">,((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">uiIndex</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">UINT</span><span class="p">)),</span><span class="n">uiNumBytes</span><span class="p">);</span>
			<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiRdbk</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>

			<span class="k">if</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiRdbk</span><span class="p">,</span> <span class="n">uiNumBytes</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="n">uiNumBytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">VOID</span> <span class="nf">BcmSwapWord</span><span class="p">(</span><span class="n">UINT</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">UINT</span>  <span class="n">tempval</span> <span class="o">=</span> <span class="p">(</span><span class="n">UINT</span><span class="p">)</span><span class="o">*</span><span class="n">ptr1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tempval</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr1</span><span class="p">;</span>

	<span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-72"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-72">&#182;</a></div><hr />

<p>Procedure:    BeceemEEPROMWritePage</p>

<p>Description: Performs page write (16bytes) to the EEPROM</p>

<p>Arguments:
    Adapter       - ptr to Adapter object instance
    uiData        - Data to be written.
    uiOffset      - Offset of the EEPROM where data needs to be written to.
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">BeceemEEPROMWritePage</span><span class="p">(</span> <span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">uiData</span><span class="p">[],</span> <span class="n">UINT</span> <span class="n">uiOffset</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiRetries</span> <span class="o">=</span> <span class="n">MAX_EEPROM_RETRIES</span><span class="o">*</span><span class="n">RETRIES_PER_DELAY</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UCHAR</span> <span class="n">uiEpromStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value</span> <span class="o">=</span><span class="mi">0</span> <span class="p">;</span>

	<span class="cm">/* Flush the Write/Read/Cmd queues. */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span> <span class="n">EEPROM_WRITE_QUEUE_FLUSH</span> <span class="o">|</span> <span class="n">EEPROM_CMD_QUEUE_FLUSH</span> <span class="o">|</span> <span class="n">EEPROM_READ_QUEUE_FLUSH</span> <span class="p">);</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">SPI_FLUSH_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
	<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">SPI_FLUSH_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">);</span>

	<span class="cm">/* Clear the Empty/Avail/Full bits.  After this it has been confirmed</span>
<span class="cm">	 * that the bit was cleared by reading back the register. See NOTE below.</span>
<span class="cm">	 * We also clear the Read queues as we do a EEPROM status register read</span>
<span class="cm">	 * later. */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span> <span class="n">EEPROM_WRITE_QUEUE_EMPTY</span> <span class="o">|</span> <span class="n">EEPROM_WRITE_QUEUE_AVAIL</span> <span class="o">|</span> <span class="n">EEPROM_WRITE_QUEUE_FULL</span> <span class="o">|</span> <span class="n">EEPROM_READ_DATA_AVAIL</span> <span class="o">|</span> <span class="n">EEPROM_READ_DATA_FULL</span> <span class="p">)</span> <span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="cm">/* Enable write */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">EEPROM_WRITE_ENABLE</span> <span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_CMDQ_SPI_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">);</span>

	<span class="cm">/* We can write back to back 8bits * 16 into the queue and as we have</span>
<span class="cm">	 * checked for the queue to be empty we can write in a burst. */</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">BcmSwapWord</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">wrm</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_WRITE_DATAQ_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">uiData</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">BcmSwapWord</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">wrm</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_WRITE_DATAQ_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">uiData</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">BcmSwapWord</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">wrm</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_WRITE_DATAQ_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">uiData</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">BcmSwapWord</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">wrm</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_WRITE_DATAQ_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* NOTE : After this write, on readback of EEPROM_SPI_Q_STATUS1_REG</span>
<span class="cm">	 * shows that we see 7 for the EEPROM data write.  Which means that</span>
<span class="cm">	 * queue got full, also space is available as well as the queue is empty.</span>
<span class="cm">	 * This may happen in sequence. */</span>
	<span class="n">value</span> <span class="o">=</span>  <span class="n">EEPROM_16_BYTE_PAGE_WRITE</span> <span class="o">|</span> <span class="n">uiOffset</span> <span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_CMDQ_SPI_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">);</span>

	<span class="cm">/* Ideally we should loop here without tries and eventually succeed.</span>
<span class="cm">	 * What we are checking if the previous write has completed, and this</span>
<span class="cm">	 * may take time. We should wait till the Empty bit is set. */</span>
	<span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiStatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiStatus</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">(</span> <span class="p">(</span> <span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="n">EEPROM_WRITE_QUEUE_EMPTY</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">uiRetries</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">uiRetries</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;0x0f003004 = %x, %d retries failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uiStatus</span><span class="p">,</span> <span class="n">MAX_EEPROM_RETRIES</span> <span class="o">*</span><span class="n">RETRIES_PER_DELAY</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span> <span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">uiRetries</span><span class="o">%</span><span class="n">RETRIES_PER_DELAY</span><span class="p">)</span> <span class="p">)</span>
					<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">uiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiStatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiStatus</span><span class="p">));</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Modem got removed hence exiting from loop....&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">uiRetries</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Clear the ones that are set - either, Empty/Full/Avail bits */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span> <span class="n">uiStatus</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">EEPROM_WRITE_QUEUE_EMPTY</span> <span class="o">|</span> <span class="n">EEPROM_WRITE_QUEUE_AVAIL</span> <span class="o">|</span> <span class="n">EEPROM_WRITE_QUEUE_FULL</span> <span class="p">)</span> <span class="p">);</span>
		<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Here we should check if the EEPROM status register is correct before</span>
<span class="cm">	 * proceeding. Bit 0 in the EEPROM Status register should be 0 before</span>
<span class="cm">	 * we proceed further.  A 1 at Bit 0 indicates that the EEPROM is busy</span>
<span class="cm">	 * with the previous write. Note also that issuing this read finally</span>
<span class="cm">	 * means the previous write to the EEPROM has completed. */</span>
	<span class="n">uiRetries</span> <span class="o">=</span> <span class="n">MAX_EEPROM_RETRIES</span><span class="o">*</span><span class="n">RETRIES_PER_DELAY</span><span class="p">;</span>
	<span class="n">uiEpromStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span> <span class="n">uiRetries</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">uiEpromStatus</span> <span class="o">=</span> <span class="n">ReadEEPROMStatusRegister</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Modem has got removed hence exiting from loop...&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">EEPROM_STATUS_REG_WRITE_BUSY</span> <span class="o">&amp;</span> <span class="n">uiEpromStatus</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;EEPROM status register = %x tries = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uiEpromStatus</span><span class="p">,</span> <span class="p">(</span><span class="n">MAX_EEPROM_RETRIES</span> <span class="o">*</span> <span class="n">RETRIES_PER_DELAY</span><span class="o">-</span> <span class="n">uiRetries</span><span class="p">)</span> <span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">uiRetries</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">uiRetries</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;0x0f003004 = %x, for EEPROM status read %d retries failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uiEpromStatus</span><span class="p">,</span> <span class="n">MAX_EEPROM_RETRIES</span> <span class="o">*</span><span class="n">RETRIES_PER_DELAY</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">uiEpromStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">uiRetries</span><span class="o">%</span><span class="n">RETRIES_PER_DELAY</span><span class="p">)</span> <span class="p">)</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
<span class="p">}</span> <span class="cm">/* BeceemEEPROMWritePage */</span></pre></div></td></tr>


<tr id="section-73"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-73">&#182;</a></div><hr />

<p>Procedure:    BeceemEEPROMBulkWrite</p>

<p>Description: Performs write to the EEPROM</p>

<p>Arguments:
    Adapter       - ptr to Adapter object instance
    pBuffer         - Data to be written.
    uiOffset       - Offset of the EEPROM where data needs to be written to.
    uiNumBytes - Number of bytes to be written.
    bVerify        - read verify flag.
Returns:
    OSAL<em>STATUS</em>CODE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="n">INT</span> <span class="nf">BeceemEEPROMBulkWrite</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUCHAR</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">,</span>
	<span class="n">BOOLEAN</span> <span class="n">bVerify</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span>  <span class="n">uiBytesToCopy</span> <span class="o">=</span> <span class="n">uiNumBytes</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-74"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-74">&#182;</a></div><p>UINT  uiRdbk         = 0;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">UINT</span>  <span class="n">uiData</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> 	<span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">UINT</span>  <span class="n">uiIndex</span> 		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiTempOffset</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span>  <span class="n">uiExtraBytes</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-75"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-75">&#182;</a></div><p>PUINT puiBuffer     = (PUINT)pBuffer;
INT value;</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">uiOffset</span><span class="o">%</span><span class="n">MAX_RW_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">uiBytesToCopy</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">uiTempOffset</span> <span class="o">=</span> <span class="n">uiOffset</span> <span class="o">-</span> <span class="p">(</span><span class="n">uiOffset</span><span class="o">%</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>
		<span class="n">uiExtraBytes</span> <span class="o">=</span> <span class="n">uiOffset</span><span class="o">-</span><span class="n">uiTempOffset</span><span class="p">;</span>


		<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uiTempOffset</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiBytesToCopy</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">-</span><span class="n">uiExtraBytes</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">memcpy</span><span class="p">((((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">uiExtraBytes</span><span class="p">),</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="o">-</span> <span class="n">uiExtraBytes</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span> <span class="n">STATUS_FAILURE</span> <span class="o">==</span> <span class="n">BeceemEEPROMWritePage</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">uiData</span><span class="p">,</span> <span class="n">uiTempOffset</span> <span class="p">)</span> <span class="p">)</span>
					<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>

			<span class="n">uiBytesToCopy</span> <span class="o">-=</span> <span class="p">(</span><span class="n">MAX_RW_SIZE</span> <span class="o">-</span> <span class="n">uiExtraBytes</span><span class="p">);</span>
			<span class="n">uiIndex</span> <span class="o">+=</span> <span class="p">(</span><span class="n">MAX_RW_SIZE</span> <span class="o">-</span> <span class="n">uiExtraBytes</span><span class="p">);</span>
			<span class="n">uiOffset</span> <span class="o">+=</span> <span class="p">(</span><span class="n">MAX_RW_SIZE</span> <span class="o">-</span> <span class="n">uiExtraBytes</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">memcpy</span><span class="p">((((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">uiExtraBytes</span><span class="p">),</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">uiBytesToCopy</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span> <span class="n">STATUS_FAILURE</span> <span class="o">==</span> <span class="n">BeceemEEPROMWritePage</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">uiData</span><span class="p">,</span> <span class="n">uiTempOffset</span> <span class="p">)</span> <span class="p">)</span>
					<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>

			<span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">uiBytesToCopy</span><span class="p">;</span>
			<span class="n">uiOffset</span> <span class="o">+=</span> <span class="n">uiBytesToCopy</span><span class="p">;</span>
			<span class="n">uiBytesToCopy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>


	<span class="p">}</span>

	<span class="k">while</span><span class="p">(</span><span class="n">uiBytesToCopy</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiBytesToCopy</span> <span class="o">&gt;=</span> <span class="n">MAX_RW_SIZE</span><span class="p">)</span>
		<span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">STATUS_FAILURE</span> <span class="o">==</span> <span class="n">BeceemEEPROMWritePage</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">[</span><span class="n">uiIndex</span><span class="p">],</span> <span class="n">uiOffset</span> <span class="p">)</span> <span class="p">)</span>
						<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>

			<span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span>
			<span class="n">uiOffset</span> <span class="o">+=</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span>
			<span class="n">uiBytesToCopy</span>	<span class="o">-=</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span></pre></div></td></tr>


<tr id="section-76"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-76">&#182;</a></div><p>To program non 16byte aligned data, read 16byte and then update.</p></td><td class="code"><div class="highlight"><pre>			<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uiOffset</span><span class="p">,</span><span class="mi">16</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pBuffer</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,</span><span class="n">uiBytesToCopy</span><span class="p">);</span>


			<span class="k">if</span> <span class="p">(</span> <span class="n">STATUS_FAILURE</span> <span class="o">==</span> <span class="n">BeceemEEPROMWritePage</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">uiData</span><span class="p">,</span> <span class="n">uiOffset</span> <span class="p">)</span> <span class="p">)</span>
					<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
			<span class="n">uiBytesToCopy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-77"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-77">&#182;</a></div><hr />

<p>Procedure:    BeceemNVMRead</p>

<p>Description: Reads n number of bytes from NVM.</p>

<p>Arguments:
    Adapter      - ptr to Adapter object instance
    pBuffer       - Buffer to store the data read from NVM
    uiOffset       - Offset of NVM from where data should be read
    uiNumBytes - Number of bytes to be read from the NVM.</p>

<p>Returns:
    OSAL<em>STATUS</em>SUCCESS - if NVM read is successful.</p>

<h2>    <FAILURE>           - if failed.</h2></td><td class="code"><div class="highlight"><pre><span class="n">INT</span> <span class="nf">BeceemNVMRead</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#if !defined(BCM_SHM_INTERFACE) || defined(FLASH_DIRECT_ACCESS)</span>
	<span class="n">UINT</span> <span class="n">uiTemp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">==</span> <span class="n">NVM_FLASH</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bFlashRawRead</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IsSectionExistInVendorInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">vendorextnReadSection</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">);</span>
			<span class="n">uiOffset</span> <span class="o">=</span> <span class="n">uiOffset</span><span class="o">+</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span> <span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#if defined(BCM_SHM_INTERFACE) &amp;&amp; !defined(FLASH_DIRECT_ACCESS)</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="n">bcmflash_raw_read</span><span class="p">((</span><span class="n">uiOffset</span><span class="o">/</span><span class="n">FLASH_PART_SIZE</span><span class="p">),(</span><span class="n">uiOffset</span> <span class="o">%</span> <span class="n">FLASH_PART_SIZE</span><span class="p">),(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">);</span>
<span class="cp">#else</span>

		<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
		<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
						<span class="n">pBuffer</span><span class="p">,</span>
						<span class="n">uiOffset</span><span class="p">,</span>
						<span class="n">uiNumBytes</span><span class="p">);</span>
		<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">==</span> <span class="n">NVM_EEPROM</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
					<span class="n">pBuffer</span><span class="p">,</span>
					<span class="n">uiOffset</span><span class="p">,</span>
					<span class="n">uiNumBytes</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-78"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-78">&#182;</a></div><hr />

<p>Procedure:    BeceemNVMWrite</p>

<p>Description: Writes n number of bytes to NVM.</p>

<p>Arguments:
    Adapter      - ptr to Adapter object instance
    pBuffer       - Buffer contains the data to be written.
    uiOffset       - Offset of NVM where data to be written to.
    uiNumBytes - Number of bytes to be written..</p>

<p>Returns:
    OSAL<em>STATUS</em>SUCCESS - if NVM write is successful.</p>

<h2>    <FAILURE>           - if failed.</h2></td><td class="code"><div class="highlight"><pre><span class="n">INT</span> <span class="nf">BeceemNVMWrite</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">,</span>
	<span class="n">BOOLEAN</span> <span class="n">bVerify</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiTemp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiMemoryLoc</span> <span class="o">=</span> <span class="n">EEPROM_CAL_DATA_INTERNAL_LOC</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#if !defined(BCM_SHM_INTERFACE) || defined(FLASH_DIRECT_ACCESS)</span>
	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">UINT</span> <span class="n">uiFlashOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">==</span> <span class="n">NVM_FLASH</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IsSectionExistInVendorInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span><span class="p">))</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">vendorextnWriteSection</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">,</span><span class="n">bVerify</span><span class="p">);</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">uiFlashOffset</span> <span class="o">=</span> <span class="n">uiOffset</span> <span class="o">+</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span><span class="p">;</span>

<span class="cp">#if defined(BCM_SHM_INTERFACE) &amp;&amp; !defined(FLASH_DIRECT_ACCESS)</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">bcmflash_raw_write</span><span class="p">((</span><span class="n">uiFlashOffset</span><span class="o">/</span><span class="n">FLASH_PART_SIZE</span><span class="p">),</span> <span class="p">(</span><span class="n">uiFlashOffset</span> <span class="o">%</span> <span class="n">FLASH_PART_SIZE</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">);</span>
<span class="cp">#else</span>
			<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
			<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bStatusWrite</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="n">BeceemFlashBulkWriteStatus</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
							<span class="n">pBuffer</span><span class="p">,</span>
							<span class="n">uiFlashOffset</span><span class="p">,</span>
							<span class="n">uiNumBytes</span> <span class="p">,</span>
							<span class="n">bVerify</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>

				<span class="n">Status</span> <span class="o">=</span> <span class="n">BeceemFlashBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
							<span class="n">pBuffer</span><span class="p">,</span>
							<span class="n">uiFlashOffset</span><span class="p">,</span>
							<span class="n">uiNumBytes</span><span class="p">,</span>
							<span class="n">bVerify</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="p">}</span>


		<span class="k">if</span><span class="p">(</span><span class="n">uiOffset</span> <span class="o">&gt;=</span> <span class="n">EEPROM_CALPARAM_START</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">uiMemoryLoc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">uiOffset</span> <span class="o">-</span> <span class="n">EEPROM_CALPARAM_START</span><span class="p">);</span>
			<span class="k">while</span><span class="p">(</span><span class="n">uiNumBytes</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">uiNumBytes</span> <span class="o">&gt;</span> <span class="n">BUFFER_4K</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">wrm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">uiMemoryLoc</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">),(</span><span class="n">PCHAR</span><span class="p">)(</span><span class="n">pBuffer</span><span class="o">+</span><span class="p">(</span><span class="n">uiIndex</span><span class="o">/</span><span class="mi">4</span><span class="p">)),</span><span class="n">BUFFER_4K</span><span class="p">);</span>
					<span class="n">uiNumBytes</span> <span class="o">-=</span> <span class="n">BUFFER_4K</span><span class="p">;</span>
					<span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">BUFFER_4K</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">else</span>
				<span class="p">{</span>
					<span class="n">wrm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiMemoryLoc</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,(</span><span class="n">PCHAR</span><span class="p">)(</span><span class="n">pBuffer</span><span class="o">+</span><span class="p">(</span><span class="n">uiIndex</span><span class="o">/</span><span class="mi">4</span><span class="p">)),</span><span class="n">uiNumBytes</span><span class="p">);</span>
					<span class="n">uiNumBytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">((</span><span class="n">uiOffset</span><span class="o">+</span><span class="n">uiNumBytes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EEPROM_CALPARAM_START</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">ULONG</span> <span class="n">ulBytesTobeSkipped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">PUCHAR</span> <span class="n">pcBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">;</span><span class="c1">// char pointer to take care of odd byte cases.</span>
				<span class="n">uiNumBytes</span> <span class="o">-=</span> <span class="p">(</span><span class="n">EEPROM_CALPARAM_START</span> <span class="o">-</span> <span class="n">uiOffset</span><span class="p">);</span>
				<span class="n">ulBytesTobeSkipped</span> <span class="o">+=</span> <span class="p">(</span><span class="n">EEPROM_CALPARAM_START</span> <span class="o">-</span> <span class="n">uiOffset</span><span class="p">);</span>
				<span class="n">uiOffset</span> <span class="o">+=</span> <span class="p">(</span><span class="n">EEPROM_CALPARAM_START</span> <span class="o">-</span> <span class="n">uiOffset</span><span class="p">);</span>
				<span class="k">while</span><span class="p">(</span><span class="n">uiNumBytes</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">if</span><span class="p">(</span><span class="n">uiNumBytes</span> <span class="o">&gt;</span> <span class="n">BUFFER_4K</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">wrm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiMemoryLoc</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,(</span><span class="n">PCHAR</span> <span class="p">)</span><span class="o">&amp;</span><span class="n">pcBuffer</span><span class="p">[</span><span class="n">ulBytesTobeSkipped</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">],</span><span class="n">BUFFER_4K</span><span class="p">);</span>
						<span class="n">uiNumBytes</span> <span class="o">-=</span> <span class="n">BUFFER_4K</span><span class="p">;</span>
						<span class="n">uiIndex</span> <span class="o">+=</span> <span class="n">BUFFER_4K</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">else</span>
					<span class="p">{</span>
						<span class="n">wrm</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiMemoryLoc</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">,(</span><span class="n">PCHAR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pcBuffer</span><span class="p">[</span><span class="n">ulBytesTobeSkipped</span><span class="o">+</span><span class="n">uiIndex</span><span class="p">],</span><span class="n">uiNumBytes</span><span class="p">);</span>
						<span class="n">uiNumBytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>

			<span class="p">}</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-79"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-79">&#182;</a></div><p>restore the values.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="mh">0x0f000C80</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">==</span> <span class="n">NVM_EEPROM</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="n">BeceemEEPROMBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
					<span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">,</span>
					<span class="n">uiOffset</span><span class="p">,</span>
					<span class="n">uiNumBytes</span><span class="p">,</span>
					<span class="n">bVerify</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">bVerify</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">BeceemEEPROMReadBackandVerify</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-80"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-80">&#182;</a></div><hr />

<p>Procedure:    BcmUpdateSectorSize</p>

<p>Description: Updates the sector size to FLASH.</p>

<p>Arguments:
    Adapter       - ptr to Adapter object instance
         uiSectorSize - sector size</p>

<p>Returns:
    OSAL<em>STATUS</em>SUCCESS - if NVM write is successful.</p>

<h2>    <FAILURE>           - if failed.</h2></td><td class="code"><div class="highlight"><pre><span class="n">INT</span> <span class="nf">BcmUpdateSectorSize</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span><span class="n">UINT</span> <span class="n">uiSectorSize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">FLASH_CS_INFO</span> <span class="n">sFlashCsInfo</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">UINT</span> <span class="n">uiTemp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">UINT</span> <span class="n">uiSectorSig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiCurrentSectorSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>



	<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
	<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-81"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-81">&#182;</a></div><p>Before updating the sector size in the reserved area, check if already present.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sFlashCsInfo</span><span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashControlSectionStart</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sFlashCsInfo</span><span class="p">));</span>
	<span class="n">uiSectorSig</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sFlashCsInfo</span><span class="p">.</span><span class="n">FlashSectorSizeSig</span><span class="p">);</span>
	<span class="n">uiCurrentSectorSize</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sFlashCsInfo</span><span class="p">.</span><span class="n">FlashSectorSize</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">uiSectorSig</span> <span class="o">==</span> <span class="n">FLASH_SECTOR_SIZE_SIG</span><span class="p">)</span>
	<span class="p">{</span>

		<span class="k">if</span><span class="p">((</span><span class="n">uiCurrentSectorSize</span> <span class="o">&lt;=</span> <span class="n">MAX_SECTOR_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiCurrentSectorSize</span> <span class="o">&gt;=</span> <span class="n">MIN_SECTOR_SIZE</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">uiSectorSize</span> <span class="o">==</span> <span class="n">uiCurrentSectorSize</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Provided sector size is same as programmed in Flash&quot;</span><span class="p">);</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">Restore</span> <span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">((</span><span class="n">uiSectorSize</span> <span class="o">&lt;=</span> <span class="n">MAX_SECTOR_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiSectorSize</span> <span class="o">&gt;=</span> <span class="n">MIN_SECTOR_SIZE</span><span class="p">))</span>
	<span class="p">{</span>

		<span class="n">sFlashCsInfo</span><span class="p">.</span><span class="n">FlashSectorSize</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">uiSectorSize</span><span class="p">);</span>
		<span class="n">sFlashCsInfo</span><span class="p">.</span><span class="n">FlashSectorSizeSig</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">FLASH_SECTOR_SIZE_SIG</span><span class="p">);</span>

		<span class="n">Status</span> <span class="o">=</span> <span class="n">BeceemFlashBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
					<span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sFlashCsInfo</span><span class="p">,</span>
					<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashControlSectionStart</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sFlashCsInfo</span><span class="p">),</span>
					<span class="n">TRUE</span><span class="p">);</span>


	<span class="p">}</span>

	<span class="n">Restore</span> <span class="o">:</span></pre></div></td></tr>


<tr id="section-82"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-82">&#182;</a></div><p>restore the values.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>


	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>

<span class="p">}</span></pre></div></td></tr>


<tr id="section-83"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-83">&#182;</a></div><hr />

<p>Procedure:    BcmGetFlashSectorSize</p>

<p>Description: Finds the sector size of the FLASH.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance</p>

<p>Returns:
    UINT - sector size.</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">UINT</span> <span class="nf">BcmGetFlashSectorSize</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">FlashSectorSizeSig</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">FlashSectorSize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiSectorSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiSectorSig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bSectorSizeOverride</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSizeInCFG</span> <span class="o">&lt;=</span> <span class="n">MAX_SECTOR_SIZE</span> <span class="o">&amp;&amp;</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSizeInCFG</span> <span class="o">&gt;=</span> <span class="n">MIN_SECTOR_SIZE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSizeInCFG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>

		<span class="n">uiSectorSig</span> <span class="o">=</span> <span class="n">FlashSectorSizeSig</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiSectorSig</span> <span class="o">==</span> <span class="n">FLASH_SECTOR_SIZE_SIG</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">uiSectorSize</span> <span class="o">=</span> <span class="n">FlashSectorSize</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-84"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-84">&#182;</a></div><p>If the sector size stored in the FLASH makes sense then use it.</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span><span class="p">(</span><span class="n">uiSectorSize</span> <span class="o">&lt;=</span> <span class="n">MAX_SECTOR_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">uiSectorSize</span> <span class="o">&gt;=</span> <span class="n">MIN_SECTOR_SIZE</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">=</span> <span class="n">uiSectorSize</span><span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-85"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-85">&#182;</a></div><p>No valid size in FLASH, check if Config file has it.</p></td><td class="code"><div class="highlight"><pre>			<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSizeInCFG</span> <span class="o">&lt;=</span> <span class="n">MAX_SECTOR_SIZE</span> <span class="o">&amp;&amp;</span>
					<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSizeInCFG</span> <span class="o">&gt;=</span> <span class="n">MIN_SECTOR_SIZE</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSizeInCFG</span><span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-86"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-86">&#182;</a></div><p>Init to Default, if none of the above works.</p></td><td class="code"><div class="highlight"><pre>			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">=</span> <span class="n">DEFAULT_SECTOR_SIZE</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSizeInCFG</span> <span class="o">&lt;=</span> <span class="n">MAX_SECTOR_SIZE</span> <span class="o">&amp;&amp;</span>
					<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSizeInCFG</span> <span class="o">&gt;=</span> <span class="n">MIN_SECTOR_SIZE</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSizeInCFG</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">=</span> <span class="n">DEFAULT_SECTOR_SIZE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;Sector size  :%x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-87"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-87">&#182;</a></div><hr />

<p>Procedure:    BcmInitEEPROMQueues</p>

<p>Description: Initialization of EEPROM queues.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance</p>

<p>Returns:</p>

<h2>    <OSAL_STATUS_CODE></h2></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">BcmInitEEPROMQueues</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* CHIP Bug : Clear the Avail bits on the Read queue. The default</span>
<span class="cm">	 * value on this register is supposed to be 0x00001102.</span>
<span class="cm">	 * But we get 0x00001122. */</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Fixing reset value on 0x0f003004 register</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">EEPROM_READ_DATA_AVAIL</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">EEPROM_SPI_Q_STATUS1_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="cm">/* Flush the all the EEPROM queues. */</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot; Flushing the queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span><span class="n">EEPROM_ALL_QUEUE_FLUSH</span> <span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">SPI_FLUSH_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">SPI_FLUSH_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">);</span>

	<span class="cm">/* Read the EEPROM Status Register. Just to see, no real purpose. */</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;EEPROM Status register value = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ReadEEPROMStatusRegister</span><span class="p">(</span><span class="n">Adapter</span><span class="p">)</span> <span class="p">);</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span> <span class="cm">/* BcmInitEEPROMQueues() */</span></pre></div></td></tr>


<tr id="section-88"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-88">&#182;</a></div><hr />

<p>Procedure:    BcmInitNVM</p>

<p>Description: Initialization of NVM, EEPROM size,FLASH size, sector size etc.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance</p>

<p>Returns:</p>

<h2>    <OSAL_STATUS_CODE></h2></td><td class="code"><div class="highlight"><pre><span class="n">INT</span> <span class="nf">BcmInitNVM</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">ps_adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BcmValidateNvmType</span><span class="p">(</span><span class="n">ps_adapter</span><span class="p">);</span>
	<span class="n">BcmInitEEPROMQueues</span><span class="p">(</span><span class="n">ps_adapter</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">ps_adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">==</span> <span class="n">NVM_AUTODETECT</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ps_adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">=</span> <span class="n">BcmGetNvmType</span><span class="p">(</span><span class="n">ps_adapter</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ps_adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">==</span> <span class="n">NVM_UNKNOWN</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">ps_adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;NVM Type is unknown!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">ps_adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">==</span> <span class="n">NVM_FLASH</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BcmGetFlashCSInfo</span><span class="p">(</span><span class="n">ps_adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BcmGetNvmSize</span><span class="p">(</span><span class="n">ps_adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/***************************************************************************/</span>
<span class="cm">/*BcmGetNvmSize : set the EEPROM or flash size in Adapter.</span>
<span class="cm">*</span>
<span class="cm">*Input Parameter:</span>
<span class="cm">*		Adapter data structure</span>
<span class="cm">*Return Value :</span>
<span class="cm">*		0. means success;</span>
<span class="cm">*/</span>
<span class="cm">/***************************************************************************/</span>

<span class="k">static</span> <span class="n">INT</span> <span class="nf">BcmGetNvmSize</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">==</span> <span class="n">NVM_EEPROM</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiNVMDSDSize</span> <span class="o">=</span> <span class="n">BcmGetEEPROMSize</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">==</span> <span class="n">NVM_FLASH</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiNVMDSDSize</span> <span class="o">=</span> <span class="n">BcmGetFlashSize</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-89"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-89">&#182;</a></div><hr />

<p>Procedure:    BcmValidateNvm</p>

<p>Description: Validates the NVM Type option selected against the device</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance</p>

<p>Returns:</p>

<h2>    <VOID></h2></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">VOID</span> <span class="nf">BcmValidateNvmType</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-90"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-90">&#182;</a></div><p>if forcing the FLASH through CFG file, we should ensure device really has a FLASH.
Accessing the FLASH address without the FLASH being present can cause hang/freeze etc.
So if NVM_FLASH is selected for older chipsets, change it to AUTODETECT where EEPROM is 1st choice.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">==</span> <span class="n">NVM_FLASH</span> <span class="o">&amp;&amp;</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">chip_id</span> <span class="o">&lt;</span> <span class="mh">0xBECE3300</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eNVMType</span> <span class="o">=</span> <span class="n">NVM_AUTODETECT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-91"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-91">&#182;</a></div><hr />

<p>Procedure:    BcmReadFlashRDID</p>

<p>Description: Reads ID from Serial Flash</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance</p>

<p>Returns:</p>

<h2>    Flash ID</h2></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">ULONG</span> <span class="nf">BcmReadFlashRDID</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONG</span> <span class="n">ulRDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-92"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-92">&#182;</a></div><p>Read ID Instruction.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">FLASH_CMD_READ_ID</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">);</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_CMDQ_REG</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-93"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-93">&#182;</a></div><p>Delay</p></td><td class="code"><div class="highlight"><pre>	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-94"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-94">&#182;</a></div><p>Read SPI READQ REG. The output will be WWXXYYZZ.
The ID is 3Bytes long and is WWXXYY. ZZ needs to be Ignored.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_SPI_READQ_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ulRDID</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ulRDID</span><span class="p">));</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ulRDID</span> <span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span>


<span class="p">}</span>

<span class="n">INT</span> <span class="nf">BcmAllocFlashCSStructure</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">psAdapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">psAdapter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">psAdapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Adapter structure point is NULL&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PFLASH_CS_INFO</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FLASH_CS_INFO</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">psAdapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Can&#39;t Allocate memory for Flash 1.x&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PFLASH2X_CS_INFO</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FLASH2X_CS_INFO</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">psAdapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Can&#39;t Allocate memory for Flash 2.x&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PFLASH2X_VENDORSPECIFIC_INFO</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FLASH2X_VENDORSPECIFIC_INFO</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">psAdapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Can&#39;t Allocate Vendor Info Memory for Flash 2.x&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">INT</span> <span class="nf">BcmDeAllocFlashCSStructure</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">psAdapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">psAdapter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">psAdapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot; Adapter structure point is NULL&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">psAdapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">INT</span>	<span class="nf">BcmDumpFlash2XCSStructure</span><span class="p">(</span><span class="n">PFLASH2X_CS_INFO</span> <span class="n">psFlash2xCSInfo</span><span class="p">,</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">Index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;**********************FLASH2X CS Structure *******************&quot;</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;Signature is  :%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">MagicNumber</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;Flash Major Version :%d&quot;</span><span class="p">,</span> <span class="n">MAJOR_VERSION</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;Flash Minor Version :%d&quot;</span><span class="p">,</span> <span class="n">MINOR_VERSION</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot; ISOImageMajorVersion:0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">ISOImageVersion</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;SCSIFirmwareMajorVersion :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SCSIFirmwareVersion</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForPart1ISOImage :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForPart1ISOImage</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForScsiFirmware :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;SizeOfScsiFirmware  :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SizeOfScsiFirmware</span> <span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForPart2ISOImage :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForPart2ISOImage</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForDSDStart :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForDSDEnd :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDEnd</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForVSAStart :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForVSAEnd :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAEnd</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForControlSectionStart :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForControlSectionData :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionData</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;CDLessInactivityTimeout :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">CDLessInactivityTimeout</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;NewImageSignature :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">NewImageSignature</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;FlashSectorSizeSig :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSizeSig</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;FlashSectorSize :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSize</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;FlashWriteSupportSize :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashWriteSupportSize</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;TotalFlashSize :0x%X&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">TotalFlashSize</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;FlashBaseAddr :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashBaseAddr</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;FlashPartMaxSize :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashPartMaxSize</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;IsCDLessDeviceBootSig :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">IsCDLessDeviceBootSig</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;MassStorageTimeout :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">MassStorageTimeout</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage1Part1Start :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage1Part1End :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1End</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage1Part2Start :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2Start</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage1Part2End :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2End</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage1Part3Start :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3Start</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage1Part3End :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3End</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage2Part1Start :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage2Part1End	:0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1End</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage2Part2Start :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2Start</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage2Part2End :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2End</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage2Part3Start :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3Start</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetISOImage2Part3End :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3End</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromDSDStartForDSDHeader :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForDSD1Start :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForDSD1End :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1End</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForDSD2Start :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForDSD2End :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2End</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForVSA1Start :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1Start</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForVSA1End :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1End</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForVSA2Start :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2Start</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;OffsetFromZeroForVSA2End :0x%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2End</span><span class="p">));</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;Sector Access Bit Map is Defined as :&quot;</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">Index</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">Index</span> <span class="o">&lt;</span><span class="p">(</span><span class="n">FLASH2X_TOTAL_SIZE</span><span class="o">/</span><span class="p">(</span><span class="n">DEFAULT_SECTOR_SIZE</span> <span class="o">*</span><span class="mi">16</span><span class="p">));</span> <span class="n">Index</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;SectorAccessBitMap[%d] :0x%x&quot;</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span>
				<span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SectorAccessBitMap</span><span class="p">[</span><span class="n">Index</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">INT</span>	<span class="nf">ConvertEndianOf2XCSStructure</span><span class="p">(</span><span class="n">PFLASH2X_CS_INFO</span> <span class="n">psFlash2xCSInfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">Index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">MagicNumber</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">MagicNumber</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span><span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-95"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-95">&#182;</a></div><p>psFlash2xCSInfo->FlashLayoutMinorVersion = ntohs(psFlash2xCSInfo->FlashLayoutMinorVersion);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">ISOImageVersion</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">ISOImageVersion</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SCSIFirmwareVersion</span> <span class="o">=</span><span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SCSIFirmwareVersion</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForPart1ISOImage</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForPart1ISOImage</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SizeOfScsiFirmware</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SizeOfScsiFirmware</span> <span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForPart2ISOImage</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForPart2ISOImage</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDEnd</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDEnd</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAEnd</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAEnd</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionData</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionData</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">CDLessInactivityTimeout</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">CDLessInactivityTimeout</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">NewImageSignature</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">NewImageSignature</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSizeSig</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSizeSig</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSize</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSize</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashWriteSupportSize</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashWriteSupportSize</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">TotalFlashSize</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">TotalFlashSize</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashBaseAddr</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashBaseAddr</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashPartMaxSize</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashPartMaxSize</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">IsCDLessDeviceBootSig</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">IsCDLessDeviceBootSig</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">MassStorageTimeout</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">MassStorageTimeout</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1End</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1End</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2Start</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2Start</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2End</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2End</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3Start</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3Start</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3End</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3End</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1End</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1End</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2Start</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2Start</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2End</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2End</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3Start</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3Start</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3End</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3End</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1End</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1End</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2End</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2End</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1Start</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1Start</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1End</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1End</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2Start</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2Start</span><span class="p">);</span>
	<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2End</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2End</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">Index</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">Index</span> <span class="o">&lt;</span><span class="p">(</span><span class="n">FLASH2X_TOTAL_SIZE</span><span class="o">/</span><span class="p">(</span><span class="n">DEFAULT_SECTOR_SIZE</span> <span class="o">*</span><span class="mi">16</span><span class="p">));</span> <span class="n">Index</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
			<span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SectorAccessBitMap</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SectorAccessBitMap</span><span class="p">[</span><span class="n">Index</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">INT</span>	<span class="nf">ConvertEndianOfCSStructure</span><span class="p">(</span><span class="n">PFLASH_CS_INFO</span> <span class="n">psFlashCSInfo</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-96"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-96">&#182;</a></div><p>UINT Index = 0;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">MagicNumber</span>					 		<span class="o">=</span><span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">MagicNumber</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span>					<span class="o">=</span><span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">ISOImageVersion</span> 						<span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">ISOImageVersion</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-97"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-97">&#182;</a></div><p>won't convert according to old assumption</p></td><td class="code"><div class="highlight"><pre>	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">SCSIFirmwareVersion</span> <span class="o">=</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">SCSIFirmwareVersion</span><span class="p">);</span>

	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForPart1ISOImage</span>  		<span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForPart1ISOImage</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span>        <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">SizeOfScsiFirmware</span>                   <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">SizeOfScsiFirmware</span> <span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForPart2ISOImage</span>       <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForPart2ISOImage</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForCalibrationStart</span>    <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForCalibrationStart</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForCalibrationEnd</span>      <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForCalibrationEnd</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span>            <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAEnd</span>              <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAEnd</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionData</span>  <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionData</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">CDLessInactivityTimeout</span> 				<span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">CDLessInactivityTimeout</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">NewImageSignature</span>                    <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">NewImageSignature</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSizeSig</span>                   <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSizeSig</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSize</span>                      <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSize</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashWriteSupportSize</span>                <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashWriteSupportSize</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">TotalFlashSize</span>        				<span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">TotalFlashSize</span><span class="p">);</span>
 	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashBaseAddr</span>         				<span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashBaseAddr</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashPartMaxSize</span>      				<span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashPartMaxSize</span><span class="p">);</span>
 	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">IsCDLessDeviceBootSig</span> 				<span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">IsCDLessDeviceBootSig</span><span class="p">);</span>
	<span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">MassStorageTimeout</span>    				<span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">MassStorageTimeout</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">INT</span> <span class="nf">IsSectionExistInVendorInfo</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">section</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="k">return</span> <span class="p">(</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiVendorExtnFlag</span> <span class="o">&amp;&amp;</span>
 		<span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">section</span><span class="p">].</span><span class="n">AccessFlags</span> <span class="o">&amp;</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
 		<span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">section</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionStart</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">VOID</span> <span class="nf">UpdateVendorInfo</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">B_UINT32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiSizeSection</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiVendorExtnFlag</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">TOTAL_SECTIONS</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionStart</span> <span class="o">=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">STATUS_SUCCESS</span> <span class="o">!=</span> <span class="n">vendorextnGetSectionInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">TOTAL_SECTIONS</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">AccessFlags</span> <span class="o">&amp;</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiVendorExtnFlag</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="n">uiSizeSection</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionEnd</span> <span class="o">-</span>
						<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionStart</span><span class="p">);</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">case</span> <span class="n">DSD0</span>:
			<span class="k">if</span><span class="p">((</span> <span class="n">uiSizeSection</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DSD_HEADER</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">UNINIT_PTR_IN_CS</span> <span class="o">!=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionStart</span><span class="p">))</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDEnd</span> <span class="o">=</span> <span class="n">VENDOR_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDEnd</span> <span class="o">=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DSD1</span>:
			<span class="k">if</span><span class="p">((</span> <span class="n">uiSizeSection</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DSD_HEADER</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">UNINIT_PTR_IN_CS</span> <span class="o">!=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionStart</span><span class="p">))</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1End</span> <span class="o">=</span> <span class="n">VENDOR_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1End</span> <span class="o">=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DSD2</span>:
			<span class="k">if</span><span class="p">((</span> <span class="n">uiSizeSection</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DSD_HEADER</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">UNINIT_PTR_IN_CS</span> <span class="o">!=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionStart</span><span class="p">))</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2End</span> <span class="o">=</span> <span class="n">VENDOR_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2End</span> <span class="o">=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA0</span>:
			<span class="k">if</span><span class="p">(</span><span class="n">UNINIT_PTR_IN_CS</span> <span class="o">!=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionStart</span><span class="p">)</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAEnd</span> <span class="o">=</span> <span class="n">VENDOR_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAEnd</span> <span class="o">=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">VSA1</span>:
			<span class="k">if</span><span class="p">(</span><span class="n">UNINIT_PTR_IN_CS</span> <span class="o">!=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionStart</span><span class="p">)</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1Start</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1End</span> <span class="o">=</span> <span class="n">VENDOR_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1Start</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1End</span> <span class="o">=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA2</span>:
			<span class="k">if</span><span class="p">(</span><span class="n">UNINIT_PTR_IN_CS</span> <span class="o">!=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionStart</span><span class="p">)</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2Start</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2End</span> <span class="o">=</span> <span class="n">VENDOR_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2Start</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2End</span> <span class="o">=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span></pre></div></td></tr>


<tr id="section-98"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-98">&#182;</a></div><hr />

<p>Procedure:    BcmGetFlashCSInfo</p>

<p>Description: Reads control structure and gets Cal section addresses.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance</p>

<p>Returns:</p>

<h2>    <VOID></h2></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">INT</span> <span class="nf">BcmGetFlashCSInfo</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-99"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-99">&#182;</a></div><p>FLASH<em>CS</em>INFO sFlashCsInfo = {0};</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if !defined(BCM_SHM_INTERFACE) || defined(FLASH_DIRECT_ACCESS)</span>
	<span class="n">UINT</span> <span class="n">value</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">UINT</span> <span class="n">uiFlashLayoutMajorVersion</span><span class="p">;</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMinorVersion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMajorVersion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashControlSectionStart</span> <span class="o">=</span> <span class="n">FLASH_CS_INFO_START_ADDR</span><span class="p">;</span>


	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashBaseAdd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FLASH_CS_INFO</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FLASH2X_CS_INFO</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bDDRInitDone</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">FLASH_CONTIGIOUS_START_ADDR_BEFORE_INIT</span><span class="p">;</span>
			<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0xAF00A080</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-100"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-100">&#182;</a></div><p>Reading first 8 Bytes to get the Flash Layout
MagicNumber(4 bytes) +FlashLayoutMinorVersion(2 Bytes) +FlashLayoutMajorVersion(2 Bytes)</p></td><td class="code"><div class="highlight"><pre>	<span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashControlSectionStart</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span> <span class="o">=</span>  <span class="n">ntohl</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;Flash Layout Version :%X&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-101"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-101">&#182;</a></div><p>BCM<em>DEBUG</em>PRINT(Adapter,DBG<em>TYPE</em>OTHERS, NVM<em>RW, DBG</em>LVL_ALL, "Flash Layout Minor Version :%d\n", ntohs(sFlashCsInfo.FlashLayoutMinorVersion));</p></td><td class="code"><div class="highlight"><pre>	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;Signature is  :%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">MagicNumber</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span><span class="n">FLASH_CONTROL_STRUCT_SIGNATURE</span> <span class="o">==</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">MagicNumber</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">uiFlashLayoutMajorVersion</span> <span class="o">=</span> <span class="n">MAJOR_VERSION</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span><span class="p">));</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMinorVersion</span> <span class="o">=</span> <span class="n">MINOR_VERSION</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashLayoutVersion</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMinorVersion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">uiFlashLayoutMajorVersion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;FLASH LAYOUT MAJOR VERSION :%X&quot;</span><span class="p">,</span> <span class="n">uiFlashLayoutMajorVersion</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">uiFlashLayoutMajorVersion</span> <span class="o">&lt;</span> <span class="n">FLASH_2X_MAJOR_NUMBER</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashControlSectionStart</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FLASH_CS_INFO</span><span class="p">));</span>
		<span class="n">ConvertEndianOfCSStructure</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="p">);</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForCalibrationStart</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMajorVersion</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMinorVersion</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="p">{</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashControlSectionStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">((</span><span class="n">FLASH_CONTROL_STRUCT_SIGNATURE</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">MagicNumber</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">SCSI_FIRMWARE_MINOR_VERSION</span> <span class="o">&lt;=</span> <span class="n">MINOR_VERSION</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">SCSIFirmwareVersion</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">FLASH_SECTOR_SIZE_SIG</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSizeSig</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">BYTE_WRITE_SUPPORT</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashWriteSupportSize</span><span class="p">)))</span>
		<span class="p">{</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashWriteSupportSize</span><span class="p">);</span>
		   	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWrite</span> <span class="o">=</span> <span class="n">flashByteWrite</span><span class="p">;</span>
		   	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWriteWithStatusCheck</span> <span class="o">=</span> <span class="n">flashByteWriteStatus</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span> <span class="o">=</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWrite</span> <span class="o">=</span> <span class="n">flashWrite</span><span class="p">;</span>
		   	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWriteWithStatusCheck</span> <span class="o">=</span> <span class="n">flashWriteStatus</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BcmGetFlashSectorSize</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSizeSig</span><span class="p">),</span>
					 <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSize</span><span class="p">));</span>


		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashBaseAdd</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlashCSInfo</span><span class="o">-&gt;</span><span class="n">FlashBaseAddr</span> <span class="o">&amp;</span> <span class="mh">0xFCFFFFFF</span><span class="p">;</span>


	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="p">,</span><span class="n">NO_SECTION_VAL</span><span class="p">,</span>
				<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashControlSectionStart</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FLASH2X_CS_INFO</span><span class="p">)))</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Unable to read CS structure </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ConvertEndianOf2XCSStructure</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="p">);</span>
		<span class="n">BcmDumpFlash2XCSStructure</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="p">,</span><span class="n">Adapter</span><span class="p">);</span>
		<span class="k">if</span><span class="p">((</span><span class="n">FLASH_CONTROL_STRUCT_SIGNATURE</span> <span class="o">==</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">MagicNumber</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">SCSI_FIRMWARE_MINOR_VERSION</span> <span class="o">&lt;=</span> <span class="n">MINOR_VERSION</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SCSIFirmwareVersion</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">FLASH_SECTOR_SIZE_SIG</span> <span class="o">==</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSizeSig</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">BYTE_WRITE_SUPPORT</span> <span class="o">==</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashWriteSupportSize</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashWriteSupportSize</span><span class="p">;</span>
		   	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWrite</span> <span class="o">=</span> <span class="n">flashByteWrite</span><span class="p">;</span>
		   	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWriteWithStatusCheck</span> <span class="o">=</span> <span class="n">flashByteWriteStatus</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span> <span class="o">=</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWrite</span> <span class="o">=</span> <span class="n">flashWrite</span><span class="p">;</span>
		   	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">fpFlashWriteWithStatusCheck</span> <span class="o">=</span> <span class="n">flashWriteStatus</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BcmGetFlashSectorSize</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSizeSig</span><span class="p">,</span>
					<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashSectorSize</span><span class="p">);</span>

		<span class="n">UpdateVendorInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

		<span class="n">BcmGetActiveDSD</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>
		<span class="n">BcmGetActiveISO</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashBaseAdd</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">FlashBaseAddr</span> <span class="o">&amp;</span> <span class="mh">0xFCFFFFFF</span><span class="p">;</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashControlSectionStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	Concerns: what if CS sector size does not match with this sector size ???</span>
<span class="cm">	what is the indication of AccessBitMap  in CS in flash 2.x ????</span>
<span class="cm">	*/</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashID</span> <span class="o">=</span> <span class="n">BcmReadFlashRDID</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMajorVersion</span> <span class="o">=</span> <span class="n">uiFlashLayoutMajorVersion</span><span class="p">;</span>


	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-102"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-102">&#182;</a></div><hr />

<p>Procedure:    BcmGetNvmType</p>

<p>Description: Finds the type of NVM used.</p>

<p>Arguments:
    Adapter    - ptr to Adapter object instance</p>

<p>Returns:
    NVM_TYPE</p>

<hr /></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">NVM_TYPE</span> <span class="nf">BcmGetNvmType</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BeceemEEPROMBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">,</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">uiData</span> <span class="o">==</span> <span class="n">BECM</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NVM_EEPROM</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-103"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-103">&#182;</a></div><p>Read control struct and get cal addresses before accessing the flash</p></td><td class="code"><div class="highlight"><pre>	<span class="n">BcmGetFlashCSInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

	<span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uiData</span><span class="p">,</span><span class="mh">0x0</span> <span class="o">+</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">uiData</span> <span class="o">==</span> <span class="n">BECM</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NVM_FLASH</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-104"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-104">&#182;</a></div><p>even if there is no valid signature on EEPROM/FLASH find out if they really exist.
if exist select it.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">BcmGetEEPROMSize</span><span class="p">(</span><span class="n">Adapter</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NVM_EEPROM</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-105"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-105">&#182;</a></div><p>TBD for Flash.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="n">NVM_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">*	BcmGetSectionValStartOffset - this will calculate the section&#39;s starting offset if section val is given</span>
<span class="cm">*	@Adapter : Drivers Private Data structure</span>
<span class="cm">*	@eFlashSectionVal : Flash secion value defined in enum FLASH2X_SECTION_VAL</span>
<span class="cm">*</span>
<span class="cm">*	Return value:-</span>
<span class="cm">*	On success it return the start offset of the provided section val</span>
<span class="cm">*	On Failure -returns STATUS_FAILURE</span>
<span class="cm">**/</span>

<span class="n">INT</span> <span class="nf">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlashSectionVal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	*	Considering all the section for which end offset can be calculated or directly given</span>
<span class="cm">	*	in CS Structure. if matching case does not exist, return STATUS_FAILURE indicating section</span>
<span class="cm">	*	endoffset can&#39;t be calculated or given in CS Structure.</span>
<span class="cm">	*/</span>

	<span class="n">INT</span> <span class="n">SectStartOffset</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

	<span class="n">SectStartOffset</span> <span class="o">=</span> <span class="n">INVALID_OFFSET</span> <span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionExistInVendorInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlashSectionVal</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">eFlashSectionVal</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionStart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">eFlashSectionVal</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE1</span> :
			  <span class="k">if</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			  	<span class="p">(</span><span class="n">IsNonCDLessDevice</span><span class="p">(</span><span class="n">Adapter</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">))</span>
				  <span class="n">SectStartOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span><span class="p">);</span>
			   <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE2</span> :
				<span class="k">if</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">IsNonCDLessDevice</span><span class="p">(</span><span class="n">Adapter</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">))</span>
			  		<span class="n">SectStartOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span><span class="p">);</span>
			  <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DSD0</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					<span class="n">SectStartOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DSD1</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					<span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DSD2</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					<span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA0</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					<span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA1</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					<span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1Start</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA2</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					<span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2Start</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCSI</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					<span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CONTROL_SECTION</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					<span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE1_PART2</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				 	 <span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2Start</span><span class="p">);</span>
				 <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE1_PART3</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				  <span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3Start</span><span class="p">);</span>
			  	<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE2_PART2</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
			 		 <span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2Start</span><span class="p">);</span>
			    <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE2_PART3</span> :
  			  <span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
  				  <span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3Start</span><span class="p">);</span>
  			  <span class="k">break</span><span class="p">;</span>
		<span class="k">default</span> <span class="o">:</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Section Does not exist in Flash 2.x&quot;</span><span class="p">);</span>
			<span class="n">SectStartOffset</span> <span class="o">=</span>  <span class="n">INVALID_OFFSET</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SectStartOffset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">*	BcmGetSectionValEndOffset - this will calculate the section&#39;s Ending offset if section val is given</span>
<span class="cm">*	@Adapter : Drivers Private Data structure</span>
<span class="cm">*	@eFlashSectionVal : Flash secion value defined in enum FLASH2X_SECTION_VAL</span>
<span class="cm">*</span>
<span class="cm">*	Return value:-</span>
<span class="cm">*	On success it return the end offset of the provided section val</span>
<span class="cm">*	On Failure -returns STATUS_FAILURE</span>
<span class="cm">**/</span>

<span class="n">INT</span> <span class="nf">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectionVal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INT</span> <span class="n">SectEndOffset</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="n">INVALID_OFFSET</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionExistInVendorInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">eFlash2xSectionVal</span><span class="p">].</span><span class="n">OffsetFromZeroForSectionEnd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">eFlash2xSectionVal</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE1</span> :
			 <span class="k">if</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1End</span><span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			 	 <span class="p">(</span><span class="n">IsNonCDLessDevice</span><span class="p">(</span><span class="n">Adapter</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">))</span>
				  <span class="n">SectEndOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1End</span><span class="p">);</span>
			   <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE2</span> :
			<span class="k">if</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1End</span><span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">IsNonCDLessDevice</span><span class="p">(</span><span class="n">Adapter</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">))</span>
					<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1End</span><span class="p">);</span>
			 <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DSD0</span> :
			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDEnd</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDEnd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DSD1</span> :
			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1End</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1End</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DSD2</span> :
			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2End</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2End</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA0</span> :
			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAEnd</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAEnd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA1</span> :
			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1End</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1End</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA2</span> :
			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2End</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2End</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCSI</span> :
			<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span><span class="p">)</span> <span class="o">+</span>
					<span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SizeOfScsiFirmware</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CONTROL_SECTION</span> :</pre></div></td></tr>


<tr id="section-106"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-106">&#182;</a></div><p>Not Clear So Putting failure. confirm and fix it.</p></td><td class="code"><div class="highlight"><pre>				<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE1_PART2</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2End</span><span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				 	 <span class="n">SectEndOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2End</span><span class="p">);</span>
				 <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE1_PART3</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3End</span><span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
				  <span class="n">SectEndOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3End</span><span class="p">);</span>
			  	<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE2_PART2</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2End</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
			 		 <span class="n">SectEndOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2End</span><span class="p">);</span>
			    <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE2_PART3</span> :
  			  <span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3End</span><span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
  				  <span class="n">SectEndOffset</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3End</span><span class="p">);</span>
  			  <span class="k">break</span><span class="p">;</span>

		<span class="k">default</span> <span class="o">:</span>
			<span class="n">SectEndOffset</span> <span class="o">=</span> <span class="n">INVALID_OFFSET</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SectEndOffset</span> <span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">*	BcmFlash2xBulkRead:- Read API for Flash Map 2.x .</span>
<span class="cm">*	@Adapter :Driver Private Data Structure</span>
<span class="cm">*	@pBuffer : Buffer where data has to be put after reading</span>
<span class="cm">*	@eFlashSectionVal :Flash Section Val defined in FLASH2X_SECTION_VAL</span>
<span class="cm">*	@uiOffsetWithinSectionVal :- Offset with in provided section</span>
<span class="cm">*	@uiNumBytes : Number of Bytes for Read</span>
<span class="cm">*</span>
<span class="cm">*	Return value:-</span>
<span class="cm">*		return true on success and STATUS_FAILURE on fail.</span>
<span class="cm">*/</span>

<span class="n">INT</span> <span class="nf">BcmFlash2xBulkRead</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectionVal</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffsetWithinSectionVal</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="n">INT</span> <span class="n">SectionStartOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiAbsoluteOffset</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiTemp</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span><span class="mi">0</span> <span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Adapter structure is NULL&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Device has been removed&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-107"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-107">&#182;</a></div><p>NO<em>SECTION</em>VAL means absolute offset is given.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">eFlash2xSectionVal</span> <span class="o">==</span> <span class="n">NO_SECTION_VAL</span><span class="p">)</span>
		<span class="n">SectionStartOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">SectionStartOffset</span> <span class="o">=</span> <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">SectionStartOffset</span> <span class="o">==</span> <span class="n">STATUS_FAILURE</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;This Section&lt;%d&gt; does not exixt in Flash 2.x Map &quot;</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionExistInVendorInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">vendorextnReadSection</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">,</span> <span class="n">eFlash2xSectionVal</span><span class="p">,</span> <span class="n">uiOffsetWithinSectionVal</span><span class="p">,</span> <span class="n">uiNumBytes</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-108"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-108">&#182;</a></div><p>calculating  the absolute offset from FLASH;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">uiAbsoluteOffset</span> <span class="o">=</span> <span class="n">uiOffsetWithinSectionVal</span> <span class="o">+</span> <span class="n">SectionStartOffset</span><span class="p">;</span>
	<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
	<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="n">Status</span><span class="o">=</span> <span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">pBuffer</span><span class="p">,</span><span class="n">uiAbsoluteOffset</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">)</span> <span class="p">;</span>

	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Flash Read Failed with Status :%d&quot;</span><span class="p">,</span> <span class="n">Status</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">Status</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">*	BcmFlash2xBulkWrite :-API for Writing on the Flash Map 2.x.</span>
<span class="cm">*	@Adapter :Driver Private Data Structure</span>
<span class="cm">*	@pBuffer : Buffer From where data has to taken for writing</span>
<span class="cm">*	@eFlashSectionVal :Flash Section Val defined in FLASH2X_SECTION_VAL</span>
<span class="cm">*	@uiOffsetWithinSectionVal :- Offset with in provided section</span>
<span class="cm">*	@uiNumBytes : Number of Bytes for Write</span>
<span class="cm">*</span>
<span class="cm">*	Return value:-</span>
<span class="cm">*		return true on success and STATUS_FAILURE on fail.</span>
<span class="cm">*</span>
<span class="cm">*/</span>

<span class="n">INT</span> <span class="nf">BcmFlash2xBulkWrite</span><span class="p">(</span>
	<span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
	<span class="n">PUINT</span> <span class="n">pBuffer</span><span class="p">,</span>
	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectVal</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">uiNumBytes</span><span class="p">,</span>
	<span class="n">UINT</span> <span class="n">bVerify</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">INT</span> <span class="n">Status</span> 	<span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">FlashSectValStartOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiTemp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Adapter structure is NULL&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">device_removed</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Device has been removed&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-109"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-109">&#182;</a></div><p>NO<em>SECTION</em>VAL means absolute offset is given.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">eFlash2xSectVal</span> <span class="o">==</span> <span class="n">NO_SECTION_VAL</span><span class="p">)</span>
		<span class="n">FlashSectValStartOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">FlashSectValStartOffset</span> <span class="o">=</span> <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectVal</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">FlashSectValStartOffset</span> <span class="o">==</span> <span class="n">STATUS_FAILURE</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;This Section&lt;%d&gt; does not exixt in Flash Map 2.x&quot;</span><span class="p">,</span><span class="n">eFlash2xSectVal</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionExistInVendorInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectVal</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">vendorextnWriteSection</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuffer</span><span class="p">,</span> <span class="n">eFlash2xSectVal</span><span class="p">,</span> <span class="n">uiOffset</span><span class="p">,</span> <span class="n">uiNumBytes</span><span class="p">,</span> <span class="n">bVerify</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-110"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-110">&#182;</a></div><p>calculating  the absolute offset from FLASH;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">uiOffset</span> <span class="o">=</span> <span class="n">uiOffset</span> <span class="o">+</span> <span class="n">FlashSectValStartOffset</span><span class="p">;</span>

	<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
	<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="n">Status</span> <span class="o">=</span> <span class="n">BeceemFlashBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">pBuffer</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">,</span><span class="n">bVerify</span><span class="p">);</span>

	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Flash Write failed with Status :%d&quot;</span><span class="p">,</span> <span class="n">Status</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">Status</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">*	BcmGetActiveDSD : Set the Active DSD in Adapter Structure which has to be dumped in DDR</span>
<span class="cm">*	@Adapter :-Drivers private Data Structure</span>
<span class="cm">*</span>
<span class="cm">*	Return Value:-</span>
<span class="cm">*		Return STATUS_SUCESS if get success in setting the right DSD else negaive error code</span>
<span class="cm">*</span>
<span class="cm">**/</span>
<span class="k">static</span> <span class="n">INT</span> <span class="nf">BcmGetActiveDSD</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">uiHighestPriDSD</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

	<span class="n">uiHighestPriDSD</span> <span class="o">=</span> <span class="n">getHighestPriDSD</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span> <span class="o">=</span> <span class="n">uiHighestPriDSD</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">DSD0</span>  <span class="o">==</span> <span class="n">uiHighestPriDSD</span><span class="p">)</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">DSD1</span> <span class="o">==</span> <span class="n">uiHighestPriDSD</span><span class="p">)</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">DSD2</span> <span class="o">==</span> <span class="n">uiHighestPriDSD</span><span class="p">)</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span><span class="p">)</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;Active DSD :%d&quot;</span><span class="p">,</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-111"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-111">&#182;</a></div><p>if No DSD gets Active, Make Active the DSD with WR  permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD2</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span> <span class="o">=</span> <span class="n">DSD2</span><span class="p">;</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD1</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span> <span class="o">=</span> <span class="n">DSD1</span><span class="p">;</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD0</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveDSD</span> <span class="o">=</span> <span class="n">DSD0</span><span class="p">;</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashCalStart</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm">*	BcmGetActiveISO :- Set the Active ISO in Adapter Data Structue</span>
<span class="cm">*	@Adapter : Driver private Data Structure</span>
<span class="cm">*</span>
<span class="cm">*	Return Value:-</span>
<span class="cm">*		Sucsess:- STATUS_SUCESS</span>
<span class="cm">*		Failure- : negative erro code</span>
<span class="cm">*</span>
<span class="cm">**/</span>

<span class="k">static</span> <span class="n">INT</span> <span class="nf">BcmGetActiveISO</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">INT</span> <span class="n">HighestPriISO</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">HighestPriISO</span> <span class="o">=</span> <span class="n">getHighestPriISO</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveISO</span> <span class="o">=</span> <span class="n">HighestPriISO</span> <span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveISO</span> <span class="o">==</span> <span class="n">ISO_IMAGE2</span><span class="p">)</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiActiveISOOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveISO</span> <span class="o">==</span> <span class="n">ISO_IMAGE1</span><span class="p">)</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiActiveISOOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveISO</span><span class="p">)</span>
	 	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Active ISO :%x&quot;</span><span class="p">,</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">eActiveISO</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">*	IsOffsetWritable :- it will tell the access permission of the sector having passed offset</span>
<span class="cm">*	@Adapter : Drivers Private Data Structure</span>
<span class="cm">*	@uiOffset : Offset provided in the Flash</span>
<span class="cm">*</span>
<span class="cm">*	Return Value:-</span>
<span class="cm">*	Success:-TRUE ,  offset is writable</span>
<span class="cm">*	Failure:-FALSE, offset is RO</span>
<span class="cm">*</span>
<span class="cm">**/</span>
<span class="n">B_UINT8</span> <span class="nf">IsOffsetWritable</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiSectorNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiWordOfSectorPermission</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiBitofSectorePermission</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">B_UINT32</span> <span class="n">permissionBits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uiSectorNum</span> <span class="o">=</span> <span class="n">uiOffset</span><span class="o">/</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-112"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-112">&#182;</a></div><p>calculating the word having this Sector Access permission from SectorAccessBitMap Array</p></td><td class="code"><div class="highlight"><pre>	<span class="n">uiWordOfSectorPermission</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">SectorAccessBitMap</span><span class="p">[</span><span class="n">uiSectorNum</span> <span class="o">/</span><span class="mi">16</span><span class="p">];</span></pre></div></td></tr>


<tr id="section-113"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-113">&#182;</a></div><p>calculating the bit index inside the word for  this sector</p></td><td class="code"><div class="highlight"><pre>	<span class="n">uiBitofSectorePermission</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">15</span> <span class="o">-</span> <span class="n">uiSectorNum</span> <span class="o">%</span><span class="mi">16</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-114"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-114">&#182;</a></div><p>Setting Access permission</p></td><td class="code"><div class="highlight"><pre>	<span class="n">permissionBits</span> <span class="o">=</span> <span class="n">uiWordOfSectorPermission</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">uiBitofSectorePermission</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">permissionBits</span> <span class="o">=</span> <span class="p">(</span><span class="n">permissionBits</span> <span class="o">&gt;&gt;</span> <span class="n">uiBitofSectorePermission</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">permissionBits</span> <span class="o">==</span> <span class="n">SECTOR_READWRITE_PERMISSION</span><span class="p">)</span>
		<span class="k">return</span> 	<span class="n">TRUE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">INT</span> <span class="nf">BcmDumpFlash2xSectionBitMap</span><span class="p">(</span><span class="n">PFLASH2X_BITMAP</span> <span class="n">psFlash2xBitMap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span> <span class="o">=</span> <span class="n">GET_BCM_ADAPTER</span><span class="p">(</span><span class="n">gblpnetdev</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;***************Flash 2.x Section Bitmap***************&quot;</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;ISO_IMAGE1  :0X%x&quot;</span><span class="p">,</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE1</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;ISO_IMAGE2  :0X%x&quot;</span><span class="p">,</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE2</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;DSD0  :0X%x&quot;</span><span class="p">,</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD0</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;DSD1  :0X%x&quot;</span><span class="p">,</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD1</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;DSD2  :0X%x&quot;</span><span class="p">,</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD2</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;VSA0  :0X%x&quot;</span><span class="p">,</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA0</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;VSA1  :0X%x&quot;</span><span class="p">,</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA1</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;VSA2  :0X%x&quot;</span><span class="p">,</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA2</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;SCSI  :0X%x&quot;</span><span class="p">,</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">SCSI</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;CONTROL_SECTION  :0X%x&quot;</span><span class="p">,</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">CONTROL_SECTION</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">*	BcmGetFlash2xSectionalBitMap :- It will provide the bit map of all the section present in Flash</span>
<span class="cm">*	8bit has been assigned to every section.</span>
<span class="cm">	bit[0] :Section present or not</span>
<span class="cm">	bit[1] :section is valid or not</span>
<span class="cm">	bit[2] : Secton is read only or has write permission too.</span>
<span class="cm">	bit[3] : Active Section -</span>
<span class="cm">	bit[7...4] = Reserved .</span>

<span class="cm">	@Adapter:-Driver private Data Structure</span>
<span class="cm">*</span>
<span class="cm">*	Return value:-</span>
<span class="cm">*	Success:- STATUS_SUCESS</span>
<span class="cm">*	Failure:- negative error code</span>
<span class="cm">**/</span>

<span class="n">INT</span> <span class="nf">BcmGetFlash2xSectionalBitMap</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">PFLASH2X_BITMAP</span> <span class="n">psFlash2xBitMap</span><span class="p">)</span>
<span class="p">{</span>


	<span class="n">PFLASH2X_CS_INFO</span> <span class="n">psFlash2xCSInfo</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="p">;</span>
	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">uiHighestPriDSD</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">uiHighestPriISO</span><span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">BOOLEAN</span> <span class="n">SetActiveDSDDone</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>
	<span class="n">BOOLEAN</span> <span class="n">SetActiveISODone</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span></pre></div></td></tr>


<tr id="section-115"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-115">&#182;</a></div><p>For 1.x map all the section except DSD0 will be shown as not present
This part will be used by calibration tool to detect the number of DSD present in Flash.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">IsFlash2x</span><span class="p">(</span><span class="n">Adapter</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD0</span> <span class="o">=</span> <span class="n">FLASH2X_SECTION_VALID</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">;</span> <span class="c1">//0xF;   //0000(Reseved)1(Active)0(RW)1(valid)1(present)</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD1</span>  <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD2</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA0</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA1</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA2</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">CONTROL_SECTION</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">SCSI</span><span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">Reserved0</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">Reserved1</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">Reserved2</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="k">return</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>

	<span class="p">}</span>

	<span class="n">uiHighestPriDSD</span> <span class="o">=</span> <span class="n">getHighestPriDSD</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>
	<span class="n">uiHighestPriISO</span> <span class="o">=</span> <span class="n">getHighestPriISO</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-116"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-116">&#182;</a></div><p>/
IS0 IMAGE 2
/</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-117"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-117">&#182;</a></div><p>Setting the 0th Bit representing the Section is present or not.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE2</span><span class="o">=</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE2</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">;</span>


		<span class="k">if</span><span class="p">(</span><span class="n">ReadISOSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2</span><span class="p">)</span><span class="o">==</span> <span class="n">ISO_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE2</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_VALID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-118"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-118">&#182;</a></div><p>Calculation for extrating the Access permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">ISO_IMAGE2</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE2</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_RO</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">SetActiveISODone</span> <span class="o">==</span> <span class="n">FALSE</span> <span class="o">&amp;&amp;</span> <span class="n">uiHighestPriISO</span> <span class="o">==</span> <span class="n">ISO_IMAGE2</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE2</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="p">;</span>
			<span class="n">SetActiveISODone</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span></pre></div></td></tr>


<tr id="section-119"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-119">&#182;</a></div><p>/
IS0 IMAGE 1
/</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-120"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-120">&#182;</a></div><p>Setting the 0th Bit representing the Section is present or not.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE1</span> <span class="o">=</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE1</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">ReadISOSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1</span><span class="p">)</span> <span class="o">==</span> <span class="n">ISO_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE1</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_VALID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-121"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-121">&#182;</a></div><p>Calculation for extrating the Access permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">ISO_IMAGE1</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE1</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_RO</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">SetActiveISODone</span> <span class="o">==</span> <span class="n">FALSE</span> <span class="o">&amp;&amp;</span> <span class="n">uiHighestPriISO</span> <span class="o">==</span> <span class="n">ISO_IMAGE1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">ISO_IMAGE1</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="p">;</span>
			<span class="n">SetActiveISODone</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-122"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-122">&#182;</a></div><p>/
DSD2
/</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-123"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-123">&#182;</a></div><p>Setting the 0th Bit representing the Section is present or not.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD2</span><span class="o">=</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD2</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">ReadDSDSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD2</span><span class="p">)</span><span class="o">==</span> <span class="n">DSD_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD2</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_VALID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-124"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-124">&#182;</a></div><p>Calculation for extrating the Access permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">DSD2</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD2</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_RO</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span></pre></div></td></tr>


<tr id="section-125"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-125">&#182;</a></div><p>Means section is writable</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span><span class="p">((</span><span class="n">SetActiveDSDDone</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiHighestPriDSD</span> <span class="o">==</span> <span class="n">DSD2</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD2</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="p">;</span>
				<span class="n">SetActiveDSDDone</span> <span class="o">=</span><span class="n">TRUE</span> <span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-126"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-126">&#182;</a></div><p>/
DSD 1
/</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-127"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-127">&#182;</a></div><p>Setting the 0th Bit representing the Section is present or not.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD1</span><span class="o">=</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD1</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">;</span>


		<span class="k">if</span><span class="p">(</span><span class="n">ReadDSDSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD1</span><span class="p">)</span><span class="o">==</span> <span class="n">DSD_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD1</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_VALID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-128"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-128">&#182;</a></div><p>Calculation for extrating the Access permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">DSD1</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD1</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_RO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span></pre></div></td></tr>


<tr id="section-129"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-129">&#182;</a></div><p>Means section is writable</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span><span class="p">((</span><span class="n">SetActiveDSDDone</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiHighestPriDSD</span> <span class="o">==</span> <span class="n">DSD1</span><span class="p">))</span>
			<span class="p">{</span>
					<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD1</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="p">;</span>
					<span class="n">SetActiveDSDDone</span> <span class="o">=</span><span class="n">TRUE</span> <span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span></pre></div></td></tr>


<tr id="section-130"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-130">&#182;</a></div><p>/
For DSD 0</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-131"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-131">&#182;</a></div><p>Setting the 0th Bit representing the Section is present or not.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD0</span> <span class="o">=</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD0</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">ReadDSDSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD0</span><span class="p">)</span> <span class="o">==</span> <span class="n">DSD_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD0</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_VALID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-132"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-132">&#182;</a></div><p>Setting Access permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">DSD0</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD0</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_RO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span></pre></div></td></tr>


<tr id="section-133"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-133">&#182;</a></div><p>Means section is writable</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span><span class="p">((</span><span class="n">SetActiveDSDDone</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">uiHighestPriDSD</span> <span class="o">==</span> <span class="n">DSD0</span><span class="p">))</span>
			<span class="p">{</span>
					<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">DSD0</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="p">;</span>
					<span class="n">SetActiveDSDDone</span> <span class="o">=</span><span class="n">TRUE</span> <span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-134"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-134">&#182;</a></div><p>/
    VSA 0
/</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-135"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-135">&#182;</a></div><p>Setting the 0th Bit representing the Section is present or not.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA0</span><span class="o">=</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA0</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-136"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-136">&#182;</a></div><p>Setting the Access Bit. Map is not defined hece setting it always valid</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA0</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_VALID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-137"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-137">&#182;</a></div><p>Calculation for extrating the Access permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">VSA0</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA0</span> <span class="o">|=</span>  <span class="n">FLASH2X_SECTION_RO</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-138"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-138">&#182;</a></div><p>By Default section is Active</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA0</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="p">;</span>

	<span class="p">}</span></pre></div></td></tr>


<tr id="section-139"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-139">&#182;</a></div><p>/
 VSA 1
/</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1Start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-140"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-140">&#182;</a></div><p>Setting the 0th Bit representing the Section is present or not.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA1</span><span class="o">=</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA1</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-141"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-141">&#182;</a></div><p>Setting the Access Bit. Map is not defined hece setting it always valid</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA1</span><span class="o">|=</span> <span class="n">FLASH2X_SECTION_VALID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-142"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-142">&#182;</a></div><p>Checking For Access permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">VSA1</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA1</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_RO</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-143"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-143">&#182;</a></div><p>By Default section is Active</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA1</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="p">;</span>

	<span class="p">}</span></pre></div></td></tr>


<tr id="section-144"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-144">&#182;</a></div><p>/
VSA 2
/</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2Start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-145"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-145">&#182;</a></div><p>Setting the 0th Bit representing the Section is present or not.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA2</span><span class="o">=</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA2</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-146"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-146">&#182;</a></div><p>Setting the Access Bit. Map is not defined hece setting it always valid</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA2</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_VALID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-147"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-147">&#182;</a></div><p>Checking For Access permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">VSA2</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA2</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_RO</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-148"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-148">&#182;</a></div><p>By Default section is Active</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">VSA2</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-149"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-149">&#182;</a></div><p>/
SCSI Section
/</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-150"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-150">&#182;</a></div><p>Setting the 0th Bit representing the Section is present or not.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">SCSI</span><span class="o">=</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">SCSI</span> <span class="o">|</span> <span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-151"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-151">&#182;</a></div><p>Setting the Access Bit. Map is not defined hece setting it always valid</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">SCSI</span><span class="o">|=</span> <span class="n">FLASH2X_SECTION_VALID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-152"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-152">&#182;</a></div><p>Checking For Access permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">SCSI</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">SCSI</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_RO</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-153"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-153">&#182;</a></div><p>By Default section is Active</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">SCSI</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="p">;</span>

	<span class="p">}</span></pre></div></td></tr>


<tr id="section-154"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-154">&#182;</a></div><p>/
Control Section
/</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-155"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-155">&#182;</a></div><p>Setting the 0th Bit representing the Section is present or not.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">CONTROL_SECTION</span> <span class="o">=</span> <span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">CONTROL_SECTION</span> <span class="o">|</span> <span class="p">(</span><span class="n">FLASH2X_SECTION_PRESENT</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-156"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-156">&#182;</a></div><p>Setting the Access Bit. Map is not defined hece setting it always valid</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">CONTROL_SECTION</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_VALID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-157"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-157">&#182;</a></div><p>Checking For Access permission</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">CONTROL_SECTION</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">CONTROL_SECTION</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_RO</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-158"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-158">&#182;</a></div><p>By Default section is Active</p></td><td class="code"><div class="highlight"><pre>		<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">CONTROL_SECTION</span> <span class="o">|=</span> <span class="n">FLASH2X_SECTION_ACT</span> <span class="p">;</span>

	<span class="p">}</span></pre></div></td></tr>


<tr id="section-159"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-159">&#182;</a></div><p>/
For Reserved Sections
/</p></td><td class="code"><div class="highlight"><pre>	<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">Reserved0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">Reserved0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">psFlash2xBitMap</span><span class="o">-&gt;</span><span class="n">Reserved0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BcmDumpFlash2xSectionBitMap</span><span class="p">(</span><span class="n">psFlash2xBitMap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>

<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm">BcmSetActiveSection :- Set Active section is used to make priority field highest over other</span>
<span class="cm">					section of same type.</span>

<span class="cm">@Adapater :- Bcm Driver Private Data Structure</span>
<span class="cm">@eFlash2xSectionVal :- Flash section val whose priority has to be made highest.</span>

<span class="cm">Return Value:- Make the priorit highest else return erorr code</span>

<span class="cm">**/</span>
<span class="n">INT</span> <span class="nf">BcmSetActiveSection</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectVal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">SectImagePriority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span><span class="n">STATUS_SUCCESS</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-160"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-160">&#182;</a></div><p>DSD<em>HEADER sDSD = {0};
ISO</em>HEADER sISO = {0};</p></td><td class="code"><div class="highlight"><pre>	<span class="n">INT</span> <span class="n">HighestPriDSD</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">INT</span> <span class="n">HighestPriISO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>



	<span class="n">Status</span> <span class="o">=</span> <span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectVal</span><span class="p">)</span> <span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Status</span> <span class="o">!=</span> <span class="n">TRUE</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Provided Section &lt;%d&gt; is not writable&quot;</span><span class="p">,</span><span class="n">eFlash2xSectVal</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">eFlash2xSectVal</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE1</span> :
		<span class="k">case</span> <span class="n">ISO_IMAGE2</span>	:
			<span class="k">if</span><span class="p">(</span><span class="n">ReadISOSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectVal</span><span class="p">)</span><span class="o">==</span> <span class="n">ISO_IMAGE_MAGIC_NUMBER</span> <span class="p">)</span>
			<span class="p">{</span>
				<span class="n">HighestPriISO</span> <span class="o">=</span> <span class="n">getHighestPriISO</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

				<span class="k">if</span><span class="p">(</span><span class="n">HighestPriISO</span> <span class="o">==</span> <span class="n">eFlash2xSectVal</span>	<span class="p">)</span>
				<span class="p">{</span>
					<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Given ISO&lt;%x&gt; already  has highest priority&quot;</span><span class="p">,</span><span class="n">eFlash2xSectVal</span> <span class="p">);</span>
					<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">SectImagePriority</span> <span class="o">=</span> <span class="n">ReadISOPriority</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">HighestPriISO</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

				<span class="k">if</span><span class="p">((</span><span class="n">SectImagePriority</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">HighestPriISO</span><span class="p">))</span>
				<span class="p">{</span></pre></div></td></tr>


<tr id="section-161"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-161">&#182;</a></div><p>This is a SPECIAL Case which will only happen if the current highest priority ISO has priority value = 0x7FFFFFFF.
We will write 1 to the current Highest priority ISO And then shall increase the priority of the requested ISO
by user</p></td><td class="code"><div class="highlight"><pre>					<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;SectImagePriority wraparound happened, eFlash2xSectVal: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">eFlash2xSectVal</span><span class="p">);</span>
					<span class="n">SectImagePriority</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mh">0x1</span><span class="p">);</span>
					<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">SectImagePriority</span><span class="p">,</span>
								<span class="n">HighestPriISO</span><span class="p">,</span>
								<span class="mi">0</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PISO_HEADER</span><span class="p">,</span> <span class="n">ISOImagePriority</span><span class="p">),</span>
								<span class="n">SIGNATURE_SIZE</span><span class="p">,</span>
								<span class="n">TRUE</span><span class="p">);</span>

					<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Priority has not been written properly&quot;</span><span class="p">);</span>
						<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
						<span class="k">break</span> <span class="p">;</span>
					<span class="p">}</span>

					<span class="n">HighestPriISO</span> <span class="o">=</span> <span class="n">getHighestPriISO</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

					<span class="k">if</span><span class="p">(</span><span class="n">HighestPriISO</span> <span class="o">==</span> <span class="n">eFlash2xSectVal</span>	<span class="p">)</span>
					<span class="p">{</span>
						<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Given ISO&lt;%x&gt; already  has highest priority&quot;</span><span class="p">,</span><span class="n">eFlash2xSectVal</span> <span class="p">);</span>
						<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="n">SectImagePriority</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				 <span class="p">}</span>


				<span class="n">SectImagePriority</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">SectImagePriority</span><span class="p">);</span>

				<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">SectImagePriority</span><span class="p">,</span>
								<span class="n">eFlash2xSectVal</span><span class="p">,</span>
								<span class="mi">0</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PISO_HEADER</span><span class="p">,</span> <span class="n">ISOImagePriority</span><span class="p">),</span>
								<span class="n">SIGNATURE_SIZE</span><span class="p">,</span>
								<span class="n">TRUE</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Priority has not been written properly&quot;</span><span class="p">);</span>
					<span class="k">break</span> <span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Signature is currupted. Hence can&#39;t increase the priority&quot;</span><span class="p">);</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DSD0</span> :
		<span class="k">case</span> <span class="n">DSD1</span> :
		<span class="k">case</span> <span class="n">DSD2</span> :
			<span class="k">if</span><span class="p">(</span><span class="n">ReadDSDSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectVal</span><span class="p">)</span><span class="o">==</span> <span class="n">DSD_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">HighestPriDSD</span> <span class="o">=</span> <span class="n">getHighestPriDSD</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

				<span class="k">if</span><span class="p">((</span><span class="n">HighestPriDSD</span> <span class="o">==</span> <span class="n">eFlash2xSectVal</span><span class="p">))</span>
				<span class="p">{</span>
					<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Given DSD&lt;%x&gt; already  has highest priority&quot;</span><span class="p">,</span> <span class="n">eFlash2xSectVal</span><span class="p">);</span>
					<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">SectImagePriority</span> <span class="o">=</span> <span class="n">ReadDSDPriority</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">HighestPriDSD</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">SectImagePriority</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="p">{</span></pre></div></td></tr>


<tr id="section-162"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-162">&#182;</a></div><p>This is a SPECIAL Case which will only happen if the current highest priority DSD has priority value = 0x7FFFFFFF.
We will write 1 to the current Highest priority DSD And then shall increase the priority of the requested DSD
by user</p></td><td class="code"><div class="highlight"><pre>					<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;SectImagePriority wraparound happened, eFlash2xSectVal: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">eFlash2xSectVal</span><span class="p">);</span>
					<span class="n">SectImagePriority</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mh">0x1</span><span class="p">);</span>

					<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
									<span class="o">&amp;</span><span class="n">SectImagePriority</span><span class="p">,</span>
									<span class="n">HighestPriDSD</span><span class="p">,</span>
									<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PDSD_HEADER</span><span class="p">,</span> <span class="n">DSDImagePriority</span><span class="p">),</span>
									<span class="n">SIGNATURE_SIZE</span><span class="p">,</span>
									<span class="n">TRUE</span><span class="p">);</span>

					<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Priority has not been written properly&quot;</span><span class="p">);</span>
						<span class="k">break</span> <span class="p">;</span>
					<span class="p">}</span>

					<span class="n">HighestPriDSD</span> <span class="o">=</span> <span class="n">getHighestPriDSD</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

					<span class="k">if</span><span class="p">((</span><span class="n">HighestPriDSD</span> <span class="o">==</span> <span class="n">eFlash2xSectVal</span><span class="p">))</span>
					<span class="p">{</span>
						<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Made the DSD: %x highest by reducing priority of other</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eFlash2xSectVal</span><span class="p">);</span>
						<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="n">SectImagePriority</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mh">0x2</span><span class="p">);</span>
					<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
									<span class="o">&amp;</span><span class="n">SectImagePriority</span><span class="p">,</span>
									<span class="n">HighestPriDSD</span><span class="p">,</span>
									<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PDSD_HEADER</span><span class="p">,</span> <span class="n">DSDImagePriority</span><span class="p">),</span>
									<span class="n">SIGNATURE_SIZE</span><span class="p">,</span>
									<span class="n">TRUE</span><span class="p">);</span>

					<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Priority has not been written properly&quot;</span><span class="p">);</span>
						<span class="k">break</span> <span class="p">;</span>
					<span class="p">}</span>

					<span class="n">HighestPriDSD</span> <span class="o">=</span> <span class="n">getHighestPriDSD</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

					<span class="k">if</span><span class="p">((</span><span class="n">HighestPriDSD</span> <span class="o">==</span> <span class="n">eFlash2xSectVal</span><span class="p">))</span>
					<span class="p">{</span>
						<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">SectImagePriority</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">;</span>

				<span class="p">}</span>
				<span class="n">SectImagePriority</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">SectImagePriority</span><span class="p">);</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">SectImagePriority</span><span class="p">,</span>
								<span class="n">eFlash2xSectVal</span><span class="p">,</span>
								<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PDSD_HEADER</span><span class="p">,</span> <span class="n">DSDImagePriority</span><span class="p">),</span>
								<span class="n">SIGNATURE_SIZE</span> <span class="p">,</span>
								<span class="n">TRUE</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Priority has not been written properly&quot;</span><span class="p">);</span>
					<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span> <span class="p">;</span>
					<span class="k">break</span> <span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Signature is currupted. Hence can&#39;t increase the priority&quot;</span><span class="p">);</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA0</span> :
		<span class="k">case</span> <span class="n">VSA1</span> :
		<span class="k">case</span> <span class="n">VSA2</span> :</pre></div></td></tr>


<tr id="section-163"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-163">&#182;</a></div><p>Has to be decided</p></td><td class="code"><div class="highlight"><pre>			<span class="k">break</span> <span class="p">;</span>
		<span class="k">default</span> <span class="o">:</span>
				<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>
	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">BcmCopyISO - Used only for copying the ISO section</span>
<span class="cm">@Adapater :- Bcm Driver Private Data Structure</span>
<span class="cm">@sCopySectStrut :- Section copy structure</span>

<span class="cm">Return value:- SUCCESS if copies successfully else negative error code</span>

<span class="cm">**/</span>
<span class="n">INT</span> <span class="nf">BcmCopyISO</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_COPY_SECTION</span> <span class="n">sCopySectStrut</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">PCHAR</span> <span class="n">Buff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eISOReadPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">eISOWritePart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiTotalDataToCopy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">BOOLEAN</span> <span class="n">IsThisHeaderSector</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>
	<span class="n">UINT</span> <span class="n">sigOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">ISOLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">SigBuff</span><span class="p">[</span><span class="n">MAX_RW_SIZE</span><span class="p">];</span>
	<span class="n">UINT</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">ReadISOSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">sCopySectStrut</span><span class="p">.</span><span class="n">SrcSection</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ISO_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;error as Source ISO Section does not have valid signature&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">ISOLength</span><span class="p">,</span>
					   <span class="n">sCopySectStrut</span><span class="p">.</span><span class="n">SrcSection</span><span class="p">,</span>
					   <span class="mi">0</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PISO_HEADER</span><span class="p">,</span><span class="n">ISOImageSize</span><span class="p">),</span>
					   <span class="mi">4</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Read failed while copying ISO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ISOLength</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">ISOLength</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">ISOLength</span> <span class="o">%</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ISOLength</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">ISOLength</span><span class="o">/</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sigOffset</span> <span class="o">=</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PISO_HEADER</span><span class="p">,</span> <span class="n">ISOImageMagicNumber</span><span class="p">);</span>

	<span class="n">Buff</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Buff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Memory allocation failed for section size&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">sCopySectStrut</span><span class="p">.</span><span class="n">SrcSection</span> <span class="o">==</span><span class="n">ISO_IMAGE1</span> <span class="o">&amp;&amp;</span> <span class="n">sCopySectStrut</span><span class="p">.</span><span class="n">DstSection</span> <span class="o">==</span><span class="n">ISO_IMAGE2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">eISOReadPart</span> <span class="o">=</span> <span class="n">ISO_IMAGE1</span> <span class="p">;</span>
		<span class="n">eISOWritePart</span> <span class="o">=</span> <span class="n">ISO_IMAGE2</span> <span class="p">;</span>
		<span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>
		<span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

		<span class="n">uiTotalDataToCopy</span> <span class="o">=</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span><span class="p">)</span><span class="o">+</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2Start</span><span class="p">)</span><span class="o">+</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3Start</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiTotalDataToCopy</span> <span class="o">&lt;</span> <span class="n">ISOLength</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;error as Source ISO Section does not have valid signature&quot;</span><span class="p">);</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uiTotalDataToCopy</span> <span class="o">=</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span><span class="p">)</span><span class="o">+</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2Start</span><span class="p">)</span><span class="o">+</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3Start</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiTotalDataToCopy</span> <span class="o">&lt;</span> <span class="n">ISOLength</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;error as Dest ISO Section does not have enough section size&quot;</span><span class="p">);</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uiTotalDataToCopy</span> <span class="o">=</span> <span class="n">ISOLength</span><span class="p">;</span>

		<span class="n">CorruptISOSig</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2</span><span class="p">);</span>

		<span class="k">while</span><span class="p">(</span><span class="n">uiTotalDataToCopy</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">uiTotalDataToCopy</span> <span class="o">==</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">)</span>
			<span class="p">{</span></pre></div></td></tr>


<tr id="section-164"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-164">&#182;</a></div><p>Setting for write of first sector. First sector is assumed to be written in last</p></td><td class="code"><div class="highlight"><pre>				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Writing the signature sector&quot;</span><span class="p">);</span>
				<span class="n">eISOReadPart</span> <span class="o">=</span> <span class="n">ISO_IMAGE1</span> <span class="p">;</span>
				<span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">eISOWritePart</span> <span class="o">=</span> <span class="n">ISO_IMAGE2</span><span class="p">;</span>
				<span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
				<span class="n">IsThisHeaderSector</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>

			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span> <span class="n">uiReadOffsetWithinPart</span> <span class="o">+</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">;</span>
				<span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="n">uiWriteOffsetWithinPart</span> <span class="o">+</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">;</span>

				<span class="k">if</span><span class="p">((</span><span class="n">eISOReadPart</span> <span class="o">==</span> <span class="n">ISO_IMAGE1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiReadOffsetWithinPart</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1End</span> <span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span><span class="p">)</span> <span class="p">))</span>
				<span class="p">{</span>
					<span class="n">eISOReadPart</span> <span class="o">=</span> <span class="n">ISO_IMAGE1_PART2</span> <span class="p">;</span>
					<span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">((</span><span class="n">eISOReadPart</span> <span class="o">==</span> <span class="n">ISO_IMAGE1_PART2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiReadOffsetWithinPart</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2End</span> <span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2Start</span><span class="p">)))</span>
				<span class="p">{</span>
					<span class="n">eISOReadPart</span> <span class="o">=</span> <span class="n">ISO_IMAGE1_PART3</span> <span class="p">;</span>
					<span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">((</span><span class="n">eISOWritePart</span> <span class="o">==</span> <span class="n">ISO_IMAGE2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiWriteOffsetWithinPart</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1End</span> <span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span><span class="p">)))</span>
				<span class="p">{</span>
					<span class="n">eISOWritePart</span> <span class="o">=</span> <span class="n">ISO_IMAGE2_PART2</span> <span class="p">;</span>
					<span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">((</span><span class="n">eISOWritePart</span> <span class="o">==</span> <span class="n">ISO_IMAGE2_PART2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiWriteOffsetWithinPart</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2End</span> <span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2Start</span><span class="p">)))</span>
				<span class="p">{</span>
					<span class="n">eISOWritePart</span> <span class="o">=</span> <span class="n">ISO_IMAGE2_PART3</span> <span class="p">;</span>
					<span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
								   <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">Buff</span><span class="p">,</span>
								   <span class="n">eISOReadPart</span><span class="p">,</span>
								   <span class="n">uiReadOffsetWithinPart</span><span class="p">,</span>
								   <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span>
								<span class="p">);</span>

			<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Read failed while copying ISO: Part: %x, OffsetWithinPart: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eISOReadPart</span><span class="p">,</span> <span class="n">uiReadOffsetWithinPart</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span><span class="p">(</span><span class="n">IsThisHeaderSector</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
			<span class="p">{</span></pre></div></td></tr>


<tr id="section-165"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-165">&#182;</a></div><p>If this is header sector write 0xFFFFFFFF at the sig time and in last write sig</p></td><td class="code"><div class="highlight"><pre>				<span class="n">memcpy</span><span class="p">(</span><span class="n">SigBuff</span><span class="p">,</span> <span class="n">Buff</span> <span class="o">+</span> <span class="n">sigOffset</span><span class="p">,</span> <span class="n">MAX_RW_SIZE</span><span class="p">);</span>

				<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
					<span class="o">*</span><span class="p">(</span><span class="n">Buff</span> <span class="o">+</span> <span class="n">sigOffset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>

			<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
								 <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">Buff</span><span class="p">,</span>
								 <span class="n">eISOWritePart</span><span class="p">,</span>
								 <span class="n">uiWriteOffsetWithinPart</span><span class="p">,</span>
								 <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">,</span>
								 <span class="n">TRUE</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Write failed while copying ISO: Part: %x, OffsetWithinPart: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eISOWritePart</span><span class="p">,</span> <span class="n">uiWriteOffsetWithinPart</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

			<span class="k">if</span><span class="p">(</span><span class="n">IsThisHeaderSector</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">WriteToFlashWithoutSectorErase</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
												<span class="n">SigBuff</span><span class="p">,</span>
												<span class="n">eISOWritePart</span><span class="p">,</span>
												<span class="n">sigOffset</span><span class="p">,</span>
												<span class="n">MAX_RW_SIZE</span><span class="p">);</span>
				<span class="n">IsThisHeaderSector</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-166"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-166">&#182;</a></div><p>subtracting the written Data</p></td><td class="code"><div class="highlight"><pre>			<span class="n">uiTotalDataToCopy</span> <span class="o">=</span> <span class="n">uiTotalDataToCopy</span> <span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">;</span>
		<span class="p">}</span>


	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">sCopySectStrut</span><span class="p">.</span><span class="n">SrcSection</span> <span class="o">==</span><span class="n">ISO_IMAGE2</span> <span class="o">&amp;&amp;</span> <span class="n">sCopySectStrut</span><span class="p">.</span><span class="n">DstSection</span> <span class="o">==</span><span class="n">ISO_IMAGE1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">eISOReadPart</span> <span class="o">=</span> <span class="n">ISO_IMAGE2</span> <span class="p">;</span>
		<span class="n">eISOWritePart</span> <span class="o">=</span> <span class="n">ISO_IMAGE1</span> <span class="p">;</span>
		<span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span>	<span class="mi">0</span><span class="p">;</span>
		<span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

		<span class="n">uiTotalDataToCopy</span> <span class="o">=</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span><span class="p">)</span><span class="o">+</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2Start</span><span class="p">)</span><span class="o">+</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part3Start</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiTotalDataToCopy</span> <span class="o">&lt;</span> <span class="n">ISOLength</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;error as Source ISO Section does not have valid signature&quot;</span><span class="p">);</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uiTotalDataToCopy</span> <span class="o">=</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span><span class="p">)</span><span class="o">+</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2Start</span><span class="p">)</span><span class="o">+</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3End</span><span class="p">)</span> <span class="o">-</span>
						   <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part3Start</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uiTotalDataToCopy</span> <span class="o">&lt;</span> <span class="n">ISOLength</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;error as Dest ISO Section does not have enough section size&quot;</span><span class="p">);</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uiTotalDataToCopy</span> <span class="o">=</span> <span class="n">ISOLength</span><span class="p">;</span>

		<span class="n">CorruptISOSig</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1</span><span class="p">);</span>

		<span class="k">while</span><span class="p">(</span><span class="n">uiTotalDataToCopy</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">uiTotalDataToCopy</span> <span class="o">==</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">)</span>
			<span class="p">{</span></pre></div></td></tr>


<tr id="section-167"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-167">&#182;</a></div><p>Setting for write of first sector. First sector is assumed to be written in last</p></td><td class="code"><div class="highlight"><pre>				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Writing the signature sector&quot;</span><span class="p">);</span>
				<span class="n">eISOReadPart</span> <span class="o">=</span> <span class="n">ISO_IMAGE2</span> <span class="p">;</span>
				<span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">eISOWritePart</span> <span class="o">=</span> <span class="n">ISO_IMAGE1</span><span class="p">;</span>
				<span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
				<span class="n">IsThisHeaderSector</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span> <span class="n">uiReadOffsetWithinPart</span> <span class="o">+</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">;</span>
				<span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="n">uiWriteOffsetWithinPart</span> <span class="o">+</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">;</span>

				<span class="k">if</span><span class="p">((</span><span class="n">eISOReadPart</span> <span class="o">==</span> <span class="n">ISO_IMAGE2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiReadOffsetWithinPart</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1End</span> <span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span><span class="p">)</span> <span class="p">))</span>
				<span class="p">{</span>
					<span class="n">eISOReadPart</span> <span class="o">=</span> <span class="n">ISO_IMAGE2_PART2</span> <span class="p">;</span>
					<span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">((</span><span class="n">eISOReadPart</span> <span class="o">==</span> <span class="n">ISO_IMAGE2_PART2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiReadOffsetWithinPart</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2End</span> <span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part2Start</span><span class="p">)))</span>
				<span class="p">{</span>
					<span class="n">eISOReadPart</span> <span class="o">=</span> <span class="n">ISO_IMAGE2_PART3</span> <span class="p">;</span>
					<span class="n">uiReadOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">((</span><span class="n">eISOWritePart</span> <span class="o">==</span> <span class="n">ISO_IMAGE1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiWriteOffsetWithinPart</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1End</span> <span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span><span class="p">)))</span>
				<span class="p">{</span>
					<span class="n">eISOWritePart</span> <span class="o">=</span> <span class="n">ISO_IMAGE1_PART2</span> <span class="p">;</span>
					<span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">((</span><span class="n">eISOWritePart</span> <span class="o">==</span> <span class="n">ISO_IMAGE1_PART2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uiWriteOffsetWithinPart</span> <span class="o">==</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2End</span> <span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part2Start</span><span class="p">)))</span>
				<span class="p">{</span>
					<span class="n">eISOWritePart</span> <span class="o">=</span> <span class="n">ISO_IMAGE1_PART3</span> <span class="p">;</span>
					<span class="n">uiWriteOffsetWithinPart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
								   <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">Buff</span><span class="p">,</span>
								   <span class="n">eISOReadPart</span><span class="p">,</span>
								   <span class="n">uiReadOffsetWithinPart</span><span class="p">,</span>
								   <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span>
								<span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Read failed while copying ISO: Part: %x, OffsetWithinPart: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eISOReadPart</span><span class="p">,</span> <span class="n">uiReadOffsetWithinPart</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span><span class="p">(</span><span class="n">IsThisHeaderSector</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
			<span class="p">{</span></pre></div></td></tr>


<tr id="section-168"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-168">&#182;</a></div><p>If this is header sector write 0xFFFFFFFF at the sig time and in last write sig</p></td><td class="code"><div class="highlight"><pre>				<span class="n">memcpy</span><span class="p">(</span><span class="n">SigBuff</span><span class="p">,</span> <span class="n">Buff</span> <span class="o">+</span> <span class="n">sigOffset</span><span class="p">,</span> <span class="n">MAX_RW_SIZE</span><span class="p">);</span>

				<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_RW_SIZE</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
					<span class="o">*</span><span class="p">(</span><span class="n">Buff</span> <span class="o">+</span> <span class="n">sigOffset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

			<span class="p">}</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
								 <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">Buff</span><span class="p">,</span>
								 <span class="n">eISOWritePart</span><span class="p">,</span>
								 <span class="n">uiWriteOffsetWithinPart</span><span class="p">,</span>
								 <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">,</span>
								 <span class="n">TRUE</span><span class="p">);</span>

			<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Write failed while copying ISO: Part: %x, OffsetWithinPart: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eISOWritePart</span><span class="p">,</span> <span class="n">uiWriteOffsetWithinPart</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>

			<span class="k">if</span><span class="p">(</span><span class="n">IsThisHeaderSector</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">WriteToFlashWithoutSectorErase</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
												<span class="n">SigBuff</span><span class="p">,</span>
												<span class="n">eISOWritePart</span><span class="p">,</span>
												<span class="n">sigOffset</span><span class="p">,</span>
												<span class="n">MAX_RW_SIZE</span><span class="p">);</span>
				<span class="n">IsThisHeaderSector</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-169"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-169">&#182;</a></div><p>subtracting the written Data</p></td><td class="code"><div class="highlight"><pre>			<span class="n">uiTotalDataToCopy</span> <span class="o">=</span> <span class="n">uiTotalDataToCopy</span> <span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">;</span>
		<span class="p">}</span>


	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">Buff</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm">BcmFlash2xCorruptSig : this API is used to corrupt the written sig in Bcm Header present in flash section.</span>
<span class="cm">					     It will corrupt the sig, if Section is writable, by making first bytes as zero.</span>
<span class="cm">@Adapater :- Bcm Driver Private Data Structure</span>
<span class="cm">@eFlash2xSectionVal :- Flash section val which has header</span>

<span class="cm">Return Value :-</span>
<span class="cm">	Success :- If Section is present and writable, corrupt the sig and return STATUS_SUCCESS</span>
<span class="cm">	Failure :-Return negative error code</span>


<span class="cm">**/</span>
<span class="n">INT</span> <span class="nf">BcmFlash2xCorruptSig</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectionVal</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Section Value :%x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eFlash2xSectionVal</span><span class="p">);</span>

	<span class="k">if</span><span class="p">((</span><span class="n">eFlash2xSectionVal</span> <span class="o">==</span> <span class="n">DSD0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">eFlash2xSectionVal</span> <span class="o">==</span> <span class="n">DSD1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">eFlash2xSectionVal</span> <span class="o">==</span> <span class="n">DSD2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="n">CorruptDSDSig</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">eFlash2xSectionVal</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">eFlash2xSectionVal</span> <span class="o">==</span> <span class="n">ISO_IMAGE1</span> <span class="o">||</span> <span class="n">eFlash2xSectionVal</span> <span class="o">==</span> <span class="n">ISO_IMAGE2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="n">CorruptISOSig</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">eFlash2xSectionVal</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Given Section &lt;%d&gt;does not have Header&quot;</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm">BcmFlash2xWriteSig :-this API is used to Write the sig if requested Section has</span>
<span class="cm">					  header and  Write Permission.</span>
<span class="cm">@Adapater :- Bcm Driver Private Data Structure</span>
<span class="cm">@eFlashSectionVal :- Flash section val which has header</span>

<span class="cm">Return Value :-</span>
<span class="cm">	Success :- If Section is present and writable write the sig and return STATUS_SUCCESS</span>
<span class="cm">	Failure :-Return negative error code</span>

<span class="cm">**/</span>
<span class="n">INT</span> <span class="nf">BcmFlash2xWriteSig</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlashSectionVal</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">UINT</span> <span class="n">uiSignature</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-170"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-170">&#182;</a></div><p>DSD_HEADER dsdHeader = {0};</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bSigCorrupted</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Signature is not corrupted by driver, hence not restoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bAllDSDWriteAllow</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlashSectionVal</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Section is not Writable...Hence can&#39;t Write signature&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SECTOR_IS_NOT_WRITABLE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">((</span><span class="n">eFlashSectionVal</span> <span class="o">==</span> <span class="n">DSD0</span><span class="p">)</span> <span class="o">||</span><span class="p">(</span><span class="n">eFlashSectionVal</span> <span class="o">==</span> <span class="n">DSD1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">eFlashSectionVal</span> <span class="o">==</span> <span class="n">DSD2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">uiSignature</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">DSD_IMAGE_MAGIC_NUMBER</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">uiOffset</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="p">;</span>

		<span class="n">uiOffset</span> <span class="o">+=</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PDSD_HEADER</span><span class="p">,</span><span class="n">DSDImageMagicNumber</span><span class="p">);</span>

		<span class="k">if</span><span class="p">((</span><span class="n">ReadDSDSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlashSectionVal</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF000000</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CORRUPTED_PATTERN</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Corrupted Pattern is not there. Hence won&#39;t write sig&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">eFlashSectionVal</span> <span class="o">==</span> <span class="n">ISO_IMAGE1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">eFlashSectionVal</span> <span class="o">==</span> <span class="n">ISO_IMAGE2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">uiSignature</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">ISO_IMAGE_MAGIC_NUMBER</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-171"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-171">&#182;</a></div><p>uiOffset = 0;</p></td><td class="code"><div class="highlight"><pre>		<span class="n">uiOffset</span> <span class="o">=</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PISO_HEADER</span><span class="p">,</span><span class="n">ISOImageMagicNumber</span><span class="p">);</span>
		<span class="k">if</span><span class="p">((</span><span class="n">ReadISOSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlashSectionVal</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF000000</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CORRUPTED_PATTERN</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Currupted Pattern is not there. Hence won&#39;t write sig&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;GIVEN SECTION&lt; %d &gt; IS NOT VALID FOR SIG WRITE...&quot;</span><span class="p">,</span> <span class="n">eFlashSectionVal</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Restoring the signature&quot;</span><span class="p">);</span>


	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bSigCorrupted</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">BcmFlash2xBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiSignature</span><span class="p">,</span><span class="n">eFlashSectionVal</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="n">SIGNATURE_SIZE</span><span class="p">,</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>



	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm">validateFlash2xReadWrite :- This API is used to validate the user request for Read/Write.</span>
<span class="cm">						      if requested Bytes goes beyond the Requested section, it reports error.</span>
<span class="cm">@Adapater :- Bcm Driver Private Data Structure</span>
<span class="cm">@psFlash2xReadWrite :-Flash2x Read/write structure pointer</span>

<span class="cm">Return values:-Return TRUE is request is valid else FALSE.</span>


<span class="cm">**/</span>
<span class="n">INT</span>	<span class="nf">validateFlash2xReadWrite</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">PFLASH2X_READWRITE</span> <span class="n">psFlash2xReadWrite</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">uiNumOfBytes</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiSectStartOffset</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiSectEndOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uiNumOfBytes</span> <span class="o">=</span> <span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">numOfBytes</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionExistInFlash</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">Section</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TRUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Section&lt;%x&gt; does not exixt in Flash&quot;</span><span class="p">,</span><span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">Section</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">uiSectStartOffset</span> <span class="o">=</span> <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">Section</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;Start offset :%x ,section :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">uiSectStartOffset</span><span class="p">,</span><span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">Section</span><span class="p">);</span>
	<span class="k">if</span><span class="p">((</span><span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">Section</span> <span class="o">==</span> <span class="n">ISO_IMAGE1</span><span class="p">)</span> <span class="o">||</span><span class="p">(</span><span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">Section</span> <span class="o">==</span> <span class="n">ISO_IMAGE2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">Section</span> <span class="o">==</span> <span class="n">ISO_IMAGE1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">uiSectEndOffset</span> <span class="o">=</span> <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1</span><span class="p">)</span> <span class="o">-</span>
							  <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1</span><span class="p">)</span><span class="o">+</span>
							  <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1_PART2</span><span class="p">)</span> <span class="o">-</span>
							  <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1_PART2</span><span class="p">)</span><span class="o">+</span>
							  <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1_PART3</span><span class="p">)</span> <span class="o">-</span>
							  <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1_PART3</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">Section</span> <span class="o">==</span> <span class="n">ISO_IMAGE2</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">uiSectEndOffset</span> <span class="o">=</span> <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2</span><span class="p">)</span> <span class="o">-</span>
							  <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2</span><span class="p">)</span><span class="o">+</span>
							  <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2_PART2</span><span class="p">)</span> <span class="o">-</span>
							  <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2_PART2</span><span class="p">)</span><span class="o">+</span>
							  <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2_PART3</span><span class="p">)</span> <span class="o">-</span>
							  <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2_PART3</span><span class="p">);</span>

		<span class="p">}</span></pre></div></td></tr>


<tr id="section-172"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-172">&#182;</a></div><p>since this uiSectEndoffset is the size of iso Image. hence for calculating the vitual endoffset
it should be added in startoffset. so that check done in last of this function can be valued.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">uiSectEndOffset</span> <span class="o">=</span> <span class="n">uiSectStartOffset</span> <span class="o">+</span> <span class="n">uiSectEndOffset</span> <span class="p">;</span>

		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Total size of the ISO Image :%x&quot;</span><span class="p">,</span><span class="n">uiSectEndOffset</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">uiSectEndOffset</span>   <span class="o">=</span> <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">Section</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span> <span class="s">&quot;End offset :%x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">uiSectEndOffset</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-173"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-173">&#182;</a></div><p>Checking the boundary condition</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">((</span><span class="n">uiSectStartOffset</span> <span class="o">+</span> <span class="n">psFlash2xReadWrite</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">uiNumOfBytes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">uiSectEndOffset</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Invalid Request....&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">IsFlash2x :- check for Flash 2.x</span>
<span class="cm">@Adapater :- Bcm Driver Private Data Structure</span>

<span class="cm">Return value:-</span>
<span class="cm">	return TRUE if flah2.x of hgher version else return false.</span>
<span class="cm">**/</span>

<span class="n">INT</span> <span class="nf">IsFlash2x</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMajorVersion</span> <span class="o">&gt;=</span> <span class="n">FLASH_2X_MAJOR_NUMBER</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">TRUE</span> <span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm">GetFlashBaseAddr :- Calculate the Flash Base address</span>
<span class="cm">@Adapater :- Bcm Driver Private Data Structure</span>

<span class="cm">Return Value:-</span>
<span class="cm">	Success :- Base Address of the Flash</span>
<span class="cm">**/</span>

<span class="k">static</span> <span class="n">INT</span> <span class="nf">GetFlashBaseAddr</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">UINT</span> <span class="n">uiBaseAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bDDRInitDone</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		For All Valid Flash Versions... except 1.1, take the value from FlashBaseAddr</span>
<span class="cm">		In case of Raw Read... use the default value</span>
<span class="cm">		*/</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMajorVersion</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bFlashRawRead</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMajorVersion</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMinorVersion</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
			<span class="p">)</span>
			<span class="n">uiBaseAddr</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashBaseAdd</span> <span class="p">;</span>
		<span class="k">else</span>
			<span class="n">uiBaseAddr</span> <span class="o">=</span> <span class="n">FLASH_CONTIGIOUS_START_ADDR_AFTER_INIT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		For All Valid Flash Versions... except 1.1, take the value from FlashBaseAddr</span>
<span class="cm">		In case of Raw Read... use the default value</span>
<span class="cm">		*/</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMajorVersion</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bFlashRawRead</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMajorVersion</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashLayoutMinorVersion</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
			<span class="p">)</span>
			<span class="n">uiBaseAddr</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiFlashBaseAdd</span> <span class="o">|</span> <span class="n">FLASH_CONTIGIOUS_START_ADDR_BEFORE_INIT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">uiBaseAddr</span> <span class="o">=</span> <span class="n">FLASH_CONTIGIOUS_START_ADDR_BEFORE_INIT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">uiBaseAddr</span> <span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm">BcmCopySection :- This API is used to copy the One section in another. Both section should</span>
<span class="cm">				    be contiuous and of same size. Hence this Will not be applicabe to copy ISO.</span>

<span class="cm">@Adapater :- Bcm Driver Private Data Structure</span>
<span class="cm">@SrcSection :- Source section From where data has to be copied</span>
<span class="cm">@DstSection :- Destination section to which data has to be copied</span>
<span class="cm">@offset :- Offset from/to  where data has to be copied from one section to another.</span>
<span class="cm">@numOfBytes :- number of byes that has to be copyed from one section to another at given offset.</span>
<span class="cm">			     in case of numofBytes  equal zero complete section will be copied.</span>

<span class="cm">Return Values-</span>
<span class="cm">	Success : Return STATUS_SUCCESS</span>
<span class="cm">	Faillure :- return negative error code</span>

<span class="cm">**/</span>

<span class="n">INT</span>	<span class="nf">BcmCopySection</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
						<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">SrcSection</span><span class="p">,</span>
						<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">DstSection</span><span class="p">,</span>
						<span class="n">UINT</span> <span class="n">offset</span><span class="p">,</span>
						<span class="n">UINT</span> <span class="n">numOfBytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">BuffSize</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">UINT</span> <span class="n">BytesToBeCopied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">PUCHAR</span> <span class="n">pBuff</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">;</span>
	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">SrcSection</span> <span class="o">==</span> <span class="n">DstSection</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Source and Destination should be different ...try again&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">((</span><span class="n">SrcSection</span> <span class="o">!=</span> <span class="n">DSD0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">SrcSection</span> <span class="o">!=</span> <span class="n">DSD1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">SrcSection</span> <span class="o">!=</span> <span class="n">DSD2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Source should be DSD subsection&quot;</span><span class="p">);</span>
		<span class="k">return</span>  <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">((</span><span class="n">DstSection</span> <span class="o">!=</span> <span class="n">DSD0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">DstSection</span> <span class="o">!=</span> <span class="n">DSD1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">DstSection</span> <span class="o">!=</span> <span class="n">DSD2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Destination should be DSD subsection&quot;</span><span class="p">);</span>
		<span class="k">return</span>  <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-174"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-174">&#182;</a></div><p>if offset zero means have to copy complete secton</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">numOfBytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">numOfBytes</span> <span class="o">=</span> <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">SrcSection</span><span class="p">)</span>
				  <span class="o">-</span> <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">SrcSection</span><span class="p">);</span>

		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot; Section Size :0x%x&quot;</span><span class="p">,</span><span class="n">numOfBytes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">numOfBytes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">SrcSection</span><span class="p">)</span>
				  <span class="o">-</span> <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">SrcSection</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot; Input parameters going beyond the section offS: %x numB: %x of Source Section</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">offset</span><span class="p">,</span> <span class="n">numOfBytes</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">numOfBytes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DstSection</span><span class="p">)</span>
				  <span class="o">-</span> <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DstSection</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot; Input parameters going beyond the section offS: %x numB: %x of Destination Section</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">offset</span><span class="p">,</span> <span class="n">numOfBytes</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span><span class="p">(</span><span class="n">numOfBytes</span> <span class="o">&gt;</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">)</span>
		<span class="n">BuffSize</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">BuffSize</span> <span class="o">=</span> <span class="n">numOfBytes</span> <span class="p">;</span>

	<span class="n">pBuff</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="n">BuffSize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pBuff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Memory allocation failed.. &quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">BytesToBeCopied</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">offset</span> <span class="o">%</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">)</span>
		<span class="n">BytesToBeCopied</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">-</span> <span class="p">(</span><span class="n">offset</span> <span class="o">%</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">BytesToBeCopied</span> <span class="o">&gt;</span> <span class="n">numOfBytes</span><span class="p">)</span>
		<span class="n">BytesToBeCopied</span> <span class="o">=</span> <span class="n">numOfBytes</span> <span class="p">;</span>



	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pBuff</span><span class="p">,</span> <span class="n">SrcSection</span> <span class="p">,</span> <span class="n">offset</span><span class="p">,</span><span class="n">BytesToBeCopied</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Read failed at offset :%d for NOB :%d&quot;</span><span class="p">,</span> <span class="n">SrcSection</span><span class="p">,</span><span class="n">BytesToBeCopied</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">Status</span> <span class="o">=</span> <span class="n">BcmFlash2xBulkWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pBuff</span><span class="p">,</span><span class="n">DstSection</span><span class="p">,</span><span class="n">offset</span><span class="p">,</span><span class="n">BytesToBeCopied</span><span class="p">,</span><span class="n">FALSE</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Status</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Write failed at offset :%d for NOB :%d&quot;</span><span class="p">,</span> <span class="n">DstSection</span><span class="p">,</span><span class="n">BytesToBeCopied</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">BytesToBeCopied</span><span class="p">;</span>
		<span class="n">numOfBytes</span> <span class="o">=</span> <span class="n">numOfBytes</span> <span class="o">-</span> <span class="n">BytesToBeCopied</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">numOfBytes</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">numOfBytes</span> <span class="o">&gt;</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="p">)</span>
				<span class="n">BytesToBeCopied</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">BytesToBeCopied</span> <span class="o">=</span> <span class="n">numOfBytes</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">numOfBytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pBuff</span><span class="p">);</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>
	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">SaveHeaderIfPresent :- This API is use to Protect the Header in case of Header Sector write</span>
<span class="cm">@Adapater :- Bcm Driver Private Data Structure</span>
<span class="cm">@pBuff :- Data buffer that has to be written in sector having the header map.</span>
<span class="cm">@uiOffset :- Flash offset that has to be written.</span>

<span class="cm">Return value :-</span>
<span class="cm">	Success :- On success return STATUS_SUCCESS</span>
<span class="cm">	Faillure :- Return negative error code</span>

<span class="cm">**/</span>

<span class="n">INT</span> <span class="nf">SaveHeaderIfPresent</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">PUCHAR</span> <span class="n">pBuff</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">offsetToProtect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">HeaderSizeToProtect</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">BOOLEAN</span> <span class="n">bHasHeader</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>
	<span class="n">PUCHAR</span> <span class="n">pTempBuff</span> <span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiSectAlignAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">sig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-175"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-175">&#182;</a></div><p>making the offset sector aligned</p></td><td class="code"><div class="highlight"><pre>	<span class="n">uiSectAlignAddr</span> <span class="o">=</span> <span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>


	<span class="k">if</span><span class="p">((</span><span class="n">uiSectAlignAddr</span> <span class="o">==</span> <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD2</span><span class="p">)</span><span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">)</span><span class="o">||</span>
	<span class="p">(</span><span class="n">uiSectAlignAddr</span> <span class="o">==</span> <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD1</span><span class="p">)</span><span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">)</span><span class="o">||</span>
	<span class="p">(</span><span class="n">uiSectAlignAddr</span> <span class="o">==</span> <span class="n">BcmGetSectionValEndOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD0</span><span class="p">)</span><span class="o">-</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">))</span>
	<span class="p">{</span></pre></div></td></tr>


<tr id="section-176"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-176">&#182;</a></div><p>offset from the sector boundary having the header map</p></td><td class="code"><div class="highlight"><pre>		<span class="n">offsetToProtect</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">%</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">;</span>
		<span class="n">HeaderSizeToProtect</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DSD_HEADER</span><span class="p">);</span>
		<span class="n">bHasHeader</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">uiSectAlignAddr</span> <span class="o">==</span> <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">uiSectAlignAddr</span> <span class="o">==</span> <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">offsetToProtect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">HeaderSizeToProtect</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ISO_HEADER</span><span class="p">);</span>
		<span class="n">bHasHeader</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-177"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-177">&#182;</a></div><p>If Header is present overwrite passed buffer with this</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">bHasHeader</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bHeaderChangeAllowed</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">pTempBuff</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="n">HeaderSizeToProtect</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">pTempBuff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Memory allocation failed &quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-178"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-178">&#182;</a></div><p>Read header</p></td><td class="code"><div class="highlight"><pre>		<span class="n">BeceemFlashBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pTempBuff</span><span class="p">,(</span><span class="n">uiSectAlignAddr</span> <span class="o">+</span> <span class="n">offsetToProtect</span><span class="p">),</span><span class="n">HeaderSizeToProtect</span><span class="p">);</span>
		<span class="n">BCM_DEBUG_PRINT_BUFFER</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="n">pTempBuff</span> <span class="p">,</span><span class="n">HeaderSizeToProtect</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-179"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-179">&#182;</a></div><p>Replace Buffer content with Header</p></td><td class="code"><div class="highlight"><pre>		<span class="n">memcpy</span><span class="p">(</span><span class="n">pBuff</span> <span class="o">+</span><span class="n">offsetToProtect</span><span class="p">,</span><span class="n">pTempBuff</span><span class="p">,</span><span class="n">HeaderSizeToProtect</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">pTempBuff</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">bHasHeader</span> <span class="o">&amp;&amp;</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bSigCorrupted</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">PUINT</span><span class="p">)(</span><span class="n">pBuff</span> <span class="o">+</span> <span class="n">offsetToProtect</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PDSD_HEADER</span><span class="p">,</span><span class="n">DSDImageMagicNumber</span><span class="p">)));</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
		<span class="k">if</span><span class="p">((</span><span class="n">sig</span> <span class="o">&amp;</span> <span class="mh">0xFF000000</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CORRUPTED_PATTERN</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Desired pattern is not at sig offset. Hence won&#39;t restore&quot;</span><span class="p">);</span>
			<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bSigCorrupted</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot; Corrupted sig is :%X&quot;</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
		<span class="o">*</span><span class="p">((</span><span class="n">PUINT</span><span class="p">)(</span><span class="n">pBuff</span> <span class="o">+</span> <span class="n">offsetToProtect</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PDSD_HEADER</span><span class="p">,</span><span class="n">DSDImageMagicNumber</span><span class="p">)))</span><span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">DSD_IMAGE_MAGIC_NUMBER</span><span class="p">);</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Restoring the signature in Header Write only&quot;</span><span class="p">);</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bSigCorrupted</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">BcmDoChipSelect : This will selcet the appropriate chip for writing.</span>
<span class="cm">@Adapater :- Bcm Driver Private Data Structure</span>

<span class="cm">OutPut:-</span>
<span class="cm">	Select the Appropriate chip and retrn status Success</span>
<span class="cm">**/</span>
<span class="k">static</span> <span class="n">INT</span> <span class="nf">BcmDoChipSelect</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UINT</span> <span class="n">FlashConfig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INT</span> <span class="n">ChipNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">GPIOConfig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">PartNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ChipNum</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">FLASH_PART_SIZE</span> <span class="p">;</span></pre></div></td></tr>


<tr id="section-180"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-180">&#182;</a></div><p>Chip Select mapping to enable flash0.
To select flash 0, we have to OR with (0&lt;&lt;12).
ORing 0 will have no impact so not doing that part.
In future if Chip select value changes from 0 to non zero,
That needs be taken care with backward comaptibility. No worries for now.</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/*</span>
<span class="cm">	SelectedChip Variable is the selection that the host is 100% Sure the same as what the register will hold. This can be ONLY ensured</span>
<span class="cm">	if the Chip doesn&#39;t goes to low power mode while the flash operation is in progress (NVMRdmWrmLock is taken)</span>
<span class="cm">	Before every new Flash Write operation, we reset the variable. This is to ensure that after any wake-up from</span>
<span class="cm">	power down modes (Idle mode/shutdown mode), the values in the register will be different.</span>
<span class="cm">	*/</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">==</span> <span class="n">ChipNum</span><span class="p">)</span>
    		<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-181"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-181">&#182;</a></div><p>BCM<em>DEBUG</em>PRINT(Adapter,DBG<em>TYPE</em>OTHERS, NVM<em>RW, DBG</em>LVL_ALL, "Selected Chip :%x", ChipNum);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">=</span> <span class="n">ChipNum</span> <span class="p">;</span></pre></div></td></tr>


<tr id="section-182"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-182">&#182;</a></div><p>bit[13..12]  will select the appropriate chip</p></td><td class="code"><div class="highlight"><pre>	<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_CONFIG_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FlashConfig</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH_GPIO_CONFIG_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GPIOConfig</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="p">{</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">ChipNum</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">PartNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">PartNum</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">GPIOConfig</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x4</span> <span class="o">&lt;&lt;</span> <span class="n">CHIP_SELECT_BIT12</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">PartNum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">GPIOConfig</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">CHIP_SELECT_BIT12</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">PartNum</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">GPIOConfig</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x2</span> <span class="o">&lt;&lt;</span> <span class="n">CHIP_SELECT_BIT12</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* In case the bits already written in the FLASH_CONFIG_REG is same as what the user desired,</span>
<span class="cm">	    nothing to do... can return immediately.</span>
<span class="cm">	    ASSUMPTION: FLASH_GPIO_CONFIG_REG will be in sync with FLASH_CONFIG_REG.</span>
<span class="cm">	    Even if the chip goes to low power mode, it should wake with values in each register in sync with each other.</span>
<span class="cm">	    These values are not written by host other than during CHIP_SELECT.</span>
<span class="cm">	*/</span>
	<span class="k">if</span><span class="p">(</span><span class="n">PartNum</span> <span class="o">==</span> <span class="p">((</span><span class="n">FlashConfig</span> <span class="o">&gt;&gt;</span> <span class="n">CHIP_SELECT_BIT12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-183"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-183">&#182;</a></div><p>clearing the bit[13..12]</p></td><td class="code"><div class="highlight"><pre>	<span class="n">FlashConfig</span> <span class="o">&amp;=</span> <span class="mh">0xFFFFCFFF</span><span class="p">;</span>
	<span class="n">FlashConfig</span> <span class="o">=</span> <span class="p">(</span><span class="n">FlashConfig</span> <span class="o">|</span> <span class="p">(</span><span class="n">PartNum</span><span class="o">&lt;&lt;</span><span class="n">CHIP_SELECT_BIT12</span><span class="p">));</span> <span class="c1">//00</span>

	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">FLASH_GPIO_CONFIG_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GPIOConfig</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">FLASH_CONFIG_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FlashConfig</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">INT</span> <span class="nf">ReadDSDSignature</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">dsd</span><span class="p">)</span>
<span class="p">{</span>
		<span class="n">UINT</span> <span class="n">uiDSDsig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-184"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-184">&#182;</a></div><p>UINT sigoffsetInMap = 0;
DSD_HEADER dsdHeader = {0};</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-185"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-185">&#182;</a></div><p>sigoffsetInMap =(PUCHAR)&amp;(dsdHeader.DSDImageMagicNumber) -(PUCHAR)&dsdHeader;</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">dsd</span> <span class="o">!=</span> <span class="n">DSD0</span> <span class="o">&amp;&amp;</span> <span class="n">dsd</span> <span class="o">!=</span> <span class="n">DSD1</span> <span class="o">&amp;&amp;</span> <span class="n">dsd</span> <span class="o">!=</span> <span class="n">DSD2</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;passed section value is not for DSDs&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">uiDSDsig</span><span class="p">,</span>
						   <span class="n">dsd</span><span class="p">,</span>
						   <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PDSD_HEADER</span><span class="p">,</span><span class="n">DSDImageMagicNumber</span><span class="p">),</span>
						   <span class="n">SIGNATURE_SIZE</span><span class="p">);</span>

		<span class="n">uiDSDsig</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">uiDSDsig</span><span class="p">);</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;DSD SIG :%x&quot;</span><span class="p">,</span> <span class="n">uiDSDsig</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">uiDSDsig</span> <span class="p">;</span>
<span class="p">}</span>
<span class="n">INT</span> <span class="nf">ReadDSDPriority</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">dsd</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-186"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-186">&#182;</a></div><p>UINT priOffsetInMap = 0 ;</p></td><td class="code"><div class="highlight"><pre>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uiDSDPri</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-187"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-187">&#182;</a></div><p>DSD_HEADER dsdHeader = {0};
priOffsetInMap = (PUCHAR)&amp;(dsdHeader.DSDImagePriority) -(PUCHAR)&dsdHeader;</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">dsd</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ReadDSDSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">dsd</span><span class="p">)</span><span class="o">==</span> <span class="n">DSD_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">uiDSDPri</span><span class="p">,</span>
							   <span class="n">dsd</span><span class="p">,</span>
							   <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">+</span><span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PDSD_HEADER</span><span class="p">,</span> <span class="n">DSDImagePriority</span><span class="p">),</span>
							   <span class="mi">4</span><span class="p">);</span>

			<span class="n">uiDSDPri</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">uiDSDPri</span><span class="p">);</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;DSD&lt;%x&gt; Priority :%x&quot;</span><span class="p">,</span> <span class="n">dsd</span><span class="p">,</span> <span class="n">uiDSDPri</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">uiDSDPri</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">FLASH2X_SECTION_VAL</span> <span class="nf">getHighestPriDSD</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INT</span> <span class="n">DSDHighestPri</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="n">INT</span>  <span class="n">DsdPri</span><span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">HighestPriDSD</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">DSDHighestPri</span> <span class="o">=</span> <span class="n">ReadDSDPriority</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD2</span><span class="p">);</span>
		<span class="n">HighestPriDSD</span> <span class="o">=</span> <span class="n">DSD2</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD1</span><span class="p">))</span>
	<span class="p">{</span>
		 <span class="n">DsdPri</span> <span class="o">=</span> <span class="n">ReadDSDPriority</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD1</span><span class="p">);</span>
		 <span class="k">if</span><span class="p">(</span><span class="n">DSDHighestPri</span>  <span class="o">&lt;</span> <span class="n">DsdPri</span><span class="p">)</span>
		 <span class="p">{</span>
		 	<span class="n">DSDHighestPri</span> <span class="o">=</span> <span class="n">DsdPri</span> <span class="p">;</span>
			<span class="n">HighestPriDSD</span> <span class="o">=</span> <span class="n">DSD1</span><span class="p">;</span>
		 <span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD0</span><span class="p">))</span>
	<span class="p">{</span>
		 <span class="n">DsdPri</span> <span class="o">=</span> <span class="n">ReadDSDPriority</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DSD0</span><span class="p">);</span>
		 <span class="k">if</span><span class="p">(</span><span class="n">DSDHighestPri</span>  <span class="o">&lt;</span> <span class="n">DsdPri</span><span class="p">)</span>
		 <span class="p">{</span>
		 	<span class="n">DSDHighestPri</span> <span class="o">=</span> <span class="n">DsdPri</span> <span class="p">;</span>
			<span class="n">HighestPriDSD</span> <span class="o">=</span> <span class="n">DSD0</span><span class="p">;</span>
		 <span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">HighestPriDSD</span><span class="p">)</span>
	 	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Highest DSD :%x , and its  Pri :%x&quot;</span><span class="p">,</span> <span class="n">HighestPriDSD</span><span class="p">,</span> <span class="n">DSDHighestPri</span><span class="p">);</span>
	<span class="k">return</span>  <span class="n">HighestPriDSD</span> <span class="p">;</span>
<span class="p">}</span>

<span class="n">INT</span> <span class="nf">ReadISOSignature</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">iso</span><span class="p">)</span>
<span class="p">{</span>
		<span class="n">UINT</span> <span class="n">uiISOsig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-188"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-188">&#182;</a></div><p>UINT sigoffsetInMap = 0;
ISO_HEADER ISOHeader = {0};</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-189"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-189">&#182;</a></div><p>sigoffsetInMap =(PUCHAR)&amp;(ISOHeader.ISOImageMagicNumber) -(PUCHAR)&ISOHeader;</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">iso</span> <span class="o">!=</span> <span class="n">ISO_IMAGE1</span> <span class="o">&amp;&amp;</span> <span class="n">iso</span> <span class="o">!=</span> <span class="n">ISO_IMAGE2</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;passed section value is not for ISOs&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">uiISOsig</span><span class="p">,</span>
						   <span class="n">iso</span><span class="p">,</span>
						   <span class="mi">0</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PISO_HEADER</span><span class="p">,</span><span class="n">ISOImageMagicNumber</span><span class="p">),</span>
						   <span class="n">SIGNATURE_SIZE</span><span class="p">);</span>

		<span class="n">uiISOsig</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">uiISOsig</span><span class="p">);</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;ISO SIG :%x&quot;</span><span class="p">,</span> <span class="n">uiISOsig</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">uiISOsig</span> <span class="p">;</span>
<span class="p">}</span>
<span class="n">INT</span> <span class="nf">ReadISOPriority</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">iso</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ISOPri</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">iso</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ReadISOSignature</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">iso</span><span class="p">)</span><span class="o">==</span> <span class="n">ISO_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">ISOPri</span><span class="p">,</span>
							   <span class="n">iso</span><span class="p">,</span>
							   <span class="mi">0</span> <span class="o">+</span> <span class="n">FIELD_OFFSET_IN_HEADER</span><span class="p">(</span><span class="n">PISO_HEADER</span><span class="p">,</span> <span class="n">ISOImagePriority</span><span class="p">),</span>
							   <span class="mi">4</span><span class="p">);</span>

			<span class="n">ISOPri</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">ISOPri</span><span class="p">);</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;ISO&lt;%x&gt; Priority :%x&quot;</span><span class="p">,</span> <span class="n">iso</span><span class="p">,</span> <span class="n">ISOPri</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ISOPri</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">FLASH2X_SECTION_VAL</span> <span class="nf">getHighestPriISO</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INT</span> <span class="n">ISOHighestPri</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="n">INT</span>  <span class="n">ISOPri</span><span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">HighestPriISO</span> <span class="o">=</span> <span class="n">NO_SECTION_VAL</span> <span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">ISOHighestPri</span> <span class="o">=</span> <span class="n">ReadISOPriority</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE2</span><span class="p">);</span>
		<span class="n">HighestPriISO</span> <span class="o">=</span> <span class="n">ISO_IMAGE2</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1</span><span class="p">))</span>
	<span class="p">{</span>
		 <span class="n">ISOPri</span> <span class="o">=</span> <span class="n">ReadISOPriority</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">ISO_IMAGE1</span><span class="p">);</span>
		 <span class="k">if</span><span class="p">(</span><span class="n">ISOHighestPri</span>  <span class="o">&lt;</span> <span class="n">ISOPri</span><span class="p">)</span>
		 <span class="p">{</span>
			<span class="n">ISOHighestPri</span> <span class="o">=</span> <span class="n">ISOPri</span> <span class="p">;</span>
			<span class="n">HighestPriISO</span> <span class="o">=</span> <span class="n">ISO_IMAGE1</span><span class="p">;</span>
		 <span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">HighestPriISO</span><span class="p">)</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Highest ISO :%x and its Pri :%x&quot;</span><span class="p">,</span><span class="n">HighestPriISO</span><span class="p">,</span><span class="n">ISOHighestPri</span><span class="p">);</span>
	<span class="k">return</span>	<span class="n">HighestPriISO</span> <span class="p">;</span>
<span class="p">}</span>
<span class="n">INT</span> <span class="nf">WriteToFlashWithoutSectorErase</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span>
										<span class="n">PUINT</span> <span class="n">pBuff</span><span class="p">,</span>
										<span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectionVal</span><span class="p">,</span>
										<span class="n">UINT</span> <span class="n">uiOffset</span><span class="p">,</span>
										<span class="n">UINT</span> <span class="n">uiNumBytes</span>
										<span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if !defined(BCM_SHM_INTERFACE) || defined(FLASH_DIRECT_ACCESS)</span>
	<span class="n">UINT</span> <span class="n">uiTemp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">UINT</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiPartOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">UINT</span> <span class="n">uiStartOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-190"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-190">&#182;</a></div><p>Adding section start address</p></td><td class="code"><div class="highlight"><pre>	<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
	<span class="n">PUCHAR</span> <span class="n">pcBuff</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">pBuff</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">uiNumBytes</span> <span class="o">%</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Writing without Sector Erase for non-FlashWriteSize number of bytes 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uiNumBytes</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uiStartOffset</span> <span class="o">=</span> <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionExistInVendorInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">vendorextnWriteSectionWithoutErase</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="n">pcBuff</span><span class="p">,</span> <span class="n">eFlash2xSectionVal</span><span class="p">,</span> <span class="n">uiOffset</span><span class="p">,</span> <span class="n">uiNumBytes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">uiOffset</span> <span class="o">=</span> <span class="n">uiOffset</span> <span class="o">+</span> <span class="n">uiStartOffset</span><span class="p">;</span>

<span class="cp">#if defined(BCM_SHM_INTERFACE) &amp;&amp; !defined(FLASH_DIRECT_ACCESS)</span>
  <span class="n">Status</span> <span class="o">=</span> <span class="n">bcmflash_raw_writenoerase</span><span class="p">((</span><span class="n">uiOffset</span><span class="o">/</span><span class="n">FLASH_PART_SIZE</span><span class="p">),(</span><span class="n">uiOffset</span> <span class="o">%</span> <span class="n">FLASH_PART_SIZE</span><span class="p">),</span> <span class="n">pcBuff</span><span class="p">,</span><span class="n">uiNumBytes</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">rdmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
	<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">=</span> <span class="n">RESET_CHIP_SELECT</span><span class="p">;</span>
	<span class="n">BcmDoChipSelect</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">);</span>
	<span class="n">uiPartOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FLASH_PART_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">GetFlashBaseAddr</span><span class="p">(</span><span class="n">Adapter</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">uiNumBytes</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span> <span class="o">==</span> <span class="n">BYTE_WRITE_SUPPORT</span><span class="p">)</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">flashByteWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiPartOffset</span><span class="p">,</span> <span class="n">pcBuff</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">Status</span> <span class="o">=</span> <span class="n">flashWrite</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiPartOffset</span><span class="p">,</span> <span class="n">pcBuff</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">Status</span> <span class="o">!=</span> <span class="n">STATUS_SUCCESS</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">pcBuff</span> <span class="o">=</span> <span class="n">pcBuff</span> <span class="o">+</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span><span class="p">;</span>
		<span class="n">uiPartOffset</span> <span class="o">=</span> <span class="n">uiPartOffset</span> <span class="o">+</span>  <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wrmalt</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="mh">0x0f000C80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiTemp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uiTemp</span><span class="p">));</span>
	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">SelectedChip</span> <span class="o">=</span> <span class="n">RESET_CHIP_SELECT</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BOOLEAN</span> <span class="nf">IsSectionExistInFlash</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">section</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">BOOLEAN</span> <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
	<span class="p">{</span>

		<span class="k">case</span> <span class="n">ISO_IMAGE1</span> :
			  <span class="k">if</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage1Part1Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			  		<span class="p">(</span><span class="n">IsNonCDLessDevice</span><span class="p">(</span><span class="n">Adapter</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">))</span>
				  <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
			   <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISO_IMAGE2</span> :
				<span class="k">if</span><span class="p">((</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetISOImage2Part1Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">IsNonCDLessDevice</span><span class="p">(</span><span class="n">Adapter</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">))</span>
					 <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
			  <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DSD0</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSDStart</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					 <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DSD1</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD1Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					 <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DSD2</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForDSD2Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					 <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA0</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSAStart</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					 <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA1</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA1Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					 <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VSA2</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForVSA2Start</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					 <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCSI</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForScsiFirmware</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					 <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CONTROL_SECTION</span> :
				<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromZeroForControlSectionStart</span> <span class="o">!=</span> <span class="n">UNINIT_PTR_IN_CS</span><span class="p">)</span>
					 <span class="n">SectionPresent</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">default</span> <span class="o">:</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Section Does not exist in Flash 2.x&quot;</span><span class="p">);</span>
			<span class="n">SectionPresent</span> <span class="o">=</span>  <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SectionPresent</span> <span class="p">;</span>
<span class="p">}</span>
<span class="n">INT</span> <span class="nf">IsSectionWritable</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">Section</span><span class="p">)</span>
<span class="p">{</span>
		<span class="n">INT</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
		<span class="n">INT</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionExistInFlash</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">Section</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Section &lt;%d&gt; does not exixt&quot;</span><span class="p">,</span> <span class="n">Section</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">BcmGetSectionValStartOffset</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">Section</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">INVALID_OFFSET</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Section&lt;%d&gt; does not exixt&quot;</span><span class="p">,</span> <span class="n">Section</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionExistInVendorInfo</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">Section</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xVendorInfo</span><span class="o">-&gt;</span><span class="n">VendorSection</span><span class="p">[</span><span class="n">Section</span><span class="p">].</span><span class="n">AccessFlags</span> <span class="o">&amp;</span> <span class="n">FLASH2X_SECTION_RO</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">Status</span> <span class="o">=</span> <span class="n">IsOffsetWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">Status</span> <span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">INT</span> <span class="nf">CorruptDSDSig</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectionVal</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">PUCHAR</span> <span class="n">pBuff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">sig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">BlockStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiSectAlignAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bSigCorrupted</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bAllDSDWriteAllow</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TRUE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Section is not Writable...Hence can&#39;t Corrupt signature&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SECTOR_IS_NOT_WRITABLE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pBuff</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="n">MAX_RW_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pBuff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Can&#39;t allocate memorey&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uiOffset</span> <span class="o">=</span> <span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">OffsetFromDSDStartForDSDHeader</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DSD_HEADER</span><span class="p">);</span>
	<span class="n">uiOffset</span> <span class="o">-=</span> <span class="n">MAX_RW_SIZE</span> <span class="p">;</span>

	<span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pBuff</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>


	<span class="n">sig</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">PUINT</span><span class="p">)(</span><span class="n">pBuff</span> <span class="o">+</span><span class="mi">12</span><span class="p">));</span>
	<span class="n">sig</span> <span class="o">=</span><span class="n">ntohl</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT_BUFFER</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="n">pBuff</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-191"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-191">&#182;</a></div><p>Now corrupting the sig by corrupting 4th last Byte.</p></td><td class="code"><div class="highlight"><pre>	<span class="o">*</span><span class="p">(</span><span class="n">pBuff</span> <span class="o">+</span> <span class="mi">12</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">DSD_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bSigCorrupted</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span> <span class="o">==</span> <span class="n">BYTE_WRITE_SUPPORT</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">uiSectAlignAddr</span> <span class="o">=</span> <span class="n">uiOffset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">BlockStatus</span> <span class="o">=</span> <span class="n">BcmFlashUnProtectBlock</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">uiSectAlignAddr</span><span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">uiSectorSize</span><span class="p">);</span>

			<span class="n">WriteToFlashWithoutSectorErase</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)(</span><span class="n">pBuff</span> <span class="o">+</span> <span class="mi">12</span><span class="p">),</span><span class="n">eFlash2xSectionVal</span><span class="p">,</span>
												<span class="p">(</span><span class="n">uiOffset</span> <span class="o">+</span> <span class="mi">12</span><span class="p">),</span><span class="n">BYTE_WRITE_SUPPORT</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">BlockStatus</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">BcmRestoreBlockProtectStatus</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">BlockStatus</span><span class="p">);</span>
				<span class="n">BlockStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">WriteToFlashWithoutSectorErase</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pBuff</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">,</span>
												<span class="n">uiOffset</span> <span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;BCM Signature is not present in header&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pBuff</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pBuff</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Corrupted the signature&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">INT</span> <span class="nf">CorruptISOSig</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">,</span> <span class="n">FLASH2X_SECTION_VAL</span> <span class="n">eFlash2xSectionVal</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">PUCHAR</span> <span class="n">pBuff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">sig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UINT</span> <span class="n">uiOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bSigCorrupted</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">IsSectionWritable</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TRUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Section is not Writable...Hence can&#39;t Corrupt signature&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SECTOR_IS_NOT_WRITABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pBuff</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="n">MAX_RW_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pBuff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;Can&#39;t allocate memorey&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uiOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BcmFlash2xBulkRead</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span> <span class="p">(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pBuff</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">,</span><span class="n">uiOffset</span><span class="p">,</span> <span class="n">MAX_RW_SIZE</span><span class="p">);</span>

	<span class="n">sig</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pBuff</span><span class="p">);</span>
	<span class="n">sig</span> <span class="o">=</span><span class="n">ntohl</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-192"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-192">&#182;</a></div><p>corrupt signature</p></td><td class="code"><div class="highlight"><pre>	<span class="o">*</span><span class="n">pBuff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">ISO_IMAGE_MAGIC_NUMBER</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">bSigCorrupted</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="n">WriteToFlashWithoutSectorErase</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,(</span><span class="n">PUINT</span><span class="p">)</span><span class="n">pBuff</span><span class="p">,</span><span class="n">eFlash2xSectionVal</span><span class="p">,</span>
											<span class="n">uiOffset</span> <span class="p">,</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">ulFlashWriteSize</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_PRINTK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="s">&quot;BCM Signature is not present in header&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pBuff</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">STATUS_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BCM_DEBUG_PRINT</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="s">&quot;Corrupted the signature&quot;</span><span class="p">);</span>
	<span class="n">BCM_DEBUG_PRINT_BUFFER</span><span class="p">(</span><span class="n">Adapter</span><span class="p">,</span><span class="n">DBG_TYPE_OTHERS</span><span class="p">,</span> <span class="n">NVM_RW</span><span class="p">,</span> <span class="n">DBG_LVL_ALL</span><span class="p">,</span><span class="n">pBuff</span><span class="p">,</span><span class="n">MAX_RW_SIZE</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pBuff</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span> <span class="p">;</span>
<span class="p">}</span>

<span class="n">BOOLEAN</span> <span class="nf">IsNonCDLessDevice</span><span class="p">(</span><span class="n">PMINI_ADAPTER</span> <span class="n">Adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Adapter</span><span class="o">-&gt;</span><span class="n">psFlash2xCSInfo</span><span class="o">-&gt;</span><span class="n">IsCDLessDeviceBootSig</span> <span class="o">==</span> <span class="n">NON_CDLESS_DEVICE_BOOT_SIG</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">FALSE</span> <span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
