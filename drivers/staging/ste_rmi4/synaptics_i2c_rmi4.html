<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › ste_rmi4 › synaptics_i2c_rmi4.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>synaptics_i2c_rmi4.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * Synaptics Register Mapped Interface (RMI4) I2C Physical Layer Driver.</span>
<span class="cm"> * Copyright (c) 2007-2010, Synaptics Incorporated</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Js HA &lt;js.ha@stericsson.com&gt; for ST-Ericsson</span>
<span class="cm"> * Author: Naveen Kumar G &lt;naveen.gaddipati@stericsson.com&gt; for ST-Ericsson</span>
<span class="cm"> * Copyright 2010 (c) ST-Ericsson AB</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * This file is licensed under the GPL2 license.</span>
<span class="cm"> *</span>
<span class="cm"> *#############################################################################</span>
<span class="cm"> * GPL</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *#############################################################################</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/input.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/regulator/consumer.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &quot;synaptics_i2c_rmi4.h&quot;</span>

<span class="cm">/* TODO: for multiple device support will need a per-device mutex */</span>
<span class="cp">#define DRIVER_NAME &quot;synaptics_rmi4_i2c&quot;</span>

<span class="cp">#define MAX_ERROR_REPORT	6</span>
<span class="cp">#define MAX_TOUCH_MAJOR		15</span>
<span class="cp">#define MAX_RETRY_COUNT		5</span>
<span class="cp">#define STD_QUERY_LEN		21</span>
<span class="cp">#define PAGE_LEN		2</span>
<span class="cp">#define DATA_BUF_LEN		32</span>
<span class="cp">#define BUF_LEN			37</span>
<span class="cp">#define QUERY_LEN		9</span>
<span class="cp">#define DATA_LEN		12</span>
<span class="cp">#define HAS_TAP			0x01</span>
<span class="cp">#define HAS_PALMDETECT		0x01</span>
<span class="cp">#define HAS_ROTATE		0x02</span>
<span class="cp">#define HAS_TAPANDHOLD		0x02</span>
<span class="cp">#define HAS_DOUBLETAP		0x04</span>
<span class="cp">#define HAS_EARLYTAP		0x08</span>
<span class="cp">#define HAS_RELEASE		0x08</span>
<span class="cp">#define HAS_FLICK		0x10</span>
<span class="cp">#define HAS_PRESS		0x20</span>
<span class="cp">#define HAS_PINCH		0x40</span>

<span class="cp">#define MASK_16BIT		0xFFFF</span>
<span class="cp">#define MASK_8BIT		0xFF</span>
<span class="cp">#define MASK_7BIT		0x7F</span>
<span class="cp">#define MASK_5BIT		0x1F</span>
<span class="cp">#define MASK_4BIT		0x0F</span>
<span class="cp">#define MASK_3BIT		0x07</span>
<span class="cp">#define MASK_2BIT		0x03</span>
<span class="cp">#define TOUCHPAD_CTRL_INTR	0x8</span>
<span class="cp">#define PDT_START_SCAN_LOCATION (0x00E9)</span>
<span class="cp">#define PDT_END_SCAN_LOCATION	(0x000A)</span>
<span class="cp">#define PDT_ENTRY_SIZE		(0x0006)</span>
<span class="cp">#define RMI4_NUMBER_OF_MAX_FINGERS		(8)</span>
<span class="cp">#define SYNAPTICS_RMI4_TOUCHPAD_FUNC_NUM	(0x11)</span>
<span class="cp">#define SYNAPTICS_RMI4_DEVICE_CONTROL_FUNC_NUM	(0x01)</span>

<span class="cm">/**</span>
<span class="cm"> * struct synaptics_rmi4_fn_desc - contains the function descriptor information</span>
<span class="cm"> * @query_base_addr: base address for query</span>
<span class="cm"> * @cmd_base_addr: base address for command</span>
<span class="cm"> * @ctrl_base_addr: base address for control</span>
<span class="cm"> * @data_base_addr: base address for data</span>
<span class="cm"> * @intr_src_count: count for the interrupt source</span>
<span class="cm"> * @fn_number: function number</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used to gives the function descriptor information</span>
<span class="cm"> * of the particular functionality.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">synaptics_rmi4_fn_desc</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">query_base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">cmd_base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">ctrl_base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">data_base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">intr_src_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">fn_number</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct synaptics_rmi4_fn - contains the function information</span>
<span class="cm"> * @fn_number: function number</span>
<span class="cm"> * @num_of_data_sources: number of data sources</span>
<span class="cm"> * @num_of_data_points: number of fingers touched</span>
<span class="cm"> * @size_of_data_register_block: data register block size</span>
<span class="cm"> * @index_to_intr_reg: index for interrupt register</span>
<span class="cm"> * @intr_mask: interrupt mask value</span>
<span class="cm"> * @fn_desc: variable for function descriptor structure</span>
<span class="cm"> * @link: linked list for function descriptors</span>
<span class="cm"> *</span>
<span class="cm"> * This structure gives information about the number of data sources and</span>
<span class="cm"> * the number of data registers associated with the function.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">synaptics_rmi4_fn</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">fn_number</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">num_of_data_sources</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">num_of_data_points</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">size_of_data_register_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">index_to_intr_reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">intr_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_fn_desc</span>	<span class="n">fn_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct synaptics_rmi4_device_info - contains the rmi4 device information</span>
<span class="cm"> * @version_major: protocol major version number</span>
<span class="cm"> * @version_minor: protocol minor version number</span>
<span class="cm"> * @manufacturer_id: manufacturer identification byte</span>
<span class="cm"> * @product_props: product properties information</span>
<span class="cm"> * @product_info: product info array</span>
<span class="cm"> * @date_code: device manufacture date</span>
<span class="cm"> * @tester_id: tester id array</span>
<span class="cm"> * @serial_number: serial number for that device</span>
<span class="cm"> * @product_id_string: product id for the device</span>
<span class="cm"> * @support_fn_list: linked list for device information</span>
<span class="cm"> *</span>
<span class="cm"> * This structure gives information about the number of data sources and</span>
<span class="cm"> * the number of data registers associated with the function.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">synaptics_rmi4_device_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">version_major</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">version_minor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">manufacturer_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">product_props</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">product_info</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">date_code</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">tester_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">serial_number</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">product_id_string</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">support_fn_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct synaptics_rmi4_data - contains the rmi4 device data</span>
<span class="cm"> * @rmi4_mod_info: structure variable for rmi4 device info</span>
<span class="cm"> * @input_dev: pointer for input device</span>
<span class="cm"> * @i2c_client: pointer for i2c client</span>
<span class="cm"> * @board: constant pointer for touch platform data</span>
<span class="cm"> * @fn_list_mutex: mutex for function list</span>
<span class="cm"> * @rmi4_page_mutex: mutex for rmi4 page</span>
<span class="cm"> * @current_page: variable for integer</span>
<span class="cm"> * @number_of_interrupt_register: interrupt registers count</span>
<span class="cm"> * @fn01_ctrl_base_addr: control base address for fn01</span>
<span class="cm"> * @fn01_query_base_addr: query base address for fn01</span>
<span class="cm"> * @fn01_data_base_addr: data base address for fn01</span>
<span class="cm"> * @sensor_max_x: sensor maximum x value</span>
<span class="cm"> * @sensor_max_y: sensor maximum y value</span>
<span class="cm"> * @regulator: pointer to the regulator structure</span>
<span class="cm"> * @wait: wait queue structure variable</span>
<span class="cm"> * @touch_stopped: flag to stop the thread function</span>
<span class="cm"> *</span>
<span class="cm"> * This structure gives the device data information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_device_info</span> <span class="n">rmi4_mod_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">input_dev</span>	<span class="o">*</span><span class="n">input_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span>	<span class="o">*</span><span class="n">i2c_client</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">synaptics_rmi4_platform_data</span> <span class="o">*</span><span class="n">board</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">fn_list_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">rmi4_page_mutex</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">current_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">number_of_interrupt_register</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">fn01_ctrl_base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">fn01_query_base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">fn01_data_base_addr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sensor_max_x</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sensor_max_y</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">regulator</span>	<span class="o">*</span><span class="n">regulator</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">wait</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">touch_stopped</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_set_page() - sets the page</span>
<span class="cm"> * @pdata: pointer to synaptics_rmi4_data structure</span>
<span class="cm"> * @address: set the address of the page</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to set the page and returns integer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">synaptics_rmi4_set_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">txbuf</span><span class="p">[</span><span class="n">PAGE_LEN</span><span class="p">];</span>
	<span class="kt">int</span>		<span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">i2c</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">i2c_client</span><span class="p">;</span>

	<span class="n">page</span>	<span class="o">=</span> <span class="p">((</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MASK_8BIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">current_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">txbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">MASK_8BIT</span><span class="p">;</span>
		<span class="n">txbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">retval</span>	<span class="o">=</span> <span class="n">i2c_master_send</span><span class="p">(</span><span class="n">i2c</span><span class="p">,</span> <span class="n">txbuf</span><span class="p">,</span> <span class="n">PAGE_LEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">PAGE_LEN</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:failed:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">current_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PAGE_LEN</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_i2c_block_read() - read the block of data</span>
<span class="cm"> * @pdata: pointer to synaptics_rmi4_data structure</span>
<span class="cm"> * @address: read the block of data from this offset</span>
<span class="cm"> * @valp: pointer to a buffer containing the data to be read</span>
<span class="cm"> * @size: number of bytes to read</span>
<span class="cm"> *</span>
<span class="cm"> * This function is to read the block of data and returns integer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">address</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">valp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">i2c</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">i2c_client</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_page_mutex</span><span class="p">));</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_set_page</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">PAGE_LEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="n">MASK_8BIT</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">i2c_smbus_read_i2c_block_data</span><span class="p">(</span><span class="n">i2c</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">valp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">retry_count</span> <span class="o">==</span> <span class="n">MAX_RETRY_COUNT</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s:address 0x%04x size %d failed:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">synaptics_rmi4_set_page</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_page_mutex</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_i2c_byte_write() - write the single byte data</span>
<span class="cm"> * @pdata: pointer to synaptics_rmi4_data structure</span>
<span class="cm"> * @address: write the block of data from this offset</span>
<span class="cm"> * @data: data to be write</span>
<span class="cm"> *</span>
<span class="cm"> * This function is to write the single byte data and returns integer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">synaptics_rmi4_i2c_byte_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">address</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">txbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">i2c</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">i2c_client</span><span class="p">;</span>

	<span class="cm">/* Can&#39;t have anyone else changing the page behind our backs */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_page_mutex</span><span class="p">));</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_set_page</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">PAGE_LEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="n">txbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="n">MASK_8BIT</span><span class="p">;</span>
	<span class="n">txbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">retval</span>		<span class="o">=</span> <span class="n">i2c_master_send</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">i2c_client</span><span class="p">,</span> <span class="n">txbuf</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="cm">/* Add in retry on writes only in certain error return values */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:failed:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">exit:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_page_mutex</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * synpatics_rmi4_touchpad_report() - reports for the rmi4 touchpad device</span>
<span class="cm"> * @pdata: pointer to synaptics_rmi4_data structure</span>
<span class="cm"> * @rfi: pointer to synaptics_rmi4_fn structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function calls to reports for the rmi4 touchpad device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">synpatics_rmi4_touchpad_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">synaptics_rmi4_fn</span> <span class="o">*</span><span class="n">rfi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* number of touch points - fingers down in this case */</span>
	<span class="kt">int</span>	<span class="n">touch_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">finger</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">fingers_supported</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">finger_registers</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">finger_shift</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">finger_status</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">data_base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">data_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">data_reg_blk_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">data</span><span class="p">[</span><span class="n">DATA_LEN</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">x</span><span class="p">[</span><span class="n">RMI4_NUMBER_OF_MAX_FINGERS</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">y</span><span class="p">[</span><span class="n">RMI4_NUMBER_OF_MAX_FINGERS</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">wx</span><span class="p">[</span><span class="n">RMI4_NUMBER_OF_MAX_FINGERS</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">wy</span><span class="p">[</span><span class="n">RMI4_NUMBER_OF_MAX_FINGERS</span><span class="p">];</span>
	<span class="k">struct</span>	<span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">i2c_client</span><span class="p">;</span>

	<span class="cm">/* get 2D sensor finger data */</span>
	<span class="cm">/*</span>
<span class="cm">	 * First get the finger status field - the size of the finger status</span>
<span class="cm">	 * field is determined by the number of finger supporte - 2 bits per</span>
<span class="cm">	 * finger, so the number of registers to read is:</span>
<span class="cm">	 * registerCount = ceil(numberOfFingers/4).</span>
<span class="cm">	 * Read the required number of registers and check each 2 bit field to</span>
<span class="cm">	 * determine if a finger is down:</span>
<span class="cm">	 *	00 = finger not present,</span>
<span class="cm">	 *	01 = finger present and data accurate,</span>
<span class="cm">	 *	10 = finger present but data may not be accurate,</span>
<span class="cm">	 *	11 = reserved for product use.</span>
<span class="cm">	 */</span>
	<span class="n">fingers_supported</span>	<span class="o">=</span> <span class="n">rfi</span><span class="o">-&gt;</span><span class="n">num_of_data_points</span><span class="p">;</span>
	<span class="n">finger_registers</span>	<span class="o">=</span> <span class="p">(</span><span class="n">fingers_supported</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">data_base_addr</span>		<span class="o">=</span> <span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_desc</span><span class="p">.</span><span class="n">data_base_addr</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span> <span class="n">data_base_addr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
							<span class="n">finger_registers</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">finger_registers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:read status registers failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * For each finger present, read the proper number of registers</span>
<span class="cm">	 * to get absolute data.</span>
<span class="cm">	 */</span>
	<span class="n">data_reg_blk_size</span> <span class="o">=</span> <span class="n">rfi</span><span class="o">-&gt;</span><span class="n">size_of_data_register_block</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">finger</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">finger</span> <span class="o">&lt;</span> <span class="n">fingers_supported</span><span class="p">;</span> <span class="n">finger</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* determine which data byte the finger status is in */</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">finger</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* bit shift to get finger&#39;s status */</span>
		<span class="n">finger_shift</span>	<span class="o">=</span> <span class="p">(</span><span class="n">finger</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">finger_status</span>	<span class="o">=</span> <span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">finger_shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * if finger status indicates a finger is present then</span>
<span class="cm">		 * read the finger data and report it</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">finger_status</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">finger_status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Read the finger data */</span>
			<span class="n">data_offset</span> <span class="o">=</span> <span class="n">data_base_addr</span> <span class="o">+</span>
					<span class="p">((</span><span class="n">finger</span> <span class="o">*</span> <span class="n">data_reg_blk_size</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">finger_registers</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span>
						<span class="n">data_offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
						<span class="n">data_reg_blk_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">data_reg_blk_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s:read data failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">x</span><span class="p">[</span><span class="n">touch_count</span><span class="p">]</span>	<span class="o">=</span>
					<span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_4BIT</span><span class="p">);</span>
				<span class="n">y</span><span class="p">[</span><span class="n">touch_count</span><span class="p">]</span>	<span class="o">=</span>
					<span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MASK_4BIT</span><span class="p">);</span>
				<span class="n">wy</span><span class="p">[</span><span class="n">touch_count</span><span class="p">]</span>	<span class="o">=</span>
						<span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MASK_4BIT</span><span class="p">;</span>
				<span class="n">wx</span><span class="p">[</span><span class="n">touch_count</span><span class="p">]</span>	<span class="o">=</span>
						<span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_4BIT</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">x_flip</span><span class="p">)</span>
					<span class="n">x</span><span class="p">[</span><span class="n">touch_count</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">sensor_max_x</span> <span class="o">-</span>
								<span class="n">x</span><span class="p">[</span><span class="n">touch_count</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">y_flip</span><span class="p">)</span>
					<span class="n">y</span><span class="p">[</span><span class="n">touch_count</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">sensor_max_y</span> <span class="o">-</span>
								<span class="n">y</span><span class="p">[</span><span class="n">touch_count</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="cm">/* number of active touch points */</span>
			<span class="n">touch_count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* report to input subsystem */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">touch_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">finger</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">finger</span> <span class="o">&lt;</span> <span class="n">touch_count</span><span class="p">;</span> <span class="n">finger</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">input_report_abs</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">ABS_MT_TOUCH_MAJOR</span><span class="p">,</span>
						<span class="n">max</span><span class="p">(</span><span class="n">wx</span><span class="p">[</span><span class="n">finger</span><span class="p">]</span> <span class="p">,</span> <span class="n">wy</span><span class="p">[</span><span class="n">finger</span><span class="p">]));</span>
			<span class="n">input_report_abs</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">ABS_MT_POSITION_X</span><span class="p">,</span>
								<span class="n">x</span><span class="p">[</span><span class="n">finger</span><span class="p">]);</span>
			<span class="n">input_report_abs</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">ABS_MT_POSITION_Y</span><span class="p">,</span>
								<span class="n">y</span><span class="p">[</span><span class="n">finger</span><span class="p">]);</span>
			<span class="n">input_mt_sync</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">input_mt_sync</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>

	<span class="cm">/* sync after groups of events */</span>
	<span class="n">input_sync</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
	<span class="cm">/* return the number of touch points */</span>
	<span class="k">return</span> <span class="n">touch_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_report_device() - reports the rmi4 device</span>
<span class="cm"> * @pdata: pointer to synaptics_rmi4_data structure</span>
<span class="cm"> * @rfi: pointer to synaptics_rmi4_fn</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to call the report function of the rmi4 device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">synaptics_rmi4_report_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">synaptics_rmi4_fn</span> <span class="o">*</span><span class="n">rfi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">touch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">i2c_client</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">num_error_reports</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_number</span> <span class="o">!=</span> <span class="n">SYNAPTICS_RMI4_TOUCHPAD_FUNC_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_error_reports</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_error_reports</span> <span class="o">&lt;</span> <span class="n">MAX_ERROR_REPORT</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:report not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">touch</span> <span class="o">=</span> <span class="n">synpatics_rmi4_touchpad_report</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span> <span class="n">rfi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">touch</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_sensor_report() - reports to input subsystem</span>
<span class="cm"> * @pdata: pointer to synaptics_rmi4_data structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to reads in all data sources and reports</span>
<span class="cm"> * them to the input subsystem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">synaptics_rmi4_sensor_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">intr_status</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* number of touch points - fingers or buttons */</span>
	<span class="kt">int</span> <span class="n">touch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_fn</span>		<span class="o">*</span><span class="n">rfi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_device_info</span>	<span class="o">*</span><span class="n">rmi</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">i2c_client</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the interrupt status from the function $01</span>
<span class="cm">	 * control register+1 to find which source(s) were interrupting</span>
<span class="cm">	 * so we can read the data from the source(s) (2D sensor, buttons..)</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span>
					<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fn01_data_base_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					<span class="n">intr_status</span><span class="p">,</span>
					<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">number_of_interrupt_register</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">number_of_interrupt_register</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;could not read interrupt status registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * check each function that has data sources and if the interrupt for</span>
<span class="cm">	 * that triggered then call that RMI4 functions report() function to</span>
<span class="cm">	 * gather data and report it to the input subsystem</span>
<span class="cm">	 */</span>
	<span class="n">rmi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rfi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmi</span><span class="o">-&gt;</span><span class="n">support_fn_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rfi</span><span class="o">-&gt;</span><span class="n">num_of_data_sources</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span><span class="p">[</span><span class="n">rfi</span><span class="o">-&gt;</span><span class="n">index_to_intr_reg</span><span class="p">]</span> <span class="o">&amp;</span>
							<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">intr_mask</span><span class="p">)</span>
				<span class="n">touch</span> <span class="o">=</span> <span class="n">synaptics_rmi4_report_device</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span>
									<span class="n">rfi</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* return the number of touch points */</span>
	<span class="k">return</span> <span class="n">touch</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_irq() - thread function for rmi4 attention line</span>
<span class="cm"> * @irq: irq value</span>
<span class="cm"> * @data: void pointer</span>
<span class="cm"> *</span>
<span class="cm"> * This function is interrupt thread function. It just notifies the</span>
<span class="cm"> * application layer that attention is required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">synaptics_rmi4_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">touch_count</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">touch_count</span> <span class="o">=</span> <span class="n">synaptics_rmi4_sensor_report</span><span class="p">(</span><span class="n">pdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">touch_count</span><span class="p">)</span>
			<span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">touch_stopped</span><span class="p">,</span>
							<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">touch_stopped</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * synpatics_rmi4_touchpad_detect() - detects the rmi4 touchpad device</span>
<span class="cm"> * @pdata: pointer to synaptics_rmi4_data structure</span>
<span class="cm"> * @rfi: pointer to synaptics_rmi4_fn structure</span>
<span class="cm"> * @fd: pointer to synaptics_rmi4_fn_desc structure</span>
<span class="cm"> * @interruptcount: count the number of interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * This function calls to detects the rmi4 touchpad device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">synpatics_rmi4_touchpad_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">synaptics_rmi4_fn</span> <span class="o">*</span><span class="n">rfi</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">synaptics_rmi4_fn_desc</span> <span class="o">*</span><span class="n">fd</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interruptcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">queries</span><span class="p">[</span><span class="n">QUERY_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">intr_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">abs_data_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">abs_data_blk_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">egr_0</span><span class="p">,</span> <span class="n">egr_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">all_data_blk_size</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">has_pinch</span><span class="p">,</span> <span class="n">has_flick</span><span class="p">,</span> <span class="n">has_tap</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">has_tapandhold</span><span class="p">,</span> <span class="n">has_doubletap</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">has_earlytap</span><span class="p">,</span> <span class="n">has_press</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">has_palmdetect</span><span class="p">,</span> <span class="n">has_rotate</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">has_rel</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">i2c_client</span><span class="p">;</span>

	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_desc</span><span class="p">.</span><span class="n">query_base_addr</span>	<span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">query_base_addr</span><span class="p">;</span>
	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_desc</span><span class="p">.</span><span class="n">data_base_addr</span>	<span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">data_base_addr</span><span class="p">;</span>
	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_desc</span><span class="p">.</span><span class="n">intr_src_count</span>	<span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">intr_src_count</span><span class="p">;</span>
	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_desc</span><span class="p">.</span><span class="n">fn_number</span>		<span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">fn_number</span><span class="p">;</span>
	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_number</span>			<span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">fn_number</span><span class="p">;</span>
	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">num_of_data_sources</span>	<span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">intr_src_count</span><span class="p">;</span>
	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_desc</span><span class="p">.</span><span class="n">ctrl_base_addr</span>	<span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">ctrl_base_addr</span><span class="p">;</span>
	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_desc</span><span class="p">.</span><span class="n">cmd_base_addr</span>	<span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">cmd_base_addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * need to get number of fingers supported, data size, etc.</span>
<span class="cm">	 * to be used when getting data since the number of registers to</span>
<span class="cm">	 * read depends on the number of fingers supported and data size.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">query_base_addr</span><span class="p">,</span>
							<span class="n">queries</span><span class="p">,</span>
							<span class="k">sizeof</span><span class="p">(</span><span class="n">queries</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">queries</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:read function query registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * 2D data sources have only 3 bits for the number of fingers</span>
<span class="cm">	 * supported - so the encoding is a bit weird.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">queries</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_3BIT</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="cm">/* add 1 since zero based */</span>
		<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">num_of_data_points</span> <span class="o">=</span> <span class="p">(</span><span class="n">queries</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_3BIT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * a value of 5 is up to 10 fingers - 6 and 7 are reserved</span>
<span class="cm">		 * (shouldn&#39;t get these i int retval;n a normal 2D source).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">queries</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_3BIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
			<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">num_of_data_points</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Need to get interrupt info for handling interrupts */</span>
	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">index_to_intr_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">interruptcount</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rfi</span><span class="o">-&gt;</span><span class="n">index_to_intr_reg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">index_to_intr_reg</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * loop through interrupts for each source in fn $11</span>
<span class="cm">	 * and or in a bit to the interrupt mask for each.</span>
<span class="cm">	 */</span>
	<span class="n">intr_offset</span> <span class="o">=</span> <span class="n">interruptcount</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">intr_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">intr_offset</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">intr_src_count</span> <span class="o">&amp;</span> <span class="n">MASK_3BIT</span><span class="p">)</span> <span class="o">+</span> <span class="n">intr_offset</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">intr_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Size of just the absolute data for one finger */</span>
	<span class="n">abs_data_size</span>	<span class="o">=</span> <span class="n">queries</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_2BIT</span><span class="p">;</span>
	<span class="cm">/* One each for X and Y, one for LSB for X &amp; Y, one for W, one for Z */</span>
	<span class="n">abs_data_blk_size</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs_data_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">size_of_data_register_block</span> <span class="o">=</span> <span class="n">abs_data_blk_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * need to determine the size of data to read - this depends on</span>
<span class="cm">	 * conditions such as whether Relative data is reported and if Gesture</span>
<span class="cm">	 * data is reported.</span>
<span class="cm">	 */</span>
	<span class="n">egr_0</span> <span class="o">=</span> <span class="n">queries</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="n">egr_1</span> <span class="o">=</span> <span class="n">queries</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get info about what EGR data is supported, whether it has</span>
<span class="cm">	 * Relative data supported, etc.</span>
<span class="cm">	 */</span>
	<span class="n">has_pinch</span>	<span class="o">=</span> <span class="n">egr_0</span> <span class="o">&amp;</span> <span class="n">HAS_PINCH</span><span class="p">;</span>
	<span class="n">has_flick</span>	<span class="o">=</span> <span class="n">egr_0</span> <span class="o">&amp;</span> <span class="n">HAS_FLICK</span><span class="p">;</span>
	<span class="n">has_tap</span>		<span class="o">=</span> <span class="n">egr_0</span> <span class="o">&amp;</span> <span class="n">HAS_TAP</span><span class="p">;</span>
	<span class="n">has_earlytap</span>	<span class="o">=</span> <span class="n">egr_0</span> <span class="o">&amp;</span> <span class="n">HAS_EARLYTAP</span><span class="p">;</span>
	<span class="n">has_press</span>	<span class="o">=</span> <span class="n">egr_0</span> <span class="o">&amp;</span> <span class="n">HAS_PRESS</span><span class="p">;</span>
	<span class="n">has_rotate</span>	<span class="o">=</span> <span class="n">egr_1</span> <span class="o">&amp;</span> <span class="n">HAS_ROTATE</span><span class="p">;</span>
	<span class="n">has_rel</span>		<span class="o">=</span> <span class="n">queries</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">HAS_RELEASE</span><span class="p">;</span>
	<span class="n">has_tapandhold</span>	<span class="o">=</span> <span class="n">egr_0</span> <span class="o">&amp;</span> <span class="n">HAS_TAPANDHOLD</span><span class="p">;</span>
	<span class="n">has_doubletap</span>	<span class="o">=</span> <span class="n">egr_0</span> <span class="o">&amp;</span> <span class="n">HAS_DOUBLETAP</span><span class="p">;</span>
	<span class="n">has_palmdetect</span>	<span class="o">=</span> <span class="n">egr_1</span> <span class="o">&amp;</span> <span class="n">HAS_PALMDETECT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Size of all data including finger status, absolute data for each</span>
<span class="cm">	 * finger, relative data and EGR data</span>
<span class="cm">	 */</span>
	<span class="n">all_data_blk_size</span> <span class="o">=</span>
		<span class="cm">/* finger status, four fingers per register */</span>
		<span class="p">((</span><span class="n">rfi</span><span class="o">-&gt;</span><span class="n">num_of_data_points</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span>
		<span class="cm">/* absolute data, per finger times number of fingers */</span>
		<span class="p">(</span><span class="n">abs_data_blk_size</span> <span class="o">*</span> <span class="n">rfi</span><span class="o">-&gt;</span><span class="n">num_of_data_points</span><span class="p">)</span> <span class="o">+</span>
		<span class="cm">/*</span>
<span class="cm">		 * two relative registers (if relative is being reported)</span>
<span class="cm">		 */</span>
		<span class="mi">2</span> <span class="o">*</span> <span class="n">has_rel</span> <span class="o">+</span>
		<span class="cm">/*</span>
<span class="cm">		 * F11_2D_data8 is only present if the egr_0</span>
<span class="cm">		 * register is non-zero.</span>
<span class="cm">		 */</span>
		<span class="o">!!</span><span class="p">(</span><span class="n">egr_0</span><span class="p">)</span> <span class="o">+</span>
		<span class="cm">/*</span>
<span class="cm">		 * F11_2D_data9 is only present if either egr_0 or</span>
<span class="cm">		 * egr_1 registers are non-zero.</span>
<span class="cm">		 */</span>
		<span class="p">(</span><span class="n">egr_0</span> <span class="o">||</span> <span class="n">egr_1</span><span class="p">)</span> <span class="o">+</span>
		<span class="cm">/*</span>
<span class="cm">		 * F11_2D_data10 is only present if EGR_PINCH or EGR_FLICK of</span>
<span class="cm">		 * egr_0 reports as 1.</span>
<span class="cm">		 */</span>
		<span class="o">!!</span><span class="p">(</span><span class="n">has_pinch</span> <span class="o">|</span> <span class="n">has_flick</span><span class="p">)</span> <span class="o">+</span>
		<span class="cm">/*</span>
<span class="cm">		 * F11_2D_data11 and F11_2D_data12 are only present if</span>
<span class="cm">		 * EGR_FLICK of egr_0 reports as 1.</span>
<span class="cm">		 */</span>
		<span class="mi">2</span> <span class="o">*</span> <span class="o">!!</span><span class="p">(</span><span class="n">has_flick</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * synpatics_rmi4_touchpad_config() - confiures the rmi4 touchpad device</span>
<span class="cm"> * @pdata: pointer to synaptics_rmi4_data structure</span>
<span class="cm"> * @rfi: pointer to synaptics_rmi4_fn structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function calls to confiures the rmi4 touchpad device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">synpatics_rmi4_touchpad_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">synaptics_rmi4_fn</span> <span class="o">*</span><span class="n">rfi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * For the data source - print info and do any</span>
<span class="cm">	 * source specific configuration.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">BUF_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">i2c_client</span><span class="p">;</span>

	<span class="cm">/* Get and print some info about the data source... */</span>
	<span class="cm">/* To Query 2D devices we need to read from the address obtained</span>
<span class="cm">	 * from the function descriptor stored in the RMI function info.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span>
						<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_desc</span><span class="p">.</span><span class="n">query_base_addr</span><span class="p">,</span>
						<span class="n">data</span><span class="p">,</span> <span class="n">QUERY_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">QUERY_LEN</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:read query registers failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span>
						<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_desc</span><span class="p">.</span><span class="n">ctrl_base_addr</span><span class="p">,</span>
						<span class="n">data</span><span class="p">,</span> <span class="n">DATA_BUF_LEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">DATA_BUF_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s:read control registers failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Store these for use later*/</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">sensor_max_x</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_8BIT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
						<span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_4BIT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">sensor_max_y</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_5BIT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
						<span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_4BIT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_i2c_query_device() - query the rmi4 device</span>
<span class="cm"> * @pdata: pointer to synaptics_rmi4_data structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to query the rmi4 device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">synaptics_rmi4_i2c_query_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">std_queries</span><span class="p">[</span><span class="n">STD_QUERY_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">intr_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_sources</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrl_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_fn</span> <span class="o">*</span><span class="n">rfi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_fn_desc</span>	<span class="n">rmi_fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_device_info</span> <span class="o">*</span><span class="n">rmi</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">i2c_client</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * init the physical drivers RMI module</span>
<span class="cm">	 * info list of functions</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">support_fn_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the Page Descriptor Table to determine what functions</span>
<span class="cm">	 * are present</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PDT_START_SCAN_LOCATION</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">PDT_END_SCAN_LOCATION</span><span class="p">;</span>
						<span class="n">i</span> <span class="o">-=</span> <span class="n">PDT_ENTRY_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rmi_fd</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">rmi_fd</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rmi_fd</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* failed to read next PDT entry */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: read error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rfi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rmi_fd</span><span class="p">.</span><span class="n">fn_number</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">rmi_fd</span><span class="p">.</span><span class="n">fn_number</span> <span class="o">&amp;</span> <span class="n">MASK_8BIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SYNAPTICS_RMI4_DEVICE_CONTROL_FUNC_NUM</span>:
				<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fn01_query_base_addr</span> <span class="o">=</span>
						<span class="n">rmi_fd</span><span class="p">.</span><span class="n">query_base_addr</span><span class="p">;</span>
				<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fn01_ctrl_base_addr</span> <span class="o">=</span>
						<span class="n">rmi_fd</span><span class="p">.</span><span class="n">ctrl_base_addr</span><span class="p">;</span>
				<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fn01_data_base_addr</span> <span class="o">=</span>
						<span class="n">rmi_fd</span><span class="p">.</span><span class="n">data_base_addr</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SYNAPTICS_RMI4_TOUCHPAD_FUNC_NUM</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">rmi_fd</span><span class="p">.</span><span class="n">intr_src_count</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">rfi</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rfi</span><span class="p">),</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfi</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							<span class="s">&quot;%s:kmalloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
							<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="n">synpatics_rmi4_touchpad_detect</span>
								<span class="p">(</span><span class="n">pdata</span><span class="p">,</span>	<span class="n">rfi</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">rmi_fd</span><span class="p">,</span>
								<span class="n">intr_count</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">kfree</span><span class="p">(</span><span class="n">rfi</span><span class="p">);</span>
						<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* interrupt count for next iteration */</span>
			<span class="n">intr_count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rmi_fd</span><span class="p">.</span><span class="n">intr_src_count</span> <span class="o">&amp;</span> <span class="n">MASK_3BIT</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * We only want to add functions to the list</span>
<span class="cm">			 * that have data associated with them.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rfi</span> <span class="o">&amp;&amp;</span> <span class="n">rmi_fd</span><span class="p">.</span><span class="n">intr_src_count</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* link this function info to the RMI module */</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fn_list_mutex</span><span class="p">));</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfi</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">support_fn_list</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fn_list_mutex</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * A zero in the function number</span>
<span class="cm">			 * signals the end of the PDT</span>
<span class="cm">			 */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s:end of PDT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * calculate the interrupt register count - used in the</span>
<span class="cm">	 * ISR to read the correct number of interrupt registers</span>
<span class="cm">	 */</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">number_of_interrupt_register</span> <span class="o">=</span> <span class="p">(</span><span class="n">intr_count</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Function $01 will be used to query the product properties,</span>
<span class="cm">	 * and product ID  so we had to read the PDT above first to get</span>
<span class="cm">	 * the Fn $01 query address and prior to filling in the product</span>
<span class="cm">	 * info. NOTE: Even an unflashed device will still have FN $01.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Load up the standard queries and get the RMI4 module info */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span>
					<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fn01_query_base_addr</span><span class="p">,</span>
					<span class="n">std_queries</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">std_queries</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std_queries</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:Failed reading queries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">);</span>
		 <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Currently supported RMI version is 4.0 */</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">version_major</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">version_minor</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * get manufacturer id, product_props, product info,</span>
<span class="cm">	 * date code, tester id, serial num and product id (name)</span>
<span class="cm">	 */</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">manufacturer_id</span>	<span class="o">=</span> <span class="n">std_queries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">product_props</span>	<span class="o">=</span> <span class="n">std_queries</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">product_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">std_queries</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">product_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="n">std_queries</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="cm">/* year - 2001-2032 */</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">date_code</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">std_queries</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_5BIT</span><span class="p">;</span>
	<span class="cm">/* month - 1-12 */</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">date_code</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="n">std_queries</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_4BIT</span><span class="p">;</span>
	<span class="cm">/* day - 1-31 */</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">date_code</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>	<span class="o">=</span> <span class="n">std_queries</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_5BIT</span><span class="p">;</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">tester_id</span> <span class="o">=</span> <span class="p">((</span><span class="n">std_queries</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_7BIT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
						<span class="p">(</span><span class="n">std_queries</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_7BIT</span><span class="p">);</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">serial_number</span> <span class="o">=</span>
		<span class="p">((</span><span class="n">std_queries</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_7BIT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">std_queries</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_7BIT</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">product_id_string</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">std_queries</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* Check if this is a Synaptics device - report if not. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">manufacturer_id</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: non-Synaptics mfg id:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">manufacturer_id</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rfi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">.</span><span class="n">support_fn_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="n">data_sources</span> <span class="o">+=</span> <span class="n">rfi</span><span class="o">-&gt;</span><span class="n">num_of_data_sources</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_sources</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rmi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rmi4_mod_info</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rfi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmi</span><span class="o">-&gt;</span><span class="n">support_fn_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rfi</span><span class="o">-&gt;</span><span class="n">num_of_data_sources</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rfi</span><span class="o">-&gt;</span><span class="n">fn_number</span> <span class="o">==</span>
					<span class="n">SYNAPTICS_RMI4_TOUCHPAD_FUNC_NUM</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="n">synpatics_rmi4_touchpad_config</span>
								<span class="p">(</span><span class="n">pdata</span><span class="p">,</span> <span class="n">rfi</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
						<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;%s:fn_number not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Turn on interrupts for this</span>
<span class="cm">				 * function&#39;s data sources.</span>
<span class="cm">				 */</span>
				<span class="n">ctrl_offset</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fn01_ctrl_base_addr</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
							<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">index_to_intr_reg</span><span class="p">;</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_byte_write</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span>
							<span class="n">ctrl_offset</span><span class="p">,</span>
							<span class="n">rfi</span><span class="o">-&gt;</span><span class="n">intr_mask</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_probe() - Initialze the i2c-client touchscreen driver</span>
<span class="cm"> * @i2c: i2c client structure pointer</span>
<span class="cm"> * @id:i2c device id pointer</span>
<span class="cm"> *</span>
<span class="cm"> * This function will allocate and initialize the instance</span>
<span class="cm"> * data and request the irq and set the instance data as the clients</span>
<span class="cm"> * platform data then register the physical driver which will do a scan of</span>
<span class="cm"> * the rmi4 Physical Device Table and enumerate any rmi4 functions that</span>
<span class="cm"> * have data sources associated with them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">synaptics_rmi4_probe</span>
	<span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">intr_status</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">rmi4_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">synaptics_rmi4_platform_data</span> <span class="o">*</span><span class="n">platformdata</span> <span class="o">=</span>
						<span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2c_check_functionality</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span>
					<span class="n">I2C_FUNC_SMBUS_BYTE_DATA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;i2c smbus byte data not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">platformdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: no platform data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate and initialize the instance data for this client */</span>
	<span class="n">rmi4_data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">synaptics_rmi4_data</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
							<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmi4_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: no memory allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span> <span class="o">=</span> <span class="n">input_allocate_device</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:input device alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_input</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">regulator</span> <span class="o">=</span> <span class="n">regulator_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vdd&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:get regulator failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_get_regulator</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">regulator_enable</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:regulator enable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_regulator_enable</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy i2c_client pointer into RTID&#39;s i2c_client pointer for</span>
<span class="cm">	 * later use in rmi4_read, rmi4_write, etc.</span>
<span class="cm">	 */</span>
	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">i2c_client</span>		<span class="o">=</span> <span class="n">client</span><span class="p">;</span>
	<span class="cm">/* So we set the page correctly the first time */</span>
	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">current_page</span>		<span class="o">=</span> <span class="n">MASK_16BIT</span><span class="p">;</span>
	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">board</span>		<span class="o">=</span> <span class="n">platformdata</span><span class="p">;</span>
	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">touch_stopped</span>	<span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* init the mutexes for maintain the lists */</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">fn_list_mutex</span><span class="p">));</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">rmi4_page_mutex</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register physical driver - this will call the detect function that</span>
<span class="cm">	 * will then scan the device and determine the supported</span>
<span class="cm">	 * rmi4 functions.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_query_device</span><span class="p">(</span><span class="n">rmi4_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: rmi4 query device failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_query_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Store the instance data in the i2c_client */</span>
	<span class="n">i2c_set_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">rmi4_data</span><span class="p">);</span>

	<span class="cm">/*initialize the input device parameters */</span>
	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">name</span>	<span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">;</span>
	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">phys</span>	<span class="o">=</span> <span class="s">&quot;Synaptics_Clearpad&quot;</span><span class="p">;</span>
	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">bustype</span> <span class="o">=</span> <span class="n">BUS_I2C</span><span class="p">;</span>
	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">input_set_drvdata</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">rmi4_data</span><span class="p">);</span>

	<span class="cm">/* Initialize the function handlers for rmi4 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">EV_SYN</span><span class="p">,</span> <span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">evbit</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">EV_KEY</span><span class="p">,</span> <span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">evbit</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">EV_ABS</span><span class="p">,</span> <span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="o">-&gt;</span><span class="n">evbit</span><span class="p">);</span>

	<span class="n">input_set_abs_params</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">ABS_MT_POSITION_X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">sensor_max_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">input_set_abs_params</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">ABS_MT_POSITION_Y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">sensor_max_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">input_set_abs_params</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">ABS_MT_TOUCH_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">MAX_TOUCH_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Clear interrupts */</span>
	<span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">rmi4_data</span><span class="p">,</span>
			<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">fn01_data_base_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">intr_status</span><span class="p">,</span>
				<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">number_of_interrupt_register</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_threaded_irq</span><span class="p">(</span><span class="n">platformdata</span><span class="o">-&gt;</span><span class="n">irq_number</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="n">synaptics_rmi4_irq</span><span class="p">,</span>
					<span class="n">platformdata</span><span class="o">-&gt;</span><span class="n">irq_type</span><span class="p">,</span>
					<span class="n">DRIVER_NAME</span><span class="p">,</span> <span class="n">rmi4_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:Unable to get attn irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">platformdata</span><span class="o">-&gt;</span><span class="n">irq_number</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_query_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">input_register_device</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:input register failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">err_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">platformdata</span><span class="o">-&gt;</span><span class="n">irq_number</span><span class="p">,</span> <span class="n">rmi4_data</span><span class="p">);</span>
<span class="nl">err_query_dev:</span>
	<span class="n">regulator_disable</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>
<span class="nl">err_regulator_enable:</span>
	<span class="n">regulator_put</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>
<span class="nl">err_get_regulator:</span>
	<span class="n">input_free_device</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">err_input:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rmi4_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_remove() - Removes the i2c-client touchscreen driver</span>
<span class="cm"> * @client: i2c client structure pointer</span>
<span class="cm"> *</span>
<span class="cm"> * This function uses to remove the i2c-client</span>
<span class="cm"> * touchscreen driver and returns integer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">synaptics_rmi4_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">rmi4_data</span> <span class="o">=</span> <span class="n">i2c_get_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">synaptics_rmi4_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">board</span><span class="p">;</span>

	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">touch_stopped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irq_number</span><span class="p">,</span> <span class="n">rmi4_data</span><span class="p">);</span>
	<span class="n">input_unregister_device</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
	<span class="n">regulator_disable</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>
	<span class="n">regulator_put</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rmi4_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_suspend() - suspend the touch screen controller</span>
<span class="cm"> * @dev: pointer to device structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to suspend the</span>
<span class="cm"> * touch panel controller and returns integer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">synaptics_rmi4_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Touch sleep mode */</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">intr_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">rmi4_data</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">synaptics_rmi4_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">board</span><span class="p">;</span>

	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">touch_stopped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">disable_irq</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irq_number</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">rmi4_data</span><span class="p">,</span>
				<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">fn01_data_base_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">intr_status</span><span class="p">,</span>
				<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">number_of_interrupt_register</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_byte_write</span><span class="p">(</span><span class="n">rmi4_data</span><span class="p">,</span>
					<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">fn01_ctrl_base_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					<span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TOUCHPAD_CTRL_INTR</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">regulator_disable</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_resume() - resume the touch screen controller</span>
<span class="cm"> * @dev: pointer to device structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to resume the touch panel</span>
<span class="cm"> * controller and returns integer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">synaptics_rmi4_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">intr_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">synaptics_rmi4_data</span> <span class="o">*</span><span class="n">rmi4_data</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">synaptics_rmi4_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">board</span><span class="p">;</span>

	<span class="n">regulator_enable</span><span class="p">(</span><span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>

	<span class="n">enable_irq</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irq_number</span><span class="p">);</span>
	<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">touch_stopped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_block_read</span><span class="p">(</span><span class="n">rmi4_data</span><span class="p">,</span>
				<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">fn01_data_base_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">intr_status</span><span class="p">,</span>
				<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">number_of_interrupt_register</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">synaptics_rmi4_i2c_byte_write</span><span class="p">(</span><span class="n">rmi4_data</span><span class="p">,</span>
					<span class="n">rmi4_data</span><span class="o">-&gt;</span><span class="n">fn01_ctrl_base_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					<span class="p">(</span><span class="n">intr_status</span> <span class="o">|</span> <span class="n">TOUCHPAD_CTRL_INTR</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">synaptics_rmi4_dev_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">synaptics_rmi4_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>  <span class="o">=</span> <span class="n">synaptics_rmi4_resume</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="n">synaptics_rmi4_id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">DRIVER_NAME</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">i2c</span><span class="p">,</span> <span class="n">synaptics_rmi4_id_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_driver</span> <span class="n">synaptics_rmi4_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span>	<span class="n">DRIVER_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
		<span class="p">.</span><span class="n">pm</span>	<span class="o">=</span>	<span class="o">&amp;</span><span class="n">synaptics_rmi4_dev_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span>	<span class="n">synaptics_rmi4_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span>	<span class="n">__devexit_p</span><span class="p">(</span><span class="n">synaptics_rmi4_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span>	<span class="n">synaptics_rmi4_id_table</span><span class="p">,</span>
<span class="p">};</span>
<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_init() - Initialize the touchscreen driver</span>
<span class="cm"> *</span>
<span class="cm"> * This function uses to initializes the synaptics</span>
<span class="cm"> * touchscreen driver and returns integer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">synaptics_rmi4_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i2c_add_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">synaptics_rmi4_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * synaptics_rmi4_exit() - De-initialize the touchscreen driver</span>
<span class="cm"> *</span>
<span class="cm"> * This function uses to de-initialize the synaptics</span>
<span class="cm"> * touchscreen driver and returns none.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">synaptics_rmi4_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2c_del_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">synaptics_rmi4_driver</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">module_init</span><span class="p">(</span><span class="n">synaptics_rmi4_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">synaptics_rmi4_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;naveen.gaddipati@stericsson.com, js.ha@stericsson.com&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;synaptics rmi4 i2c touch Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;i2c:synaptics_rmi4_ts&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
