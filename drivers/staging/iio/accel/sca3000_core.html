<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › iio › accel › sca3000_core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>sca3000_core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * sca3000_core.c -- support VTI sca3000 series accelerometers via SPI</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2009 Jonathan Cameron &lt;jic23@cam.ac.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * See industrialio/accels/sca3000.h for comments.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/spi/spi.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/iio/iio.h&gt;</span>
<span class="cp">#include &lt;linux/iio/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/iio/events.h&gt;</span>
<span class="cp">#include &lt;linux/iio/buffer.h&gt;</span>

<span class="cp">#include &quot;sca3000.h&quot;</span>

<span class="k">enum</span> <span class="n">sca3000_variant</span> <span class="p">{</span>
	<span class="n">d01</span><span class="p">,</span>
	<span class="n">e02</span><span class="p">,</span>
	<span class="n">e04</span><span class="p">,</span>
	<span class="n">e05</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Note where option modes are not defined, the chip simply does not</span>
<span class="cm"> * support any.</span>
<span class="cm"> * Other chips in the sca3000 series use i2c and are not included here.</span>
<span class="cm"> *</span>
<span class="cm"> * Some of these devices are only listed in the family data sheet and</span>
<span class="cm"> * do not actually appear to be available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sca3000_chip_info</span> <span class="n">sca3000_spi_chip_info_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">d01</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mi">7357</span><span class="p">,</span>
		<span class="p">.</span><span class="n">temp_output</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
		<span class="p">.</span><span class="n">measurement_mode_freq</span> <span class="o">=</span> <span class="mi">250</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_1</span> <span class="o">=</span> <span class="n">SCA3000_OP_MODE_BYPASS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_1_freq</span> <span class="o">=</span> <span class="mi">250</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mot_det_mult_xz</span> <span class="o">=</span> <span class="p">{</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">350</span><span class="p">,</span> <span class="mi">650</span><span class="p">,</span> <span class="mi">1300</span><span class="p">},</span>
		<span class="p">.</span><span class="n">mot_det_mult_y</span> <span class="o">=</span> <span class="p">{</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="mi">850</span><span class="p">,</span> <span class="mi">1750</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">e02</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mi">9810</span><span class="p">,</span>
		<span class="p">.</span><span class="n">measurement_mode_freq</span> <span class="o">=</span> <span class="mi">125</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_1</span> <span class="o">=</span> <span class="n">SCA3000_OP_MODE_NARROW</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_1_freq</span> <span class="o">=</span> <span class="mi">63</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mot_det_mult_xz</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">550</span><span class="p">,</span> <span class="mi">1050</span><span class="p">,</span> <span class="mi">2050</span><span class="p">},</span>
		<span class="p">.</span><span class="n">mot_det_mult_y</span> <span class="o">=</span> <span class="p">{</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">350</span><span class="p">,</span> <span class="mi">700</span><span class="p">,</span> <span class="mi">1350</span><span class="p">,</span> <span class="mi">2700</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">e04</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mi">19620</span><span class="p">,</span>
		<span class="p">.</span><span class="n">measurement_mode_freq</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_1</span> <span class="o">=</span> <span class="n">SCA3000_OP_MODE_NARROW</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_1_freq</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_2</span> <span class="o">=</span> <span class="n">SCA3000_OP_MODE_WIDE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_2_freq</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mot_det_mult_xz</span> <span class="o">=</span> <span class="p">{</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">1100</span><span class="p">,</span> <span class="mi">2100</span><span class="p">,</span> <span class="mi">4100</span><span class="p">},</span>
		<span class="p">.</span><span class="n">mot_det_mult_y</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">7000</span><span class="p">,</span> <span class="mi">1400</span><span class="p">,</span> <span class="mi">2700</span><span class="p">,</span> <span class="mi">54000</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">e05</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mi">61313</span><span class="p">,</span>
		<span class="p">.</span><span class="n">measurement_mode_freq</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_1</span> <span class="o">=</span> <span class="n">SCA3000_OP_MODE_NARROW</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_1_freq</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_2</span> <span class="o">=</span> <span class="n">SCA3000_OP_MODE_WIDE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">option_mode_2_freq</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mot_det_mult_xz</span> <span class="o">=</span> <span class="p">{</span><span class="mi">600</span><span class="p">,</span> <span class="mi">900</span><span class="p">,</span> <span class="mi">1700</span><span class="p">,</span> <span class="mi">3200</span><span class="p">,</span> <span class="mi">6100</span><span class="p">,</span> <span class="mi">11900</span><span class="p">},</span>
		<span class="p">.</span><span class="n">mot_det_mult_y</span> <span class="o">=</span> <span class="p">{</span><span class="mi">300</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">1200</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">4100</span><span class="p">,</span> <span class="mi">7800</span><span class="p">,</span> <span class="mi">15600</span><span class="p">},</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">sca3000_write_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span> <span class="n">u8</span> <span class="n">address</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCA3000_WRITE_REG</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">spi_write</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">us</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sca3000_read_data_short</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span>
			    <span class="kt">uint8_t</span> <span class="n">reg_address_high</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="n">xfer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span>
			<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">.</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">,</span>
		<span class="p">},</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span>
			<span class="p">.</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">};</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCA3000_READ_REG</span><span class="p">(</span><span class="n">reg_address_high</span><span class="p">);</span>
	<span class="n">spi_message_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">spi_sync</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">us</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_reg_lock_on() test if the ctrl register lock is on</span>
<span class="cm"> *</span>
<span class="cm"> * Lock must be held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_reg_lock_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_STATUS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">SCA3000_LOCKED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __sca3000_unlock_reg_lock() unlock the control registers</span>
<span class="cm"> *</span>
<span class="cm"> * Note the device does not appear to support doing this in a single transfer.</span>
<span class="cm"> * This should only ever be used as part of ctrl reg read.</span>
<span class="cm"> * Lock must be held before calling this</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__sca3000_unlock_reg_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="n">xfer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span>
			<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
			<span class="p">.</span><span class="n">cs_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">.</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">,</span>
		<span class="p">},</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
			<span class="p">.</span><span class="n">cs_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">.</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
		<span class="p">},</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
			<span class="p">.</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">};</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCA3000_WRITE_REG</span><span class="p">(</span><span class="n">SCA3000_REG_ADDR_UNLOCK</span><span class="p">);</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCA3000_WRITE_REG</span><span class="p">(</span><span class="n">SCA3000_REG_ADDR_UNLOCK</span><span class="p">);</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x50</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCA3000_WRITE_REG</span><span class="p">(</span><span class="n">SCA3000_REG_ADDR_UNLOCK</span><span class="p">);</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xA0</span><span class="p">;</span>
	<span class="n">spi_message_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">spi_sync</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">us</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_write_ctrl_reg() write to a lock protect ctrl register</span>
<span class="cm"> * @sel: selects which registers we wish to write to</span>
<span class="cm"> * @val: the value to be written</span>
<span class="cm"> *</span>
<span class="cm"> * Certain control registers are protected against overwriting by the lock</span>
<span class="cm"> * register and use a shared write address. This function allows writing of</span>
<span class="cm"> * these registers.</span>
<span class="cm"> * Lock must be held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_write_ctrl_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span>
				  <span class="kt">uint8_t</span> <span class="n">sel</span><span class="p">,</span>
				  <span class="kt">uint8_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_reg_lock_on</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__sca3000_unlock_reg_lock</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the control select register */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_CTRL_SEL</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>

	<span class="cm">/* Write the actual value into the register */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_CTRL_DATA</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

<span class="nl">error_ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Crucial that lock is called before calling this */</span>
<span class="cm">/**</span>
<span class="cm"> * sca3000_read_ctrl_reg() read from lock protected control register.</span>
<span class="cm"> *</span>
<span class="cm"> * Lock must be held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_read_ctrl_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">ctrl_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_reg_lock_on</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__sca3000_unlock_reg_lock</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Set the control select register */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_CTRL_SEL</span><span class="p">,</span> <span class="n">ctrl_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_CTRL_DATA</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="nl">error_ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef SCA3000_DEBUG</span>
<span class="cm">/**</span>
<span class="cm"> * sca3000_check_status() check the status register</span>
<span class="cm"> *</span>
<span class="cm"> * Only used for debugging purposes</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_check_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_STATUS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">SCA3000_EEPROM_CS_ERROR</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;eeprom error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">SCA3000_SPI_FRAME_ERROR</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Previous SPI Frame was corrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">error_ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* SCA3000_DEBUG */</span><span class="cp"></span>


<span class="cm">/**</span>
<span class="cm"> * sca3000_show_reg() - sysfs interface to read the chip revision number</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sca3000_show_rev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_REVID</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
		       <span class="s">&quot;major=%d, minor=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">SCA3000_REVID_MAJOR_MASK</span><span class="p">,</span>
		       <span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">SCA3000_REVID_MINOR_MASK</span><span class="p">);</span>
<span class="nl">error_ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_show_available_measurement_modes() display available modes</span>
<span class="cm"> *</span>
<span class="cm"> * This is all read from chip specific data in the driver. Not all</span>
<span class="cm"> * of the sca3000 series support modes other than normal.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sca3000_show_available_measurement_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;0 - normal mode&quot;</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_1</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCA3000_OP_MODE_NARROW</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;, 1 - narrow mode&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCA3000_OP_MODE_BYPASS</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;, 1 - bypass mode&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_2</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCA3000_OP_MODE_WIDE</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;, 2 - wide mode&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* always supported */</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot; 3 - motion detection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_show_measurmenet_mode() sysfs read of current mode</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sca3000_show_measurement_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="cm">/* mask bottom 2 bits - only ones that are relevant */</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0x03</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCA3000_MEAS_MODE_NORMAL</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;0 - normal mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCA3000_MEAS_MODE_MOT_DET</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;3 - motion detection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCA3000_MEAS_MODE_OP_1</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCA3000_OP_MODE_NARROW</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;1 - narrow mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCA3000_OP_MODE_BYPASS</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;1 - bypass mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCA3000_MEAS_MODE_OP_2</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCA3000_OP_MODE_WIDE</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;2 - wide mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">error_ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_store_measurement_mode() set the current mode</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sca3000_store_measurement_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtou8</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">error_ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Not even vaguely standard attributes so defined here rather than</span>
<span class="cm"> * in the relevant IIO core headers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">IIO_DEVICE_ATTR</span><span class="p">(</span><span class="n">measurement_mode_available</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		       <span class="n">sca3000_show_available_measurement_modes</span><span class="p">,</span>
		       <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="n">IIO_DEVICE_ATTR</span><span class="p">(</span><span class="n">measurement_mode</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		       <span class="n">sca3000_show_measurement_mode</span><span class="p">,</span>
		       <span class="n">sca3000_store_measurement_mode</span><span class="p">,</span>
		       <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* More standard attributes */</span>

<span class="k">static</span> <span class="n">IIO_DEVICE_ATTR</span><span class="p">(</span><span class="n">revision</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">sca3000_show_rev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#define SCA3000_INFO_MASK			\</span>
<span class="cp">	IIO_CHAN_INFO_RAW_SEPARATE_BIT | IIO_CHAN_INFO_SCALE_SHARED_BIT</span>
<span class="cp">#define SCA3000_EVENT_MASK					\</span>
<span class="cp">	(IIO_EV_BIT(IIO_EV_TYPE_MAG, IIO_EV_DIR_RISING))</span>

<span class="cp">#define SCA3000_CHAN(index, mod)				\</span>
<span class="cp">	{							\</span>
<span class="cp">		.type = IIO_ACCEL,				\</span>
<span class="cp">		.modified = 1,					\</span>
<span class="cp">		.channel2 = mod,				\</span>
<span class="cp">		.info_mask = SCA3000_INFO_MASK,			\</span>
<span class="cp">		.address = index,				\</span>
<span class="cp">		.scan_index = index,				\</span>
<span class="cp">		.scan_type = {					\</span>
<span class="cp">			.sign = &#39;s&#39;,				\</span>
<span class="cp">			.realbits = 11,				\</span>
<span class="cp">			.storagebits = 16,			\</span>
<span class="cp">			.shift = 5,				\</span>
<span class="cp">		},						\</span>
<span class="cp">		.event_mask = SCA3000_EVENT_MASK,		\</span>
<span class="cp">	 }</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="n">sca3000_channels</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SCA3000_CHAN</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">IIO_MOD_X</span><span class="p">),</span>
	<span class="n">SCA3000_CHAN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IIO_MOD_Y</span><span class="p">),</span>
	<span class="n">SCA3000_CHAN</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">IIO_MOD_Z</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">u8</span> <span class="n">sca3000_addresses</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">SCA3000_REG_ADDR_X_MSB</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_MD_X_TH</span><span class="p">,</span>
	       <span class="n">SCA3000_MD_CTRL_OR_X</span><span class="p">},</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">SCA3000_REG_ADDR_Y_MSB</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_MD_Y_TH</span><span class="p">,</span>
	       <span class="n">SCA3000_MD_CTRL_OR_Y</span><span class="p">},</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">SCA3000_REG_ADDR_Z_MSB</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_MD_Z_TH</span><span class="p">,</span>
	       <span class="n">SCA3000_MD_CTRL_OR_Z</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_read_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="k">const</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="o">*</span><span class="n">val2</span><span class="p">,</span>
			    <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">address</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IIO_CHAN_INFO_RAW</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">mo_det_use_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">sca3000_addresses</span><span class="p">[</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">be16_to_cpup</span><span class="p">((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1FFF</span><span class="p">;</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">val</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">val</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">13</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
			<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">val</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">13</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IIO_VAL_INT</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IIO_CHAN_INFO_SCALE</span>:
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">IIO_ACCEL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">val2</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">scale</span><span class="p">;</span>
		<span class="k">else</span> <span class="cm">/* temperature */</span>
			<span class="o">*</span><span class="n">val2</span> <span class="o">=</span> <span class="mi">555556</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">IIO_VAL_INT_PLUS_MICRO</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_read_av_freq() sysfs function to get available frequencies</span>
<span class="cm"> *</span>
<span class="cm"> * The later modes are only relevant to the ring buffer - and depend on current</span>
<span class="cm"> * mode. Note that data sheet gives rather wide tolerances for these so integer</span>
<span class="cm"> * division will give good enough answer and not all chips have them specified</span>
<span class="cm"> * at all.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sca3000_read_av_freq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCA3000_MEAS_MODE_NORMAL</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">measurement_mode_freq</span><span class="p">,</span>
			       <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">measurement_mode_freq</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
			       <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">measurement_mode_freq</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCA3000_MEAS_MODE_OP_1</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_1_freq</span><span class="p">,</span>
			       <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_1_freq</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
			       <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_1_freq</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCA3000_MEAS_MODE_OP_2</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_2_freq</span><span class="p">,</span>
			       <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_2_freq</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
			       <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_2_freq</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="nl">error_ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * __sca3000_get_base_frequency() obtain mode specific base frequency</span>
<span class="cm"> *</span>
<span class="cm"> * lock must be held</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__sca3000_get_base_freq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">sca3000_chip_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="o">*</span><span class="n">base_freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="mh">0x03</span> <span class="o">&amp;</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCA3000_MEAS_MODE_NORMAL</span>:
		<span class="o">*</span><span class="n">base_freq</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">measurement_mode_freq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCA3000_MEAS_MODE_OP_1</span>:
		<span class="o">*</span><span class="n">base_freq</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_1_freq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCA3000_MEAS_MODE_OP_2</span>:
		<span class="o">*</span><span class="n">base_freq</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">option_mode_2_freq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">error_ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_read_frequency() sysfs interface to get the current frequency</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sca3000_read_frequency</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">base_freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sca3000_get_base_freq</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base_freq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret_mut</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_OUT_CTRL</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base_freq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x00</span>:
		<span class="k">case</span> <span class="mh">0x03</span>:
			<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">base_freq</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x01</span>:
			<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">base_freq</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x02</span>:
			<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">base_freq</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="nl">error_ret_mut:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">error_ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_set_frequency() sysfs interface to set the current frequency</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sca3000_set_frequency</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">base_freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctrlval</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">strict_strtol</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* What mode are we in? */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sca3000_get_base_freq</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base_freq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_free_lock</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_OUT_CTRL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_free_lock</span><span class="p">;</span>
	<span class="n">ctrlval</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* clear the bits */</span>
	<span class="n">ctrlval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x03</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">base_freq</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrlval</span> <span class="o">|=</span> <span class="n">SCA3000_OUT_CTRL_BUF_DIV_2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">base_freq</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrlval</span> <span class="o">|=</span> <span class="n">SCA3000_OUT_CTRL_BUF_DIV_4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">base_freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_free_lock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_OUT_CTRL</span><span class="p">,</span>
				     <span class="n">ctrlval</span><span class="p">);</span>
<span class="nl">error_free_lock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Should only really be registered if ring buffer support is compiled in.</span>
<span class="cm"> * Does no harm however and doing it right would add a fair bit of complexity</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">IIO_DEV_ATTR_SAMP_FREQ_AVAIL</span><span class="p">(</span><span class="n">sca3000_read_av_freq</span><span class="p">);</span>

<span class="k">static</span> <span class="n">IIO_DEV_ATTR_SAMP_FREQ</span><span class="p">(</span><span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			      <span class="n">sca3000_read_frequency</span><span class="p">,</span>
			      <span class="n">sca3000_set_frequency</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * sca3000_read_temp() sysfs interface to get the temperature when available</span>
<span class="cm"> *</span>
<span class="cm">* The alignment of data in here is downright odd. See data sheet.</span>
<span class="cm">* Converting this into a meaningful value is left to inline functions in</span>
<span class="cm">* userspace part of header.</span>
<span class="cm">**/</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sca3000_read_temp</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_TEMP_MSB</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

<span class="nl">error_ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">IIO_DEV_ATTR_TEMP_RAW</span><span class="p">(</span><span class="n">sca3000_read_temp</span><span class="p">);</span>

<span class="k">static</span> <span class="n">IIO_CONST_ATTR_TEMP_SCALE</span><span class="p">(</span><span class="s">&quot;0.555556&quot;</span><span class="p">);</span>
<span class="k">static</span> <span class="n">IIO_CONST_ATTR_TEMP_OFFSET</span><span class="p">(</span><span class="s">&quot;-214.6&quot;</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_read_thresh() - query of a threshold</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_read_thresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">e</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">IIO_EVENT_CODE_EXTRACT_MODIFIER</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">sca3000_addresses</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span>
				 <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mot_det_mult_y</span><span class="p">))</span>
			<span class="o">*</span><span class="n">val</span> <span class="o">+=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mot_det_mult_y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span>
				 <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mot_det_mult_xz</span><span class="p">))</span>
			<span class="o">*</span><span class="n">val</span> <span class="o">+=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mot_det_mult_xz</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_write_thresh() control of threshold</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_write_thresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">e</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">IIO_EVENT_CODE_EXTRACT_MODIFIER</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">nonlinear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mot_det_mult_y</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mot_det_mult_y</span><span class="p">[</span><span class="o">--</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">nonlinear</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">val</span> <span class="o">-=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mot_det_mult_y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mot_det_mult_xz</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mot_det_mult_xz</span><span class="p">[</span><span class="o">--</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">nonlinear</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">val</span> <span class="o">-=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mot_det_mult_xz</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">sca3000_addresses</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">nonlinear</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">sca3000_attributes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_revision</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_measurement_mode_available</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_measurement_mode</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_sampling_frequency_available</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_sampling_frequency</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">sca3000_attributes_with_temp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_revision</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_measurement_mode_available</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_measurement_mode</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_sampling_frequency_available</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_sampling_frequency</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="cm">/* Only present if temp sensor is */</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_in_temp_raw</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_const_attr_in_temp_offset</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_const_attr_in_temp_scale</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">sca3000_attribute_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">sca3000_attributes</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">sca3000_attribute_group_with_temp</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">sca3000_attributes_with_temp</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* RING RELATED interrupt handler */</span>
<span class="cm">/* depending on event, push to the ring buffer event chrdev or the event one */</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_event_handler() - handling ring and non ring events</span>
<span class="cm"> *</span>
<span class="cm"> * This function is complicated by the fact that the devices can signify ring</span>
<span class="cm"> * and non ring events via the same interrupt line and they can only</span>
<span class="cm"> * be distinguished via a read of the relevant status register.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">sca3000_event_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">last_timestamp</span> <span class="o">=</span> <span class="n">iio_get_time_ns</span><span class="p">();</span>

	<span class="cm">/* Could lead if badly timed to an extra read of status reg,</span>
<span class="cm">	 * but ensures no interrupt is missed.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_INT_STATUS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">sca3000_ring_int_process</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SCA3000_INT_STATUS_FREE_FALL</span><span class="p">)</span>
		<span class="n">iio_push_event</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">,</span>
			       <span class="n">IIO_MOD_EVENT_CODE</span><span class="p">(</span><span class="n">IIO_ACCEL</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span>
						  <span class="n">IIO_MOD_X_AND_Y_AND_Z</span><span class="p">,</span>
						  <span class="n">IIO_EV_TYPE_MAG</span><span class="p">,</span>
						  <span class="n">IIO_EV_DIR_FALLING</span><span class="p">),</span>
			       <span class="n">last_timestamp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SCA3000_INT_STATUS_Y_TRIGGER</span><span class="p">)</span>
		<span class="n">iio_push_event</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">,</span>
			       <span class="n">IIO_MOD_EVENT_CODE</span><span class="p">(</span><span class="n">IIO_ACCEL</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span>
						  <span class="n">IIO_MOD_Y</span><span class="p">,</span>
						  <span class="n">IIO_EV_TYPE_MAG</span><span class="p">,</span>
						  <span class="n">IIO_EV_DIR_RISING</span><span class="p">),</span>
			       <span class="n">last_timestamp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SCA3000_INT_STATUS_X_TRIGGER</span><span class="p">)</span>
		<span class="n">iio_push_event</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">,</span>
			       <span class="n">IIO_MOD_EVENT_CODE</span><span class="p">(</span><span class="n">IIO_ACCEL</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span>
						  <span class="n">IIO_MOD_X</span><span class="p">,</span>
						  <span class="n">IIO_EV_TYPE_MAG</span><span class="p">,</span>
						  <span class="n">IIO_EV_DIR_RISING</span><span class="p">),</span>
			       <span class="n">last_timestamp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SCA3000_INT_STATUS_Z_TRIGGER</span><span class="p">)</span>
		<span class="n">iio_push_event</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">,</span>
			       <span class="n">IIO_MOD_EVENT_CODE</span><span class="p">(</span><span class="n">IIO_ACCEL</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span>
						  <span class="n">IIO_MOD_Z</span><span class="p">,</span>
						  <span class="n">IIO_EV_TYPE_MAG</span><span class="p">,</span>
						  <span class="n">IIO_EV_DIR_RISING</span><span class="p">),</span>
			       <span class="n">last_timestamp</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_read_event_config() what events are enabled</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_read_event_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">protect_mask</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">IIO_EVENT_CODE_EXTRACT_MODIFIER</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

	<span class="cm">/* read current value of mode register */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">protect_mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SCA3000_MEAS_MODE_MOT_DET</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_MD_CTRL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
		<span class="cm">/* only supporting logical or&#39;s for now */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">sca3000_addresses</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="nl">error_ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * sca3000_query_free_fall_mode() is free fall mode enabled</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sca3000_query_free_fall_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="o">!!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SCA3000_FREE_FALL_DETECT</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_set_free_fall_mode() simple on off control for free fall int</span>
<span class="cm"> *</span>
<span class="cm"> * In these chips the free fall detector should send an interrupt if</span>
<span class="cm"> * the device falls more than 25cm.  This has not been tested due</span>
<span class="cm"> * to fragile wiring.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sca3000_set_free_fall_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">dev_to_iio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">protect_mask</span> <span class="o">=</span> <span class="n">SCA3000_FREE_FALL_DETECT</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">strict_strtol</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>

	<span class="cm">/* read current value of mode register */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>

	<span class="cm">/*if off and should be on*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">protect_mask</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span>
					<span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">SCA3000_FREE_FALL_DETECT</span><span class="p">));</span>
	<span class="cm">/* if on and should be off */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">protect_mask</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span>
					<span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">protect_mask</span><span class="p">));</span>
<span class="nl">error_ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_set_mo_det() simple on off control for motion detector</span>
<span class="cm"> *</span>
<span class="cm"> * This is a per axis control, but enabling any will result in the</span>
<span class="cm"> * motion detector unit being enabled.</span>
<span class="cm"> * N.B. enabling motion detector stops normal data acquisition.</span>
<span class="cm"> * There is a complexity in knowing which mode to return to when</span>
<span class="cm"> * this mode is disabled.  Currently normal mode is assumed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_write_event_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">e</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ctrlval</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">protect_mask</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">IIO_EVENT_CODE_EXTRACT_MODIFIER</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* First read the motion detector config to find out if</span>
<span class="cm">	 * this axis is on*/</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_MD_CTRL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_point</span><span class="p">;</span>
	<span class="n">ctrlval</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Off and should be on */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ctrlval</span> <span class="o">&amp;</span> <span class="n">sca3000_addresses</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span>
					     <span class="n">SCA3000_REG_CTRL_SEL_MD_CTRL</span><span class="p">,</span>
					     <span class="n">ctrlval</span> <span class="o">|</span>
					     <span class="n">sca3000_addresses</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_point</span><span class="p">;</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">mo_det_use_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctrlval</span> <span class="o">&amp;</span> <span class="n">sca3000_addresses</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span>
					     <span class="n">SCA3000_REG_CTRL_SEL_MD_CTRL</span><span class="p">,</span>
					     <span class="n">ctrlval</span> <span class="o">&amp;</span>
					     <span class="o">~</span><span class="p">(</span><span class="n">sca3000_addresses</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="mi">2</span><span class="p">]));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_point</span><span class="p">;</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">mo_det_use_count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* read current value of mode register */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_point</span><span class="p">;</span>
	<span class="cm">/*if off and should be on*/</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">mo_det_use_count</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">protect_mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SCA3000_MEAS_MODE_MOT_DET</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span>
					<span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">protect_mask</span><span class="p">)</span>
					<span class="o">|</span> <span class="n">SCA3000_MEAS_MODE_MOT_DET</span><span class="p">);</span>
	<span class="cm">/* if on and should be off */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">mo_det_use_count</span><span class="p">)</span>
		 <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">protect_mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">SCA3000_MEAS_MODE_MOT_DET</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span>
					<span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">protect_mask</span><span class="p">));</span>
<span class="nl">exit_point:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free fall detector related event attribute */</span>
<span class="k">static</span> <span class="n">IIO_DEVICE_ATTR_NAMED</span><span class="p">(</span><span class="n">accel_xayaz_mag_falling_en</span><span class="p">,</span>
			     <span class="n">in_accel_x</span><span class="o">&amp;</span><span class="n">y</span><span class="o">&amp;</span><span class="n">z_mag_falling_en</span><span class="p">,</span>
			     <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
			     <span class="n">sca3000_query_free_fall_mode</span><span class="p">,</span>
			     <span class="n">sca3000_set_free_fall_mode</span><span class="p">,</span>
			     <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="n">IIO_CONST_ATTR_NAMED</span><span class="p">(</span><span class="n">accel_xayaz_mag_falling_period</span><span class="p">,</span>
			    <span class="n">in_accel_x</span><span class="o">&amp;</span><span class="n">y</span><span class="o">&amp;</span><span class="n">z_mag_falling_period</span><span class="p">,</span>
			    <span class="s">&quot;0.226&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">sca3000_event_attributes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">iio_dev_attr_accel_xayaz_mag_falling_en</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">iio_const_attr_accel_xayaz_mag_falling_period</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">sca3000_event_attribute_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">sca3000_event_attributes</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;events&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_clean_setup() get the device into a predictable state</span>
<span class="cm"> *</span>
<span class="cm"> * Devices use flash memory to store many of the register values</span>
<span class="cm"> * and hence can come up in somewhat unpredictable states.</span>
<span class="cm"> * Hence reset everything on driver load.</span>
<span class="cm">  **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_clean_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* Ensure all interrupts have been acknowledged */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_INT_STATUS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>

	<span class="cm">/* Turn off all motion detection channels */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_MD_CTRL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_MD_CTRL</span><span class="p">,</span>
				     <span class="n">ret</span> <span class="o">&amp;</span> <span class="n">SCA3000_MD_CTRL_PROT_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>

	<span class="cm">/* Disable ring buffer */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_OUT_CTRL</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_ctrl_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_CTRL_SEL_OUT_CTRL</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">SCA3000_OUT_CTRL_PROT_MASK</span><span class="p">)</span>
				     <span class="o">|</span> <span class="n">SCA3000_OUT_CTRL_BUF_X_EN</span>
				     <span class="o">|</span> <span class="n">SCA3000_OUT_CTRL_BUF_Y_EN</span>
				     <span class="o">|</span> <span class="n">SCA3000_OUT_CTRL_BUF_Z_EN</span>
				     <span class="o">|</span> <span class="n">SCA3000_OUT_CTRL_BUF_DIV_4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="cm">/* Enable interrupts, relevant to mode and set up as active low */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_INT_MASK</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span>
				<span class="n">SCA3000_REG_ADDR_INT_MASK</span><span class="p">,</span>
				<span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">SCA3000_INT_MASK_PROT_MASK</span><span class="p">)</span>
				<span class="o">|</span> <span class="n">SCA3000_INT_MASK_ACTIVE_LOW</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="cm">/* Select normal measurement mode, free fall off, ring off */</span>
	<span class="cm">/* Ring in 12 bit mode - it is fine to overwrite reserved bits 3,5</span>
<span class="cm">	 * as that occurs in one of the example on the datasheet */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_MODE</span><span class="p">,</span>
				<span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">SCA3000_MODE_PROT_MASK</span><span class="p">));</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">bpse</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>

<span class="nl">error_ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iio_info</span> <span class="n">sca3000_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_attribute_group</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_raw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_read_raw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">event_attrs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_event_attribute_group</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_event_value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_read_thresh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_event_value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_write_thresh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_event_config</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_read_event_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_event_config</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_write_event_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver_module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iio_info</span> <span class="n">sca3000_info_with_temp</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_attribute_group_with_temp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_raw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_read_raw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_event_value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_read_thresh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_event_value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_write_thresh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_event_config</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_read_event_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_event_config</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_write_event_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver_module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sca3000_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">;</span>

	<span class="n">indio_dev</span> <span class="o">=</span> <span class="n">iio_device_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">st</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">indio_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="n">spi_set_drvdata</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">indio_dev</span><span class="p">);</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">us</span> <span class="o">=</span> <span class="n">spi</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_spi_chip_info_tbl</span><span class="p">[</span><span class="n">spi_get_device_id</span><span class="p">(</span><span class="n">spi</span><span class="p">)</span>
					      <span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">];</span>

	<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">spi_get_device_id</span><span class="p">(</span><span class="n">spi</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">temp_output</span><span class="p">)</span>
		<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_info_with_temp</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sca3000_info</span><span class="p">;</span>
		<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">=</span> <span class="n">sca3000_channels</span><span class="p">;</span>
		<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">num_channels</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sca3000_channels</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">=</span> <span class="n">INDIO_DIRECT_MODE</span><span class="p">;</span>

	<span class="n">sca3000_configure_ring</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iio_device_register</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_free_dev</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iio_buffer_register</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">,</span>
				  <span class="n">sca3000_channels</span><span class="p">,</span>
				  <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sca3000_channels</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unregister_dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iio_scan_mask_set</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">,</span> <span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">iio_scan_mask_set</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">,</span> <span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">iio_scan_mask_set</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">,</span> <span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_threaded_irq</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
					   <span class="nb">NULL</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">sca3000_event_handler</span><span class="p">,</span>
					   <span class="n">IRQF_TRIGGER_FALLING</span><span class="p">,</span>
					   <span class="s">&quot;sca3000&quot;</span><span class="p">,</span>
					   <span class="n">indio_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_unregister_ring</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sca3000_register_ring_funcs</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_clean_setup</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_free_irq</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_free_irq:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">indio_dev</span><span class="p">);</span>
<span class="nl">error_unregister_ring:</span>
	<span class="n">iio_buffer_unregister</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
<span class="nl">error_unregister_dev:</span>
	<span class="n">iio_device_unregister</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
<span class="nl">error_free_dev:</span>
	<span class="n">iio_device_free</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>

<span class="nl">error_ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_stop_all_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_INT_MASK</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">SCA3000_REG_ADDR_INT_MASK</span><span class="p">,</span>
				<span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span>
				 <span class="o">~</span><span class="p">(</span><span class="n">SCA3000_INT_MASK_RING_THREE_QUARTER</span> <span class="o">|</span>
				   <span class="n">SCA3000_INT_MASK_RING_HALF</span> <span class="o">|</span>
				   <span class="n">SCA3000_INT_MASK_ALL_INTS</span><span class="p">)));</span>
<span class="nl">error_ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sca3000_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">spi_get_drvdata</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Must ensure no interrupts can be generated after this!*/</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sca3000_stop_all_interrupts</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">indio_dev</span><span class="p">);</span>
	<span class="n">iio_device_unregister</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="n">iio_buffer_unregister</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="n">sca3000_unconfigure_ring</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="n">iio_device_free</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device_id</span> <span class="n">sca3000_id</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">&quot;sca3000_d01&quot;</span><span class="p">,</span> <span class="n">d01</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;sca3000_e02&quot;</span><span class="p">,</span> <span class="n">e02</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;sca3000_e04&quot;</span><span class="p">,</span> <span class="n">e04</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;sca3000_e05&quot;</span><span class="p">,</span> <span class="n">e05</span><span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">sca3000_id</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spi_driver</span> <span class="n">sca3000_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;sca3000&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">sca3000_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">sca3000_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">sca3000_id</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">module_spi_driver</span><span class="p">(</span><span class="n">sca3000_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jonathan Cameron &lt;jic23@cam.ac.uk&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;VTI SCA3000 Series Accelerometers SPI driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
