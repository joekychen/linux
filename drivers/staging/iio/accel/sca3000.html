<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › iio › accel › sca3000.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>sca3000.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * sca3000.c -- support VTI sca3000 series accelerometers</span>
<span class="cm"> *              via SPI</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2007 Jonathan Cameron &lt;jic23@cam.ac.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Partly based upon tle62x0.c</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Initial mode is direct measurement.</span>
<span class="cm"> *</span>
<span class="cm"> * Untested things</span>
<span class="cm"> *</span>
<span class="cm"> * Temperature reading (the e05 I&#39;m testing with doesn&#39;t have a sensor)</span>
<span class="cm"> *</span>
<span class="cm"> * Free fall detection mode - supported but untested as I&#39;m not droping my</span>
<span class="cm"> * dubious wire rig far enough to test it.</span>
<span class="cm"> *</span>
<span class="cm"> * Unsupported as yet</span>
<span class="cm"> *</span>
<span class="cm"> * Time stamping of data from ring. Various ideas on how to do this but none</span>
<span class="cm"> * are remotely simple. Suggestions welcome.</span>
<span class="cm"> *</span>
<span class="cm"> * Individual enabling disabling of channels going into ring buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Overflow handling (this is signaled for all but 8 bit ring buffer mode.)</span>
<span class="cm"> *</span>
<span class="cm"> * Motion detector using AND combinations of signals.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Be very careful about not touching an register bytes marked</span>
<span class="cm"> * as reserved on the data sheet. They really mean it as changing convents of</span>
<span class="cm"> * some will cause the device to lock up.</span>
<span class="cm"> *</span>
<span class="cm"> * Known issues - on rare occasions the interrupts lock up. Not sure why as yet.</span>
<span class="cm"> * Can probably alleviate this by reading the interrupt register on start, but</span>
<span class="cm"> * that is really just brushing the problem under the carpet.</span>
<span class="cm"> */</span>
<span class="cp">#define SCA3000_WRITE_REG(a) (((a) &lt;&lt; 2) | 0x02)</span>
<span class="cp">#define SCA3000_READ_REG(a) ((a) &lt;&lt; 2)</span>

<span class="cp">#define SCA3000_REG_ADDR_REVID			0x00</span>
<span class="cp">#define SCA3000_REVID_MAJOR_MASK		0xf0</span>
<span class="cp">#define SCA3000_REVID_MINOR_MASK		0x0f</span>

<span class="cp">#define SCA3000_REG_ADDR_STATUS			0x02</span>
<span class="cp">#define SCA3000_LOCKED				0x20</span>
<span class="cp">#define SCA3000_EEPROM_CS_ERROR			0x02</span>
<span class="cp">#define SCA3000_SPI_FRAME_ERROR			0x01</span>

<span class="cm">/* All reads done using register decrement so no need to directly access LSBs */</span>
<span class="cp">#define SCA3000_REG_ADDR_X_MSB			0x05</span>
<span class="cp">#define SCA3000_REG_ADDR_Y_MSB			0x07</span>
<span class="cp">#define SCA3000_REG_ADDR_Z_MSB			0x09</span>

<span class="cp">#define SCA3000_REG_ADDR_RING_OUT		0x0f</span>

<span class="cm">/* Temp read untested - the e05 doesn&#39;t have the sensor */</span>
<span class="cp">#define SCA3000_REG_ADDR_TEMP_MSB		0x13</span>

<span class="cp">#define SCA3000_REG_ADDR_MODE			0x14</span>
<span class="cp">#define SCA3000_MODE_PROT_MASK			0x28</span>

<span class="cp">#define SCA3000_RING_BUF_ENABLE			0x80</span>
<span class="cp">#define SCA3000_RING_BUF_8BIT			0x40</span>
<span class="cm">/* Free fall detection triggers an interrupt if the acceleration</span>
<span class="cm"> * is below a threshold for equivalent of 25cm drop</span>
<span class="cm"> */</span>
<span class="cp">#define SCA3000_FREE_FALL_DETECT		0x10</span>
<span class="cp">#define SCA3000_MEAS_MODE_NORMAL		0x00</span>
<span class="cp">#define SCA3000_MEAS_MODE_OP_1			0x01</span>
<span class="cp">#define SCA3000_MEAS_MODE_OP_2			0x02</span>

<span class="cm">/* In motion detection mode the accelerations are band pass filtered</span>
<span class="cm"> * (aprox 1 - 25Hz) and then a programmable threshold used to trigger</span>
<span class="cm"> * and interrupt.</span>
<span class="cm"> */</span>
<span class="cp">#define SCA3000_MEAS_MODE_MOT_DET		0x03</span>

<span class="cp">#define SCA3000_REG_ADDR_BUF_COUNT		0x15</span>

<span class="cp">#define SCA3000_REG_ADDR_INT_STATUS		0x16</span>

<span class="cp">#define SCA3000_INT_STATUS_THREE_QUARTERS	0x80</span>
<span class="cp">#define SCA3000_INT_STATUS_HALF			0x40</span>

<span class="cp">#define SCA3000_INT_STATUS_FREE_FALL		0x08</span>
<span class="cp">#define SCA3000_INT_STATUS_Y_TRIGGER		0x04</span>
<span class="cp">#define SCA3000_INT_STATUS_X_TRIGGER		0x02</span>
<span class="cp">#define SCA3000_INT_STATUS_Z_TRIGGER		0x01</span>

<span class="cm">/* Used to allow access to multiplexed registers */</span>
<span class="cp">#define SCA3000_REG_ADDR_CTRL_SEL		0x18</span>
<span class="cm">/* Only available for SCA3000-D03 and SCA3000-D01 */</span>
<span class="cp">#define SCA3000_REG_CTRL_SEL_I2C_DISABLE	0x01</span>
<span class="cp">#define SCA3000_REG_CTRL_SEL_MD_CTRL		0x02</span>
<span class="cp">#define SCA3000_REG_CTRL_SEL_MD_Y_TH		0x03</span>
<span class="cp">#define SCA3000_REG_CTRL_SEL_MD_X_TH		0x04</span>
<span class="cp">#define SCA3000_REG_CTRL_SEL_MD_Z_TH		0x05</span>
<span class="cm">/* BE VERY CAREFUL WITH THIS, IF 3 BITS ARE NOT SET the device</span>
<span class="cm">   will not function */</span>
<span class="cp">#define SCA3000_REG_CTRL_SEL_OUT_CTRL		0x0B</span>
<span class="cp">#define SCA3000_OUT_CTRL_PROT_MASK		0xE0</span>
<span class="cp">#define SCA3000_OUT_CTRL_BUF_X_EN		0x10</span>
<span class="cp">#define SCA3000_OUT_CTRL_BUF_Y_EN		0x08</span>
<span class="cp">#define SCA3000_OUT_CTRL_BUF_Z_EN		0x04</span>
<span class="cp">#define SCA3000_OUT_CTRL_BUF_DIV_4		0x02</span>
<span class="cp">#define SCA3000_OUT_CTRL_BUF_DIV_2		0x01</span>

<span class="cm">/* Control which motion detector interrupts are on.</span>
<span class="cm"> * For now only OR combinations are supported.x</span>
<span class="cm"> */</span>
<span class="cp">#define SCA3000_MD_CTRL_PROT_MASK		0xC0</span>
<span class="cp">#define SCA3000_MD_CTRL_OR_Y			0x01</span>
<span class="cp">#define SCA3000_MD_CTRL_OR_X			0x02</span>
<span class="cp">#define SCA3000_MD_CTRL_OR_Z			0x04</span>
<span class="cm">/* Currently unsupported */</span>
<span class="cp">#define SCA3000_MD_CTRL_AND_Y			0x08</span>
<span class="cp">#define SCA3000_MD_CTRL_AND_X			0x10</span>
<span class="cp">#define SAC3000_MD_CTRL_AND_Z			0x20</span>

<span class="cm">/* Some control registers of complex access methods requiring this register to</span>
<span class="cm"> * be used to remove a lock.</span>
<span class="cm"> */</span>
<span class="cp">#define SCA3000_REG_ADDR_UNLOCK			0x1e</span>

<span class="cp">#define SCA3000_REG_ADDR_INT_MASK		0x21</span>
<span class="cp">#define SCA3000_INT_MASK_PROT_MASK		0x1C</span>

<span class="cp">#define SCA3000_INT_MASK_RING_THREE_QUARTER	0x80</span>
<span class="cp">#define SCA3000_INT_MASK_RING_HALF		0x40</span>

<span class="cp">#define SCA3000_INT_MASK_ALL_INTS		0x02</span>
<span class="cp">#define SCA3000_INT_MASK_ACTIVE_HIGH		0x01</span>
<span class="cp">#define SCA3000_INT_MASK_ACTIVE_LOW		0x00</span>

<span class="cm">/* Values of multiplexed registers (write to ctrl_data after select) */</span>
<span class="cp">#define SCA3000_REG_ADDR_CTRL_DATA		0x22</span>

<span class="cm">/* Measurement modes available on some sca3000 series chips. Code assumes others</span>
<span class="cm"> * may become available in the future.</span>
<span class="cm"> *</span>
<span class="cm"> * Bypass - Bypass the low-pass filter in the signal channel so as to increase</span>
<span class="cm"> *          signal bandwidth.</span>
<span class="cm"> *</span>
<span class="cm"> * Narrow - Narrow low-pass filtering of the signal channel and half output</span>
<span class="cm"> *          data rate by decimation.</span>
<span class="cm"> *</span>
<span class="cm"> * Wide - Widen low-pass filtering of signal channel to increase bandwidth</span>
<span class="cm"> */</span>
<span class="cp">#define SCA3000_OP_MODE_BYPASS			0x01</span>
<span class="cp">#define SCA3000_OP_MODE_NARROW			0x02</span>
<span class="cp">#define SCA3000_OP_MODE_WIDE			0x04</span>
<span class="cp">#define SCA3000_MAX_TX 6</span>
<span class="cp">#define SCA3000_MAX_RX 2</span>

<span class="cm">/**</span>
<span class="cm"> * struct sca3000_state - device instance state information</span>
<span class="cm"> * @us:			the associated spi device</span>
<span class="cm"> * @info:			chip variant information</span>
<span class="cm"> * @indio_dev:			device information used by the IIO core</span>
<span class="cm"> * @interrupt_handler_ws:	event interrupt handler for all events</span>
<span class="cm"> * @last_timestamp:		the timestamp of the last event</span>
<span class="cm"> * @mo_det_use_count:		reference counter for the motion detection unit</span>
<span class="cm"> * @lock:			lock used to protect elements of sca3000_state</span>
<span class="cm"> *				and the underlying device state.</span>
<span class="cm"> * @bpse:			number of bits per scan element</span>
<span class="cm"> * @tx:			dma-able transmit buffer</span>
<span class="cm"> * @rx:			dma-able receive buffer</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">sca3000_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_device</span>		<span class="o">*</span><span class="n">us</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sca3000_chip_info</span>	<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>		<span class="n">interrupt_handler_ws</span><span class="p">;</span>
	<span class="n">s64</span>				<span class="n">last_timestamp</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">mo_det_use_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">bpse</span><span class="p">;</span>
	<span class="cm">/* Can these share a cacheline ? */</span>
	<span class="n">u8</span>				<span class="n">rx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">tx</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct sca3000_chip_info - model dependent parameters</span>
<span class="cm"> * @scale:			scale * 10^-6</span>
<span class="cm"> * @temp_output:		some devices have temperature sensors.</span>
<span class="cm"> * @measurement_mode_freq:	normal mode sampling frequency</span>
<span class="cm"> * @option_mode_1:		first optional mode. Not all models have one</span>
<span class="cm"> * @option_mode_1_freq:		option mode 1 sampling frequency</span>
<span class="cm"> * @option_mode_2:		second optional mode. Not all chips have one</span>
<span class="cm"> * @option_mode_2_freq:		option mode 2 sampling frequency</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used to hold information about the functionality of a given</span>
<span class="cm"> * sca3000 variant.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">sca3000_chip_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">scale</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">temp_output</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">measurement_mode_freq</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">option_mode_1</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">option_mode_1_freq</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">option_mode_2</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">option_mode_2_freq</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">mot_det_mult_xz</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">mot_det_mult_y</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">sca3000_read_data_short</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span>
			    <span class="n">u8</span> <span class="n">reg_address_high</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_write_reg() write a single register</span>
<span class="cm"> * @address:	address of register on chip</span>
<span class="cm"> * @val:	value to be written to register</span>
<span class="cm"> *</span>
<span class="cm"> * The main lock must be held.</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="n">sca3000_write_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sca3000_state</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span> <span class="n">u8</span> <span class="n">address</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IIO_BUFFER</span>
<span class="cm">/**</span>
<span class="cm"> * sca3000_register_ring_funcs() setup the ring state change functions</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="n">sca3000_register_ring_funcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_configure_ring() - allocate and configure ring buffer</span>
<span class="cm"> * @indio_dev: iio-core device whose ring is to be configured</span>
<span class="cm"> *</span>
<span class="cm"> * The hardware ring buffer needs far fewer ring buffer functions than</span>
<span class="cm"> * a software one as a lot of things are handled automatically.</span>
<span class="cm"> * This function also tells the iio core that our device supports a</span>
<span class="cm"> * hardware ring buffer mode.</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="n">sca3000_configure_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_unconfigure_ring() - deallocate the ring buffer</span>
<span class="cm"> * @indio_dev: iio-core device whose ring we are freeing</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="n">sca3000_unconfigure_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sca3000_ring_int_process() handles ring related event pushing and escalation</span>
<span class="cm"> * @val:	the event code</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="n">sca3000_ring_int_process</span><span class="p">(</span><span class="n">u8</span> <span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iio_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sca3000_register_ring_funcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">sca3000_register_ring_access_and_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sca3000_ring_int_process</span><span class="p">(</span><span class="n">u8</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
