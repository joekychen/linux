<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › iio › iio_simple_dummy.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>iio_simple_dummy.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Copyright (c) 2011 Jonathan Cameron</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * A reference industrial I/O driver to illustrate the functionality available.</span>
<span class="cm"> *</span>
<span class="cm"> * There are numerous real drivers to illustrate the finer points.</span>
<span class="cm"> * The purpose of this driver is to provide a driver with far more comments</span>
<span class="cm"> * and explanatory notes than any &#39;real&#39; driver would have.</span>
<span class="cm"> * Anyone starting out writing an IIO driver should first make sure they</span>
<span class="cm"> * understand all of this driver except those bits specifically marked</span>
<span class="cm"> * as being present to allow us to &#39;fake&#39; the presence of hardware.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>

<span class="cp">#include &lt;linux/iio/iio.h&gt;</span>
<span class="cp">#include &lt;linux/iio/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/iio/events.h&gt;</span>
<span class="cp">#include &lt;linux/iio/buffer.h&gt;</span>
<span class="cp">#include &quot;iio_simple_dummy.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * A few elements needed to fake a bus for this driver</span>
<span class="cm"> * Note instances parmeter controls how many of these</span>
<span class="cm"> * dummy devices are registered.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">instances</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">instances</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Pointer array used to fake bus elements */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">**</span><span class="n">iio_dummy_devs</span><span class="p">;</span>

<span class="cm">/* Fake a name for the part number, usually obtained from the id table */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">iio_dummy_part_number</span> <span class="o">=</span> <span class="s">&quot;iio_dummy_part_no&quot;</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct iio_dummy_accel_calibscale - realworld to register mapping</span>
<span class="cm"> * @val: first value in read_raw - here integer part.</span>
<span class="cm"> * @val2: second value in read_raw etc - here micro part.</span>
<span class="cm"> * @regval: register value - magic device specific numbers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iio_dummy_accel_calibscale</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">regval</span><span class="p">;</span> <span class="cm">/* what would be written to hardware */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iio_dummy_accel_calibscale</span> <span class="n">dummy_scales</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mh">0x8</span> <span class="p">},</span> <span class="cm">/* 0.000100 */</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">133</span><span class="p">,</span> <span class="mh">0x7</span> <span class="p">},</span> <span class="cm">/* 0.000133 */</span>
	<span class="p">{</span> <span class="mi">733</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mh">0x9</span> <span class="p">},</span> <span class="cm">/* 733.00013 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * iio_dummy_channels - Description of available channels</span>
<span class="cm"> *</span>
<span class="cm"> * This array of structures tells the IIO core about what the device</span>
<span class="cm"> * actually provides for a given channel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="n">iio_dummy_channels</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* indexed ADC channel in_voltage0_raw etc */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">IIO_VOLTAGE</span><span class="p">,</span>
		<span class="cm">/* Channel has a numeric index of 0 */</span>
		<span class="p">.</span><span class="n">indexed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="cm">/* What other information is available? */</span>
		<span class="p">.</span><span class="n">info_mask</span> <span class="o">=</span>
		<span class="cm">/*</span>
<span class="cm">		 * in_voltage0_raw</span>
<span class="cm">		 * Raw (unscaled no bias removal etc) measurement</span>
<span class="cm">		 * from the device.</span>
<span class="cm">		 */</span>
		<span class="n">IIO_CHAN_INFO_RAW_SEPARATE_BIT</span> <span class="o">|</span>
		<span class="cm">/*</span>
<span class="cm">		 * in_voltage0_offset</span>
<span class="cm">		 * Offset for userspace to apply prior to scale</span>
<span class="cm">		 * when converting to standard units (microvolts)</span>
<span class="cm">		 */</span>
		<span class="n">IIO_CHAN_INFO_OFFSET_SEPARATE_BIT</span> <span class="o">|</span>
		<span class="cm">/*</span>
<span class="cm">		 * in_voltage0_scale</span>
<span class="cm">		 * Multipler for userspace to apply post offset</span>
<span class="cm">		 * when converting to standard units (microvolts)</span>
<span class="cm">		 */</span>
		<span class="n">IIO_CHAN_INFO_SCALE_SEPARATE_BIT</span><span class="p">,</span>
		<span class="cm">/* The ordering of elements in the buffer via an enum */</span>
		<span class="p">.</span><span class="n">scan_index</span> <span class="o">=</span> <span class="n">voltage0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">scan_type</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* Description of storage in buffer */</span>
			<span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="cm">/* unsigned */</span>
			<span class="p">.</span><span class="n">realbits</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span> <span class="cm">/* 13 bits */</span>
			<span class="p">.</span><span class="n">storagebits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="cm">/* 16 bits used for storage */</span>
			<span class="p">.</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* zero shift */</span>
		<span class="p">},</span>
<span class="cp">#ifdef CONFIG_IIO_SIMPLE_DUMMY_EVENTS</span>
		<span class="cm">/*</span>
<span class="cm">		 * simple event - triggered when value rises above</span>
<span class="cm">		 * a threshold</span>
<span class="cm">		 */</span>
		<span class="p">.</span><span class="n">event_mask</span> <span class="o">=</span> <span class="n">IIO_EV_BIT</span><span class="p">(</span><span class="n">IIO_EV_TYPE_THRESH</span><span class="p">,</span>
					 <span class="n">IIO_EV_DIR_RISING</span><span class="p">),</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IIO_SIMPLE_DUMMY_EVENTS */</span><span class="cp"></span>
	<span class="p">},</span>
	<span class="cm">/* Differential ADC channel in_voltage1-voltage2_raw etc*/</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">IIO_VOLTAGE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">differential</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="cm">/*</span>
<span class="cm">		 * Indexing for differential channels uses channel</span>
<span class="cm">		 * for the positive part, channel2 for the negative.</span>
<span class="cm">		 */</span>
		<span class="p">.</span><span class="n">indexed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">channel2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">info_mask</span> <span class="o">=</span>
		<span class="cm">/*</span>
<span class="cm">		 * in_voltage1-voltage2_raw</span>
<span class="cm">		 * Raw (unscaled no bias removal etc) measurement</span>
<span class="cm">		 * from the device.</span>
<span class="cm">		 */</span>
		<span class="n">IIO_CHAN_INFO_RAW_SEPARATE_BIT</span> <span class="o">|</span>
		<span class="cm">/*</span>
<span class="cm">		 * in_voltage-voltage_scale</span>
<span class="cm">		 * Shared version of scale - shared by differential</span>
<span class="cm">		 * input channels of type IIO_VOLTAGE.</span>
<span class="cm">		 */</span>
		<span class="n">IIO_CHAN_INFO_SCALE_SHARED_BIT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">scan_index</span> <span class="o">=</span> <span class="n">diffvoltage1m2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">scan_type</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* Description of storage in buffer */</span>
			<span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="cm">/* signed */</span>
			<span class="p">.</span><span class="n">realbits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="cm">/* 12 bits */</span>
			<span class="p">.</span><span class="n">storagebits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="cm">/* 16 bits used for storage */</span>
			<span class="p">.</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* zero shift */</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="cm">/* Differential ADC channel in_voltage3-voltage4_raw etc*/</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">IIO_VOLTAGE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">differential</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">indexed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="p">.</span><span class="n">channel2</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">info_mask</span> <span class="o">=</span>
		<span class="n">IIO_CHAN_INFO_RAW_SEPARATE_BIT</span> <span class="o">|</span>
		<span class="n">IIO_CHAN_INFO_SCALE_SHARED_BIT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">scan_index</span> <span class="o">=</span> <span class="n">diffvoltage3m4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">scan_type</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">realbits</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
			<span class="p">.</span><span class="n">storagebits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
			<span class="p">.</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="cm">/*</span>
<span class="cm">	 * &#39;modified&#39; (i.e. axis specified) acceleration channel</span>
<span class="cm">	 * in_accel_z_raw</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">IIO_ACCEL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">modified</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="cm">/* Channel 2 is use for modifiers */</span>
		<span class="p">.</span><span class="n">channel2</span> <span class="o">=</span> <span class="n">IIO_MOD_X</span><span class="p">,</span>
		<span class="p">.</span><span class="n">info_mask</span> <span class="o">=</span>
		<span class="n">IIO_CHAN_INFO_RAW_SEPARATE_BIT</span> <span class="o">|</span>
		<span class="cm">/*</span>
<span class="cm">		 * Internal bias correction value. Applied</span>
<span class="cm">		 * by the hardware or driver prior to userspace</span>
<span class="cm">		 * seeing the readings. Typically part of hardware</span>
<span class="cm">		 * calibration.</span>
<span class="cm">		 */</span>
		<span class="n">IIO_CHAN_INFO_CALIBBIAS_SEPARATE_BIT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">scan_index</span> <span class="o">=</span> <span class="n">accelx</span><span class="p">,</span>
		<span class="p">.</span><span class="n">scan_type</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* Description of storage in buffer */</span>
			<span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="cm">/* signed */</span>
			<span class="p">.</span><span class="n">realbits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="cm">/* 12 bits */</span>
			<span class="p">.</span><span class="n">storagebits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="cm">/* 16 bits used for storage */</span>
			<span class="p">.</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* zero shift */</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="cm">/*</span>
<span class="cm">	 * Convenience macro for timestamps. 4 is the index in</span>
<span class="cm">	 * the buffer.</span>
<span class="cm">	 */</span>
	<span class="n">IIO_CHAN_SOFT_TIMESTAMP</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="cm">/* DAC channel out_voltage0_raw */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">IIO_VOLTAGE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">info_mask</span> <span class="o">=</span> <span class="n">IIO_CHAN_INFO_RAW_SEPARATE_BIT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">output</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">indexed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * iio_dummy_read_raw() - data read function.</span>
<span class="cm"> * @indio_dev:	the struct iio_dev associated with this device instance</span>
<span class="cm"> * @chan:	the channel whose data is to be read</span>
<span class="cm"> * @val:	first element of returned value (typically INT)</span>
<span class="cm"> * @val2:	second element of returned value (typically MICRO)</span>
<span class="cm"> * @mask:	what we actually want to read. 0 is the channel, everything else</span>
<span class="cm"> *		is as per the info_mask in iio_chan_spec.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iio_dummy_read_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="k">const</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="o">*</span><span class="n">val2</span><span class="p">,</span>
			      <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dummy_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IIO_CHAN_INFO_RAW</span>: <span class="cm">/* magic value - channel value read */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IIO_VOLTAGE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Set integer part to cached value */</span>
				<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">dac_val</span><span class="p">;</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">IIO_VAL_INT</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">differential</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
					<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">differential_adc_val</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="k">else</span>
					<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">differential_adc_val</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">IIO_VAL_INT</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">single_ended_adc_val</span><span class="p">;</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">IIO_VAL_INT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IIO_ACCEL</span>:
			<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">accel_val</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">IIO_VAL_INT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IIO_CHAN_INFO_OFFSET</span>:
		<span class="cm">/* only single ended adc -&gt; 7 */</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">IIO_VAL_INT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IIO_CHAN_INFO_SCALE</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">differential</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="cm">/* only single ended adc -&gt; 0.001333 */</span>
			<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">*</span><span class="n">val2</span> <span class="o">=</span> <span class="mi">1333</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">IIO_VAL_INT_PLUS_MICRO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="cm">/* all differential adc channels -&gt; 0.000001344 */</span>
			<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">*</span><span class="n">val2</span> <span class="o">=</span> <span class="mi">1344</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">IIO_VAL_INT_PLUS_NANO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IIO_CHAN_INFO_CALIBBIAS</span>:
		<span class="cm">/* only the acceleration axis - read from cache */</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">accel_calibbias</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">IIO_VAL_INT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IIO_CHAN_INFO_CALIBSCALE</span>:
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">accel_calibscale</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
		<span class="o">*</span><span class="n">val2</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">accel_calibscale</span><span class="o">-&gt;</span><span class="n">val2</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">IIO_VAL_INT_PLUS_MICRO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iio_dummy_write_raw() - data write function.</span>
<span class="cm"> * @indio_dev:	the struct iio_dev associated with this device instance</span>
<span class="cm"> * @chan:	the channel whose data is to be read</span>
<span class="cm"> * @val:	first element of returned value (typically INT)</span>
<span class="cm"> * @val2:	second element of returned value (typically MICRO)</span>
<span class="cm"> * @mask:	what we actually want to read. 0 is the channel, everything else</span>
<span class="cm"> *		is as per the info_mask in iio_chan_spec.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that all raw writes are assumed IIO_VAL_INT and info mask elements</span>
<span class="cm"> * are assumed to be IIO_INT_PLUS_MICRO unless the callback write_raw_get_fmt</span>
<span class="cm"> * in struct iio_info is provided by the driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iio_dummy_write_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="k">const</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">val</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">val2</span><span class="p">,</span>
			       <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iio_dummy_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IIO_CHAN_INFO_RAW</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* Locking not required as writing single value */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">dac_val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IIO_CHAN_INFO_CALIBBIAS</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* Compare against table - hard matching here */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dummy_scales</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">dummy_scales</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">&amp;&amp;</span>
			    <span class="n">val2</span> <span class="o">==</span> <span class="n">dummy_scales</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val2</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dummy_scales</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">st</span><span class="o">-&gt;</span><span class="n">accel_calibscale</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy_scales</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Device type specific information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iio_info</span> <span class="n">iio_dummy_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver_module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_raw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iio_dummy_read_raw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_raw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iio_dummy_write_raw</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_IIO_SIMPLE_DUMMY_EVENTS</span>
	<span class="p">.</span><span class="n">read_event_config</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iio_simple_dummy_read_event_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_event_config</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iio_simple_dummy_write_event_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_event_value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iio_simple_dummy_read_event_value</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_event_value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iio_simple_dummy_write_event_value</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IIO_SIMPLE_DUMMY_EVENTS */</span><span class="cp"></span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * iio_dummy_init_device() - device instance specific init</span>
<span class="cm"> * @indio_dev: the iio device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Most drivers have one of these to set up default values,</span>
<span class="cm"> * reset the device to known state etc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iio_dummy_init_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iio_dummy_state</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>

	<span class="n">st</span><span class="o">-&gt;</span><span class="n">dac_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">single_ended_adc_val</span> <span class="o">=</span> <span class="mi">73</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">differential_adc_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">33</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">differential_adc_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">34</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">accel_val</span> <span class="o">=</span> <span class="mi">34</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">accel_calibbias</span> <span class="o">=</span> <span class="o">-</span><span class="mi">7</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">accel_calibscale</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy_scales</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iio_dummy_probe() - device instance probe</span>
<span class="cm"> * @index: an id number for this instance.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments are bus type specific.</span>
<span class="cm"> * I2C: iio_dummy_probe(struct i2c_client *client,</span>
<span class="cm"> *                      const struct i2c_device_id *id)</span>
<span class="cm"> * SPI: iio_dummy_probe(struct spi_device *spi)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">iio_dummy_probe</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iio_dummy_state</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate an IIO device.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This structure contains all generic state</span>
<span class="cm">	 * information about the device instance.</span>
<span class="cm">	 * It also has a region (accessed by iio_priv()</span>
<span class="cm">	 * for chip specific state information.</span>
<span class="cm">	 */</span>
	<span class="n">indio_dev</span> <span class="o">=</span> <span class="n">iio_device_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">st</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">indio_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">st</span> <span class="o">=</span> <span class="n">iio_priv</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">iio_dummy_init_device</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * With hardware: Set the parent device.</span>
<span class="cm">	 * indio_dev-&gt;dev.parent = &amp;spi-&gt;dev;</span>
<span class="cm">	 * indio_dev-&gt;dev.parent = &amp;client-&gt;dev;</span>
<span class="cm">	 */</span>

	 <span class="cm">/*</span>
<span class="cm">	 * Make the iio_dev struct available to remove function.</span>
<span class="cm">	 * Bus equivalents</span>
<span class="cm">	 * i2c_set_clientdata(client, indio_dev);</span>
<span class="cm">	 * spi_set_drvdata(spi, indio_dev);</span>
<span class="cm">	 */</span>
	<span class="n">iio_dummy_devs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">indio_dev</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * Set the device name.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is typically a part number and obtained from the module</span>
<span class="cm">	 * id table.</span>
<span class="cm">	 * e.g. for i2c and spi:</span>
<span class="cm">	 *    indio_dev-&gt;name = id-&gt;name;</span>
<span class="cm">	 *    indio_dev-&gt;name = spi_get_device_id(spi)-&gt;name;</span>
<span class="cm">	 */</span>
	<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">iio_dummy_part_number</span><span class="p">;</span>

	<span class="cm">/* Provide description of available channels */</span>
	<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">=</span> <span class="n">iio_dummy_channels</span><span class="p">;</span>
	<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">num_channels</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">iio_dummy_channels</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Provide device type specific interface functions and</span>
<span class="cm">	 * constant data.</span>
<span class="cm">	 */</span>
	<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iio_dummy_info</span><span class="p">;</span>

	<span class="cm">/* Specify that device provides sysfs type interfaces */</span>
	<span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">=</span> <span class="n">INDIO_DIRECT_MODE</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iio_simple_dummy_events_register</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_free_device</span><span class="p">;</span>

	<span class="cm">/* Configure buffered capture support. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iio_simple_dummy_configure_buffer</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unregister_events</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register the channels with the buffer, but avoid the output</span>
<span class="cm">	 * channel being registered by reducing the number of channels by 1.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iio_buffer_register</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">,</span> <span class="n">iio_dummy_channels</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unconfigure_buffer</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iio_device_register</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unregister_buffer</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_unregister_buffer:</span>
	<span class="n">iio_buffer_unregister</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
<span class="nl">error_unconfigure_buffer:</span>
	<span class="n">iio_simple_dummy_unconfigure_buffer</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
<span class="nl">error_unregister_events:</span>
	<span class="n">iio_simple_dummy_events_unregister</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
<span class="nl">error_free_device:</span>
	<span class="n">iio_device_free</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
<span class="nl">error_ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iio_dummy_remove() - device instance removal function</span>
<span class="cm"> * @index: device index.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters follow those of iio_dummy_probe for buses.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iio_dummy_remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get a pointer to the device instance iio_dev structure</span>
<span class="cm">	 * from the bus subsystem. E.g.</span>
<span class="cm">	 * struct iio_dev *indio_dev = i2c_get_clientdata(client);</span>
<span class="cm">	 * struct iio_dev *indio_dev = spi_get_drvdata(spi);</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span> <span class="o">=</span> <span class="n">iio_dummy_devs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>


	<span class="cm">/* Unregister the device */</span>
	<span class="n">iio_device_unregister</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>

	<span class="cm">/* Device specific code to power down etc */</span>

	<span class="cm">/* Buffered capture related cleanup */</span>
	<span class="n">iio_buffer_unregister</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="n">iio_simple_dummy_unconfigure_buffer</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iio_simple_dummy_events_unregister</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ret</span><span class="p">;</span>

	<span class="cm">/* Free all structures */</span>
	<span class="n">iio_device_free</span><span class="p">(</span><span class="n">indio_dev</span><span class="p">);</span>

<span class="nl">error_ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iio_dummy_init() -  device driver registration</span>
<span class="cm"> *</span>
<span class="cm"> * Varies depending on bus type of the device. As there is no device</span>
<span class="cm"> * here, call probe directly. For information on device registration</span>
<span class="cm"> * i2c:</span>
<span class="cm"> * Documentation/i2c/writing-clients</span>
<span class="cm"> * spi:</span>
<span class="cm"> * Documentation/spi/spi-summary</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">iio_dummy_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instances</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">instances</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Fake a bus */</span>
	<span class="n">iio_dummy_devs</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">instances</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iio_dummy_devs</span><span class="p">),</span>
				 <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="cm">/* Here we have no actual device so call probe */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iio_dummy_probe</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">iio_dummy_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iio_dummy_exit() - device driver removal</span>
<span class="cm"> *</span>
<span class="cm"> * Varies depending on bus type of the device.</span>
<span class="cm"> * As there is no device here, call remove directly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__exit</span> <span class="kt">void</span> <span class="nf">iio_dummy_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">iio_dummy_remove</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iio_dummy_devs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">iio_dummy_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jonathan Cameron &lt;jic23@cam.ac.uk&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;IIO dummy driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
