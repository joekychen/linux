<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › usbip › stub_dev.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>stub_dev.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2003-2008 Takahiro Hirofuchi</span>
<span class="cm"> *</span>
<span class="cm"> * This is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,</span>
<span class="cm"> * USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &quot;usbip_common.h&quot;</span>
<span class="cp">#include &quot;stub.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Define device IDs here if you want to explicitly limit exportable devices.</span>
<span class="cm"> * In most cases, wildcard matching will be okay because driver binding can be</span>
<span class="cm"> * changed dynamically by a userland program.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">stub_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* just an example */</span>
<span class="c">	{ USB_DEVICE(0x05ac, 0x0301) },   /* Mac 1 button mouse */</span>
<span class="c">	{ USB_DEVICE(0x0430, 0x0009) },   /* Plat Home Keyboard */</span>
<span class="c">	{ USB_DEVICE(0x059b, 0x0001) },   /* Iomega USB Zip 100 */</span>
<span class="c">	{ USB_DEVICE(0x04b3, 0x4427) },   /* IBM USB CD-ROM */</span>
<span class="c">	{ USB_DEVICE(0x05a9, 0xa511) },   /* LifeView USB cam */</span>
<span class="c">	{ USB_DEVICE(0x55aa, 0x0201) },   /* Imation card reader */</span>
<span class="c">	{ USB_DEVICE(0x046d, 0x0870) },   /* Qcam Express(QV-30) */</span>
<span class="c">	{ USB_DEVICE(0x04bb, 0x0101) },   /* IO-DATA HD 120GB */</span>
<span class="c">	{ USB_DEVICE(0x04bb, 0x0904) },   /* IO-DATA USB-ET/TX */</span>
<span class="c">	{ USB_DEVICE(0x04bb, 0x0201) },   /* IO-DATA USB-ET/TX */</span>
<span class="c">	{ USB_DEVICE(0x08bb, 0x2702) },   /* ONKYO USB Speaker */</span>
<span class="c">	{ USB_DEVICE(0x046d, 0x08b2) },   /* Logicool Qcam 4000 Pro */</span>
<span class="cp">#endif</span>
	<span class="cm">/* magic for wild card */</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>                                     <span class="cm">/* Terminating entry */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">stub_table</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * usbip_status shows the status of usbip-host as long as this driver is bound</span>
<span class="cm"> * to the target device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stub_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sdev is null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">usbip_status</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">show_status</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * usbip_sockfd gets a socket descriptor of an established TCP connection that</span>
<span class="cm"> * is used to transfer usbip requests by kernel threads. -1 is a magic number</span>
<span class="cm"> * by which usbip connection is finished.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_sockfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stub_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">socket</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sdev is null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sockfd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sockfd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;stub up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SDEV_ST_AVAILABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;not ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">socket</span> <span class="o">=</span> <span class="n">sockfd_to_socket</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">socket</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="p">;</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_rx</span> <span class="o">=</span> <span class="n">kthread_get_run</span><span class="p">(</span><span class="n">stub_rx_loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">,</span> <span class="s">&quot;stub_rx&quot;</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_tx</span> <span class="o">=</span> <span class="n">kthread_get_run</span><span class="p">(</span><span class="n">stub_tx_loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">,</span> <span class="s">&quot;stub_tx&quot;</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">SDEV_ST_USED</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;stub down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SDEV_ST_USED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">usbip_event_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">,</span> <span class="n">SDEV_EVENT_DOWN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">usbip_sockfd</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">store_sockfd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">stub_add_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_usbip_status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_status</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_usbip_sockfd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_sockfd</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_usbip_debug</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_debug</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_debug:</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_usbip_sockfd</span><span class="p">);</span>
<span class="nl">err_sockfd:</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_usbip_status</span><span class="p">);</span>
<span class="nl">err_status:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">stub_remove_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_usbip_status</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_usbip_sockfd</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_usbip_debug</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">stub_shutdown_connection</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stub_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ud</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stub_device</span><span class="p">,</span> <span class="n">ud</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When removing an exported device, kernel panic sometimes occurred</span>
<span class="cm">	 * and then EIP was sk_wait_data of stub_rx thread. Is this because</span>
<span class="cm">	 * sk_wait_data returned though stub_rx thread was already finished by</span>
<span class="cm">	 * step 1?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;shutdown tcp_socket %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">);</span>
		<span class="n">kernel_sock_shutdown</span><span class="p">(</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">,</span> <span class="n">SHUT_RDWR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* 1. stop threads */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_rx</span><span class="p">)</span>
		<span class="n">kthread_stop_put</span><span class="p">(</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_rx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_tx</span><span class="p">)</span>
		<span class="n">kthread_stop_put</span><span class="p">(</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_tx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * 2. close the socket</span>
<span class="cm">	 *</span>
<span class="cm">	 * tcp_socket is freed after threads are killed so that usbip_xmit does</span>
<span class="cm">	 * not touch NULL socket.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock_release</span><span class="p">(</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">);</span>
		<span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_socket</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* 3. free used data */</span>
	<span class="n">stub_device_cleanup_urbs</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="cm">/* 4. free stub_unlink */</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">stub_unlink</span> <span class="o">*</span><span class="n">unlink</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">unlink</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">unlink_tx</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unlink</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">unlink</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">unlink</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">unlink_free</span><span class="p">,</span>
					 <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unlink</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">unlink</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">stub_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stub_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ud</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stub_device</span><span class="p">,</span> <span class="n">ud</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reset&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_lock_device_for_reset</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;lock for reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">ud</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">SDEV_ST_ERROR</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* try to reset the device */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_reset_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ud</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">SDEV_ST_ERROR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ud</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">SDEV_ST_AVAILABLE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">stub_device_unusable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ud</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">SDEV_ST_ERROR</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * stub_device_alloc - allocate a new stub_device struct</span>
<span class="cm"> * @interface: usb_interface of a new device</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates and initializes a new stub_device struct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">stub_device</span> <span class="o">*</span><span class="nf">stub_device_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stub_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">busnum</span> <span class="o">=</span> <span class="n">interface_to_busnum</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">devnum</span> <span class="o">=</span> <span class="n">interface_to_devnum</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;allocating stub device&quot;</span><span class="p">);</span>

	<span class="cm">/* yes, it&#39;s a new device */</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stub_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no memory for stub_device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">=</span> <span class="n">usb_get_intf</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usb_get_dev</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * devid is defined with devnum when this driver is first allocated.</span>
<span class="cm">	 * devnum may change later if a device is reset. However, devid never</span>
<span class="cm">	 * changes during a usbip connection.</span>
<span class="cm">	 */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">devid</span>		<span class="o">=</span> <span class="p">(</span><span class="n">busnum</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">devnum</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">side</span>		<span class="o">=</span> <span class="n">USBIP_STUB</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span>		<span class="o">=</span> <span class="n">SDEV_ST_AVAILABLE</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_socket</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">priv_init</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">priv_tx</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">priv_free</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">unlink_free</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">unlink_tx</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tx_waitq</span><span class="p">);</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">eh_ops</span><span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">stub_shutdown_connection</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">eh_ops</span><span class="p">.</span><span class="n">reset</span>    <span class="o">=</span> <span class="n">stub_device_reset</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">eh_ops</span><span class="p">.</span><span class="n">unusable</span> <span class="o">=</span> <span class="n">stub_device_unusable</span><span class="p">;</span>

	<span class="n">usbip_start_eh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;register new interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sdev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">stub_device_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">stub_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kfree udev ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If a usb device has multiple active interfaces, this driver is bound to all</span>
<span class="cm"> * the active interfaces. However, usbip exports *a* usb device (i.e., not *an*</span>
<span class="cm"> * active interface). Currently, a userland program must ensure that it</span>
<span class="cm"> * looks at the usbip&#39;s sysfs entries of only the first active interface.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: use &quot;struct usb_device_driver&quot; to bind a usb device.</span>
<span class="cm"> * However, it seems it is not fully supported in mainline kernel yet</span>
<span class="cm"> * (2.6.19.2).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">stub_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">stub_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">udev_busid</span> <span class="o">=</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bus_id_priv</span> <span class="o">*</span><span class="n">busid_priv</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* check we should claim or not by busid_table */</span>
	<span class="n">busid_priv</span> <span class="o">=</span> <span class="n">get_busid_priv</span><span class="p">(</span><span class="n">udev_busid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">busid_priv</span> <span class="o">||</span> <span class="p">(</span><span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">STUB_BUSID_REMOV</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">STUB_BUSID_OTHER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s is not in match_busid table... &quot;</span>
			 <span class="s">&quot;skip!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev_busid</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Return value should be ENODEV or ENOXIO to continue trying</span>
<span class="cm">		 * other matched drivers by the driver core.</span>
<span class="cm">		 * See driver_probe_device() in driver/base/dd.c</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceClass</span> <span class="o">==</span> <span class="n">USB_CLASS_HUB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s is a usb hub device... skip!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">udev_busid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_name</span><span class="p">,</span> <span class="s">&quot;vhci_hcd&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s is attached on vhci_hcd... skip!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">udev_busid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">STUB_BUSID_ALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdev</span> <span class="o">=</span> <span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">interf_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usbip-host: register new interface &quot;</span>
			 <span class="s">&quot;(bus %u dev %u ifn %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span>
			 <span class="n">interface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">);</span>

		<span class="cm">/* set private data to usb_interface */</span>
		<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">stub_add_files</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;stub_add_files for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">udev_busid</span><span class="p">);</span>
			<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">interf_count</span><span class="o">--</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">usb_get_intf</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ok, this is my device */</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">stub_device_alloc</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">interface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usbip-host: register new device &quot;</span>
		 <span class="s">&quot;(bus %u dev %u ifn %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span>
		 <span class="n">interface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">);</span>

	<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">interf_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">shutdown_busid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set private data to usb_interface */</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">interf_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">stub_add_files</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;stub_add_files for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev_busid</span><span class="p">);</span>
		<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">usb_put_intf</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>

		<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">interf_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">stub_device_free</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">STUB_BUSID_ALLOC</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shutdown_busid</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_id_priv</span> <span class="o">*</span><span class="n">busid_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">shutdown_busid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">shutdown_busid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">usbip_event_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">,</span> <span class="n">SDEV_EVENT_REMOVED</span><span class="p">);</span>

		<span class="cm">/* 2. wait for the stop of the event handler */</span>
		<span class="n">usbip_stop_eh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called in usb_disconnect() or usb_deregister()</span>
<span class="cm"> * but only if actconfig(active configuration) exists</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stub_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stub_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">udev_busid</span> <span class="o">=</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bus_id_priv</span> <span class="o">*</span><span class="n">busid_priv</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">busid_priv</span> <span class="o">=</span> <span class="n">get_busid_priv</span><span class="p">(</span><span class="n">udev_busid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">busid_priv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>

	<span class="cm">/* get stub_device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not get device&quot;</span><span class="p">);</span>
		<span class="cm">/* BUG(); */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE:</span>
<span class="cm">	 * rx/tx threads are invoked for each usb_device.</span>
<span class="cm">	 */</span>
	<span class="n">stub_remove_files</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*If usb reset called from event handler*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">eh</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">interf_count</span><span class="o">--</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">interf_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">interf_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">shutdown_busid</span><span class="p">(</span><span class="n">busid_priv</span><span class="p">);</span>
		<span class="n">usb_put_intf</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">interf_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 1. shutdown the current connection */</span>
	<span class="n">shutdown_busid</span><span class="p">(</span><span class="n">busid_priv</span><span class="p">);</span>

	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">usb_put_intf</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>

	<span class="cm">/* 3. free sdev */</span>
	<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">stub_device_free</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">STUB_BUSID_ALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">STUB_BUSID_ADDED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">busid_priv</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">STUB_BUSID_OTHER</span><span class="p">;</span>
		<span class="n">del_match_busid</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">udev_busid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Presence of pre_reset and post_reset prevents the driver from being unbound</span>
<span class="cm"> * when the device is being reset</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">stub_pre_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pre_reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">stub_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;post_reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">stub_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;usbip-host&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">stub_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span>	<span class="o">=</span> <span class="n">stub_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">stub_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_reset</span>	<span class="o">=</span> <span class="n">stub_pre_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_reset</span>	<span class="o">=</span> <span class="n">stub_post_reset</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
