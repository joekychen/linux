<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › usbip › vhci_hcd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vhci_hcd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2003-2008 Takahiro Hirofuchi</span>
<span class="cm"> *</span>
<span class="cm"> * This is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,</span>
<span class="cm"> * USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;usbip_common.h&quot;</span>
<span class="cp">#include &quot;vhci.h&quot;</span>

<span class="cp">#define DRIVER_AUTHOR &quot;Takahiro Hirofuchi&quot;</span>
<span class="cp">#define DRIVER_DESC &quot;USB/IP &#39;Virtual&#39; Host Controller (VHCI) Driver&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * TODO</span>
<span class="cm"> *	- update root hub emulation</span>
<span class="cm"> *	- move the emulation code to userland ?</span>
<span class="cm"> *		porting to other operating systems</span>
<span class="cm"> *		minimize kernel code</span>
<span class="cm"> *	- add suspend/resume code</span>
<span class="cm"> *	- clean up everything</span>
<span class="cm"> */</span>

<span class="cm">/* See usb gadget dummy hcd */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">vhci_hub_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vhci_hub_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
			    <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vhci_urb_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
			    <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vhci_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vhci_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">vhci_hcd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">vhci_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vhci_get_frame_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;vhci_hcd&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_desc</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;USB/IP Virtual Host Controller&quot;</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vhci_hcd</span> <span class="o">*</span><span class="n">the_controller</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">bit_desc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;CONNECTION&quot;</span><span class="p">,</span>		<span class="cm">/*0*/</span>
	<span class="s">&quot;ENABLE&quot;</span><span class="p">,</span>		<span class="cm">/*1*/</span>
	<span class="s">&quot;SUSPEND&quot;</span><span class="p">,</span>		<span class="cm">/*2*/</span>
	<span class="s">&quot;OVER_CURRENT&quot;</span><span class="p">,</span>		<span class="cm">/*3*/</span>
	<span class="s">&quot;RESET&quot;</span><span class="p">,</span>		<span class="cm">/*4*/</span>
	<span class="s">&quot;R5&quot;</span><span class="p">,</span>			<span class="cm">/*5*/</span>
	<span class="s">&quot;R6&quot;</span><span class="p">,</span>			<span class="cm">/*6*/</span>
	<span class="s">&quot;R7&quot;</span><span class="p">,</span>			<span class="cm">/*7*/</span>
	<span class="s">&quot;POWER&quot;</span><span class="p">,</span>		<span class="cm">/*8*/</span>
	<span class="s">&quot;LOWSPEED&quot;</span><span class="p">,</span>		<span class="cm">/*9*/</span>
	<span class="s">&quot;HIGHSPEED&quot;</span><span class="p">,</span>		<span class="cm">/*10*/</span>
	<span class="s">&quot;PORT_TEST&quot;</span><span class="p">,</span>		<span class="cm">/*11*/</span>
	<span class="s">&quot;INDICATOR&quot;</span><span class="p">,</span>		<span class="cm">/*12*/</span>
	<span class="s">&quot;R13&quot;</span><span class="p">,</span>			<span class="cm">/*13*/</span>
	<span class="s">&quot;R14&quot;</span><span class="p">,</span>			<span class="cm">/*14*/</span>
	<span class="s">&quot;R15&quot;</span><span class="p">,</span>			<span class="cm">/*15*/</span>
	<span class="s">&quot;C_CONNECTION&quot;</span><span class="p">,</span>		<span class="cm">/*16*/</span>
	<span class="s">&quot;C_ENABLE&quot;</span><span class="p">,</span>		<span class="cm">/*17*/</span>
	<span class="s">&quot;C_SUSPEND&quot;</span><span class="p">,</span>		<span class="cm">/*18*/</span>
	<span class="s">&quot;C_OVER_CURRENT&quot;</span><span class="p">,</span>	<span class="cm">/*19*/</span>
	<span class="s">&quot;C_RESET&quot;</span><span class="p">,</span>		<span class="cm">/*20*/</span>
	<span class="s">&quot;R21&quot;</span><span class="p">,</span>			<span class="cm">/*21*/</span>
	<span class="s">&quot;R22&quot;</span><span class="p">,</span>			<span class="cm">/*22*/</span>
	<span class="s">&quot;R23&quot;</span><span class="p">,</span>			<span class="cm">/*23*/</span>
	<span class="s">&quot;R24&quot;</span><span class="p">,</span>			<span class="cm">/*24*/</span>
	<span class="s">&quot;R25&quot;</span><span class="p">,</span>			<span class="cm">/*25*/</span>
	<span class="s">&quot;R26&quot;</span><span class="p">,</span>			<span class="cm">/*26*/</span>
	<span class="s">&quot;R27&quot;</span><span class="p">,</span>			<span class="cm">/*27*/</span>
	<span class="s">&quot;R28&quot;</span><span class="p">,</span>			<span class="cm">/*28*/</span>
	<span class="s">&quot;R29&quot;</span><span class="p">,</span>			<span class="cm">/*29*/</span>
	<span class="s">&quot;R30&quot;</span><span class="p">,</span>			<span class="cm">/*30*/</span>
	<span class="s">&quot;R31&quot;</span><span class="p">,</span>			<span class="cm">/*31*/</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_port_status_diff</span><span class="p">(</span><span class="n">u32</span> <span class="n">prev_status</span><span class="p">,</span> <span class="n">u32</span> <span class="n">new_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;status prev -&gt; new: %08x -&gt; %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">prev_status</span><span class="p">,</span> <span class="n">new_status</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">prev_status</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">new</span> <span class="o">=</span> <span class="n">new_status</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">change</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">new</span><span class="p">)</span>
			<span class="n">change</span> <span class="o">=</span> <span class="sc">&#39;+&#39;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">new</span><span class="p">)</span>
			<span class="n">change</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">change</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">||</span> <span class="n">new</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; %c%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">change</span><span class="p">,</span> <span class="n">bit_desc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">bit</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rh_port_connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">rhport</span><span class="p">,</span> <span class="k">enum</span> <span class="n">usb_device_speed</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>

	<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot;rh_port_connect %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rhport</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_CONNECTION</span>
		<span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_PORT_FEAT_C_CONNECTION</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:
		<span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>:
		<span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_LOW_SPEED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* spin_lock(&amp;the_controller-&gt;vdev[rhport].ud.lock);</span>
<span class="cm">	 * the_controller-&gt;vdev[rhport].ud.status = VDEV_CONNECT;</span>
<span class="cm">	 * spin_unlock(&amp;the_controller-&gt;vdev[rhport].ud.lock); */</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">usb_hcd_poll_rh_status</span><span class="p">(</span><span class="n">vhci_to_hcd</span><span class="p">(</span><span class="n">the_controller</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rh_port_disconnect</span><span class="p">(</span><span class="kt">int</span> <span class="n">rhport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot;rh_port_disconnect %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rhport</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* stop_activity(dum, driver); */</span>
	<span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">;</span>
	<span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">|=</span>
					<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_PORT_FEAT_C_CONNECTION</span><span class="p">);</span>

	<span class="cm">/* not yet complete the disconnection</span>
<span class="cm">	 * spin_lock(&amp;vdev-&gt;ud.lock);</span>
<span class="cm">	 * vdev-&gt;ud.status = VHC_ST_DISCONNECT;</span>
<span class="cm">	 * spin_unlock(&amp;vdev-&gt;ud.lock); */</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">usb_hcd_poll_rh_status</span><span class="p">(</span><span class="n">vhci_to_hcd</span><span class="p">(</span><span class="n">the_controller</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define PORT_C_MASK				\</span>
<span class="cp">	((USB_PORT_STAT_C_CONNECTION		\</span>
<span class="cp">	  | USB_PORT_STAT_C_ENABLE		\</span>
<span class="cp">	  | USB_PORT_STAT_C_SUSPEND		\</span>
<span class="cp">	  | USB_PORT_STAT_C_OVERCURRENT		\</span>
<span class="cp">	  | USB_PORT_STAT_C_RESET) &lt;&lt; 16)</span>

<span class="cm">/*</span>
<span class="cm"> * This function is almostly the same as dummy_hcd.c:dummy_hub_status() without</span>
<span class="cm"> * suspend/resume support. But, it is modified to provide multiple ports.</span>
<span class="cm"> *</span>
<span class="cm"> * @buf: a bitmap to show which port status has been changed.</span>
<span class="cm"> *  bit  0: reserved or used for another purpose?</span>
<span class="cm"> *  bit  1: the status of port 0 has been changed.</span>
<span class="cm"> *  bit  2: the status of port 1 has been changed.</span>
<span class="cm"> *  ...</span>
<span class="cm"> *  bit  7: the status of port 6 has been changed.</span>
<span class="cm"> *  bit  8: the status of port 7 has been changed.</span>
<span class="cm"> *  ...</span>
<span class="cm"> *  bit 15: the status of port 14 has been changed.</span>
<span class="cm"> *</span>
<span class="cm"> * So, the maximum number of ports is 31 ( port 0 to port 30) ?</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the actual transferred length in byte. If nothing has</span>
<span class="cm"> * been changed, return 0. In the case that the number of ports is less than or</span>
<span class="cm"> * equal to 6 (VHCI_NPORTS==7), return 1.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_hub_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vhci_hcd</span>	<span class="o">*</span><span class="n">vhci</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* the enough buffer is allocated according to USB_MAXCHILDREN */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="o">*</span><span class="n">event_bits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rhport</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">event_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vhci</span> <span class="o">=</span> <span class="n">hcd_to_vhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot;hw accessible flag in on?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check pseudo status register for each port */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rhport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rhport</span> <span class="o">&lt;</span> <span class="n">VHCI_NPORTS</span><span class="p">;</span> <span class="n">rhport</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PORT_C_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* The status of a port has been changed, */</span>
			<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot;port %d is changed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rhport</span><span class="p">);</span>

			<span class="o">*</span><span class="n">event_bits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">rhport</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;changed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">changed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">HC_STATE_SUSPENDED</span><span class="p">)</span>
		<span class="n">usb_hcd_resume_root_hub</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">VHCI_NPORTS</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* See hub_configure in hub.c */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hub_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">));</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="mh">0x29</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescLength</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">wHubCharacteristics</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__u16</span><span class="p">)</span>
		<span class="p">(</span><span class="n">__constant_cpu_to_le16</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">));</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span> <span class="o">=</span> <span class="n">VHCI_NPORTS</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_hub_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
			    <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vhci_hcd</span>	<span class="o">*</span><span class="n">dum</span><span class="p">;</span>
	<span class="kt">int</span>             <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rhport</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">prev_port_status</span><span class="p">[</span><span class="n">VHCI_NPORTS</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE:</span>
<span class="cm">	 * wIndex shows the port number and begins from 1.</span>
<span class="cm">	 */</span>
	<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot;typeReq %x wValue %x wIndex %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span>
			  <span class="n">wIndex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">VHCI_NPORTS</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;invalid port number %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">);</span>
	<span class="n">rhport</span> <span class="o">=</span> <span class="p">((</span><span class="n">__u8</span><span class="p">)(</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dum</span> <span class="o">=</span> <span class="n">hcd_to_vhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dum</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* store old status and compare now and old later */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usbip_dbg_flag_vhci_rh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">prev_port_status</span><span class="p">,</span> <span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">prev_port_status</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">typeReq</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ClearHubFeature</span>:
		<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; ClearHubFeature</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ClearPortFeature</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_SUSPEND</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* 20msec signaling */</span>
				<span class="n">dum</span><span class="o">-&gt;</span><span class="n">resuming</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">dum</span><span class="o">-&gt;</span><span class="n">re_timeout</span> <span class="o">=</span>
					<span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_POWER</span>:
			<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; ClearPortFeature: &quot;</span>
					  <span class="s">&quot;USB_PORT_FEAT_POWER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* dum-&gt;address = 0; */</span>
			<span class="cm">/* dum-&gt;hdev = 0; */</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">resuming</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_RESET</span>:
			<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; ClearPortFeature: &quot;</span>
					  <span class="s">&quot;USB_PORT_FEAT_C_RESET</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dum</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">[</span><span class="n">rhport</span><span class="p">].</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:
				<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">|=</span>
					<span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>:
				<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">|=</span>
					<span class="n">USB_PORT_STAT_LOW_SPEED</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; ClearPortFeature: default %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">wValue</span><span class="p">);</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wValue</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetHubDescriptor</span>:
		<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; GetHubDescriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hub_descriptor</span><span class="p">((</span><span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetHubStatus</span>:
		<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; GetHubStatus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">__constant_cpu_to_le32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetPortStatus</span>:
		<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; GetPortStatus port %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">VHCI_NPORTS</span> <span class="o">||</span> <span class="n">wIndex</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;invalid port number %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we do no care of resume. */</span>

		<span class="cm">/* whoever resets or resumes must GetPortStatus to</span>
<span class="cm">		 * complete it!!</span>
<span class="cm">		 *                                   */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dum</span><span class="o">-&gt;</span><span class="n">resuming</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">dum</span><span class="o">-&gt;</span><span class="n">re_timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">|=</span>
				<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_PORT_FEAT_C_SUSPEND</span><span class="p">);</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&amp;=</span>
				<span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_PORT_FEAT_SUSPEND</span><span class="p">);</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">resuming</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">re_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* if (dum-&gt;driver &amp;&amp; dum-&gt;driver-&gt;resume) {</span>
<span class="cm">			 *	spin_unlock (&amp;dum-&gt;lock);</span>
<span class="cm">			 *	dum-&gt;driver-&gt;resume (&amp;dum-&gt;gadget);</span>
<span class="cm">			 *	spin_lock (&amp;dum-&gt;lock);</span>
<span class="cm">			 * } */</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_PORT_FEAT_RESET</span><span class="p">))</span> <span class="o">!=</span>
		    <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">dum</span><span class="o">-&gt;</span><span class="n">re_timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">|=</span>
				<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_PORT_FEAT_C_RESET</span><span class="p">);</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&amp;=</span>
				<span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_PORT_FEAT_RESET</span><span class="p">);</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">re_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dum</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">[</span><span class="n">rhport</span><span class="p">].</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span>
			    <span class="n">VDEV_ST_NOTASSIGNED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; enable rhport %d &quot;</span>
						  <span class="s">&quot;(status %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">rhport</span><span class="p">,</span>
						  <span class="n">dum</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">[</span><span class="n">rhport</span><span class="p">].</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
				<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">|=</span>
					<span class="n">USB_PORT_STAT_ENABLE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]);</span>
		<span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

		<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; GetPortStatus bye %x %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
				  <span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SetHubFeature</span>:
		<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; SetHubFeature</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SetPortFeature</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
			<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; SetPortFeature: &quot;</span>
					  <span class="s">&quot;USB_PORT_FEAT_SUSPEND</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_RESET</span>:
			<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; SetPortFeature: &quot;</span>
					  <span class="s">&quot;USB_PORT_FEAT_RESET</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* if it&#39;s already running, disconnect first */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&amp;=</span>
					<span class="o">~</span><span class="p">(</span><span class="n">USB_PORT_STAT_ENABLE</span> <span class="o">|</span>
					  <span class="n">USB_PORT_STAT_LOW_SPEED</span> <span class="o">|</span>
					  <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">);</span>
				<span class="cm">/* FIXME test that code path! */</span>
			<span class="p">}</span>
			<span class="cm">/* 50msec reset signaling */</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">re_timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

			<span class="cm">/* FALLTHROUGH */</span>
		<span class="nl">default:</span>
			<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; SetPortFeature: default %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">wValue</span><span class="p">);</span>
			<span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wValue</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;default: no such request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* dev_dbg (hardware,</span>
<span class="cm">		 *		&quot;hub control req%04x v%04x i%04x l%d\n&quot;,</span>
<span class="cm">		 *		typeReq, wValue, wIndex, wLength); */</span>

		<span class="cm">/* &quot;protocol stall&quot; on error */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usbip_dbg_flag_vhci_rh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rhport</span><span class="p">);</span>
		<span class="cm">/* Only dump valid port status */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rhport</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dump_port_status_diff</span><span class="p">(</span><span class="n">prev_port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">],</span>
					      <span class="n">dum</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">usbip_dbg_vhci_rh</span><span class="p">(</span><span class="s">&quot; bye</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dum</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vhci_device</span> <span class="o">*</span><span class="nf">get_vdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VHCI_NPORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">udev</span> <span class="o">==</span> <span class="n">udev</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">port_to_vdev</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vhci_tx_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vhci_device</span> <span class="o">*</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">get_vdev</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vhci_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;could not get virtual device&quot;</span><span class="p">);</span>
		<span class="cm">/* BUG(); */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vhci_priv</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;malloc vhci_priv</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="n">usbip_event_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">,</span> <span class="n">VDEV_EVENT_ERROR_MALLOC</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">seqnum</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">seqnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">seqnum</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;seqnum max</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">vdev</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_tx</span><span class="p">);</span>

	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">waitq_tx</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_urb_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
			    <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vhci_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>

	<span class="n">usbip_dbg_vhci_hc</span><span class="p">(</span><span class="s">&quot;enter, usb_hcd %p urb %p mem_flags %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>

	<span class="cm">/* patch to usb_sg_init() is in 2.5.60 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;URB already unlinked!, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vdev</span> <span class="o">=</span> <span class="n">port_to_vdev</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* refuse enqueue for dead connection */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">VDEV_ST_NULL</span> <span class="o">||</span>
	    <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">VDEV_ST_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;enqueue for inactive port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">rhport</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_need_unlink</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The enumeration process is as follows;</span>
<span class="cm">	 *</span>
<span class="cm">	 *  1. Get_Descriptor request to DevAddrs(0) EndPoint(0)</span>
<span class="cm">	 *     to get max packet length of default pipe</span>
<span class="cm">	 *</span>
<span class="cm">	 *  2. Set_Address request to DevAddr(0) EndPoint(0)</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipedevice</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__u8</span> <span class="n">type</span> <span class="o">=</span> <span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrlreq</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PIPE_CONTROL</span> <span class="o">||</span> <span class="o">!</span><span class="n">ctrlreq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid request to devnum 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">no_need_xmit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ctrlreq</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_REQ_SET_ADDRESS</span>:
			<span class="cm">/* set_address may come when a device is reset */</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SetAddress Request (%d) to port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">ctrlreq</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">,</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">rhport</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">)</span>
				<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
			<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usb_get_dev</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">VDEV_ST_USED</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* This request is successfully completed. */</span>
				<span class="cm">/* If not -EINPROGRESS, possibly unlinked. */</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">goto</span> <span class="n">no_need_xmit</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">USB_REQ_GET_DESCRIPTOR</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">ctrlreq</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">==</span> <span class="p">(</span><span class="n">USB_DT_DEVICE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span>
				<span class="n">usbip_dbg_vhci_hc</span><span class="p">(</span><span class="s">&quot;Not yet?: &quot;</span>
						  <span class="s">&quot;Get_Descriptor to device 0 &quot;</span>
						  <span class="s">&quot;(get max pipe size)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">)</span>
				<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
			<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usb_get_dev</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/* NOT REACHED */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid request to devnum 0 bRequest %u, &quot;</span>
				<span class="s">&quot;wValue %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctrlreq</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">,</span>
				<span class="n">ctrlreq</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span>  <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">no_need_xmit</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">vhci_tx_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">no_need_xmit:</span>
	<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
<span class="nl">no_need_unlink:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">vhci_to_hcd</span><span class="p">(</span><span class="n">the_controller</span><span class="p">),</span> <span class="n">urb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vhci_rx gives back the urb after receiving the reply of the urb.  If an</span>
<span class="cm"> * unlink pdu is sent or not, vhci_rx receives a normal return pdu and gives</span>
<span class="cm"> * back its urb. For the driver unlinking the urb, the content of the urb is</span>
<span class="cm"> * not important, but the calling to its completion handler is important; the</span>
<span class="cm"> * completion of unlinking is notified by the completion handler.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * CLIENT SIDE</span>
<span class="cm"> *</span>
<span class="cm"> * - When vhci_hcd receives RET_SUBMIT,</span>
<span class="cm"> *</span>
<span class="cm"> *	- case 1a). the urb of the pdu is not unlinking.</span>
<span class="cm"> *		- normal case</span>
<span class="cm"> *		=&gt; just give back the urb</span>
<span class="cm"> *</span>
<span class="cm"> *	- case 1b). the urb of the pdu is unlinking.</span>
<span class="cm"> *		- usbip.ko will return a reply of the unlinking request.</span>
<span class="cm"> *		=&gt; give back the urb now and go to case 2b).</span>
<span class="cm"> *</span>
<span class="cm"> * - When vhci_hcd receives RET_UNLINK,</span>
<span class="cm"> *</span>
<span class="cm"> *	- case 2a). a submit request is still pending in vhci_hcd.</span>
<span class="cm"> *		- urb was really pending in usbip.ko and urb_unlink_urb() was</span>
<span class="cm"> *		  completed there.</span>
<span class="cm"> *		=&gt; free a pending submit request</span>
<span class="cm"> *		=&gt; notify unlink completeness by giving back the urb</span>
<span class="cm"> *</span>
<span class="cm"> *	- case 2b). a submit request is *not* pending in vhci_hcd.</span>
<span class="cm"> *		- urb was already given back to the core driver.</span>
<span class="cm"> *		=&gt; do not give back the urb</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * SERVER SIDE</span>
<span class="cm"> *</span>
<span class="cm"> * - When usbip receives CMD_UNLINK,</span>
<span class="cm"> *</span>
<span class="cm"> *	- case 3a). the urb of the unlink request is now in submission.</span>
<span class="cm"> *		=&gt; do usb_unlink_urb().</span>
<span class="cm"> *		=&gt; after the unlink is completed, send RET_UNLINK.</span>
<span class="cm"> *</span>
<span class="cm"> *	- case 3b). the urb of the unlink request is not in submission.</span>
<span class="cm"> *		- may be already completed or never be received</span>
<span class="cm"> *		=&gt; send RET_UNLINK</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vhci_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vhci_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;dequeue a urb %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* URB was never linked! or will be soon given back by</span>
<span class="cm">		 * vhci_rx. */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_hcd_check_unlink_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	 <span class="cm">/* send unlink request here? */</span>
	<span class="n">vdev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_socket</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* tcp connection is closed */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags2</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;device %p seems to be disconnected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vdev</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If tcp connection is alive, we have sent CMD_UNLINK.</span>
<span class="cm">		 * vhci_rx will receive RET_UNLINK and give back the URB.</span>
<span class="cm">		 * Otherwise, we give back it here.</span>
<span class="cm">		 */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;gives back urb %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

		<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">vhci_to_hcd</span><span class="p">(</span><span class="n">the_controller</span><span class="p">),</span> <span class="n">urb</span><span class="p">,</span>
				     <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* tcp connection is alive */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vhci_unlink</span> <span class="o">*</span><span class="n">unlink</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>

		<span class="cm">/* setup CMD_UNLINK pdu */</span>
		<span class="n">unlink</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vhci_unlink</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unlink</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;malloc vhci_unlink</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">usbip_event_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">,</span> <span class="n">VDEV_EVENT_ERROR_MALLOC</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">unlink</span><span class="o">-&gt;</span><span class="n">seqnum</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">seqnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlink</span><span class="o">-&gt;</span><span class="n">seqnum</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;seqnum max</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">unlink</span><span class="o">-&gt;</span><span class="n">unlink_seqnum</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">seqnum</span><span class="p">;</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;device %p seems to be still connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vdev</span><span class="p">);</span>

		<span class="cm">/* send cmd_unlink and try to cancel the pending URB in the</span>
<span class="cm">		 * peer */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unlink</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unlink_tx</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">waitq_tx</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">usbip_dbg_vhci_hc</span><span class="p">(</span><span class="s">&quot;leave</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vhci_device_unlink_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vhci_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vhci_unlink</span> <span class="o">*</span><span class="n">unlink</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">unlink</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unlink_tx</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;unlink cleanup tx %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unlink</span><span class="o">-&gt;</span><span class="n">unlink_seqnum</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unlink</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">unlink</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">unlink</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unlink_rx</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>

		<span class="cm">/* give back URB of unanswered unlink request */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;unlink cleanup rx %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unlink</span><span class="o">-&gt;</span><span class="n">unlink_seqnum</span><span class="p">);</span>

		<span class="n">urb</span> <span class="o">=</span> <span class="n">pickup_urb_and_free_priv</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="n">unlink</span><span class="o">-&gt;</span><span class="n">unlink_seqnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;the urb (seqnum %lu) was already given back</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">unlink</span><span class="o">-&gt;</span><span class="n">unlink_seqnum</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unlink</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">unlink</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">vhci_to_hcd</span><span class="p">(</span><span class="n">the_controller</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">vhci_to_hcd</span><span class="p">(</span><span class="n">the_controller</span><span class="p">),</span> <span class="n">urb</span><span class="p">,</span>
				     <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unlink</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">unlink</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The important thing is that only one context begins cleanup.</span>
<span class="cm"> * This is why error handling and cleanup become simple.</span>
<span class="cm"> * We do not want to consider race condition as possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vhci_shutdown_connection</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vhci_device</span> <span class="o">*</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ud</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vhci_device</span><span class="p">,</span> <span class="n">ud</span><span class="p">);</span>

	<span class="cm">/* need this? see stub_dev.c */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;shutdown tcp_socket %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">);</span>
		<span class="n">kernel_sock_shutdown</span><span class="p">(</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">,</span> <span class="n">SHUT_RDWR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* kill threads related to this sdev, if v.c. exists */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_rx</span><span class="p">)</span>
		<span class="n">kthread_stop_put</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_rx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_tx</span><span class="p">)</span>
		<span class="n">kthread_stop_put</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_tx</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;stop threads</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* active connection is closed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_socket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock_release</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_socket</span><span class="p">);</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">tcp_socket</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;release socket</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">vhci_device_unlink_cleanup</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * rh_port_disconnect() is a trigger of ...</span>
<span class="cm">	 *   usb_disable_device():</span>
<span class="cm">	 *	disable all the endpoints for a USB device.</span>
<span class="cm">	 *   usb_disable_endpoint():</span>
<span class="cm">	 *	disable endpoints. pending urbs are unlinked(dequeued).</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: After calling rh_port_disconnect(), the USB device drivers of a</span>
<span class="cm">	 * deteched device should release used urbs in a cleanup function(i.e.</span>
<span class="cm">	 * xxx_disconnect()). Therefore, vhci_hcd does not need to release</span>
<span class="cm">	 * pushed urbs and their private data in this function.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: vhci_dequeue() must be considered carefully. When shutdowning</span>
<span class="cm">	 * a connection, vhci_shutdown_connection() expects vhci_dequeue()</span>
<span class="cm">	 * gives back pushed urbs and frees their private data by request of</span>
<span class="cm">	 * the cleanup function of a USB driver. When unlinking a urb with an</span>
<span class="cm">	 * active connection, vhci_dequeue() does not give back the urb which</span>
<span class="cm">	 * is actually given back by vhci_rx after receiving its return pdu.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="n">rh_port_disconnect</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">rhport</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;disconnect device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">vhci_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vhci_device</span> <span class="o">*</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ud</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vhci_device</span><span class="p">,</span> <span class="n">ud</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">speed</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">devid</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">)</span>
		<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ud</span><span class="o">-&gt;</span><span class="n">tcp_socket</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ud</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">VDEV_ST_NULL</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vhci_device_unusable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ud</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">VDEV_ST_ERROR</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ud</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vhci_device_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vhci_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vdev</span><span class="p">));</span>

	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">side</span>   <span class="o">=</span> <span class="n">USBIP_VHCI</span><span class="p">;</span>
	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">VDEV_ST_NULL</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_rx</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_tx</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unlink_tx</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unlink_rx</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">priv_lock</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">waitq_tx</span><span class="p">);</span>

	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">eh_ops</span><span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">vhci_shutdown_connection</span><span class="p">;</span>
	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">eh_ops</span><span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="n">vhci_device_reset</span><span class="p">;</span>
	<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">.</span><span class="n">eh_ops</span><span class="p">.</span><span class="n">unusable</span> <span class="o">=</span> <span class="n">vhci_device_unusable</span><span class="p">;</span>

	<span class="n">usbip_start_eh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vhci_hcd</span> <span class="o">*</span><span class="n">vhci</span> <span class="o">=</span> <span class="n">hcd_to_vhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rhport</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">usbip_dbg_vhci_hc</span><span class="p">(</span><span class="s">&quot;enter vhci_start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* initialize private data of usb_hcd */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">rhport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rhport</span> <span class="o">&lt;</span> <span class="n">VHCI_NPORTS</span><span class="p">;</span> <span class="n">rhport</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vhci_device</span> <span class="o">*</span><span class="n">vdev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">[</span><span class="n">rhport</span><span class="p">];</span>
		<span class="n">vhci_device_init</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">rhport</span> <span class="o">=</span> <span class="n">rhport</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">seqnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">power_budget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* no limit */</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span>  <span class="o">=</span> <span class="n">HC_STATE_RUNNING</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* vhci_hcd is now ready to be controlled through sysfs */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci_dev</span><span class="p">(</span><span class="n">vhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;create sysfs files</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vhci_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vhci_hcd</span> <span class="o">*</span><span class="n">vhci</span> <span class="o">=</span> <span class="n">hcd_to_vhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rhport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">usbip_dbg_vhci_hc</span><span class="p">(</span><span class="s">&quot;stop VHCI controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* 1. remove the userland interface of vhci_hcd */</span>
	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci_dev</span><span class="p">(</span><span class="n">vhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_group</span><span class="p">);</span>

	<span class="cm">/* 2. shutdown all the ports of vhci_hcd */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rhport</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">rhport</span> <span class="o">&lt;</span> <span class="n">VHCI_NPORTS</span><span class="p">;</span> <span class="n">rhport</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vhci_device</span> <span class="o">*</span><span class="n">vdev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">[</span><span class="n">rhport</span><span class="p">];</span>

		<span class="n">usbip_event_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">,</span> <span class="n">VDEV_EVENT_REMOVED</span><span class="p">);</span>
		<span class="n">usbip_stop_eh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ud</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_get_frame_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Not yet implemented</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="cm">/* FIXME: suspend/resume */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_bus_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vhci_hcd</span> <span class="o">*</span><span class="n">vhci</span> <span class="o">=</span> <span class="n">hcd_to_vhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* vhci-&gt;rh_state = DUMMY_RH_SUSPENDED;</span>
<span class="cm">	 * set_link_state(vhci); */</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_SUSPENDED</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_bus_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vhci_hcd</span> <span class="o">*</span><span class="n">vhci</span> <span class="o">=</span> <span class="n">hcd_to_vhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* vhci-&gt;rh_state = DUMMY_RH_RUNNING;</span>
<span class="cm">		 * set_link_state(vhci);</span>
<span class="cm">		 * if (!list_empty(&amp;vhci-&gt;urbp_list))</span>
<span class="cm">		 *	mod_timer(&amp;vhci-&gt;timer, jiffies); */</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_RUNNING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define vhci_bus_suspend      NULL</span>
<span class="cp">#define vhci_bus_resume       NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hc_driver</span> <span class="n">vhci_hc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span>	<span class="o">=</span> <span class="n">driver_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">product_desc</span>	<span class="o">=</span> <span class="n">driver_desc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hcd_priv_size</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vhci_hcd</span><span class="p">),</span>

	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">HCD_USB2</span><span class="p">,</span>

	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">vhci_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">vhci_stop</span><span class="p">,</span>

	<span class="p">.</span><span class="n">urb_enqueue</span>	<span class="o">=</span> <span class="n">vhci_urb_enqueue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">urb_dequeue</span>	<span class="o">=</span> <span class="n">vhci_urb_dequeue</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_frame_number</span> <span class="o">=</span> <span class="n">vhci_get_frame_number</span><span class="p">,</span>

	<span class="p">.</span><span class="n">hub_status_data</span> <span class="o">=</span> <span class="n">vhci_hub_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hub_control</span>    <span class="o">=</span> <span class="n">vhci_hub_control</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus_suspend</span>	<span class="o">=</span> <span class="n">vhci_bus_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus_resume</span>	<span class="o">=</span> <span class="n">vhci_bus_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_hcd_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ret</span><span class="p">;</span>

	<span class="n">usbip_dbg_vhci_hc</span><span class="p">(</span><span class="s">&quot;name %s id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="cm">/* will be removed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vhci_hcd DMA not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize hcd.</span>
<span class="cm">	 * Our private data is also allocated automatically.</span>
<span class="cm">	 */</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">usb_create_hcd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci_hc_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;create hcd failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">has_tt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* this is private data for vhci_hcd */</span>
	<span class="n">the_controller</span> <span class="o">=</span> <span class="n">hcd_to_vhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finish generic HCD structure initialization and register.</span>
<span class="cm">	 * Call the driver&#39;s reset() and start() routines.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_add_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;usb_add_hcd failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">usb_put_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
		<span class="n">the_controller</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usbip_dbg_vhci_hc</span><span class="p">(</span><span class="s">&quot;bye</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_hcd_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>	<span class="o">*</span><span class="n">hcd</span><span class="p">;</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disconnects the root hub,</span>
<span class="cm">	 * then reverses the effects of usb_add_hcd(),</span>
<span class="cm">	 * invoking the HCD&#39;s stop() methods.</span>
<span class="cm">	 */</span>
	<span class="n">usb_remove_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">usb_put_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">the_controller</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="cm">/* what should happen for USB/IP under suspend/resume? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_hcd_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rhport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">rhport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rhport</span> <span class="o">&lt;</span> <span class="n">VHCI_NPORTS</span><span class="p">;</span> <span class="n">rhport</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">rhport</span><span class="p">]</span> <span class="o">&amp;</span>
		    <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">)</span>
			<span class="n">connected</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">connected</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;We have %d active connection%s. Do not &quot;</span>
			 <span class="s">&quot;suspend.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">connected</span><span class="p">,</span> <span class="p">(</span><span class="n">connected</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;s&quot;</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span>  <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;suspend vhci_hcd&quot;</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vhci_hcd_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">usb_hcd_poll_rh_status</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define vhci_hcd_suspend	NULL</span>
<span class="cp">#define vhci_hcd_resume		NULL</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">vhci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>	<span class="o">=</span> <span class="n">vhci_hcd_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>	<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">vhci_hcd_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">vhci_hcd_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>	<span class="o">=</span> <span class="n">vhci_hcd_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span>	<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">driver_name</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The VHCI &#39;device&#39; is &#39;virtual&#39;; not a real plug&amp;play hardware.</span>
<span class="cm"> * We need to add this virtual device as a platform device arbitrarily:</span>
<span class="cm"> *	1. platform_device_register()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">the_pdev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="n">the_pdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* should be the same name as driver_name */</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">driver_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* .driver = &amp;vhci_driver, */</span>
		<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">the_pdev_release</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">vhci_hcd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_driver_register</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_platform_device_register</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="n">DRIVER_DESC</span> <span class="s">&quot; v&quot;</span> <span class="n">USBIP_VERSION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">err_platform_device_register:</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci_driver</span><span class="p">);</span>
<span class="nl">err_driver_register:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">vhci_hcd_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_pdev</span><span class="p">);</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vhci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">vhci_hcd_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">vhci_hcd_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="n">DRIVER_AUTHOR</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">USBIP_VERSION</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
