<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › usbip › usbip_common.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>usbip_common.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2003-2008 Takahiro Hirofuchi</span>
<span class="cm"> *</span>
<span class="cm"> * This is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,</span>
<span class="cm"> * USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __USBIP_COMMON_H</span>
<span class="cp">#define __USBIP_COMMON_H</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/printk.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>

<span class="cp">#define USBIP_VERSION &quot;1.0.0&quot;</span>

<span class="cp">#undef pr_fmt</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define pr_fmt(fmt)     KBUILD_MODNAME &quot;: %s:%d: &quot; fmt, __func__, __LINE__</span>
<span class="cp">#else</span>
<span class="cp">#define pr_fmt(fmt)     KBUILD_MODNAME &quot;: &quot; fmt</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">usbip_debug_xmit</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">usbip_debug_sysfs</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">usbip_debug_urb</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">usbip_debug_eh</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>

	<span class="n">usbip_debug_stub_cmp</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
	<span class="n">usbip_debug_stub_dev</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
	<span class="n">usbip_debug_stub_rx</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
	<span class="n">usbip_debug_stub_tx</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>

	<span class="n">usbip_debug_vhci_rh</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
	<span class="n">usbip_debug_vhci_hc</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
	<span class="n">usbip_debug_vhci_rx</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
	<span class="n">usbip_debug_vhci_tx</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>
	<span class="n">usbip_debug_vhci_sysfs</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span>
<span class="p">};</span>

<span class="cp">#define usbip_dbg_flag_xmit	(usbip_debug_flag &amp; usbip_debug_xmit)</span>
<span class="cp">#define usbip_dbg_flag_vhci_rh	(usbip_debug_flag &amp; usbip_debug_vhci_rh)</span>
<span class="cp">#define usbip_dbg_flag_vhci_hc	(usbip_debug_flag &amp; usbip_debug_vhci_hc)</span>
<span class="cp">#define usbip_dbg_flag_vhci_rx	(usbip_debug_flag &amp; usbip_debug_vhci_rx)</span>
<span class="cp">#define usbip_dbg_flag_vhci_tx	(usbip_debug_flag &amp; usbip_debug_vhci_tx)</span>
<span class="cp">#define usbip_dbg_flag_stub_rx	(usbip_debug_flag &amp; usbip_debug_stub_rx)</span>
<span class="cp">#define usbip_dbg_flag_stub_tx	(usbip_debug_flag &amp; usbip_debug_stub_tx)</span>
<span class="cp">#define usbip_dbg_flag_vhci_sysfs  (usbip_debug_flag &amp; usbip_debug_vhci_sysfs)</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usbip_debug_flag</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_attr_usbip_debug</span><span class="p">;</span>

<span class="cp">#define usbip_dbg_with_flag(flag, fmt, args...)		\</span>
<span class="cp">	do {						\</span>
<span class="cp">		if (flag &amp; usbip_debug_flag)		\</span>
<span class="cp">			pr_debug(fmt, ##args);		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define usbip_dbg_sysfs(fmt, args...) \</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_sysfs, fmt , ##args)</span>
<span class="cp">#define usbip_dbg_xmit(fmt, args...) \</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_xmit, fmt , ##args)</span>
<span class="cp">#define usbip_dbg_urb(fmt, args...) \</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_urb, fmt , ##args)</span>
<span class="cp">#define usbip_dbg_eh(fmt, args...) \</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_eh, fmt , ##args)</span>

<span class="cp">#define usbip_dbg_vhci_rh(fmt, args...)	\</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_vhci_rh, fmt , ##args)</span>
<span class="cp">#define usbip_dbg_vhci_hc(fmt, args...)	\</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_vhci_hc, fmt , ##args)</span>
<span class="cp">#define usbip_dbg_vhci_rx(fmt, args...)	\</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_vhci_rx, fmt , ##args)</span>
<span class="cp">#define usbip_dbg_vhci_tx(fmt, args...)	\</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_vhci_tx, fmt , ##args)</span>
<span class="cp">#define usbip_dbg_vhci_sysfs(fmt, args...) \</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_vhci_sysfs, fmt , ##args)</span>

<span class="cp">#define usbip_dbg_stub_cmp(fmt, args...) \</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_stub_cmp, fmt , ##args)</span>
<span class="cp">#define usbip_dbg_stub_rx(fmt, args...) \</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_stub_rx, fmt , ##args)</span>
<span class="cp">#define usbip_dbg_stub_tx(fmt, args...) \</span>
<span class="cp">	usbip_dbg_with_flag(usbip_debug_stub_tx, fmt , ##args)</span>

<span class="cm">/*</span>
<span class="cm"> * USB/IP request headers</span>
<span class="cm"> *</span>
<span class="cm"> * Each request is transferred across the network to its counterpart, which</span>
<span class="cm"> * facilitates the normal USB communication. The values contained in the headers</span>
<span class="cm"> * are basically the same as in a URB. Currently, four request types are</span>
<span class="cm"> * defined:</span>
<span class="cm"> *</span>
<span class="cm"> *  - USBIP_CMD_SUBMIT: a USB request block, corresponds to usb_submit_urb()</span>
<span class="cm"> *    (client to server)</span>
<span class="cm"> *</span>
<span class="cm"> *  - USBIP_RET_SUBMIT: the result of USBIP_CMD_SUBMIT</span>
<span class="cm"> *    (server to client)</span>
<span class="cm"> *</span>
<span class="cm"> *  - USBIP_CMD_UNLINK: an unlink request of a pending USBIP_CMD_SUBMIT,</span>
<span class="cm"> *    corresponds to usb_unlink_urb()</span>
<span class="cm"> *    (client to server)</span>
<span class="cm"> *</span>
<span class="cm"> *  - USBIP_RET_UNLINK: the result of USBIP_CMD_UNLINK</span>
<span class="cm"> *    (server to client)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define USBIP_CMD_SUBMIT	0x0001</span>
<span class="cp">#define USBIP_CMD_UNLINK	0x0002</span>
<span class="cp">#define USBIP_RET_SUBMIT	0x0003</span>
<span class="cp">#define USBIP_RET_UNLINK	0x0004</span>

<span class="cp">#define USBIP_DIR_OUT	0x00</span>
<span class="cp">#define USBIP_DIR_IN	0x01</span>

<span class="cm">/**</span>
<span class="cm"> * struct usbip_header_basic - data pertinent to every request</span>
<span class="cm"> * @command: the usbip request type</span>
<span class="cm"> * @seqnum: sequential number that identifies requests; incremented per</span>
<span class="cm"> *	    connection</span>
<span class="cm"> * @devid: specifies a remote USB device uniquely instead of busnum and devnum;</span>
<span class="cm"> *	   in the stub driver, this value is ((busnum &lt;&lt; 16) | devnum)</span>
<span class="cm"> * @direction: direction of the transfer</span>
<span class="cm"> * @ep: endpoint number</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbip_header_basic</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">command</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">seqnum</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">devid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">direction</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ep</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct usbip_header_cmd_submit - USBIP_CMD_SUBMIT packet header</span>
<span class="cm"> * @transfer_flags: URB flags</span>
<span class="cm"> * @transfer_buffer_length: the data size for (in) or (out) transfer</span>
<span class="cm"> * @start_frame: initial frame for isochronous or interrupt transfers</span>
<span class="cm"> * @number_of_packets: number of isochronous packets</span>
<span class="cm"> * @interval: maximum time for the request on the server-side host controller</span>
<span class="cm"> * @setup: setup data for a control request</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbip_header_cmd_submit</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">transfer_flags</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">transfer_buffer_length</span><span class="p">;</span>

	<span class="cm">/* it is difficult for usbip to sync frames (reserved only?) */</span>
	<span class="n">__s32</span> <span class="n">start_frame</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">number_of_packets</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">interval</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">setup</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct usbip_header_ret_submit - USBIP_RET_SUBMIT packet header</span>
<span class="cm"> * @status: return status of a non-iso request</span>
<span class="cm"> * @actual_length: number of bytes transferred</span>
<span class="cm"> * @start_frame: initial frame for isochronous or interrupt transfers</span>
<span class="cm"> * @number_of_packets: number of isochronous packets</span>
<span class="cm"> * @error_count: number of errors for isochronous transfers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbip_header_ret_submit</span> <span class="p">{</span>
	<span class="n">__s32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">actual_length</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">start_frame</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">number_of_packets</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">error_count</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct usbip_header_cmd_unlink - USBIP_CMD_UNLINK packet header</span>
<span class="cm"> * @seqnum: the URB seqnum to unlink</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbip_header_cmd_unlink</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">seqnum</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct usbip_header_ret_unlink - USBIP_RET_UNLINK packet header</span>
<span class="cm"> * @status: return status of the request</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbip_header_ret_unlink</span> <span class="p">{</span>
	<span class="n">__s32</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct usbip_header - common header for all usbip packets</span>
<span class="cm"> * @base: the basic header</span>
<span class="cm"> * @u: packet type dependent header</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbip_header</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbip_header_basic</span> <span class="n">base</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usbip_header_cmd_submit</span>	<span class="n">cmd_submit</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usbip_header_ret_submit</span>	<span class="n">ret_submit</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usbip_header_cmd_unlink</span>	<span class="n">cmd_unlink</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usbip_header_ret_unlink</span>	<span class="n">ret_unlink</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the same as usb_iso_packet_descriptor but packed for pdu.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbip_iso_packet_descriptor</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>			<span class="cm">/* expected length */</span>
	<span class="n">__u32</span> <span class="n">actual_length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">usbip_side</span> <span class="p">{</span>
	<span class="n">USBIP_VHCI</span><span class="p">,</span>
	<span class="n">USBIP_STUB</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">usbip_status</span> <span class="p">{</span>
	<span class="cm">/* sdev is available. */</span>
	<span class="n">SDEV_ST_AVAILABLE</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="cm">/* sdev is now used. */</span>
	<span class="n">SDEV_ST_USED</span><span class="p">,</span>
	<span class="cm">/* sdev is unusable because of a fatal error. */</span>
	<span class="n">SDEV_ST_ERROR</span><span class="p">,</span>

	<span class="cm">/* vdev does not connect a remote device. */</span>
	<span class="n">VDEV_ST_NULL</span><span class="p">,</span>
	<span class="cm">/* vdev is used, but the USB address is not assigned yet */</span>
	<span class="n">VDEV_ST_NOTASSIGNED</span><span class="p">,</span>
	<span class="n">VDEV_ST_USED</span><span class="p">,</span>
	<span class="n">VDEV_ST_ERROR</span>
<span class="p">};</span>

<span class="cm">/* event handler */</span>
<span class="cp">#define USBIP_EH_SHUTDOWN	(1 &lt;&lt; 0)</span>
<span class="cp">#define USBIP_EH_BYE		(1 &lt;&lt; 1)</span>
<span class="cp">#define USBIP_EH_RESET		(1 &lt;&lt; 2)</span>
<span class="cp">#define USBIP_EH_UNUSABLE	(1 &lt;&lt; 3)</span>

<span class="cp">#define SDEV_EVENT_REMOVED   (USBIP_EH_SHUTDOWN | USBIP_EH_RESET | USBIP_EH_BYE)</span>
<span class="cp">#define	SDEV_EVENT_DOWN		(USBIP_EH_SHUTDOWN | USBIP_EH_RESET)</span>
<span class="cp">#define	SDEV_EVENT_ERROR_TCP	(USBIP_EH_SHUTDOWN | USBIP_EH_RESET)</span>
<span class="cp">#define	SDEV_EVENT_ERROR_SUBMIT	(USBIP_EH_SHUTDOWN | USBIP_EH_RESET)</span>
<span class="cp">#define	SDEV_EVENT_ERROR_MALLOC	(USBIP_EH_SHUTDOWN | USBIP_EH_UNUSABLE)</span>

<span class="cp">#define	VDEV_EVENT_REMOVED	(USBIP_EH_SHUTDOWN | USBIP_EH_BYE)</span>
<span class="cp">#define	VDEV_EVENT_DOWN		(USBIP_EH_SHUTDOWN | USBIP_EH_RESET)</span>
<span class="cp">#define	VDEV_EVENT_ERROR_TCP	(USBIP_EH_SHUTDOWN | USBIP_EH_RESET)</span>
<span class="cp">#define	VDEV_EVENT_ERROR_MALLOC	(USBIP_EH_SHUTDOWN | USBIP_EH_UNUSABLE)</span>

<span class="cm">/* a common structure for stub_device and vhci_device */</span>
<span class="k">struct</span> <span class="n">usbip_device</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">usbip_side</span> <span class="n">side</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">usbip_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* lock for status */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">tcp_socket</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tcp_rx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tcp_tx</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">eh_waitq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">eh_ops</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="p">);</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="p">);</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unusable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">eh_ops</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define kthread_get_run(threadfn, data, namefmt, ...)			   \</span>
<span class="cp">({									   \</span>
<span class="cp">	struct task_struct *__k						   \</span>
<span class="cp">		= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \</span>
<span class="cp">	if (!IS_ERR(__k)) {						   \</span>
<span class="cp">		get_task_struct(__k);					   \</span>
<span class="cp">		wake_up_process(__k);					   \</span>
<span class="cp">	}								   \</span>
<span class="cp">	__k;								   \</span>
<span class="cp">})</span>

<span class="cp">#define kthread_stop_put(k)		\</span>
<span class="cp">	do {				\</span>
<span class="cp">		kthread_stop(k);	\</span>
<span class="cp">		put_task_struct(k);	\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/* usbip_common.c */</span>
<span class="kt">void</span> <span class="n">usbip_dump_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">purb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbip_dump_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_header</span> <span class="o">*</span><span class="n">pdu</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">usbip_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sockfd_to_socket</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">usbip_pack_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_header</span> <span class="o">*</span><span class="n">pdu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">pack</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbip_header_correct_endian</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_header</span> <span class="o">*</span><span class="n">pdu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">send</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">usbip_alloc_iso_desc_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="o">*</span><span class="n">bufflen</span><span class="p">);</span>
<span class="cm">/* some members of urb must be substituted before. */</span>
<span class="kt">int</span> <span class="n">usbip_recv_iso</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbip_pad_iso</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbip_recv_xbuff</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>

<span class="cm">/* usbip_event.c */</span>
<span class="kt">int</span> <span class="n">usbip_start_eh</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbip_stop_eh</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usbip_event_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usbip_event_happened</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbip_device</span> <span class="o">*</span><span class="n">ud</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">interface_to_busnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">interface_to_devnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __USBIP_COMMON_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
