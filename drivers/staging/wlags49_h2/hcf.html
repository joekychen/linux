<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › wlags49_h2 › hcf.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hcf.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FILE   :  HCF.C</span>
<span class="cm"> *</span>
<span class="cm"> * DATE    : $Date: 2004/08/05 11:47:10 $   $Revision: 1.10 $</span>
<span class="cm"> * Original: 2004/06/02 10:22:22    Revision: 1.85      Tag: hcf7_t20040602_01</span>
<span class="cm"> * Original: 2004/04/15 09:24:41    Revision: 1.63      Tag: hcf7_t7_20040415_01</span>
<span class="cm"> * Original: 2004/04/13 14:22:44    Revision: 1.62      Tag: t7_20040413_01</span>
<span class="cm"> * Original: 2004/04/01 15:32:55    Revision: 1.59      Tag: t7_20040401_01</span>
<span class="cm"> * Original: 2004/03/10 15:39:27    Revision: 1.55      Tag: t20040310_01</span>
<span class="cm"> * Original: 2004/03/04 11:03:37    Revision: 1.53      Tag: t20040304_01</span>
<span class="cm"> * Original: 2004/03/02 14:51:21    Revision: 1.50      Tag: t20040302_03</span>
<span class="cm"> * Original: 2004/02/24 13:00:27    Revision: 1.43      Tag: t20040224_01</span>
<span class="cm"> * Original: 2004/02/19 10:57:25    Revision: 1.39      Tag: t20040219_01</span>
<span class="cm"> *</span>
<span class="cm"> * AUTHOR :  Nico Valster</span>
<span class="cm"> *</span>
<span class="cm"> * SPECIFICATION: ........</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION : HCF Routines for Hermes-II (callable via the Wireless Connection I/F or WCI)</span>
<span class="cm"> *               Local Support Routines for above procedures</span>
<span class="cm"> *</span>
<span class="cm"> *           Customizable via HCFCFG.H, which is included by HCF.H</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * SOFTWARE LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * This software is provided subject to the following terms and conditions,</span>
<span class="cm"> * which you should read carefully before using the software.  Using this</span>
<span class="cm"> * software indicates your acceptance of these terms and conditions.  If you do</span>
<span class="cm"> * not agree with these terms and conditions, do not use the software.</span>
<span class="cm"> *</span>
<span class="cm"> * COPYRIGHT © 1994 - 1995   by AT&amp;T.                All Rights Reserved</span>
<span class="cm"> * COPYRIGHT © 1996 - 2000 by Lucent Technologies.   All Rights Reserved</span>
<span class="cm"> * COPYRIGHT © 2001 - 2004   by Agere Systems Inc.   All Rights Reserved</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source or binary forms, with or without</span>
<span class="cm"> * modifications, are permitted provided that the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> * . Redistributions of source code must retain the above copyright notice, this</span>
<span class="cm"> *    list of conditions and the following Disclaimer as comments in the code as</span>
<span class="cm"> *    well as in the documentation and/or other materials provided with the</span>
<span class="cm"> *    distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * . Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="cm"> *    this list of conditions and the following Disclaimer in the documentation</span>
<span class="cm"> *    and/or other materials provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * . Neither the name of Agere Systems Inc. nor the names of the contributors</span>
<span class="cm"> *    may be used to endorse or promote products derived from this software</span>
<span class="cm"> *    without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Disclaimer</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,</span>
<span class="cm"> * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY</span>
<span class="cm"> * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN</span>
<span class="cm"> * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY</span>
<span class="cm"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="cm"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="cm"> * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT</span>
<span class="cm"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
<span class="cm"> * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
<span class="cm"> * DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> **</span>
<span class="cm"> ** Implementation Notes</span>
<span class="cm"> **</span>
<span class="cm"> * - a leading marker of //! is used. The purpose of such a sequence is to help to understand the flow</span>
<span class="cm"> *   An example is:  //!rc = HCF_SUCCESS;</span>
<span class="cm"> *   if this is superfluous because rc is already guaranteed to be 0 but it shows to the (maintenance)</span>
<span class="cm"> *   programmer it is an intentional omission at the place where someone could consider it most appropriate at</span>
<span class="cm"> *   first glance</span>
<span class="cm"> * - using near pointers in a model where ss!=ds is an invitation for disaster, so be aware of how you specify</span>
<span class="cm"> *   your model and how you define variables which are used at interrupt time</span>
<span class="cm"> * - remember that sign extension on 32 bit platforms may cause problems unless code is carefully constructed,</span>
<span class="cm"> *   e.g. use &quot;(hcf_16)~foo&quot; rather than &quot;~foo&quot;</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>

<span class="cp">#include &quot;hcf.h&quot;                </span><span class="c1">// HCF and MSF common include file</span>
<span class="cp">#include &quot;hcfdef.h&quot;             </span><span class="c1">// HCF specific include file</span>
<span class="cp">#include &quot;mmd.h&quot;                </span><span class="c1">// MoreModularDriver common include file</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>

<span class="cp">#if ! defined offsetof</span>
<span class="cp">#define offsetof(s,m)   ((unsigned int)&amp;(((s *)0)-&gt;m))</span>
<span class="cp">#endif </span><span class="c1">// offsetof</span>


<span class="cm">/***********************************************************************************************************/</span>
<span class="cm">/***************************************  PROTOTYPES  ******************************************************/</span>
<span class="cm">/***********************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>          <span class="n">cmd_exe</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">cmd_code</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">par_0</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>          <span class="n">init</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>          <span class="n">put_info</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">LTVP</span> <span class="n">ltvp</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>          <span class="n">put_info_mb</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">CFG_MB_INFO_STRCT</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">ltvp</span> <span class="p">);</span>
<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>         <span class="n">calc_mic</span><span class="p">(</span> <span class="n">hcf_32</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">hcf_32</span> <span class="n">M</span> <span class="p">);</span>
<span class="kt">void</span>                    <span class="n">calc_mic_rx_frag</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">wci_bufp</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span> <span class="p">);</span>
<span class="kt">void</span>                    <span class="n">calc_mic_tx_frag</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">wci_bufp</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>          <span class="n">check_mic</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>

<span class="n">HCF_STATIC</span> <span class="kt">void</span>         <span class="n">calibrate</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>          <span class="n">cmd_cmpl</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="n">hcf_16</span>       <span class="n">get_fid</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>         <span class="n">isr_info</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">);</span>
<span class="cp">#if HCF_DMA</span>
<span class="n">HCF_STATIC</span> <span class="n">DESC_STRCT</span><span class="o">*</span>  <span class="n">get_frame_lst</span><span class="p">(</span><span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_rx_flag</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_DMA</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>         <span class="n">get_frag</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">wci_bufp</span> <span class="n">bufp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span> <span class="n">BE_PAR</span><span class="p">(</span> <span class="kt">int</span> <span class="n">word_len</span> <span class="p">)</span> <span class="p">);</span>   <span class="c1">//char*, byte count (usually even)</span>
<span class="cp">#if HCF_DMA</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>         <span class="n">put_frame_lst</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">descp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_rx_flag</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_DMA</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>         <span class="n">put_frag</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">wci_bufp</span> <span class="n">bufp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span> <span class="n">BE_PAR</span><span class="p">(</span> <span class="kt">int</span> <span class="n">word_len</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>         <span class="n">put_frag_finalize</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>          <span class="n">setup_bap</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">fid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span> <span class="p">);</span>
<span class="cp">#if (HCF_ASSERT) &amp; HCF_ASSERT_PRINTF</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fw_printf</span><span class="p">(</span><span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">CFG_FW_PRINTF_STRCT</span> <span class="n">FAR</span> <span class="o">*</span><span class="n">ltvp</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_PRINTF</span>

<span class="n">HCF_STATIC</span> <span class="kt">int</span>          <span class="n">download</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">CFG_PROG_STRCT</span> <span class="n">FAR</span> <span class="o">*</span><span class="n">ltvp</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="n">hcf_8</span>        <span class="n">hcf_encap</span><span class="p">(</span> <span class="n">wci_bufp</span> <span class="n">type</span> <span class="p">);</span>
<span class="n">HCF_STATIC</span> <span class="n">hcf_8</span>        <span class="n">null_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
<span class="cp">#if ! defined IN_PORT_WORD          </span><span class="c1">//replace I/O Macros with logging facility</span>
<span class="k">extern</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">log_file</span><span class="p">;</span>

<span class="cp">#define IN_PORT_WORD(port)          in_port_word( (hcf_io)(port) )</span>

<span class="k">static</span> <span class="n">hcf_16</span> <span class="nf">in_port_word</span><span class="p">(</span> <span class="n">hcf_io</span> <span class="n">port</span> <span class="p">)</span> <span class="p">{</span>
	<span class="n">hcf_16</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">_inpw</span><span class="p">(</span> <span class="n">port</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">log_file</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">R %2.2x %4.4x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// in_port_word</span>

<span class="cp">#define OUT_PORT_WORD(port, value)  out_port_word( (hcf_io)(port), (hcf_16)(value) )</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">out_port_word</span><span class="p">(</span> <span class="n">hcf_io</span> <span class="n">port</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
	<span class="n">_outpw</span><span class="p">(</span> <span class="n">port</span><span class="p">,</span> <span class="n">value</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">log_file</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">W %2.02x %4.04x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">,</span> <span class="n">value</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">IN_PORT_STRING_32</span><span class="p">(</span> <span class="n">hcf_io</span> <span class="n">prt</span><span class="p">,</span> <span class="n">hcf_32</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>    <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hcf_16</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">log_file</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">read string_32 length %04x (%04d) at port %02.2x to addr %lp&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">prt</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span> <span class="n">n</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">_inpw</span><span class="p">(</span> <span class="n">prt</span> <span class="p">);</span>
		<span class="o">*</span><span class="n">p</span>   <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">_inpw</span><span class="p">(</span> <span class="n">prt</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">log_file</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;%s%08lx &quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span> <span class="o">%</span> <span class="mh">0x08</span> <span class="o">?</span> <span class="s">&quot; &quot;</span> <span class="o">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">dst</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dst</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="c1">// IN_PORT_STRING_32</span>

<span class="kt">void</span> <span class="nf">IN_PORT_STRING_8_16</span><span class="p">(</span> <span class="n">hcf_io</span> <span class="n">prt</span><span class="p">,</span> <span class="n">hcf_8</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//also handles byte alignment problems</span>
	<span class="n">hcf_16</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span><span class="p">;</span>                         <span class="c1">//this needs more elaborate code in non-x86 platforms</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">log_file</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">read string_16 length %04x (%04d) at port %02.2x to addr %lp&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">prt</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">,</span> <span class="n">dst</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span> <span class="n">n</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">_inpw</span><span class="p">(</span> <span class="n">prt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">log_file</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">i</span><span class="o">++</span> <span class="o">%</span> <span class="mh">0x10</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;%04x &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">%04x &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="c1">// IN_PORT_STRING_8_16</span>

<span class="kt">void</span> <span class="nf">OUT_PORT_STRING_32</span><span class="p">(</span> <span class="n">hcf_io</span> <span class="n">prt</span><span class="p">,</span> <span class="n">hcf_32</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>   <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hcf_16</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">log_file</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">write string_32 length %04x (%04d) at port %02.2x&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">prt</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span> <span class="n">n</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">;</span>
		<span class="n">_outpw</span><span class="p">(</span> <span class="n">prt</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="p">);</span>
		<span class="n">_outpw</span><span class="p">(</span> <span class="n">prt</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span>   <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">log_file</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;%s%08lx &quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span> <span class="o">%</span> <span class="mh">0x08</span> <span class="o">?</span> <span class="s">&quot; &quot;</span> <span class="o">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">src</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="c1">// OUT_PORT_STRING_32</span>

<span class="kt">void</span> <span class="nf">OUT_PORT_STRING_8_16</span><span class="p">(</span> <span class="n">hcf_io</span> <span class="n">prt</span><span class="p">,</span> <span class="n">hcf_8</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>  <span class="p">{</span>   <span class="c1">//also handles byte alignment problems</span>
	<span class="n">hcf_16</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">;</span>                             <span class="c1">//this needs more elaborate code in non-x86 platforms</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">log_file</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">write string_16 length %04x (%04d) at port %04x&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">prt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span> <span class="n">n</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">_outpw</span><span class="p">(</span> <span class="n">prt</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">log_file</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">i</span><span class="o">++</span> <span class="o">%</span> <span class="mh">0x10</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;%04x &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">fprintf</span><span class="p">(</span> <span class="n">log_file</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">%04x &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="c1">// OUT_PORT_STRING_8_16</span>

<span class="cp">#endif </span><span class="c1">// IN_PORT_WORD</span>

<span class="cm">/************************************************************************************************************</span>
<span class="cm"> ******************************* D A T A    D E F I N I T I O N S ********************************************</span>
<span class="cm"> ************************************************************************************************************/</span>

<span class="cp">#if HCF_ASSERT</span>
<span class="n">IFBP</span> <span class="n">BASED</span> <span class="n">assert_ifbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>          <span class="c1">//to make asserts easily work under MMD and DHF</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT</span>

<span class="cm">/* SNAP header to be inserted in Ethernet-II frames */</span>
<span class="n">HCF_STATIC</span>  <span class="n">hcf_8</span> <span class="n">BASED</span> <span class="n">snap_header</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="c1">//5 bytes signature +</span>
                                          <span class="mi">0</span> <span class="p">};</span>                          <span class="c1">//1 byte protocol identifier</span>

<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
<span class="n">HCF_STATIC</span> <span class="n">hcf_8</span> <span class="n">BASED</span> <span class="n">mic_pad</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x5A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>      <span class="c1">//MIC padding of message</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>

<span class="cp">#if defined MSF_COMPONENT_ID</span>
<span class="n">CFG_IDENTITY_STRCT</span> <span class="n">BASED</span> <span class="n">cfg_drv_identity</span> <span class="o">=</span> <span class="p">{</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="n">cfg_drv_identity</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>    <span class="c1">//length of RID</span>
	<span class="n">CFG_DRV_IDENTITY</span><span class="p">,</span>           <span class="c1">// (0x0826)</span>
	<span class="n">MSF_COMPONENT_ID</span><span class="p">,</span>
	<span class="n">MSF_COMPONENT_VAR</span><span class="p">,</span>
	<span class="n">MSF_COMPONENT_MAJOR_VER</span><span class="p">,</span>
	<span class="n">MSF_COMPONENT_MINOR_VER</span>
<span class="p">}</span> <span class="p">;</span>

<span class="n">CFG_RANGES_STRCT</span> <span class="n">BASED</span> <span class="n">cfg_drv_sup_range</span> <span class="o">=</span> <span class="p">{</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="n">cfg_drv_sup_range</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>   <span class="c1">//length of RID</span>
	<span class="n">CFG_DRV_SUP_RANGE</span><span class="p">,</span>          <span class="c1">// (0x0827)</span>

	<span class="n">COMP_ROLE_SUPL</span><span class="p">,</span>
	<span class="n">COMP_ID_DUI</span><span class="p">,</span>
	<span class="p">{{</span>  <span class="n">DUI_COMPAT_VAR</span><span class="p">,</span>
	    <span class="n">DUI_COMPAT_BOT</span><span class="p">,</span>
	    <span class="n">DUI_COMPAT_TOP</span>
	<span class="p">}}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">CFG_RANGE3_STRCT</span> <span class="n">BASED</span> <span class="n">cfg_drv_act_ranges_pri</span> <span class="o">=</span> <span class="p">{</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="n">cfg_drv_act_ranges_pri</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">//length of RID</span>
	<span class="n">CFG_DRV_ACT_RANGES_PRI</span><span class="p">,</span>     <span class="c1">// (0x0828)</span>

	<span class="n">COMP_ROLE_ACT</span><span class="p">,</span>
	<span class="n">COMP_ID_PRI</span><span class="p">,</span>
	<span class="p">{</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>                           <span class="c1">// HCF_PRI_VAR_1 not supported by HCF 7</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>                           <span class="c1">// HCF_PRI_VAR_2 not supported by HCF 7</span>
		<span class="p">{</span>  <span class="mi">3</span><span class="p">,</span>                                  <span class="c1">//var_rec[2] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_PRI_3_BOTTOM</span><span class="p">,</span>        <span class="c1">//       - Bottom Compatibility</span>
		   <span class="n">CFG_DRV_ACT_RANGES_PRI_3_TOP</span>            <span class="c1">//       - Top Compatibility</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>


<span class="k">struct</span> <span class="n">CFG_RANGE4_STRCT</span> <span class="n">BASED</span> <span class="n">cfg_drv_act_ranges_sta</span> <span class="o">=</span> <span class="p">{</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="n">cfg_drv_act_ranges_sta</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">//length of RID</span>
	<span class="n">CFG_DRV_ACT_RANGES_STA</span><span class="p">,</span>     <span class="c1">// (0x0829)</span>

	<span class="n">COMP_ROLE_ACT</span><span class="p">,</span>
	<span class="n">COMP_ID_STA</span><span class="p">,</span>
	<span class="p">{</span>
<span class="cp">#if defined HCF_STA_VAR_1</span>
		<span class="p">{</span>  <span class="mi">1</span><span class="p">,</span>                                  <span class="c1">//var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_STA_1_BOTTOM</span><span class="p">,</span>        <span class="c1">//       - Bottom Compatibility</span>
		   <span class="n">CFG_DRV_ACT_RANGES_STA_1_TOP</span>            <span class="c1">//       - Top Compatibility</span>
		<span class="p">},</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cp">#endif </span><span class="c1">// HCF_STA_VAR_1</span>
<span class="cp">#if defined HCF_STA_VAR_2</span>
		<span class="p">{</span>  <span class="mi">2</span><span class="p">,</span>                                  <span class="c1">//var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_STA_2_BOTTOM</span><span class="p">,</span>        <span class="c1">//       - Bottom Compatibility</span>
		   <span class="n">CFG_DRV_ACT_RANGES_STA_2_TOP</span>            <span class="c1">//       - Top Compatibility</span>
		<span class="p">},</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cp">#endif </span><span class="c1">// HCF_STA_VAR_2</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>For Native_USB (Not used!)</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if defined HCF_STA_VAR_3</span>
		<span class="p">{</span>  <span class="mi">3</span><span class="p">,</span>                                  <span class="c1">//var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_STA_3_BOTTOM</span><span class="p">,</span>        <span class="c1">//       - Bottom Compatibility</span>
		   <span class="n">CFG_DRV_ACT_RANGES_STA_3_TOP</span>            <span class="c1">//       - Top Compatibility</span>
		<span class="p">},</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cp">#endif </span><span class="c1">// HCF_STA_VAR_3</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Warp</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if defined HCF_STA_VAR_4</span>
		<span class="p">{</span>  <span class="mi">4</span><span class="p">,</span>                                  <span class="c1">//var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_STA_4_BOTTOM</span><span class="p">,</span>        <span class="c1">//           - Bottom Compatibility</span>
		   <span class="n">CFG_DRV_ACT_RANGES_STA_4_TOP</span>            <span class="c1">//           - Top Compatibility</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_STA_VAR_4</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>


<span class="k">struct</span> <span class="n">CFG_RANGE6_STRCT</span> <span class="n">BASED</span> <span class="n">cfg_drv_act_ranges_hsi</span> <span class="o">=</span> <span class="p">{</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="n">cfg_drv_act_ranges_hsi</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">//length of RID</span>
	<span class="n">CFG_DRV_ACT_RANGES_HSI</span><span class="p">,</span>     <span class="c1">// (0x082A)</span>
	<span class="n">COMP_ROLE_ACT</span><span class="p">,</span>
	<span class="n">COMP_ID_HSI</span><span class="p">,</span>
	<span class="p">{</span>
<span class="cp">#if defined HCF_HSI_VAR_0                   </span><span class="c1">// Controlled deployment</span>
		<span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>                                  <span class="c1">// var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_HSI_0_BOTTOM</span><span class="p">,</span>        <span class="c1">//           - Bottom Compatibility</span>
		   <span class="n">CFG_DRV_ACT_RANGES_HSI_0_TOP</span>            <span class="c1">//           - Top Compatibility</span>
		<span class="p">},</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cp">#endif </span><span class="c1">// HCF_HSI_VAR_0</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>                           <span class="c1">// HCF_HSI_VAR_1 not supported by HCF 7</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>                           <span class="c1">// HCF_HSI_VAR_2 not supported by HCF 7</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>                           <span class="c1">// HCF_HSI_VAR_3 not supported by HCF 7</span>
<span class="cp">#if defined HCF_HSI_VAR_4                   </span><span class="c1">// Hermes-II all types</span>
		<span class="p">{</span>  <span class="mi">4</span><span class="p">,</span>                                  <span class="c1">// var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_HSI_4_BOTTOM</span><span class="p">,</span>        <span class="c1">//           - Bottom Compatibility</span>
		   <span class="n">CFG_DRV_ACT_RANGES_HSI_4_TOP</span>            <span class="c1">//           - Top Compatibility</span>
		<span class="p">},</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cp">#endif </span><span class="c1">// HCF_HSI_VAR_4</span>
<span class="cp">#if defined HCF_HSI_VAR_5                   </span><span class="c1">// WARP Hermes-2.5</span>
		<span class="p">{</span>  <span class="mi">5</span><span class="p">,</span>                                  <span class="c1">// var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_HSI_5_BOTTOM</span><span class="p">,</span>        <span class="c1">//           - Bottom Compatibility</span>
		   <span class="n">CFG_DRV_ACT_RANGES_HSI_5_TOP</span>            <span class="c1">//           - Top Compatibility</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_HSI_VAR_5</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>


<span class="n">CFG_RANGE4_STRCT</span> <span class="n">BASED</span> <span class="n">cfg_drv_act_ranges_apf</span> <span class="o">=</span> <span class="p">{</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="n">cfg_drv_act_ranges_apf</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">//length of RID</span>
	<span class="n">CFG_DRV_ACT_RANGES_APF</span><span class="p">,</span>     <span class="c1">// (0x082B)</span>

	<span class="n">COMP_ROLE_ACT</span><span class="p">,</span>
	<span class="n">COMP_ID_APF</span><span class="p">,</span>
	<span class="p">{</span>
<span class="cp">#if defined HCF_APF_VAR_1               </span><span class="c1">//(Fake) Hermes-I</span>
		<span class="p">{</span>  <span class="mi">1</span><span class="p">,</span>                                  <span class="c1">//var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_APF_1_BOTTOM</span><span class="p">,</span>        <span class="c1">//           - Bottom Compatibility</span>
		   <span class="n">CFG_DRV_ACT_RANGES_APF_1_TOP</span>            <span class="c1">//           - Top Compatibility</span>
		<span class="p">},</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cp">#endif </span><span class="c1">// HCF_APF_VAR_1</span>
<span class="cp">#if defined HCF_APF_VAR_2               </span><span class="c1">//Hermes-II</span>
		<span class="p">{</span>  <span class="mi">2</span><span class="p">,</span>                                  <span class="c1">// var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_APF_2_BOTTOM</span><span class="p">,</span>        <span class="c1">//           - Bottom Compatibility</span>
		   <span class="n">CFG_DRV_ACT_RANGES_APF_2_TOP</span>            <span class="c1">//           - Top Compatibility</span>
		<span class="p">},</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cp">#endif </span><span class="c1">// HCF_APF_VAR_2</span>
<span class="cp">#if defined HCF_APF_VAR_3                       </span><span class="c1">// Native_USB</span>
		<span class="p">{</span>  <span class="mi">3</span><span class="p">,</span>                                      <span class="c1">// var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_APF_3_BOTTOM</span><span class="p">,</span>        <span class="c1">//           - Bottom Compatibility !!!!!see note below!!!!!!!</span>
		   <span class="n">CFG_DRV_ACT_RANGES_APF_3_TOP</span>            <span class="c1">//           - Top Compatibility</span>
		<span class="p">},</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cp">#endif </span><span class="c1">// HCF_APF_VAR_3</span>
<span class="cp">#if defined HCF_APF_VAR_4                       </span><span class="c1">// WARP Hermes 2.5</span>
		<span class="p">{</span>  <span class="mi">4</span><span class="p">,</span>                                      <span class="c1">// var_rec[1] - Variant number</span>
		   <span class="n">CFG_DRV_ACT_RANGES_APF_4_BOTTOM</span><span class="p">,</span>        <span class="c1">//           - Bottom Compatibility !!!!!see note below!!!!!!!</span>
		   <span class="n">CFG_DRV_ACT_RANGES_APF_4_TOP</span>            <span class="c1">//           - Top Compatibility</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_APF_VAR_4</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
<span class="cp">#define HCF_VERSION  TEXT( &quot;HCF$Revision: 1.10 $&quot; )</span>

<span class="k">static</span> <span class="k">struct</span> <span class="cm">/*CFG_HCF_OPT_STRCT*/</span> <span class="p">{</span>
	<span class="n">hcf_16</span>  <span class="n">len</span><span class="p">;</span>                    <span class="c1">//length of cfg_hcf_opt struct</span>
	<span class="n">hcf_16</span>  <span class="n">typ</span><span class="p">;</span>                    <span class="c1">//type 0x082C</span>
	<span class="n">hcf_16</span>   <span class="n">v0</span><span class="p">;</span>                        <span class="c1">//offset HCF_VERSION</span>
	<span class="n">hcf_16</span>   <span class="n">v1</span><span class="p">;</span>                        <span class="c1">// MSF_COMPONENT_ID</span>
	<span class="n">hcf_16</span>   <span class="n">v2</span><span class="p">;</span>                        <span class="c1">// HCF_ALIGN</span>
	<span class="n">hcf_16</span>   <span class="n">v3</span><span class="p">;</span>                        <span class="c1">// HCF_ASSERT</span>
	<span class="n">hcf_16</span>   <span class="n">v4</span><span class="p">;</span>                        <span class="c1">// HCF_BIG_ENDIAN</span>
	<span class="n">hcf_16</span>   <span class="n">v5</span><span class="p">;</span>                        <span class="c1">// /* HCF_DLV | HCF_DLNV */</span>
	<span class="n">hcf_16</span>   <span class="n">v6</span><span class="p">;</span>                        <span class="c1">// HCF_DMA</span>
	<span class="n">hcf_16</span>   <span class="n">v7</span><span class="p">;</span>                        <span class="c1">// HCF_ENCAP</span>
	<span class="n">hcf_16</span>   <span class="n">v8</span><span class="p">;</span>                        <span class="c1">// HCF_EXT</span>
	<span class="n">hcf_16</span>   <span class="n">v9</span><span class="p">;</span>                        <span class="c1">// HCF_INT_ON</span>
	<span class="n">hcf_16</span>  <span class="n">v10</span><span class="p">;</span>                        <span class="c1">// HCF_IO</span>
	<span class="n">hcf_16</span>  <span class="n">v11</span><span class="p">;</span>                        <span class="c1">// HCF_LEGACY</span>
	<span class="n">hcf_16</span>  <span class="n">v12</span><span class="p">;</span>                        <span class="c1">// HCF_MAX_LTV</span>
	<span class="n">hcf_16</span>  <span class="n">v13</span><span class="p">;</span>                        <span class="c1">// HCF_PROT_TIME</span>
	<span class="n">hcf_16</span>  <span class="n">v14</span><span class="p">;</span>                        <span class="c1">// HCF_SLEEP</span>
	<span class="n">hcf_16</span>  <span class="n">v15</span><span class="p">;</span>                        <span class="c1">// HCF_TALLIES</span>
	<span class="n">hcf_16</span>  <span class="n">v16</span><span class="p">;</span>                        <span class="c1">// HCF_TYPE</span>
	<span class="n">hcf_16</span>  <span class="n">v17</span><span class="p">;</span>                        <span class="c1">// HCF_NIC_TAL_CNT</span>
	<span class="n">hcf_16</span>  <span class="n">v18</span><span class="p">;</span>                        <span class="c1">// HCF_HCF_TAL_CNT</span>
	<span class="n">hcf_16</span>  <span class="n">v19</span><span class="p">;</span>                        <span class="c1">// offset tallies</span>
	<span class="kt">char</span>    <span class="n">val</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HCF_VERSION</span><span class="p">)];</span>
<span class="p">}</span> <span class="n">BASED</span> <span class="n">cfg_hcf_opt</span> <span class="o">=</span> <span class="p">{</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="n">cfg_hcf_opt</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">CFG_HCF_OPT</span><span class="p">,</span>                <span class="c1">// (0x082C)</span>
	<span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cfg_hcf_opt</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HCF_VERSION</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span> <span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">),</span>
<span class="cp">#if defined MSF_COMPONENT_ID</span>
	<span class="n">MSF_COMPONENT_ID</span><span class="p">,</span>
<span class="cp">#else</span>
	<span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif </span><span class="c1">// MSF_COMPONENT_ID</span>
	<span class="n">HCF_ALIGN</span><span class="p">,</span>
	<span class="n">HCF_ASSERT</span><span class="p">,</span>
	<span class="n">HCF_BIG_ENDIAN</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>                                  <span class="c1">// /* HCF_DLV | HCF_DLNV*/,</span>
	<span class="n">HCF_DMA</span><span class="p">,</span>
	<span class="n">HCF_ENCAP</span><span class="p">,</span>
	<span class="n">HCF_EXT</span><span class="p">,</span>
	<span class="n">HCF_INT_ON</span><span class="p">,</span>
	<span class="n">HCF_IO</span><span class="p">,</span>
	<span class="n">HCF_LEGACY</span><span class="p">,</span>
	<span class="n">HCF_MAX_LTV</span><span class="p">,</span>
	<span class="n">HCF_PROT_TIME</span><span class="p">,</span>
	<span class="n">HCF_SLEEP</span><span class="p">,</span>
	<span class="n">HCF_TALLIES</span><span class="p">,</span>
	<span class="n">HCF_TYPE</span><span class="p">,</span>
<span class="cp">#if (HCF_TALLIES) &amp; ( HCF_TALLIES_NIC | HCF_TALLIES_HCF )</span>
	<span class="n">HCF_NIC_TAL_CNT</span><span class="p">,</span>
	<span class="n">HCF_HCF_TAL_CNT</span><span class="p">,</span>
	<span class="n">offsetof</span><span class="p">(</span><span class="n">IFB_STRCT</span><span class="p">,</span> <span class="n">IFB_TallyLen</span> <span class="p">),</span>
<span class="cp">#else</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif </span><span class="c1">// HCF_TALLIES_NIC / HCF_TALLIES_HCF</span>
	<span class="n">HCF_VERSION</span>
<span class="p">};</span> <span class="c1">// cfg_hcf_opt</span>
<span class="cp">#endif </span><span class="c1">// MSF_COMPONENT_ID</span>

<span class="n">HCF_STATIC</span> <span class="n">LTV_STRCT</span> <span class="n">BASED</span> <span class="n">cfg_null</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CFG_NULL</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span> <span class="p">};</span>

<span class="n">HCF_STATIC</span> <span class="n">hcf_16</span><span class="o">*</span> <span class="n">BASED</span> <span class="n">xxxx</span><span class="p">[</span> <span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">cfg_null</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>                          <span class="c1">//CFG_NULL                      0x0820</span>
<span class="cp">#if defined MSF_COMPONENT_ID</span>
	<span class="o">&amp;</span><span class="n">cfg_drv_identity</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>                  <span class="c1">//CFG_DRV_IDENTITY              0x0826</span>
	<span class="o">&amp;</span><span class="n">cfg_drv_sup_range</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>                 <span class="c1">//CFG_DRV_SUP_RANGE             0x0827</span>
	<span class="o">&amp;</span><span class="n">cfg_drv_act_ranges_pri</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>            <span class="c1">//CFG_DRV_ACT_RANGES_PRI        0x0828</span>
	<span class="o">&amp;</span><span class="n">cfg_drv_act_ranges_sta</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>            <span class="c1">//CFG_DRV_ACT_RANGES_STA        0x0829</span>
	<span class="o">&amp;</span><span class="n">cfg_drv_act_ranges_hsi</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>            <span class="c1">//CFG_DRV_ACT_RANGES_HSI        0x082A</span>
	<span class="o">&amp;</span><span class="n">cfg_drv_act_ranges_apf</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>            <span class="c1">//CFG_DRV_ACT_RANGES_APF        0x082B</span>
	<span class="o">&amp;</span><span class="n">cfg_hcf_opt</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>                       <span class="c1">//CFG_HCF_OPT                   0x082C</span>
	<span class="nb">NULL</span><span class="p">,</span>                                   <span class="c1">//IFB_PRIIdentity placeholder   0xFD02</span>
	<span class="nb">NULL</span><span class="p">,</span>                                   <span class="c1">//IFB_PRISup placeholder        0xFD03</span>
<span class="cp">#endif </span><span class="c1">// MSF_COMPONENT_ID</span>
	<span class="nb">NULL</span>                                    <span class="c1">//endsentinel</span>
<span class="p">};</span>
<span class="cp">#define xxxx_PRI_IDENTITY_OFFSET    (ARRAY_SIZE(xxxx) - 3)</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> ************************** T O P   L E V E L   H C F   R O U T I N E S **************************************</span>
<span class="cm"> ************************************************************************************************************/</span>

<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        int hcf_action( IFBP ifbp, hcf_16 action )</span>
<span class="cm"> *.PURPOSE       Changes the run-time Card behavior.</span>
<span class="cm"> *               Performs Miscellanuous actions.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp                    address of the Interface Block</span>
<span class="cm"> *   action                  number identifying the type of change</span>
<span class="cm"> *    - HCF_ACT_INT_FORCE_ON enable interrupt generation by WaveLAN NIC</span>
<span class="cm"> *    - HCF_ACT_INT_OFF      disable interrupt generation by WaveLAN NIC</span>
<span class="cm"> *    - HCF_ACT_INT_ON       compensate 1 HCF_ACT_INT_OFF, enable interrupt generation if balance reached</span>
<span class="cm"> *    - HCF_ACT_PRS_SCAN     Hermes Probe Respons Scan (F102) command</span>
<span class="cm"> *    - HCF_ACT_RX_ACK       acknowledge non-DMA receiver to Hermes</span>
<span class="cm"> *    - HCF_ACT_SCAN         Hermes Inquire Scan (F101) command (non-WARP only)</span>
<span class="cm"> *    - HCF_ACT_SLEEP        DDS Sleep request</span>
<span class="cm"> *    - HCF_ACT_TALLIES      Hermes Inquire Tallies (F100) command</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_SUCCESS             all (including invalid)</span>
<span class="cm"> *   HCF_INT_PENDING         HCF_ACT_INT_OFF, interrupt pending</span>
<span class="cm"> *   HCF_ERR_NO_NIC          HCF_ACT_INT_OFF, NIC presence check fails</span>
<span class="cm"> *</span>
<span class="cm"> *.CONDITIONS</span>
<span class="cm"> * Except for hcf_action with HCF_ACT_INT_FORCE_ON or HCF_ACT_INT_OFF as parameter or hcf_connect with an I/O</span>
<span class="cm"> * address (i.e. not HCF_DISCONNECT), all hcf-function calls MUST be preceded by a call of hcf_action with</span>
<span class="cm"> * HCF_ACT_INT_OFF as parameter.</span>
<span class="cm"> * Note that hcf_connect defaults to NIC interrupt disabled mode, i.e. as if hcf_action( HCF_ACT_INT_OFF )</span>
<span class="cm"> * was called.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * hcf_action supports the following mode changing action-code pairs that are antonyms</span>
<span class="cm"> *    - HCF_ACT_INT_[FORCE_]ON / HCF_ACT_INT_OFF</span>
<span class="cm"> *</span>
<span class="cm"> * Additionally hcf_action can start the following actions in the NIC:</span>
<span class="cm"> *    - HCF_ACT_PRS_SCAN</span>
<span class="cm"> *    - HCF_ACT_RX_ACK</span>
<span class="cm"> *    - HCF_ACT_SCAN</span>
<span class="cm"> *    - HCF_ACT_SLEEP</span>
<span class="cm"> *    - HCF_ACT_TALLIES</span>
<span class="cm"> *</span>
<span class="cm"> * o HCF_ACT_INT_OFF: Sets NIC Interrupts mode Disabled.</span>
<span class="cm"> * This command, and the associated [Force] Enable NIC interrupts command, are only available if the HCF_INT_ON</span>
<span class="cm"> * compile time option is not set at 0x0000.</span>
<span class="cm"> *</span>
<span class="cm"> * o HCF_ACT_INT_ON: Sets NIC Interrupts mode Enabled.</span>
<span class="cm"> * Enable NIC Interrupts, depending on the number of preceding Disable NIC Interrupt calls.</span>
<span class="cm"> *</span>
<span class="cm"> * o HCF_ACT_INT_FORCE_ON: Force NIC Interrupts mode Enabled.</span>
<span class="cm"> * Sets NIC Interrupts mode Enabled, regardless off the number of preceding Disable NIC Interrupt calls.</span>
<span class="cm"> *</span>
<span class="cm"> * The disabling and enabling of interrupts are antonyms.</span>
<span class="cm"> * These actions must be balanced.</span>
<span class="cm"> * For each &quot;disable interrupts&quot; there must be a matching &quot;enable interrupts&quot;.</span>
<span class="cm"> * The disable interrupts may be executed multiple times in a row without intervening enable interrupts, in</span>
<span class="cm"> * other words, the disable interrupts may be nested.</span>
<span class="cm"> * The interrupt generation mechanism is disabled at the first call with HCF_ACT_INT_OFF.</span>
<span class="cm"> * The interrupt generation mechanism is re-enabled when the number of calls with HCF_ACT_INT_ON matches the</span>
<span class="cm"> * number of calls with INT_OFF.</span>
<span class="cm"> *</span>
<span class="cm"> * It is not allowed to have more Enable NIC Interrupts calls than Disable NIC Interrupts calls.</span>
<span class="cm"> * The interrupt generation mechanism is initially (i.e. after hcf_connect) disabled.</span>
<span class="cm"> * An MSF based on a interrupt strategy must call hcf_action with INT_ON in its initialization logic.</span>
<span class="cm"> *</span>
<span class="cm"> *!  The INT_OFF/INT_ON housekeeping is initialized at 0x0000 by hcf_connect, causing the interrupt generation</span>
<span class="cm"> *   mechanism to be disabled at first. This suits MSF implementation based on a polling strategy.</span>
<span class="cm"> *</span>
<span class="cm"> * o HCF_ACT_SLEEP: Initiates the Disconnected DeepSleep process</span>
<span class="cm"> * This command is only available if the HCF_DDS compile time option is set. It triggers the F/W to start the</span>
<span class="cm"> * sleep handshaking. Regardless whether the Host initiates a Disconnected DeepSleep (DDS) or the F/W initiates</span>
<span class="cm"> * a Connected DeepSleep (CDS), the Host-F/W sleep handshaking is completed when the NIC Interrupts mode is</span>
<span class="cm"> * enabled (by means of the balancing HCF_ACT_INT_ON), i.e. at that moment the F/W really goes into sleep mode.</span>
<span class="cm"> * The F/W is wokenup by the HCF when the NIC Interrupts mode are disabled, i.e. at the first HCF_ACT_INT_OFF</span>
<span class="cm"> * after going into sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * The following Miscellanuous actions are defined:</span>
<span class="cm"> *</span>
<span class="cm"> * o HCF_ACT_RX_ACK: Receiver Acknowledgement (non-DMA, non-USB mode only)</span>
<span class="cm"> * Acking the receiver, frees the NIC memory used to hold the Rx frame and allows the F/W to</span>
<span class="cm"> * report the existence of the next Rx frame.</span>
<span class="cm"> * If the MSF does not need access (any longer) to the current frame, e.g. because it is rejected based on the</span>
<span class="cm"> * look ahead or copied to another buffer, the receiver may be acked. Acking earlier is assumed to have the</span>
<span class="cm"> * potential of improving the performance.</span>
<span class="cm"> * If the MSF does not explitly ack te receiver, the acking is done implicitly if:</span>
<span class="cm"> * - the received frame fits in the look ahead buffer, by the hcf_service_nic call that reported the Rx frame</span>
<span class="cm"> * - if not in the above step, by hcf_rcv_msg (assuming hcf_rcv_msg is called)</span>
<span class="cm"> * - if neither of the above implicit acks nor an explicit ack by the MSF, by the first hcf_service_nic after</span>
<span class="cm"> *   the hcf_service_nic that reported the Rx frame.</span>
<span class="cm"> * Note: If an Rx frame is already acked, an explicit ACK by the MSF acts as a NoOperation.</span>
<span class="cm"> *</span>
<span class="cm"> * o HCF_ACT_TALLIES: Inquire Tallies command</span>
<span class="cm"> * This command is only operational if the F/W is enabled.</span>
<span class="cm"> * The Inquire Tallies command requests the F/W to provide its current set of tallies.</span>
<span class="cm"> * See also hcf_get_info with CFG_TALLIES as parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * o HCF_ACT_PRS_SCAN: Inquire Probe Respons Scan command</span>
<span class="cm"> * This command is only operational if the F/W is enabled.</span>
<span class="cm"> * The Probe Respons Scan command starts a scan sequence.</span>
<span class="cm"> * The HCF puts the result of this action in an MSF defined buffer (see CFG_RID_LOG_STRCT).</span>
<span class="cm"> *</span>
<span class="cm"> * o HCF_ACT_SCAN: Inquire Scan command</span>
<span class="cm"> * This command is only supported for HII F/W (i.e. pre-WARP) and it is operational if the F/W is enabled.</span>
<span class="cm"> * The Inquire Scan command starts a scan sequence.</span>
<span class="cm"> * The HCF puts the result of this action in an MSF defined buffer (see CFG_RID_LOG_STRCT).</span>
<span class="cm"> *</span>
<span class="cm"> * Assert fails if</span>
<span class="cm"> * - ifbp has a recognizable out-of-range value.</span>
<span class="cm"> * - NIC interrupts are not disabled while required by parameter action.</span>
<span class="cm"> * - an invalid code is specified in parameter action.</span>
<span class="cm"> * - HCF_ACT_INT_ON commands outnumber the HCF_ACT_INT_OFF commands.</span>
<span class="cm"> * - reentrancy, may be  caused by calling hcf_functions without adequate protection against NIC interrupts or</span>
<span class="cm"> *   multi-threading</span>
<span class="cm"> *</span>
<span class="cm"> * - Since the HCF does not maintain status information relative to the F/W enabled state, it is not asserted</span>
<span class="cm"> *   whether HCF_ACT_SCAN, HCF_ACT_PRS_SCAN or HCF_ACT_TALLIES are only used while F/W is enabled.</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> * 0: The assert embedded in HCFLOGENTRY checks against re-entrancy. Re-entrancy could be caused by a MSF logic</span>
<span class="cm"> *   at task-level calling hcf_functions without shielding with HCF_ACT_ON/_OFF. However the HCF_ACT_INT_OFF</span>
<span class="cm"> *   action itself can per definition not be protected this way. Based on code inspection, it can be concluded,</span>
<span class="cm"> *   that there is no re-entrancy PROBLEM in this particular flow. It does not seem worth the trouble to</span>
<span class="cm"> *   explicitly check for this condition (although there was a report of an MSF which ran into this assert.</span>
<span class="cm"> * 2:IFB_IntOffCnt is used to balance the INT_OFF and INT_ON calls.  Disabling of the interrupts is achieved by</span>
<span class="cm"> *   writing a zero to the Hermes IntEn register.  In a shared interrupt environment (e.g. the mini-PCI NDIS</span>
<span class="cm"> *   driver) it is considered more correct to return the status HCF_INT_PENDING if and only if, the current</span>
<span class="cm"> *   invocation of hcf_service_nic is (apparently) called in the ISR when the ISR was activated as result of a</span>
<span class="cm"> *   change in HREG_EV_STAT matching a bit in HREG_INT_EN, i.e. not if invoked as result of another device</span>
<span class="cm"> *   generating an interrupt on the shared interrupt line.</span>
<span class="cm"> *   Note 1: it has been observed that under certain adverse conditions on certain platforms the writing of</span>
<span class="cm"> *   HREG_INT_EN can apparently fail, therefor it is paramount that HREG_INT_EN is written again with 0 for</span>
<span class="cm"> *   each and every call to HCF_ACT_INT_OFF.</span>
<span class="cm"> *   Note 2: it has been observed that under certain H/W &amp; S/W architectures this logic is called when there is</span>
<span class="cm"> *   no NIC at all. To cater for this, the value of HREG_INT_EN is validated. If the unused bit 0x0100 is set,</span>
<span class="cm"> *   it is assumed there is no NIC.</span>
<span class="cm"> *   Note 3: During the download process, some versions of the F/W reset HREG_SW_0, hence checking this</span>
<span class="cm"> *   register for HCF_MAGIC (the classical NIC presence test) when HCF_ACT_INT_OFF is called due to another</span>
<span class="cm"> *   card interrupting via a shared IRQ during a download, fails.</span>
<span class="cm"> *4: The construction &quot;if ( ifbp-&gt;IFB_IntOffCnt-- == 0 )&quot; is optimal (in the sense of shortest/quickest</span>
<span class="cm"> *   path in error free flows) but NOT fail safe in case of too many INT_ON invocations compared to INT_OFF).</span>
<span class="cm"> *   Enabling of the interrupts is achieved by writing the Hermes IntEn register.</span>
<span class="cm"> *    - If the HCF is in Defunct mode, the interrupts stay disabled.</span>
<span class="cm"> *    - Under &quot;normal&quot; conditions, the HCF is only interested in Info Events, Rx Events and Notify Events.</span>
<span class="cm"> *    - When the HCF is out of Tx/Notify resources, the HCF is also interested in Alloc Events.</span>
<span class="cm"> *    - via HCF_EXT, the MSF programmer can also request HREG_EV_TICK and/or HREG_EV_TX_EXC interrupts.</span>
<span class="cm"> *   For DMA operation, the DMA hardware handles the alloc events. The DMA engine will generate a &#39;TxDmaDone&#39;</span>
<span class="cm"> *   event as soon as it has pumped a frame from host ram into NIC-RAM (note that the frame does not have to be</span>
<span class="cm"> *   transmitted then), and a &#39;RxDmaDone&#39; event as soon as a received frame has been pumped from NIC-RAM into</span>
<span class="cm"> *   host ram.  Note that the &#39;alloc&#39; event has been removed from the event-mask, because the DMA engine will</span>
<span class="cm"> *   react to and acknowledge this event.</span>
<span class="cm"> *6: ack the &quot;old&quot; Rx-event. See &quot;Rx Buffer free strategy&quot; in hcf_service_nic above for more explanation.</span>
<span class="cm"> *   IFB_RxFID and IFB_RxLen must be cleared to bring both the internal HCF house keeping and the information</span>
<span class="cm"> *   supplied to the MSF in the state &quot;no frame received&quot;.</span>
<span class="cm"> *8: The HCF_ACT_SCAN, HCF_ACT_PRS_SCAN and HCF_ACT_TALLIES activity are merged by &quot;clever&quot; algebraic</span>
<span class="cm"> *   manipulations of the RID-values and action codes, so foregoing robustness against migration problems for</span>
<span class="cm"> *   ease of implementation. The assumptions about numerical relationships between CFG_TALLIES etc and</span>
<span class="cm"> *   HCF_ACT_TALLIES etc are checked by the &quot;#if&quot; statements just prior to the body of this routine, resulting</span>
<span class="cm"> *   in: err &quot;maintenance&quot; during compilation if the assumptions are no longer met. The writing of HREG_PARAM_1</span>
<span class="cm"> *   with 0x3FFF in case of an PRS scan, is a kludge to get around lack of specification, hence different</span>
<span class="cm"> *   implementation in F/W and Host.</span>
<span class="cm"> *   When there is no NIC RAM available, some versions of the Hermes F/W do report 0x7F00 as error in the</span>
<span class="cm"> *   Result field of the Status register and some F/W versions don&#39;t. To mask this difference to the MSF all</span>
<span class="cm"> *   return codes of the Hermes are ignored (&quot;best&quot; and &quot;most simple&quot; solution to these types of analomies with</span>
<span class="cm"> *   an acceptable loss due to ignoring all error situations as well).</span>
<span class="cm"> *   The &quot;No inquire space&quot; is reported via the Hermes tallies.</span>
<span class="cm"> *30: do not HCFASSERT( rc, rc ) since rc == HCF_INT_PENDING is no error</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="cp">#if ( (HCF_TYPE) &amp; HCF_TYPE_HII5 ) == 0</span>
<span class="cp">#if CFG_SCAN != CFG_TALLIES - HCF_ACT_TALLIES + HCF_ACT_SCAN</span>
<span class="nl">err:</span> <span class="s">&quot;maintenance&quot;</span> <span class="n">apparently</span> <span class="n">inviolated</span> <span class="n">the</span> <span class="n">underlying</span> <span class="n">assumption</span> <span class="n">about</span> <span class="n">the</span> <span class="n">numerical</span> <span class="n">values</span> <span class="n">of</span> <span class="n">these</span> <span class="n">macros</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_HII5</span>
<span class="cp">#if CFG_PRS_SCAN != CFG_TALLIES - HCF_ACT_TALLIES + HCF_ACT_PRS_SCAN</span>
<span class="nl">err:</span> <span class="s">&quot;maintenance&quot;</span> <span class="n">apparently</span> <span class="n">inviolated</span> <span class="n">the</span> <span class="n">underlying</span> <span class="n">assumption</span> <span class="n">about</span> <span class="n">the</span> <span class="n">numerical</span> <span class="n">values</span> <span class="n">of</span> <span class="n">these</span> <span class="n">macros</span>
<span class="cp">#endif</span>
<span class="kt">int</span>
<span class="n">hcf_action</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">action</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>

	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="o">==</span> <span class="n">HCF_MAGIC</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="p">);</span>
<span class="cp">#if HCF_INT_ON</span>
	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">action</span> <span class="o">==</span> <span class="n">HCF_ACT_INT_FORCE_ON</span> <span class="o">?</span> <span class="n">HCF_TRACE_ACTION_KLUDGE</span> <span class="o">:</span> <span class="n">HCF_TRACE_ACTION</span><span class="p">,</span> <span class="n">action</span> <span class="p">);</span>                                                      <span class="cm">/* 0 */</span>
<span class="cp">#if (HCF_SLEEP)</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span> <span class="o">!=</span> <span class="mh">0xFFFE</span> <span class="o">||</span> <span class="n">action</span> <span class="o">==</span> <span class="n">HCF_ACT_INT_OFF</span><span class="p">,</span>
		   <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">action</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span> <span class="p">)</span> <span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span> <span class="o">!=</span> <span class="mh">0xFFFE</span><span class="p">,</span> <span class="n">action</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_SLEEP</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span> <span class="o">!=</span> <span class="mh">0xFFFF</span> <span class="o">||</span>
		   <span class="n">action</span> <span class="o">==</span> <span class="n">HCF_ACT_INT_OFF</span> <span class="o">||</span> <span class="n">action</span> <span class="o">==</span> <span class="n">HCF_ACT_INT_FORCE_ON</span><span class="p">,</span>  <span class="n">action</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span> <span class="o">&lt;=</span> <span class="mi">16</span> <span class="o">||</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span> <span class="o">&gt;=</span> <span class="mh">0xFFFE</span><span class="p">,</span>
		   <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">action</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">//nesting more than 16 deep seems unreasonable</span>
<span class="cp">#endif </span><span class="c1">// HCF_INT_ON</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if HCF_INT_ON</span>
		<span class="n">hcf_16</span>  <span class="n">i</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HCF_ACT_INT_OFF</span>:                     <span class="c1">// Disable Interrupt generation</span>
<span class="cp">#if HCF_SLEEP</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span> <span class="o">==</span> <span class="mh">0xFFFE</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">// WakeUp test  ;?tie this to the &quot;new&quot; super-LinkStat</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span><span class="o">++</span><span class="p">;</span>                      <span class="c1">// restore conventional I/F</span>
			<span class="n">OPW</span><span class="p">(</span><span class="n">HREG_IO</span><span class="p">,</span> <span class="n">HREG_IO_WAKEUP_ASYNC</span> <span class="p">);</span>        <span class="c1">// set wakeup bit</span>
			<span class="n">OPW</span><span class="p">(</span><span class="n">HREG_IO</span><span class="p">,</span> <span class="n">HREG_IO_WAKEUP_ASYNC</span> <span class="p">);</span>        <span class="c1">// set wakeup bit to counteract the clearing by F/W</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>800 us latency before FW switches to high power</p></td><td class="code"><div class="highlight"><pre>			<span class="n">MSF_WAIT</span><span class="p">(</span><span class="mi">800</span><span class="p">);</span>                              <span class="c1">// MSF-defined function to wait n microseconds.</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>OOR            if ( ifbp->IFB<em>DSLinkStat &amp; CFG</em>LINK<em>STAT</em>DS<em>OOR ) { // OutOfRange
            printk( "&lt;5>ACT</em>INT<em>OFF: Deepsleep phase terminated, enable and go to AwaitConnection\n" );     //;?remove me 1 day
            hcf</em>cntl( ifbp, HCF<em>CNTL</em>ENABLE );
        }
        ifbp->IFB<em>DSLinkStat &amp;= ~( CFG</em>LINK<em>STAT</em>DS<em>IR | CFG</em>LINK<em>STAT</em>DS_OOR); //clear IR/OOR state</p></td><td class="code"><div class="highlight"><pre>		<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_SLEEP</span>
	<span class="cm">/*2*/</span>   <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span><span class="o">++</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>!        rc = 0;</p></td><td class="code"><div class="highlight"><pre>		<span class="n">i</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_INT_EN</span> <span class="p">);</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_INT_EN</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x1000</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_ERR_NO_NIC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_INT_PENDING</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HCF_ACT_INT_FORCE_ON</span>:                <span class="c1">// Enforce Enable Interrupt generation</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>Fall through in HCF<em>ACT</em>INT_ON</p></td><td class="code"><div class="highlight"><pre>	<span class="k">case</span> <span class="n">HCF_ACT_INT_ON</span>:                      <span class="c1">// Enable Interrupt generation</span>
	<span class="cm">/*4*/</span>   <span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>determine Interrupt Event mask</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if HCF_DMA</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">USE_DMA</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">HREG_EV_INFO</span> <span class="o">|</span> <span class="n">HREG_EV_RDMAD</span> <span class="o">|</span> <span class="n">HREG_EV_TDMAD</span> <span class="o">|</span> <span class="n">HREG_EV_TX_EXT</span><span class="p">;</span>  <span class="c1">//mask when DMA active</span>
			<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif </span><span class="c1">// HCF_DMA</span>
			<span class="p">{</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">HREG_EV_INFO</span> <span class="o">|</span> <span class="n">HREG_EV_RX</span> <span class="o">|</span> <span class="n">HREG_EV_TX_EXT</span><span class="p">;</span>                     <span class="c1">//mask when DMA not active</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
					<span class="n">i</span> <span class="o">|=</span> <span class="n">HREG_EV_ALLOC</span><span class="p">;</span>                                         <span class="c1">//mask when no TxFID available</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="cp">#if HCF_SLEEP</span>
			<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">IPW</span><span class="p">(</span><span class="n">HREG_EV_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">i</span> <span class="o">|</span> <span class="n">HREG_EV_SLEEP_REQ</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="n">HREG_EV_SLEEP_REQ</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>firmware indicates it would like to go into sleep modus
only acknowledge this request if no other events that can cause an interrupt are pending</p></td><td class="code"><div class="highlight"><pre>				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span><span class="o">--</span><span class="p">;</span>          <span class="c1">//becomes 0xFFFE</span>
				<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_INT_EN</span><span class="p">,</span> <span class="n">i</span> <span class="o">|</span> <span class="n">HREG_EV_TICK</span> <span class="p">);</span>
				<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_EV_ACK</span><span class="p">,</span> <span class="n">HREG_EV_SLEEP_REQ</span> <span class="o">|</span> <span class="n">HREG_EV_TICK</span> <span class="o">|</span> <span class="n">HREG_EV_ACK_REG_READY</span> <span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif </span><span class="c1">// HCF_SLEEP</span>
			<span class="p">{</span>
				<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_INT_EN</span><span class="p">,</span> <span class="n">i</span> <span class="o">|</span> <span class="n">HREG_EV_SLEEP_REQ</span> <span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_INT_ON</span>

<span class="cp">#if (HCF_SLEEP) &amp; HCF_DDS</span>
	<span class="k">case</span> <span class="n">HCF_ACT_SLEEP</span>:                       <span class="c1">// DDS Sleep request</span>
		<span class="n">hcf_cntl</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCF_CNTL_DISABLE</span> <span class="p">);</span>
		<span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCMD_SLEEP</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
		<span class="k">break</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>case HCF<em>ACT</em>WAKEUP:                      // DDS Wakeup request
    HCFASSERT( ifbp->IFB<em>IntOffCnt == 0xFFFE, ifbp->IFB</em>IntOffCnt );
    ifbp->IFB<em>IntOffCnt++;                  // restore conventional I/F
    OPW( HREG</em>IO, HREG<em>IO</em>WAKEUP<em>ASYNC );
    MSF</em>WAIT(800);                          // MSF-defined function to wait n microseconds.
    rc = hcf<em>action( ifbp, HCF</em>ACT<em>INT</em>OFF );   /*bogus, IFB<em>IntOffCnt == 0xFFFF, so if you carefully look
                                                 *at the #if HCF</em>DDS statements, HCF<em>ACT</em>INT<em>OFF is empty
                                                 *for DDS. "Much" better would be to merge the flows for
                                                 *DDS and DEEP</em>SLEEP
                                                 */
    break;</p></td><td class="code"><div class="highlight"><pre><span class="cp">#endif </span><span class="c1">// HCF_DDS</span>

	<span class="k">case</span> <span class="n">HCF_ACT_RX_ACK</span>:                      <span class="c1">//Receiver ACK</span>
	<span class="cm">/*6*/</span>   <span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxFID</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">DAWA_ACK</span><span class="p">(</span> <span class="n">HREG_EV_RX</span> <span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxFID</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

  <span class="cm">/*8*/</span> <span class="k">case</span>  <span class="n">HCF_ACT_PRS_SCAN</span>:                   <span class="c1">// Hermes PRS Scan (F102)</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_PARAM_1</span><span class="p">,</span> <span class="mh">0x3FFF</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>Fall through in HCF<em>ACT</em>TALLIES</p></td><td class="code"><div class="highlight"><pre>	<span class="k">case</span> <span class="n">HCF_ACT_TALLIES</span>:                     <span class="c1">// Hermes Inquire Tallies (F100)</span>
<span class="cp">#if ( (HCF_TYPE) &amp; HCF_TYPE_HII5 ) == 0</span>
	<span class="k">case</span> <span class="n">HCF_ACT_SCAN</span>:                        <span class="c1">// Hermes Inquire Scan (F101)</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_HII5</span>
		<span class="cm">/*!! the assumptions about numerical relationships between CFG_TALLIES etc and HCF_ACT_TALLIES etc</span>
<span class="cm">		 *   are checked by #if statements just prior to this routine resulting in: err &quot;maintenance&quot;   */</span>
		<span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCMD_INQUIRE</span><span class="p">,</span> <span class="n">action</span> <span class="o">-</span> <span class="n">HCF_ACT_TALLIES</span> <span class="o">+</span> <span class="n">CFG_TALLIES</span> <span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">action</span> <span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>! do not HCFASSERT( rc == HCF_SUCCESS, rc )                                                       /* 30*/</p></td><td class="code"><div class="highlight"><pre>	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_ACTION</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_action</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        int hcf_cntl( IFBP ifbp, hcf_16 cmd )</span>
<span class="cm"> *.PURPOSE       Connect or disconnect a specific port to a specific network.</span>
<span class="cm"> *!!  ;???????????????? continue needs more explanation</span>
<span class="cm"> *               recovers by means of &quot;continue&quot; when the connect process in CCX mode fails</span>
<span class="cm"> *               Enables or disables data transmission and reception for the NIC.</span>
<span class="cm"> *               Activates static NIC configuration for a specific port at connect.</span>
<span class="cm"> *               Activates static configuration for all ports at enable.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   cmd         0x001F: Hermes command (disable, enable, connect, disconnect, continue)</span>
<span class="cm"> *                   HCF_CNTL_ENABLE     Enable</span>
<span class="cm"> *                   HCF_CNTL_DISABLE    Disable</span>
<span class="cm"> *                   HCF_CNTL_CONTINUE   Continue</span>
<span class="cm"> *                   HCF_CNTL_CONNECT    Connect</span>
<span class="cm"> *                   HCF_CNTL_DISCONNECT Disconnect</span>
<span class="cm"> *               0x0100: command qualifier (continue)</span>
<span class="cm"> *                   HCMD_RETRY          retry flag</span>
<span class="cm"> *               0x0700:  port number (connect/disconnect)</span>
<span class="cm"> *                   HCF_PORT_0          MAC Port 0</span>
<span class="cm"> *                   HCF_PORT_1          MAC Port 1</span>
<span class="cm"> *                   HCF_PORT_2          MAC Port 2</span>
<span class="cm"> *                   HCF_PORT_3          MAC Port 3</span>
<span class="cm"> *                   HCF_PORT_4          MAC Port 4</span>
<span class="cm"> *                   HCF_PORT_5          MAC Port 5</span>
<span class="cm"> *                   HCF_PORT_6          MAC Port 6</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_SUCCESS</span>
<span class="cm"> *!! via cmd_exe</span>
<span class="cm"> *   HCF_ERR_NO_NIC</span>
<span class="cm"> *   HCF_ERR_DEFUNCT_...</span>
<span class="cm"> *   HCF_ERR_TIME_OUT</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * The parameter cmd contains a number of subfields.</span>
<span class="cm"> * The actual value for cmd is created by logical or-ing the appropriate mnemonics for the subfields.</span>
<span class="cm"> * The field 0x001F contains the command code</span>
<span class="cm"> *  - HCF_CNTL_ENABLE</span>
<span class="cm"> *  - HCF_CNTL_DISABLE</span>
<span class="cm"> *  - HCF_CNTL_CONNECT</span>
<span class="cm"> *  - HCF_CNTL_DISCONNECT</span>
<span class="cm"> *  - HCF_CNTL_CONTINUE</span>
<span class="cm"> *</span>
<span class="cm"> * For HCF_CNTL_CONTINUE, the field 0x0100 contains the retry flag HCMD_RETRY.</span>
<span class="cm"> * For HCF_CNTL_CONNECT and HCF_CNTL_DISCONNECT, the field 0x0700 contains the port number as HCF_PORT_#.</span>
<span class="cm"> * For Station as well as AccessPoint F/W, MAC Port 0 is the &quot;normal&quot; communication channel.</span>
<span class="cm"> * For AccessPoint F/W, MAC Port 1 through 6 control the WDS links.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that despite the names HCF_CNTL_DISABLE and HCF_CNTL_ENABLE, hcf_cntl does not influence the NIC</span>
<span class="cm"> * Interrupts mode.</span>
<span class="cm"> *</span>
<span class="cm"> * The Connect is used by the MSF to bring a particular port in an inactive state as far as data transmission</span>
<span class="cm"> * and reception are concerned.</span>
<span class="cm"> * When a particular port is disconnected:</span>
<span class="cm"> * - the F/W disables the receiver for that port.</span>
<span class="cm"> * - the F/W ignores send commands for that port.</span>
<span class="cm"> * - all frames (Receive as well as pending Transmit) for that port on the NIC are discarded.</span>
<span class="cm"> *</span>
<span class="cm"> * When the NIC is disabled, above list applies to all ports, i.e. the result is like all ports are</span>
<span class="cm"> * disconnected.</span>
<span class="cm"> *</span>
<span class="cm"> * When a particular port is connected:</span>
<span class="cm"> * - the F/W effectuates the static configuration for that port.</span>
<span class="cm"> * - enables the receiver for that port.</span>
<span class="cm"> * - accepts send commands for that port.</span>
<span class="cm"> *</span>
<span class="cm"> * Enabling has the following effects:</span>
<span class="cm"> * - the F/W effectuates the static configuration for all ports.</span>
<span class="cm"> *   The F/W only updates its static configuration at a transition from disabled to enabled or from</span>
<span class="cm"> *   disconnected to connected.</span>
<span class="cm"> *   In order to enforce the static configuration, the MSF must assure that such a transition takes place.</span>
<span class="cm"> *   Due to such a disable/enable or disconnect/connect sequence, Rx/Tx frames may be lost, in other words,</span>
<span class="cm"> *   configuration may impact communication.</span>
<span class="cm"> * - The DMA Engine (if applicable) is enabled.</span>
<span class="cm"> * Note that the Enable Function by itself only enables data transmission and reception, it</span>
<span class="cm"> * does not enable the Interrupt Generation mechanism. This is done by hcf_action.</span>
<span class="cm"> *</span>
<span class="cm"> * Disabling has the following effects:</span>
<span class="cm"> *!!  ;?????is the following statement really true</span>
<span class="cm"> * - it acts as a disconnect on all ports.</span>
<span class="cm"> * - The DMA Engine (if applicable) is disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * For impact of the disable command on the behavior of hcf_dma_tx/rx_get see the appropriate sections.</span>
<span class="cm"> *</span>
<span class="cm"> * Although the Enable/Disable and Connect/Disconnect are antonyms, there is no restriction on their sequencing,</span>
<span class="cm"> * in other words, they may be called multiple times in arbitrary sequence without being paired or balanced.</span>
<span class="cm"> * Each time one of these functions is called, the effects of the preceding calls cease.</span>
<span class="cm"> *</span>
<span class="cm"> * Assert fails if</span>
<span class="cm"> * - ifbp has a recognizable out-of-range value.</span>
<span class="cm"> * - NIC interrupts are not disabled.</span>
<span class="cm"> * - A command other than Continue, Enable, Disable, Connect or Disconnect is given.</span>
<span class="cm"> * - An invalid combination of the subfields is given or a bit outside the subfields is given.</span>
<span class="cm"> * - any return code besides HCF_SUCCESS.</span>
<span class="cm"> * - reentrancy, may be  caused by calling a hcf_function without adequate protection against NIC interrupts or</span>
<span class="cm"> *   multi-threading</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *   hcf_cntl takes successively the following actions:</span>
<span class="cm"> *2: If the HCF is in Defunct mode or incompatible with the Primary or Station Supplier in the Hermes,</span>
<span class="cm"> *   hcf_cntl() returns immediately with HCF_ERR_NO_NIC;? as status.</span>
<span class="cm"> *8: when the port is disabled, the DMA engine needs to be de-activated, so the host can safely reclaim tx</span>
<span class="cm"> *   packets from the tx descriptor chain.</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="kt">int</span>
<span class="n">hcf_cntl</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">cmd</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_ERR_INCOMP_FW</span><span class="p">;</span>
<span class="cp">#if HCF_ASSERT</span>
	<span class="p">{</span>   <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">HCMD_CMD_CODE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">x</span> <span class="o">==</span> <span class="n">HCF_CNTL_CONTINUE</span> <span class="p">)</span> <span class="n">x</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HCMD_RETRY</span><span class="p">;</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">HCMD_DISABLE</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">HCMD_ENABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">comp_id</span> <span class="o">==</span> <span class="n">COMP_ID_FW_AP</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">x</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HFS_TX_CNTL_PORT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">x</span><span class="o">==</span><span class="n">HCF_CNTL_ENABLE</span>  <span class="o">||</span> <span class="n">x</span><span class="o">==</span><span class="n">HCF_CNTL_DISABLE</span>    <span class="o">||</span> <span class="n">HCF_CNTL_CONTINUE</span> <span class="o">||</span>
			   <span class="n">x</span><span class="o">==</span><span class="n">HCF_CNTL_CONNECT</span> <span class="o">||</span> <span class="n">x</span><span class="o">==</span><span class="n">HCF_CNTL_DISCONNECT</span><span class="p">,</span> <span class="n">cmd</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><h1>if (HCF<em>SLEEP) &amp; HCF</em>DDS</h1>

<p>HCFASSERT( ifbp->IFB_IntOffCnt != 0xFFFE, cmd );</p>

<h1>endif // HCF_DDS</h1></td><td class="code"><div class="highlight"><pre>	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_CNTL</span><span class="p">,</span> <span class="n">cmd</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>                                                                 <span class="cm">/*2*/</span>
	<span class="cm">/*6*/</span>   <span class="n">rc</span> <span class="o">=</span> <span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="cp">#if (HCF_SLEEP) &amp; HCF_DDS</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TickCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>              <span class="c1">//start 2 second period (with 1 tick uncertanty)</span>
<span class="cp">#endif </span><span class="c1">// HCF_DDS</span>
	<span class="p">}</span>
<span class="cp">#if HCF_DMA</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>!rlav : note that this piece of code is always executed, regardless of the DEFUNCT bit in IFB_CardStat.
The reason behind this is that the MSF should be able to get all its DMA resources back from the HCF,
even if the hardware is disfunctional. Practical example under Windows : surprise removal.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">USE_DMA</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">hcf_io</span> <span class="n">io_port</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span><span class="p">;</span>
		<span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">HCF_CNTL_DISABLE</span> <span class="o">||</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">HCF_CNTL_ENABLE</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">OUT_PORT_DWORD</span><span class="p">(</span> <span class="p">(</span><span class="n">io_port</span> <span class="o">+</span> <span class="n">HREG_DMA_CTRL</span><span class="p">),</span> <span class="n">DMA_CTRLSTAT_RESET</span><span class="p">);</span>                     <span class="cm">/*8*/</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_ENABLED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">HCF_CNTL_ENABLE</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">OUT_PORT_DWORD</span><span class="p">(</span> <span class="p">(</span><span class="n">io_port</span> <span class="o">+</span> <span class="n">HREG_DMA_CTRL</span><span class="p">),</span> <span class="n">DMA_CTRLSTAT_GO</span><span class="p">);</span>
			<span class="cm">/* ;? by rewriting hcf_dma_rx_put you can probably just call hcf_dma_rx_put( ifbp-&gt;IFB_FirstDesc[DMA_RX] )</span>
<span class="cm">			 * as additional beneficiary side effect, the SOP and EOP bits will also be cleared</span>
<span class="cm">			 */</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">|=</span> <span class="n">DMA_ENABLED</span><span class="p">;</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">NT_ASSERT</span><span class="p">,</span> <span class="n">NEVER_TESTED</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>make the entire rx descriptor chain DMA-owned, so the DMA engine can (re-)use it.</p></td><td class="code"><div class="highlight"><pre>			<span class="n">p</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">DMA_RX</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">//;? Think this over again in the light of the new chaining strategy</span>
				<span class="k">if</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>    <span class="p">{</span> <span class="c1">//begin alternative</span>
					<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">NT_ASSERT</span><span class="p">,</span> <span class="n">NEVER_TESTED</span> <span class="p">);</span>
					<span class="n">put_frame_lst</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">DMA_RX</span><span class="p">],</span> <span class="n">DMA_RX</span> <span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">DMA_RX</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
						<span class="n">put_frame_lst</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">DMA_RX</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="p">,</span> <span class="n">DMA_RX</span> <span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">while</span> <span class="p">(</span> <span class="n">p</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>p->buf<em>cntl.cntl</em>stat |= DESC<em>DMA</em>OWNED;</p></td><td class="code"><div class="highlight"><pre>						<span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">|=</span> <span class="n">DESC_DMA_OWNED</span><span class="p">;</span>
						<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="p">;</span>
					<span class="p">}</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>a rx chain is available so hand it over to the DMA engine</p></td><td class="code"><div class="highlight"><pre>					<span class="n">p</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">DMA_RX</span><span class="p">];</span>
					<span class="n">OUT_PORT_DWORD</span><span class="p">(</span> <span class="p">(</span><span class="n">io_port</span> <span class="o">+</span> <span class="n">HREG_RXDMA_PTR32</span><span class="p">),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">desc_phys_addr</span><span class="p">);</span>
				<span class="p">}</span>  <span class="c1">//end alternative</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_DMA</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span><span class="p">,</span> <span class="n">rc</span> <span class="p">);</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_CNTL</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_cntl</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        int hcf_connect( IFBP ifbp, hcf_io io_base )</span>
<span class="cm"> *.PURPOSE       Grants access right for the HCF to the IFB.</span>
<span class="cm"> *               Initializes Card and HCF housekeeping.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        (near) address of the Interface Block</span>
<span class="cm"> *   io_base     non-USB: I/O Base address of the NIC (connect)</span>
<span class="cm"> *               non-USB: HCF_DISCONNECT</span>
<span class="cm"> *               USB:     HCF_CONNECT, HCF_DISCONNECT</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_SUCCESS</span>
<span class="cm"> *   HCF_ERR_INCOMP_PRI</span>
<span class="cm"> *   HCF_ERR_INCOMP_FW</span>
<span class="cm"> *   HCF_ERR_DEFUNCT_CMD_SEQ</span>
<span class="cm"> *!! HCF_ERR_NO_NIC really returned ;?</span>
<span class="cm"> *   HCF_ERR_NO_NIC</span>
<span class="cm"> *   HCF_ERR_TIME_OUT</span>
<span class="cm"> *</span>
<span class="cm"> *   MSF-accessible fields of Result Block:</span>
<span class="cm"> *   IFB_IOBase              entry parameter io_base</span>
<span class="cm"> *   IFB_IORange             HREG_IO_RANGE (0x40/0x80)</span>
<span class="cm"> *   IFB_Version             version of the IFB layout</span>
<span class="cm"> *   IFB_FWIdentity          CFG_FW_IDENTITY_STRCT, specifies the identity of the</span>
<span class="cm"> *                           &quot;running&quot; F/W, i.e. tertiary F/W under normal conditions</span>
<span class="cm"> *   IFB_FWSup               CFG_SUP_RANGE_STRCT, specifies the supplier range of</span>
<span class="cm"> *                           the &quot;running&quot; F/W, i.e. tertiary F/W under normal conditions</span>
<span class="cm"> *   IFB_HSISup              CFG_SUP_RANGE_STRCT, specifies the HW/SW I/F range of the NIC</span>
<span class="cm"> *   IFB_PRIIdentity         CFG_PRI_IDENTITY_STRCT, specifies the Identity of the Primary F/W</span>
<span class="cm"> *   IFB_PRISup              CFG_SUP_RANGE_STRCT, specifies the supplier range of the Primary F/W</span>
<span class="cm"> *   all other               all MSF accessible fields, which are not specified above, are zero-filled</span>
<span class="cm"> *</span>
<span class="cm"> *.CONDITIONS</span>
<span class="cm"> * It is the responsibility of the MSF to assure the correctness of the I/O Base address.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: hcf_connect defaults to NIC interrupt disabled mode, i.e. as if hcf_action( HCF_ACT_INT_OFF )</span>
<span class="cm"> * was called.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * hcf_connect passes the MSF-defined location of the IFB to the HCF and grants or revokes access right for the</span>
<span class="cm"> * HCF to the IFB. Revoking is done by specifying HCF_DISCONNECT rather than an I/O address for the parameter</span>
<span class="cm"> * io_base.  Every call of hcf_connect in &quot;connect&quot; mode, must eventually be followed by a call of hcf_connect</span>
<span class="cm"> * in &quot;disconnect&quot; mode. Clalling hcf_connect in &quot;connect&quot;/&quot;disconnect&quot; mode can not be nested.</span>
<span class="cm"> * The IFB address must be used as a handle with all subsequent HCF-function calls and the HCF uses the IFB</span>
<span class="cm"> * address as a handle when it performs a call(back) of an MSF-function (i.e. msf_assert).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that not only the MSF accessible fields are cleared, but also all internal housekeeping</span>
<span class="cm"> * information is re-initialized.</span>
<span class="cm"> * This implies that all settings which are done via hcf_action and hcf_put_info (e.g. CFG_MB_ASSERT, CFG_REG_MB,</span>
<span class="cm"> * CFG_REG_INFO_LOG) must be done again. The only field which is not cleared, is IFB_MSFSup.</span>
<span class="cm"> *</span>
<span class="cm"> * If HCF_INT_ON is selected as compile option, NIC interrupts are disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Assert fails if</span>
<span class="cm"> * - ifbp is not properly aligned ( ref chapter HCF_ALIGN in 4.1.1)</span>
<span class="cm"> * - I/O Base Address is not a multiple of 0x40 (note: 0x0000 is explicitly allowed).</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *0: Throughout hcf_connect you need to distinguish the connect from the disconnect case, which requires</span>
<span class="cm"> *   some attention about what to use as &quot;I/O&quot; address when for which purpose.</span>
<span class="cm"> *2:</span>
<span class="cm"> *2a: Reset H-II by toggling reset bit in IO-register on and off.</span>
<span class="cm"> *   The HCF_TYPE_PRELOADED caters for the DOS environment where H-II is loaded by a separate program to</span>
<span class="cm"> *   overcome the 64k size limit posed on DOS drivers.</span>
<span class="cm"> *   The macro OPW is not yet useable because the IFB_IOBase field is not set.</span>
<span class="cm"> *   Note 1: hopefully the clearing and initializing of the IFB (see below) acts as a delay which meets the</span>
<span class="cm"> *   specification for S/W reset</span>
<span class="cm"> *   Note 2: it turns out that on some H/W constellations, the clock to access the EEProm is not lowered</span>
<span class="cm"> *   to an appropriate frequency by HREG_IO_SRESET. By giving an HCMD_INI first, this problem is worked around.</span>
<span class="cm"> *2b: Experimentally it is determined over a wide range of F/W versions that waiting for the for Cmd bit in</span>
<span class="cm"> *   Ev register gives a workable strategy. The available documentation does not give much clues.</span>
<span class="cm"> *4: clear and initialize the IFB</span>
<span class="cm"> *   The HCF house keeping info is designed such that zero is the appropriate initial value for as much as</span>
<span class="cm"> *   feasible IFB-items.</span>
<span class="cm"> *   The readable fields mentioned in the description section and some HCF specific fields are given their</span>
<span class="cm"> *   actual value.</span>
<span class="cm"> *   IFB_TickIni is initialized at best guess before calibration</span>
<span class="cm"> *   Hcf_connect defaults to &quot;no interrupt generation&quot; (implicitly achieved by the zero-filling).</span>
<span class="cm"> *6: Register compile-time linked MSF Routine and set default filter level</span>
<span class="cm"> *   cast needed to get around the &quot;near&quot; problem in DOS COM model</span>
<span class="cm"> *   er C2446: no conversion from void (__near __cdecl *)(unsigned char __far *,unsigned int,unsigned short,int)</span>
<span class="cm"> *                           to   void (__far  __cdecl *)(unsigned char __far *,unsigned int,unsigned short,int)</span>
<span class="cm"> *8: If a command is apparently still active (as indicated by the Busy bit in Cmd register) this may indicate a</span>
<span class="cm"> *   blocked cmd pipe line.  To unblock the following actions are done:</span>
<span class="cm"> *    - Ack everything</span>
<span class="cm"> *    - Wait for Busy bit drop  in Cmd register</span>
<span class="cm"> *    - Wait for Cmd  bit raise in Ev  register</span>
<span class="cm"> *   The two waits are combined in a single HCF_WAIT_WHILE to optimize memory size. If either of these waits</span>
<span class="cm"> *   fail (prot_cnt becomes 0), then something is serious wrong. Rather than PANICK, the assumption is that the</span>
<span class="cm"> *   next cmd_exe will fail, causing the HCF to go into DEFUNCT mode</span>
<span class="cm"> *10:    Ack everything to unblock a (possibly blocked) cmd pipe line</span>
<span class="cm"> *   Note 1: it is very likely that an Alloc event is pending and very well possible that a (Send) Cmd event is</span>
<span class="cm"> *   pending on non-initial calls</span>
<span class="cm"> *   Note 2: it is assumed that this strategy takes away the need to ack every conceivable event after an</span>
<span class="cm"> *   Hermes Initialize</span>
<span class="cm"> *12:    Only H-II NEEDS the Hermes Initialize command. Due to the different semantics for H-I and H-II</span>
<span class="cm"> *   Initialize command, init() does not (and can not, since it is called e.g. after a download) execute the</span>
<span class="cm"> *   Hermes Initialize command. Executing the Hermes Initialize command for H-I would not harm but not do</span>
<span class="cm"> *   anything useful either, so it is skipped.</span>
<span class="cm"> *   The return status of cmd_exe is ignored. It is assumed that if cmd_exe fails, init fails too</span>
<span class="cm"> *14:    use io_base as a flag to merge hcf_connect and hcf_disconnect into 1 routine</span>
<span class="cm"> *   the call to init and its subsequent call of cmd_exe will return HCF_ERR_NO_NIC if appropriate. This status</span>
<span class="cm"> *   is (badly) needed by some legacy combination of NT4 and card services which do not yield an I/O address in</span>
<span class="cm"> *   time.</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *   On platforms where the NULL-pointer is not a bit-pattern of all zeros, the zero-filling of the IFB results</span>
<span class="cm"> *   in an incorrect initialization of pointers.</span>
<span class="cm"> *   The implementation of the MailBox manipulation in put_mb_info protects against the absence of a MailBox</span>
<span class="cm"> *   based on IFB_MBSize, IFB_MBWp and ifbp-&gt;IFB_MBRp. This has ramifications on the initialization of the</span>
<span class="cm"> *   MailBox via hcf_put_info with the CFG_REG_MB type, but it prevents dependency on the &quot;NULL-&quot;ness of</span>
<span class="cm"> *   IFB_MBp.</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *   There are a number of problems when asserting and logging hcf_connect, e.g.</span>
<span class="cm"> *    - Asserting on re-entrancy of hcf_connect by means of</span>
<span class="cm"> *    &quot;HCFASSERT( (ifbp-&gt;IFB_AssertTrace &amp; HCF_ASSERT_CONNECT) == 0, 0 )&quot; is not useful because IFB contents</span>
<span class="cm"> *    are undefined</span>
<span class="cm"> *    - Asserting before the IFB is cleared will cause mdd_assert() to interpret the garbage in IFB_AssertRtn</span>
<span class="cm"> *    as a routine address</span>
<span class="cm"> *   Therefore HCFTRACE nor HCFLOGENTRY is called by hcf_connect.</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="kt">int</span>
<span class="n">hcf_connect</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">hcf_io</span> <span class="n">io_base</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>         <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>
	<span class="n">hcf_io</span>      <span class="n">io_addr</span><span class="p">;</span>
	<span class="n">hcf_32</span>      <span class="n">prot_cnt</span><span class="p">;</span>
	<span class="n">hcf_8</span>       <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="n">LTV_STRCT</span>   <span class="n">x</span><span class="p">;</span>
<span class="cp">#if HCF_ASSERT</span>
	<span class="n">hcf_16</span> <span class="n">xa</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">typ</span><span class="p">;</span>
	<span class="cm">/* is assumed to cause an assert later on if hcf_connect is called without intervening hcf_disconnect.</span>
<span class="cm">	 * xa == CFG_FW_IDENTITY in subsequent calls without preceding hcf_disconnect,</span>
<span class="cm">	 * xa == 0 in subsequent calls with preceding hcf_disconnect,</span>
<span class="cm">	 * xa == &quot;garbage&quot; (any value except CFG_FW_IDENTITY is acceptable) in the initial call</span>
<span class="cm">	 */</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">io_base</span> <span class="o">==</span> <span class="n">HCF_DISCONNECT</span> <span class="p">)</span> <span class="p">{</span>                  <span class="c1">//disconnect</span>
		<span class="n">io_addr</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span><span class="p">;</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_INT_EN</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>      <span class="c1">//;?workaround against dying F/W on subsequent hcf_connect calls</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                            <span class="c1">//connect                               /* 0 */</span>
		<span class="n">io_addr</span> <span class="o">=</span> <span class="n">io_base</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"> //;? if a subsequent hcf_connect is preceded by an hcf_disconnect the wakeup is not needed !!</span>
<span class="cp">#if HCF_SLEEP</span>
<span class="c">	OUT_PORT_WORD( .....+HREG_IO, HREG_IO_WAKEUP_ASYNC );       //OPW not yet useable</span>
<span class="c">	MSF_WAIT(800);                              // MSF-defined function to wait n microseconds.</span>
<span class="c">	note that MSF_WAIT uses not yet defined!!!! IFB_IOBase and IFB_TickIni (via PROT_CNT_INI)</span>
<span class="c">	so be careful if this code is restored</span>
<span class="cp">#endif // HCF_SLEEP</span>
<span class="cp">#endif // 0</span>

<span class="cp">#if ( (HCF_TYPE) &amp; HCF_TYPE_PRELOADED ) == 0    </span><span class="c1">//switch clock back for SEEPROM access  !!!</span>
	<span class="n">OUT_PORT_WORD</span><span class="p">(</span> <span class="n">io_addr</span> <span class="o">+</span> <span class="n">HREG_CMD</span><span class="p">,</span> <span class="n">HCMD_INI</span> <span class="p">);</span>          <span class="c1">//OPW not yet useable</span>
	<span class="n">prot_cnt</span> <span class="o">=</span> <span class="n">INI_TICK_INI</span><span class="p">;</span>
	<span class="n">HCF_WAIT_WHILE</span><span class="p">(</span> <span class="p">(</span><span class="n">IN_PORT_WORD</span><span class="p">(</span> <span class="n">io_addr</span> <span class="o">+</span>  <span class="n">HREG_EV_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HREG_EV_CMD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="n">OUT_PORT_WORD</span><span class="p">(</span> <span class="p">(</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">HREG_IO</span><span class="p">),</span> <span class="n">HREG_IO_SRESET</span> <span class="p">);</span>   <span class="c1">//OPW not yet useable                   /* 2a*/</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_PRELOADED</span>
	<span class="k">for</span> <span class="p">(</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_8</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span><span class="p">);</span> <span class="n">q</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">hcf_8</span><span class="o">*</span><span class="p">)</span><span class="n">ifbp</span><span class="p">;</span> <span class="o">*--</span><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="cm">/*NOP*/</span><span class="p">;</span>                     <span class="cm">/* 4 */</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span>     <span class="o">=</span> <span class="n">HCF_MAGIC</span><span class="p">;</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Version</span>   <span class="o">=</span> <span class="n">IFB_VERSION</span><span class="p">;</span>
<span class="cp">#if defined MSF_COMPONENT_ID </span><span class="c1">//a new IFB demonstrates how dirty the solution is</span>
	<span class="n">xxxx</span><span class="p">[</span><span class="n">xxxx_PRI_IDENTITY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>      <span class="c1">//IFB_PRIIdentity placeholder   0xFD02</span>
	<span class="n">xxxx</span><span class="p">[</span><span class="n">xxxx_PRI_IDENTITY_OFFSET</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>    <span class="c1">//IFB_PRISup placeholder        0xFD03</span>
<span class="cp">#endif </span><span class="c1">// MSF_COMPONENT_ID</span>
<span class="cp">#if (HCF_TALLIES) &amp; ( HCF_TALLIES_NIC | HCF_TALLIES_HCF )</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TallyLen</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">HCF_NIC_TAL_CNT</span> <span class="o">+</span> <span class="n">HCF_HCF_TAL_CNT</span><span class="p">);</span>   <span class="c1">//convert # of Tallies to L value for LTV</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TallyTyp</span> <span class="o">=</span> <span class="n">CFG_TALLIES</span><span class="p">;</span>           <span class="c1">//IFB_TallyTyp: set T value</span>
<span class="cp">#endif </span><span class="c1">// HCF_TALLIES_NIC / HCF_TALLIES_HCF</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span>    <span class="o">=</span> <span class="n">io_addr</span><span class="p">;</span>              <span class="c1">//set IO_Base asap, so asserts via HREG_SW_2 don&#39;t harm</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IORange</span>   <span class="o">=</span> <span class="n">HREG_IO_RANGE</span><span class="p">;</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span>   <span class="o">=</span> <span class="n">USE_16BIT</span><span class="p">;</span>
<span class="cp">#if HCF_ASSERT</span>
	<span class="n">assert_ifbp</span> <span class="o">=</span> <span class="n">ifbp</span><span class="p">;</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertLvl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#if (HCF_ASSERT) &amp; HCF_ASSERT_LNK_MSF_RTN</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">io_base</span> <span class="o">!=</span> <span class="n">HCF_DISCONNECT</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertRtn</span> <span class="o">=</span> <span class="p">(</span><span class="n">MSF_ASSERT_RTNP</span><span class="p">)</span><span class="n">msf_assert</span><span class="p">;</span>                                          <span class="cm">/* 6 */</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_LNK_MSF_RTN</span>
<span class="cp">#if (HCF_ASSERT) &amp; HCF_ASSERT_MB                </span><span class="c1">//build the structure to pass the assert info to hcf_put_info</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertStrct</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertStrct</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertStrct</span><span class="p">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">CFG_MB_INFO</span><span class="p">;</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertStrct</span><span class="p">.</span><span class="n">base_typ</span> <span class="o">=</span> <span class="n">CFG_MB_ASSERT</span><span class="p">;</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertStrct</span><span class="p">.</span><span class="n">frag_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertStrct</span><span class="p">.</span><span class="n">frag_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">frag_len</span> <span class="o">=</span>
		<span class="p">(</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">IFB_STRCT</span><span class="p">,</span> <span class="n">IFB_AssertLvl</span><span class="p">)</span> <span class="o">-</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">IFB_STRCT</span><span class="p">,</span> <span class="n">IFB_AssertLine</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">);</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertStrct</span><span class="p">.</span><span class="n">frag_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">frag_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertLine</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_MB</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT</span>
	<span class="n">IF_PROT_TIME</span><span class="p">(</span> <span class="n">prot_cnt</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TickIni</span> <span class="o">=</span> <span class="n">INI_TICK_INI</span> <span class="p">);</span>
<span class="cp">#if ( (HCF_TYPE) &amp; HCF_TYPE_PRELOADED ) == 0</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>!! No asserts before Reset-bit in HREG_IO is cleared</p></td><td class="code"><div class="highlight"><pre>	<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_IO</span><span class="p">,</span> <span class="mh">0x0000</span> <span class="p">);</span>                     <span class="c1">//OPW useable                                       /* 2b*/</span>
	<span class="n">HCF_WAIT_WHILE</span><span class="p">(</span> <span class="p">(</span><span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HREG_EV_CMD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="n">IF_PROT_TIME</span><span class="p">(</span> <span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">prot_cnt</span><span class="p">,</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
	<span class="n">IF_PROT_TIME</span><span class="p">(</span> <span class="k">if</span> <span class="p">(</span> <span class="n">prot_cnt</span> <span class="p">)</span> <span class="n">prot_cnt</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TickIni</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_PRELOADED</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>!! No asserts before Reset-bit in HREG_IO is cleared</p></td><td class="code"><div class="highlight"><pre>	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">HCF_ASSERT</span><span class="p">,</span> <span class="mh">0xCAF0</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">//just to proof that the complete assert machinery is working</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">xa</span> <span class="o">!=</span> <span class="n">CFG_FW_IDENTITY</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>       <span class="c1">// assert if hcf_connect is called without intervening hcf_disconnect.</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">((</span><span class="n">hcf_32</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">ifbp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HCF_ALIGN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">ifbp</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span><span class="n">io_addr</span> <span class="o">&amp;</span> <span class="mh">0x003F</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">io_addr</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>if Busy bit in Cmd register</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_CMD</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">HCMD_BUSY</span> <span class="p">)</span> <span class="p">{</span>                                                             <span class="cm">/* 8 */</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>.  Ack all to unblock a (possibly) blocked cmd pipe line</p></td><td class="code"><div class="highlight"><pre>		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_EV_ACK</span><span class="p">,</span> <span class="o">~</span><span class="n">HREG_EV_SLEEP_REQ</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>.  Wait for Busy bit drop  in Cmd register
.  Wait for Cmd  bit raise in Ev  register</p></td><td class="code"><div class="highlight"><pre>		<span class="n">HCF_WAIT_WHILE</span><span class="p">(</span> <span class="p">(</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_CMD</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">HCMD_BUSY</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HREG_EV_CMD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
		<span class="n">IF_PROT_TIME</span><span class="p">(</span> <span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">prot_cnt</span><span class="p">,</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span> <span class="cm">/* if prot_cnt == 0, cmd_exe will fail, causing DEFUNCT */</span>
	<span class="p">}</span>
	<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_EV_ACK</span><span class="p">,</span> <span class="o">~</span><span class="n">HREG_EV_SLEEP_REQ</span> <span class="p">);</span>
<span class="cp">#if ( (HCF_TYPE) &amp; HCF_TYPE_PRELOADED ) == 0                                                        </span><span class="cm">/*12*/</span><span class="cp"></span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCMD_INI</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_PRELOADED</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">io_base</span> <span class="o">!=</span> <span class="n">HCF_DISCONNECT</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">init</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>                                                                          <span class="cm">/*14*/</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">x</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">x</span><span class="p">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">CFG_NIC_BUS_TYPE</span><span class="p">;</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">hcf_get_info</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">);</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_BusType</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>CFG<em>NIC</em>BUS<em>TYPE not supported -> default 32 bits/DMA, MSF has to overrule via CFG</em>CNTL_OPT</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">(</span> <span class="n">x</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x0002</span> <span class="o">||</span> <span class="n">x</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x0003</span> <span class="p">)</span> <span class="p">{</span>
<span class="cp">#if (HCF_IO) &amp; HCF_IO_32BITS</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USE_16BIT</span><span class="p">;</span>            <span class="c1">//reset USE_16BIT</span>
<span class="cp">#endif </span><span class="c1">// HCF_IO_32BITS</span>
<span class="cp">#if HCF_DMA</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">|=</span> <span class="n">USE_DMA</span><span class="p">;</span>               <span class="c1">//SET DMA</span>
<span class="cp">#else</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IORange</span> <span class="o">=</span> <span class="mh">0x40</span> <span class="cm">/*i.s.o. HREG_IO_RANGE*/</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_DMA</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="n">HCFASSERT</span><span class="p">(</span>  <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="o">^=</span> <span class="n">HCF_MAGIC</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="p">)</span> <span class="cm">/*NOP*/</span><span class="p">;</span>
	<span class="cm">/* of above HCFASSERT only the side effect is needed, NOP in case HCFASSERT is dummy */</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span> <span class="o">=</span> <span class="n">io_base</span><span class="p">;</span>                                                                     <span class="cm">/* 0*/</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_connect</span>

<span class="cp">#if HCF_DMA</span>
<span class="cm">/************************************************************************************************************</span>
<span class="cm"> * Function get_frame_lst</span>
<span class="cm"> *  - resolve the &quot;last host-owned descriptor&quot; problems when a descriptor list is reclaimed by the MSF.</span>
<span class="cm"> *</span>
<span class="cm"> * The FrameList to be reclaimed as well as the DescriptorList always start in IFB_FirstDesc[tx_rx_flag]</span>
<span class="cm"> * and this is always the &quot;current&quot; DELWA Descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * If a FrameList is available, the last descriptor of the FrameList to turned into a new DELWA Descriptor:</span>
<span class="cm"> *  - a copy is made from the information in the last descriptor of the FrameList into the current</span>
<span class="cm"> *    DELWA Descriptor</span>
<span class="cm"> *  - the remainder of the DescriptorList is detached from the copy by setting the next_desc_addr at NULL</span>
<span class="cm"> *  - the DMA control bits of the copy are cleared to do not confuse the MSF</span>
<span class="cm"> *  - the copy of the last descriptor (i.e. the &quot;old&quot; DELWA Descriptor) is chained to the prev Descriptor</span>
<span class="cm"> *    of the FrameList, thus replacing the original last Descriptor of the FrameList.</span>
<span class="cm"> *  - IFB_FirstDesc is changed to the address of that replaced (original) last descriptor of the FrameList,</span>
<span class="cm"> *    i.e. the &quot;new&quot; DELWA Descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes a copy of that last host-owned descriptor, so the MSF will get a copy of the descriptor.</span>
<span class="cm"> * On top of that, it adjusts DMA related fields in the IFB structure.</span>

<span class="cm">//DIVIDER</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: address of the first descriptor of the FrameList</span>
<span class="cm"> *</span>
<span class="cm"> 8: Be careful once you start re-ordering the steps in the copy process, that it still works for cases</span>
<span class="cm"> *   of FrameLists of 1, 2 and more than 2 descriptors</span>
<span class="cm"> *</span>
<span class="cm"> * Input parameters:</span>
<span class="cm"> * tx_rx_flag      : specifies &#39;transmit&#39; or &#39;receive&#39; descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="n">DESC_STRCT</span><span class="o">*</span>
<span class="n">get_frame_lst</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_rx_flag</span> <span class="p">)</span>
<span class="p">{</span>

	<span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">];</span>
	<span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">copy</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">tx_rx_flag</span> <span class="o">==</span> <span class="n">DMA_RX</span> <span class="o">||</span> <span class="n">tx_rx_flag</span> <span class="o">==</span> <span class="n">DMA_TX</span><span class="p">,</span> <span class="n">tx_rx_flag</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>perform a copying-scheme to circumvent the 'last host owned descriptor cannot be reclaimed' limitation imposed by H2.5's DMA hardware design
a 'reclaim descriptor' should be available in the HCF:</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="n">head</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>if FrameList</p></td><td class="code"><div class="highlight"><pre>		<span class="n">p</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span> <span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">&amp;</span> <span class="n">DESC_EOP</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">DMA_ENABLED</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>   <span class="c1">//clear control bits when disabled</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">&amp;=</span> <span class="n">DESC_CNT_MASK</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>.  search for last descriptor of first FrameList</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">DMA_ENABLED</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>.  if DMA enabled</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">&amp;</span> <span class="n">DESC_DMA_OWNED</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>.  .  if last descriptor of FrameList is DMA owned
.  .  or if FrameList is single (DELWA) Descriptor</p></td><td class="code"><div class="highlight"><pre>				<span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>.  .  .  refuse to return FrameList to caller</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="n">head</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>if returnable FrameList found</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>.  if FrameList is single (DELWA) Descriptor (implies DMA disabled)</p></td><td class="code"><div class="highlight"><pre>			<span class="cm">/*;?ifbp-&gt;IFB_LastDesc[tx_rx_flag] =*/</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>.  .  clear DescriptorList</p></td><td class="code"><div class="highlight"><pre>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>.  else</p></td><td class="code"><div class="highlight"><pre>			<span class="n">copy</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
			<span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>.  .  strip hardware-related bits from last descriptor
.  .  remove DELWA Descriptor from head of DescriptorList</p></td><td class="code"><div class="highlight"><pre>			<span class="n">copy</span><span class="o">-&gt;</span><span class="n">buf_phys_addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_phys_addr</span><span class="p">;</span>
			<span class="n">copy</span><span class="o">-&gt;</span><span class="n">buf_addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">;</span>
			<span class="n">copy</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">&amp;=</span> <span class="n">DESC_CNT_MASK</span><span class="p">;</span>  <span class="c1">//get rid of DESC_EOP and possibly DESC_SOP</span>
			<span class="n">copy</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">&amp;=</span> <span class="n">DESC_CNT_MASK</span><span class="p">;</span>    <span class="c1">//get rid of DESC_DMA_OWNED</span>
<span class="cp">#if (HCF_EXT) &amp; HCF_DESC_STRCT_EXT</span>
			<span class="n">copy</span><span class="o">-&gt;</span><span class="n">DESC_MSFSup</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">DESC_MSFSup</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_DESC_STRCT_EXT</span></pre></div></td></tr>


<tr id="section-35"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-35">&#182;</a></div><p>.   .  exchange first (Confined) and last (possibly imprisoned) Descriptor</p></td><td class="code"><div class="highlight"><pre>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-36"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-36">&#182;</a></div><p>.  .  turn into a DELWA Descriptor</p></td><td class="code"><div class="highlight"><pre>			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="o">=</span> <span class="n">copy</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-37"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-37">&#182;</a></div><p>.  .  chain copy to prev                                          /* 8*/</p></td><td class="code"><div class="highlight"><pre>			<span class="n">copy</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">copy</span><span class="o">-&gt;</span><span class="n">next_desc_phys_addr</span> <span class="o">=</span> <span class="mh">0xDEAD0000</span><span class="p">;</span> <span class="c1">//! just to be nice, not really needed</span></pre></div></td></tr>


<tr id="section-38"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-38">&#182;</a></div><p>.  .  detach remainder of the DescriptorList from FrameList</p></td><td class="code"><div class="highlight"><pre>			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-39"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-39">&#182;</a></div><p>.  .  save the new start (i.e. DELWA Descriptor) in IFB_FirstDesc</p></td><td class="code"><div class="highlight"><pre>		<span class="n">head</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">&amp;=</span> <span class="n">DESC_CNT_MASK</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-40"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-40">&#182;</a></div><p>.  strip DESC_SOP from first descriptor</p></td><td class="code"><div class="highlight"><pre>		<span class="n">head</span><span class="o">-&gt;</span><span class="n">next_desc_phys_addr</span> <span class="o">=</span> <span class="mh">0xDEAD0000</span><span class="p">;</span> <span class="c1">//! just to be nice, not really needed</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-41"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-41">&#182;</a></div><p>head->BUF<em>CNT &amp;= DESC</em>CNT<em>MASK;  get rid of DESC</em>DMA_OWNED</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// get_frame_lst</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> * Function put_frame_lst</span>
<span class="cm"> *</span>
<span class="cm"> * This function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: address of the first descriptor of the FrameList</span>
<span class="cm"> *</span>
<span class="cm"> * Input parameters:</span>
<span class="cm"> * tx_rx_flag      : specifies &#39;transmit&#39; or &#39;receive&#39; descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * The following list should be kept in sync with hcf_dma_tx/rx_put, in order to get them in the WCI-spec !!!!</span>
<span class="cm"> * Assert fails if</span>
<span class="cm"> * - DMA is not enabled</span>
<span class="cm"> * - descriptor list is NULL</span>
<span class="cm"> * - a descriptor in the descriptor list is not double word aligned</span>
<span class="cm"> * - a count of size field of a descriptor contains control bits, i.e. bits in the high order nibble.</span>
<span class="cm"> * - the DELWA descriptor is not a &quot;singleton&quot; DescriptorList.</span>
<span class="cm"> * - the DELWA descriptor is not the first Descriptor supplied</span>
<span class="cm"> * - a non_DMA descriptor is supplied before the DELWA Descriptor is supplied</span>
<span class="cm"> * - Possibly more checks could be added !!!!!!!!!!!!!</span>

<span class="cm"> *.NOTICE</span>
<span class="cm"> * The asserts marked with *sc* are really sanity checks for the HCF, they can (supposedly) not be influenced</span>
<span class="cm"> * by incorrect MSF behavior</span>


<span class="cm">//DIVIDER</span>
<span class="cm"> *********************************************************************************************</span>
<span class="cm"> * Although not required from a hardware perspective:</span>
<span class="cm"> * - make each descriptor in this rx-chain DMA-owned.</span>
<span class="cm"> * - Also set the count to zero. EOP and SOP bits are also cleared.</span>
<span class="cm"> *********************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>
<span class="n">put_frame_lst</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">descp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_rx_flag</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">DESC_STRCT</span>  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">descp</span><span class="p">;</span>
	<span class="n">hcf_16</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">USE_DMA</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span><span class="p">);</span> <span class="c1">//only hcf_dma_tx_put must also be DMA_ENABLED</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">tx_rx_flag</span> <span class="o">==</span> <span class="n">DMA_RX</span> <span class="o">||</span> <span class="n">tx_rx_flag</span> <span class="o">==</span> <span class="n">DMA_TX</span><span class="p">,</span> <span class="n">tx_rx_flag</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">p</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span> <span class="n">p</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">((</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">p</span> <span class="p">);</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DESC_CNT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="p">);</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DESC_CNT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">&amp;=</span> <span class="n">DESC_CNT_MASK</span><span class="p">;</span>                   <span class="c1">//!!this SHOULD be superfluous in case of correct MSF</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">&amp;=</span> <span class="n">tx_rx_flag</span> <span class="o">==</span> <span class="n">DMA_RX</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">DESC_CNT_MASK</span><span class="p">;</span> <span class="c1">//!!this SHOULD be superfluous in case of correct MSF</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">|=</span> <span class="n">DESC_DMA_OWNED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-42"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-42">&#182;</a></div><p>return the just detached FrameList (if any)</p></td><td class="code"><div class="highlight"><pre>			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="o">-&gt;</span><span class="n">desc_phys_addr</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="p">);</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_phys_addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="o">-&gt;</span><span class="n">desc_phys_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                    <span class="c1">//</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_phys_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>            <span class="c1">// DELWA Descriptor</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">descp</span> <span class="o">==</span> <span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">descp</span> <span class="p">);</span>  <span class="c1">//singleton DescriptorList</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]);</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_LastDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_LastDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]);</span>
				<span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//&amp;= ~DESC_DMA_OWNED;</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]</span> <span class="o">=</span> <span class="n">descp</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-43"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-43">&#182;</a></div><p>The MSF is required to supply the HCF with a single descriptor for MSF tx reclaim purposes.
This 'reclaim descriptor' can be recognized by the fact that its buf_addr field is zero.</p></td><td class="code"><div class="highlight"><pre>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                <span class="c1">//a &quot;real&quot; FrameList, hand it over to the DMA engine</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FirstDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">],</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">descp</span> <span class="p">);</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_LastDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">],</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">descp</span> <span class="p">);</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_LastDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_LastDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-44"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-44">&#182;</a></div><pre><code>    HCFASSERT( p-&gt;buf_addr &amp;&amp; p-&gt;buf_phys_addr  &amp;&amp; p-&gt;BUF_SIZE &amp;&amp; +/- p-&gt;BUF_SIZE, ... );
</code></pre></td><td class="code"><div class="highlight"><pre>				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_LastDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="o">=</span> <span class="n">descp</span><span class="p">;</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_LastDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next_desc_phys_addr</span> <span class="o">=</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">desc_phys_addr</span><span class="p">;</span>
				<span class="n">port</span> <span class="o">=</span> <span class="n">HREG_RXDMA_PTR32</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">tx_rx_flag</span> <span class="p">)</span> <span class="p">{</span>
					<span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">|=</span> <span class="n">DESC_EOP</span><span class="p">;</span>    <span class="c1">// p points at the last descriptor in the caller-supplied descriptor chain</span>
					<span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">|=</span> <span class="n">DESC_SOP</span><span class="p">;</span>
					<span class="n">port</span> <span class="o">=</span> <span class="n">HREG_TXDMA_PTR32</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">OUT_PORT_DWORD</span><span class="p">(</span> <span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span> <span class="o">+</span> <span class="n">port</span><span class="p">),</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">desc_phys_addr</span> <span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_LastDesc</span><span class="p">[</span><span class="n">tx_rx_flag</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="c1">// put_frame_lst</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        DESC_STRCT* hcf_dma_rx_get( IFBP ifbp )</span>
<span class="cm"> *.PURPOSE       decapsulate a message and provides that message to the MSF.</span>
<span class="cm"> *               reclaim all descriptors in the rx descriptor chain.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   pointer to a FrameList</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * hcf_dma_rx_get is intended to  return a received frame when such a frame is deposited in Host memory by the</span>
<span class="cm"> * DMA engine. In addition hcf_dma_rx_get can be used to reclaim all descriptors in the rx descriptor chain</span>
<span class="cm"> * when the DMA Engine is disabled, e.g. as part of a driver unloading strategy.</span>
<span class="cm"> * hcf_dma_rx_get must be called repeatedly by the MSF when hcf_service_nic signals availability of a rx frame</span>
<span class="cm"> * through the HREG_EV_RDMAD flag of IFB_DmaPackets. The calling must stop when a NULL pointer is returned, at</span>
<span class="cm"> * which time the HREG_EV_RDMAD flag is also cleared by the HCF to arm the mechanism for the next frame</span>
<span class="cm"> * reception.</span>
<span class="cm"> * Regardless whether the DMA Engine is currently enabled (as controlled via hcf_cntl), if the DMA controller</span>
<span class="cm"> * deposited an Rx-frame in the Rx-DescriptorList, this frame is detached from the Rx-DescriptorList,</span>
<span class="cm"> * transformed into a FrameList (i.e.  updating the housekeeping fields in the descriptors) and returned to the</span>
<span class="cm"> * caller.</span>
<span class="cm"> * If no such Rx-frame is available in the Rx-DescriptorList, the behavior of hcf_dma_rx_get depends on the</span>
<span class="cm"> * status of the DMA Engine.</span>
<span class="cm"> * If the DMA Engine is enabled, a NULL pointer is returned.</span>
<span class="cm"> * If the DMA Engine is disabled, the following strategy is used:</span>
<span class="cm"> * - the complete Rx-DescriptorList is returned. The DELWA Descriptor is not part of the Rx-DescriptorList.</span>
<span class="cm"> * - If there is no Rx-DescriptorList, the DELWA Descriptor is returned.</span>
<span class="cm"> * - If there is no DELWA Descriptor, a NULL pointer is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * If the MSF performs an disable/enable sequence without exhausting the Rx-DescriptorList as described above,</span>
<span class="cm"> * the enable command will reset all house keeping information, i.e. already received but not yet by the MSF</span>
<span class="cm"> * retrieved frames are lost and the next frame will be received starting with the oldest descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * The HCF can be used in 2 fashions: with and without decapsulation for data transfer.</span>
<span class="cm"> * This is controlled at compile time by the HCF_ENC bit of the HCF_ENCAP system constant.</span>
<span class="cm"> * If appropriate, decapsulation is done by moving some data inside the buffers and updating the descriptors</span>
<span class="cm"> * accordingly.</span>
<span class="cm"> *!! ;?????where did I describe why a simple manipulation with the count values does not suffice?</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>

<span class="n">DESC_STRCT</span><span class="o">*</span>
<span class="n">hcf_dma_rx_get</span> <span class="p">(</span><span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">descp</span><span class="p">;</span>  <span class="c1">// pointer to start of FrameList</span>

	<span class="n">descp</span> <span class="o">=</span> <span class="n">get_frame_lst</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">DMA_RX</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">descp</span> <span class="o">&amp;&amp;</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-45"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-45">&#182;</a></div><p>part of alternative ifbp->IFB<em>LastDesc[tx</em>rx<em>flag] = ifbp->IFB</em>FirstDesc[tx<em>rx</em>flag] = descp;
if "recycling" a FrameList
(e.g. called from hcf<em>cntl( HCF</em>CNTL<em>ENABLE )
.  prepare for activation DMA controller
part of alternative descp = descp->next</em>desc_addr;</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if (HCF_ENCAP) == HCF_ENC</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="p">;</span>  <span class="c1">//pointer to 2nd descriptor of frame</span>
		<span class="n">HCFASSERT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-46"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-46">&#182;</a></div><pre><code>        p-&gt;buf_cntl.cntl_stat |= DESC_DMA_OWNED;
</code></pre></td><td class="code"><div class="highlight"><pre>		<span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">wci_recordp</span><span class="p">)</span><span class="o">&amp;</span><span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">HFS_STAT</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">HFS_STAT_MSG_TYPE</span> <span class="o">|</span> <span class="n">HFS_STAT_ERR</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">HFS_STAT_TUNNEL</span> <span class="o">||</span>
		     <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">HFS_STAT_1042</span> <span class="o">&amp;&amp;</span> <span class="n">hcf_encap</span><span class="p">(</span> <span class="p">(</span><span class="n">wci_bufp</span><span class="p">)</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">HCF_DASA_SIZE</span><span class="p">]</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">ENC_TUNNEL</span> <span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-47"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-47">&#182;</a></div><p>skip decapsulation at confined descriptor</p></td><td class="code"><div class="highlight"><pre>			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">==</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-48"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-48">&#182;</a></div><p>The 2nd descriptor contains (maybe) a SNAP header plus part or whole of the payload.
determine decapsulation sub-flag in RxFS</p></td><td class="code"><div class="highlight"><pre>			<span class="n">HCFASSERT</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">&gt;=</span><span class="mi">8</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-49"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-49">&#182;</a></div><p>The 2nd descriptor contains a SNAP header plus part or whole of the payload.</p></td><td class="code"><div class="highlight"><pre>			<span class="k">for</span> <span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span></pre></div></td></tr>


<tr id="section-50"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-50">&#182;</a></div><p>perform decapsulation</p></td><td class="code"><div class="highlight"><pre>			<span class="k">for</span> <span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">HFS_ADDR_DEST</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span></pre></div></td></tr>


<tr id="section-51"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-51">&#182;</a></div><p>move SA[2:5] in the second buffer to replace part of the SNAP header</p></td><td class="code"><div class="highlight"><pre>			<span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">=</span> <span class="n">HFS_ADDR_DEST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_ENC</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">descp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DmaPackets</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="o">~</span><span class="n">HREG_EV_RDMAD</span><span class="p">;</span>  <span class="c1">//;?could be integrated into get_frame_lst</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_DMA_RX_GET</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">descp</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_dma_rx_get</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        void hcf_dma_rx_put( IFBP ifbp, DESC_STRCT *descp )</span>
<span class="cm"> *.PURPOSE       supply buffers for receive purposes.</span>
<span class="cm"> *               supply the Rx-DELWA descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   descp       address of a DescriptorList</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * This function is called by the MSF to supply the HCF with new/more buffers for receive purposes.</span>
<span class="cm"> * The HCF can be used in 2 fashions: with and without encapsulation for data transfer.</span>
<span class="cm"> * This is controlled at compile time by the HCF_ENC bit of the HCF_ENCAP system constant.</span>
<span class="cm"> * As a consequence, some additional constraints apply to the number of descriptor and the buffers associated</span>
<span class="cm"> * with the first 2 descriptors. Independent of the encapsulation feature, the COUNT fields are ignored.</span>
<span class="cm"> * A special case is the supplying of the DELWA descriptor, which must be supplied as the first descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * Assert fails if</span>
<span class="cm"> * - ifbp has a recognizable out-of-range value.</span>
<span class="cm"> * - NIC interrupts are not disabled while required by parameter action.</span>
<span class="cm"> * - in case decapsulation by the HCF is selected:</span>
<span class="cm"> *     - The first databuffer does not have the exact size corresponding with the RxFS up to the 802.3 DestAddr</span>
<span class="cm"> *       field (== 29 words).</span>
<span class="cm"> *     - The FrameList does not consists of at least 2 Descriptors.</span>
<span class="cm"> *     - The second databuffer does not have the minimum size of 8 bytes.</span>
<span class="cm"> *!! The 2nd part of the list of asserts should be kept in sync with put_frame_lst, in order to get</span>
<span class="cm"> *!! them in the WCI-spec !!!!</span>
<span class="cm"> * - DMA is not enabled</span>
<span class="cm"> * - descriptor list is NULL</span>
<span class="cm"> * - a descriptor in the descriptor list is not double word aligned</span>
<span class="cm"> * - a count of size field of a descriptor contains control bits, i.e. bits in the high order nibble.</span>
<span class="cm"> * - the DELWA descriptor is not a &quot;singleton&quot; DescriptorList.</span>
<span class="cm"> * - the DELWA descriptor is not the first Descriptor supplied</span>
<span class="cm"> * - a non_DMA descriptor is supplied before the DELWA Descriptor is supplied</span>
<span class="cm"> *!! - Possibly more checks could be added !!!!!!!!!!!!!</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="kt">void</span>
<span class="n">hcf_dma_rx_put</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">descp</span> <span class="p">)</span>
<span class="p">{</span>

	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_DMA_RX_PUT</span><span class="p">,</span> <span class="mh">0xDA01</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="o">==</span> <span class="n">HCF_MAGIC</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="p">);</span>
	<span class="n">HCFASSERT_INT</span><span class="p">;</span>

	<span class="n">put_frame_lst</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">descp</span><span class="p">,</span> <span class="n">DMA_RX</span> <span class="p">);</span>
<span class="cp">#if HCF_ASSERT &amp;&amp; (HCF_ENCAP) == HCF_ENC</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">==</span> <span class="n">HCF_DMA_RX_BUF1_SIZE</span><span class="p">,</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="p">);</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">// first descriptor should be followed by another descriptor</span></pre></div></td></tr>


<tr id="section-52"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-52">&#182;</a></div><p>copy DA[0:5], SA[0:1] from first buffer to second buffer</p></td><td class="code"><div class="highlight"><pre>		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">,</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCFASSERT / HCF_ENC</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_DMA_RX_PUT</span> <span class="p">);</span>
<span class="p">}</span> <span class="c1">// hcf_dma_rx_put</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        DESC_STRCT* hcf_dma_tx_get( IFBP ifbp )</span>
<span class="cm"> *.PURPOSE       DMA mode: reclaims and decapsulates packets in the tx descriptor chain if:</span>
<span class="cm"> *                - A Tx packet has been copied from host-RAM into NIC-RAM by the DMA engine</span>
<span class="cm"> *                - The Hermes/DMAengine have been disabled</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   pointer to a reclaimed Tx packet.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * impact of the disable command:</span>
<span class="cm"> * When a non-empty pool of Tx descriptors exists (created by means of hcf_dma_put_tx), the MSF</span>
<span class="cm"> * is supposed to empty that pool by means of hcf_dma_tx_get calls after the disable in an</span>
<span class="cm"> * disable/enable sequence.</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">DESC_STRCT</span><span class="o">*</span>
<span class="n">hcf_dma_tx_get</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">descp</span><span class="p">;</span>  <span class="c1">// pointer to start of FrameList</span>

	<span class="n">descp</span> <span class="o">=</span> <span class="n">get_frame_lst</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">DMA_TX</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">descp</span> <span class="o">&amp;&amp;</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-53"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-53">&#182;</a></div><p>make first buffer shorter in count</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if (HCF_ENCAP) == HCF_ENC</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">==</span> <span class="n">HFS_TYPE</span> <span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-54"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-54">&#182;</a></div><p>The second DB is for SNAP and payload purposes. It should be a minimum of 12 bytes in size.</p></td><td class="code"><div class="highlight"><pre>			<span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="o">-&gt;</span><span class="n">buf_phys_addr</span> <span class="o">-=</span> <span class="n">HCF_DASA_SIZE</span><span class="p">;</span>
			<span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span>       <span class="o">+=</span> <span class="n">HCF_DASA_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_ENC</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">descp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">//;?could be integrated into get_frame_lst</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DmaPackets</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="o">~</span><span class="n">HREG_EV_TDMAD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_DMA_TX_GET</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">descp</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_dma_tx_get</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        void hcf_dma_tx_put( IFBP ifbp, DESC_STRCT *descp, hcf_16 tx_cntl )</span>
<span class="cm"> *.PURPOSE       puts a packet in the Tx DMA queue in host ram and kicks off the TxDma engine.</span>
<span class="cm"> *               supply the Tx-DELWA descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   descp       address of Tx Descriptor Chain (i.e. a single Tx frame)</span>
<span class="cm"> *   tx_cntl     indicates MAC-port and (Hermes) options</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * The HCF can be used in 2 fashions: with and without encapsulation for data transfer.</span>
<span class="cm"> * This is controlled at compile time by the HCF_ENC bit of the HCF_ENCAP system constant.</span>
<span class="cm"> *</span>
<span class="cm"> * Regardless of the HCF_ENCAP system constant, the descriptor list created to describe the frame to be</span>
<span class="cm"> * transmitted, must supply space to contain the 802.11 header, preceding the actual frame to be transmitted.</span>
<span class="cm"> * Basically, this only supplies working storage to the HCF which passes this on to the DMA engine.</span>
<span class="cm"> * As a consequence the contents of this space do not matter.</span>
<span class="cm"> * Nevertheless BUF_CNT must take in account this storage.</span>
<span class="cm"> * This working space to contain the 802.11 header may not be fragmented, the first buffer must be</span>
<span class="cm"> * sufficiently large to contain at least the 802.11 header, i.e. HFS_ADDR_DEST (29 words or 0x3A bytes).</span>
<span class="cm"> * This way, the HCF can simply, regardless whether or not the HCF encapsulates the frame, write the parameter</span>
<span class="cm"> * tx_cntl at offset 0x36 (HFS_TX_CNTL) in the first buffer.</span>
<span class="cm"> * Note that it is allowed to have part or all of the actual frame represented by the first descriptor as long</span>
<span class="cm"> * as the requirement for storage for the 802.11 header is met, i.e. the 802.3 frame starts at offset</span>
<span class="cm"> * HFS_ADDR_DEST.</span>
<span class="cm"> * Except for the Assert on the 1st buffer in case of Encapsualtion, the SIZE fields are ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * In case the encapsulation feature is compiled in, there are the following additional requirements.</span>
<span class="cm"> * o The BUF_CNT of the first buffer changes from a minimum of 0x3A bytes to exactly 0x3A, i.e. the workspace</span>
<span class="cm"> *   to store the 802.11 header</span>
<span class="cm"> * o The BUF_SIZE of the first buffer is at least the space needed to store the</span>
<span class="cm"> *   - 802.11 header (29 words)</span>
<span class="cm"> *   - 802.3 header, i.e. 12 bytes addressing information and 2 bytes length field</span>
<span class="cm"> *   - 6 bytes SNAP-header</span>
<span class="cm"> *   This results in 39 words or 0x4E bytes or HFS_TYPE.</span>
<span class="cm"> *   Note that if the BUF_SIZE is larger than 0x4E, this surplus is not used.</span>
<span class="cm"> * o The actual frame begins in the 2nd descriptor (which is already implied by the BUF_CNT == 0x3A requirement) and the associated buffer contains at least the 802.3 header, i.e. the 14 bytes representing addressing information and length/type field</span>
<span class="cm"> *</span>
<span class="cm"> *   When the HCF does not encapsulates (i.e. length/type field &lt;= 1500),  no changes are made to descriptors</span>
<span class="cm"> *   or buffers.</span>
<span class="cm"> *</span>
<span class="cm"> *   When the HCF actually encapsulates (i.e. length/type field &gt; 1500), it successively writes, starting at</span>
<span class="cm"> *   offset HFS_ADDR_DEST (0x3A) in the first buffer:</span>
<span class="cm"> *     - the 802.3 addressing information, copied from the begin of the second buffer</span>
<span class="cm"> *     - the frame length, derived from the total length of the individual fragments, corrected for the SNAP</span>
<span class="cm"> *       header length and Type field and ignoring the Destination Address, Source Address and Length field</span>
<span class="cm"> *     - the appropriate snap header (Tunnel or 1042, depending on the value of the type field).</span>
<span class="cm"> *</span>
<span class="cm"> *    The information in the first two descriptors is adjusted accordingly:</span>
<span class="cm"> *     - the first descriptor count is changed from 0x3A to 0x4E (HFS_TYPE), which matches 0x3A + 12 + 2 + 6</span>
<span class="cm"> *     - the second descriptor count is decreased by 12, being the moved addressing information</span>
<span class="cm"> *     - the second descriptor (physical) buffer address is increased by 12.</span>
<span class="cm"> *</span>
<span class="cm"> * When the descriptors are returned by hcf_dma_tx_get, the transformation of the first two descriptors is</span>
<span class="cm"> * undone.</span>
<span class="cm"> *</span>
<span class="cm"> * Under any of the above scenarios, the assert BUF_CNT &lt;= BUF_SIZE must be true for all descriptors</span>
<span class="cm"> * In case of encapsulation, BUF_SIZE of the 1st descriptor is asserted to be at least HFS_TYPE (0x4E), so it is NOT tested.</span>
<span class="cm"> *</span>
<span class="cm"> * Assert fails if</span>
<span class="cm"> * - ifbp has a recognizable out-of-range value.</span>
<span class="cm"> * - tx_cntl has a recognizable out-of-range value.</span>
<span class="cm"> * - NIC interrupts are not disabled while required by parameter action.</span>
<span class="cm"> * - in case encapsulation by the HCF is selected:</span>
<span class="cm"> *     - The FrameList does not consists of at least 2 Descriptors.</span>
<span class="cm"> *     - The first databuffer does not contain exactly the (space for) the 802.11 header (== 28 words)</span>
<span class="cm"> *     - The first databuffer does not have a size to additionally accommodate the 802.3 header and the</span>
<span class="cm"> *       SNAP header of the frame after encapsulation (== 39 words).</span>
<span class="cm"> *     - The second databuffer does not contain at least DA, SA and &#39;type/length&#39; (==14 bytes or 7 words)</span>
<span class="cm"> *!! The 2nd part of the list of asserts should be kept in sync with put_frame_lst, in order to get</span>
<span class="cm"> *!! them in the WCI-spec !!!!</span>
<span class="cm"> * - DMA is not enabled</span>
<span class="cm"> * - descriptor list is NULL</span>
<span class="cm"> * - a descriptor in the descriptor list is not double word aligned</span>
<span class="cm"> * - a count of size field of a descriptor contains control bits, i.e. bits in the high order nibble.</span>
<span class="cm"> * - the DELWA descriptor is not a &quot;singleton&quot; DescriptorList.</span>
<span class="cm"> * - the DELWA descriptor is not the first Descriptor supplied</span>
<span class="cm"> * - a non_DMA descriptor is supplied before the DELWA Descriptor is supplied</span>
<span class="cm"> *!! - Possibly more checks could be added !!!!!!!!!!!!!</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *1: Write tx_cntl parameter to HFS_TX_CNTL field into the Hermes-specific header in buffer 1</span>
<span class="cm"> *4: determine whether encapsulation is needed and write the type (tunnel or 1042) already at the appropriate</span>
<span class="cm"> *   offset in the 1st buffer</span>
<span class="cm"> *6: Build the encapsualtion enveloppe in the free space at the end of the 1st buffer</span>
<span class="cm"> *   - Copy DA/SA fields from the 2nd buffer</span>
<span class="cm"> *   - Calculate total length of the message (snap-header + type-field + the length of all buffer fragments</span>
<span class="cm"> *     associated with the 802.3 frame (i.e all descriptors except the first), but not the DestinationAddress,</span>
<span class="cm"> *     SourceAddress and length-field)</span>
<span class="cm"> *     Assert the message length</span>
<span class="cm"> *     Write length. Note that the message is in BE format, hence on LE platforms the length must be converted</span>
<span class="cm"> *     ;? THIS IS NOT WHAT CURRENTLY IS IMPLEMENTED</span>
<span class="cm"> *   - Write snap header. Note that the last byte of the snap header is NOT copied, that byte is already in</span>
<span class="cm"> *     place as result of the call to hcf_encap.</span>
<span class="cm"> *   Note that there are many ways to skin a cat. To express the offsets in the 1st buffer while writing</span>
<span class="cm"> *   the snap header, HFS_TYPE is chosen as a reference point to make it easier to grasp that the snap header</span>
<span class="cm"> *   and encapsualtion type are at least relative in the right.</span>
<span class="cm"> *8: modify 1st descriptor to reflect moved part of the 802.3 header + Snap-header</span>
<span class="cm"> *   modify 2nd descriptor to skip the moved part of the 802.3 header (DA/SA</span>
<span class="cm"> *10: set each descriptor to &#39;DMA owned&#39;,  clear all other control bits.</span>
<span class="cm"> *   Set SOP bit on first descriptor. Set EOP bit on last descriptor.</span>
<span class="cm"> *12: Either append the current frame to an existing descriptor list or</span>
<span class="cm"> *14: create a list beginning with the current frame</span>
<span class="cm"> *16: remember the new end of the list</span>
<span class="cm"> *20: hand the frame over to the DMA engine</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="kt">void</span>
<span class="n">hcf_dma_tx_put</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">descp</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">tx_cntl</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">DESC_STRCT</span>  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="p">;</span>
	<span class="kt">int</span>         <span class="n">i</span><span class="p">;</span>

<span class="cp">#if HCF_ASSERT</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">comp_id</span> <span class="o">==</span> <span class="n">COMP_ID_FW_AP</span> <span class="o">?</span> <span class="n">tx_cntl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HFS_TX_CNTL_PORT</span> <span class="o">:</span> <span class="n">tx_cntl</span><span class="p">;</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HCF_TX_CNTL_MASK</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tx_cntl</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT</span>
	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_DMA_TX_PUT</span><span class="p">,</span> <span class="mh">0xDA03</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="o">==</span> <span class="n">HCF_MAGIC</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="p">);</span>
	<span class="n">HCFASSERT_INT</span><span class="p">;</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USE_DMA</span><span class="o">|</span><span class="n">DMA_ENABLED</span><span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">USE_DMA</span><span class="o">|</span><span class="n">DMA_ENABLED</span><span class="p">),</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span> <span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="n">hcf_16</span><span class="o">*</span><span class="p">)(</span><span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span> <span class="o">+</span> <span class="n">HFS_TX_CNTL</span><span class="p">)</span> <span class="o">=</span> <span class="n">tx_cntl</span><span class="p">;</span>                                            <span class="cm">/*1*/</span>
<span class="cp">#if (HCF_ENCAP) == HCF_ENC</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>                                   <span class="c1">//at least 2 descripors</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">==</span> <span class="n">HFS_ADDR_DEST</span><span class="p">,</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="p">);</span>    <span class="c1">//exact length required for 1st buffer</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="o">&gt;=</span> <span class="n">HCF_DMA_TX_BUF1_SIZE</span><span class="p">,</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="p">);</span>   <span class="c1">//minimal storage for encapsulation</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">&gt;=</span> <span class="mi">14</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="p">);</span>                  <span class="c1">//at least DA, SA and &#39;type&#39; in 2nd buffer</span>

		<span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">HFS_TYPE</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hcf_encap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">HCF_DASA_SIZE</span><span class="p">]);</span>       <span class="cm">/*4*/</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">HFS_TYPE</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ENC_NONE</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HCF_DASA_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>                                                       <span class="cm">/*6*/</span>
				<span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">HFS_ADDR_DEST</span><span class="p">]</span> <span class="o">=</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">i</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">snap_header</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">);</span>
			<span class="k">do</span> <span class="p">{</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="p">(</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">);</span>
			<span class="o">*</span><span class="p">(</span><span class="n">hcf_16</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">HFS_LEN</span><span class="p">])</span> <span class="o">=</span> <span class="n">CNV_END_SHORT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   <span class="c1">//!! this converts on ALL platforms, how does that relate to the CCX code</span>
			<span class="k">for</span> <span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">snap_header</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">HFS_TYPE</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">snap_header</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">snap_header</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">=</span> <span class="n">HFS_TYPE</span><span class="p">;</span>                                                                  <span class="cm">/*8*/</span>
			<span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="o">-&gt;</span><span class="n">buf_phys_addr</span>    <span class="o">+=</span> <span class="n">HCF_DASA_SIZE</span><span class="p">;</span>
			<span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span>          <span class="o">-=</span> <span class="n">HCF_DASA_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_ENC</span>
	<span class="p">}</span>
	<span class="n">put_frame_lst</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">descp</span><span class="p">,</span> <span class="n">DMA_TX</span> <span class="p">);</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_DMA_TX_PUT</span> <span class="p">);</span>
<span class="p">}</span> <span class="c1">// hcf_dma_tx_put</span>

<span class="cp">#endif </span><span class="c1">// HCF_DMA</span>

<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        hcf_8 hcf_encap( wci_bufp type )</span>
<span class="cm"> *.PURPOSE       test whether RFC1042 or Bridge-Tunnel encapsulation is needed.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   type        (Far) pointer to the (Big Endian) Type/Length field in the message</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   ENC_NONE        len/type is &quot;len&quot; ( (BIG_ENDIAN)type &lt;= 1500 )</span>
<span class="cm"> *   ENC_TUNNEL      len/type is &quot;type&quot; and 0x80F3 or 0x8137</span>
<span class="cm"> *   ENC_1042        len/type is &quot;type&quot; but not 0x80F3 or 0x8137</span>
<span class="cm"> *</span>
<span class="cm"> *.CONDITIONS</span>
<span class="cm"> *   NIC Interrupts  d.c</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * Type must point to the Len/Type field of the message, this is the 2-byte field immediately after the 6 byte</span>
<span class="cm"> * Destination Address and 6 byte Source Address.  The 2 successive bytes addressed by type are interpreted as</span>
<span class="cm"> * a Big Endian value.  If that value is less than or equal to 1500, the message is assumed to be in 802.3</span>
<span class="cm"> * format.  Otherwise the message is assumed to be in Ethernet-II format.  Depending on the value of Len/Typ,</span>
<span class="cm"> * Bridge Tunnel or RFC1042 encapsulation is needed.</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *  1:   presume 802.3, hence preset return value at ENC_NONE</span>
<span class="cm"> *  2:   convert type from &quot;network&quot; Endian format to native Endian</span>
<span class="cm"> *  4:   the litmus test to distinguish type and len.</span>
<span class="cm"> *   The hard code &quot;magic&quot; value of 1500 is intentional and should NOT be replaced by a mnemonic because it is</span>
<span class="cm"> *   not related at all to the maximum frame size supported  by the Hermes.</span>
<span class="cm"> *  6:   check type against:</span>
<span class="cm"> *       0x80F3  //AppleTalk Address Resolution Protocol (AARP)</span>
<span class="cm"> *       0x8137  //IPX</span>
<span class="cm"> *   to determine the type of encapsulation</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="n">hcf_8</span>
<span class="n">hcf_encap</span><span class="p">(</span> <span class="n">wci_bufp</span> <span class="n">type</span> <span class="p">)</span>
<span class="p">{</span>

	<span class="n">hcf_8</span>   <span class="n">rc</span> <span class="o">=</span> <span class="n">ENC_NONE</span><span class="p">;</span>                                                                                  <span class="cm">/* 1 */</span>
	<span class="n">hcf_16</span>  <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="o">*</span><span class="n">type</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="n">type</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>                                                             <span class="cm">/* 2 */</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">1500</span> <span class="p">)</span> <span class="p">{</span>                                                                                   <span class="cm">/* 4 */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">t</span> <span class="o">==</span> <span class="mh">0x8137</span> <span class="o">||</span> <span class="n">t</span> <span class="o">==</span> <span class="mh">0x80F3</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ENC_TUNNEL</span><span class="p">;</span>                                                                            <span class="cm">/* 6 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ENC_1042</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_encap</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        int hcf_get_info( IFBP ifbp, LTVP ltvp )</span>
<span class="cm"> *.PURPOSE       Obtains transient and persistent configuration information from the Card and from the HCF.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   ltvp        address of LengthTypeValue structure specifying the &quot;what&quot; and the &quot;how much&quot; of the</span>
<span class="cm"> *               information to be collected from the HCF or from the Hermes</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_ERR_LEN         The provided buffer was too small</span>
<span class="cm"> *   HCF_SUCCESS         Success</span>
<span class="cm"> *!! via cmd_exe ( type &gt;= CFG_RID_FW_MIN )</span>
<span class="cm"> *   HCF_ERR_NO_NIC      NIC removed during retrieval</span>
<span class="cm"> *   HCF_ERR_TIME_OUT    Expected Hermes event did not occur in expected time</span>
<span class="cm"> *!! via cmd_exe and setup_bap (type &gt;= CFG_RID_FW_MIN )</span>
<span class="cm"> *   HCF_ERR_DEFUNCT_... HCF is in defunct mode (bits 0x7F reflect cause)</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * The T-field of the LTV-record (provided by the MSF in parameter ltvp) specifies the RID wanted. The RID</span>
<span class="cm"> * information identified by the T-field is copied into the V-field.</span>
<span class="cm"> * On entry, the L-field specifies the size of the buffer, also called the &quot;Initial DataLength&quot;. The L-value</span>
<span class="cm"> * includes the size of the T-field, but not the size of the L-field itself.</span>
<span class="cm"> * On return, the L-field indicates the number of words actually contained by the Type and Value fields.</span>
<span class="cm"> * As the size of the Type field in the LTV-record is included in the &quot;Initial DataLength&quot; of the record, the</span>
<span class="cm"> * V-field can contain at most &quot;Initial DataLength&quot; - 1 words of data.</span>
<span class="cm"> * Copying stops if either the complete Information is copied or if the number of words indicated by the</span>
<span class="cm"> * &quot;Initial DataLength&quot; were copied.  The &quot;Initial DataLength&quot; acts as a safe guard against Configuration</span>
<span class="cm"> * Information blocks that have different sizes for different F/W versions, e.g. when later versions support</span>
<span class="cm"> * more tallies than earlier versions.</span>
<span class="cm"> * If the size of Value field of the RID exceeds the size of the &quot;Initial DataLength&quot; -1, as much data</span>
<span class="cm"> * as fits is copied, and an error status of HCF_ERR_LEN is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * It is the responsibility of the MSF to detect card removal and re-insertion and not call the HCF when the</span>
<span class="cm"> * NIC is absent. The MSF cannot, however, timely detect a Card removal if the Card is removed while</span>
<span class="cm"> * hcf_get_info is in progress.  Therefore, the HCF performs its own check on Card presence after the read</span>
<span class="cm"> * operation of the NIC data.  If the Card is not present or removed during the execution of hcf_get_info,</span>
<span class="cm"> * HCF_ERR_NO_NIC is returned and the content of the Data Buffer is unpredictable. This check is not performed</span>
<span class="cm"> * in case of the &quot;HCF embedded&quot; pseudo RIDs like CFG_TALLIES.</span>
<span class="cm"> *</span>
<span class="cm"> * Assert fails if</span>
<span class="cm"> * - ifbp has a recognizable out-of-range value.</span>
<span class="cm"> * - reentrancy, may be  caused by calling hcf_functions without adequate protection</span>
<span class="cm"> *   against NIC interrupts or multi-threading.</span>
<span class="cm"> * - ltvp is a NULL pointer.</span>
<span class="cm"> * - length field of the LTV-record at entry is 0 or 1 or has an excessive value (i.e. exceeds HCF_MAX_LTV).</span>
<span class="cm"> * - type field of the LTV-record is invalid.</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *   Hcf_get_mb_info copies the contents of the oldest MailBox Info block in the MailBox to PC RAM. If len is</span>
<span class="cm"> *   less than the size of the MailBox Info block, only as much as fits in the PC RAM buffer is copied. After</span>
<span class="cm"> *   the copying the MailBox Read pointer is updated to point to the next MailBox Info block, hence the</span>
<span class="cm"> *   remainder of an &quot;oversized&quot; MailBox Info block is lost. The truncation of the MailBox Info block is NOT</span>
<span class="cm"> *   reflected in the return status. Note that hcf_get_info guarantees the length of the PC RAM buffer meets</span>
<span class="cm"> *   the minimum requirements of at least 2, so no PC RAM buffer overrun.</span>
<span class="cm"> *</span>
<span class="cm"> *   Calling hcf_get_mb_info when their is no MailBox Info block available or when there is no MailBox at all,</span>
<span class="cm"> *   results in a &quot;NULL&quot; MailBox Info block.</span>
<span class="cm"> *</span>
<span class="cm"> *12:    see NOTICE</span>
<span class="cm"> *17: The return status of cmd_wait and the first hcfio_in_string can be ignored, because when one fails, the</span>
<span class="cm"> *   other fails via the IFB_DefunctStat mechanism</span>
<span class="cm"> *20: &quot;HCFASSERT( rc == HCF_SUCCESS, rc )&quot; is not suitable because this will always trigger as side effect of</span>
<span class="cm"> *   the HCFASSERT in hcf_put_info which calls hcf_get_info to figure out whether the RID exists at all.</span>

<span class="cm"> *.NOTICE</span>
<span class="cm"> *</span>
<span class="cm"> *   &quot;HCF embedded&quot; pseudo RIDs:</span>
<span class="cm"> *   CFG_MB_INFO, CFG_TALLIES, CFG_DRV_IDENTITY, CFG_DRV_SUP_RANGE, CFG_DRV_ACT_RANGES_PRI,</span>
<span class="cm"> *   CFG_DRV_ACT_RANGES_STA, CFG_DRV_ACT_RANGES_HSI</span>
<span class="cm"> *   Note the HCF_ERR_LEN is NOT adequately set, when L &gt;= 2 but less than needed</span>
<span class="cm"> *</span>
<span class="cm"> *   Remarks: Transfers operation information and transient and persistent configuration information from the</span>
<span class="cm"> *   Card and from the HCF to the MSF.</span>
<span class="cm"> *   The exact layout of the provided data structure depends on the action code. Copying stops if either the</span>
<span class="cm"> *   complete Configuration Information is copied or if the number of bytes indicated by len is copied.  Len</span>
<span class="cm"> *   acts as a safe guard against Configuration Information blocks which have different sizes for different</span>
<span class="cm"> *   Hermes versions, e.g. when later versions support more tallies than earlier versions. It is a conscious</span>
<span class="cm"> *   decision that unused parts of the PC RAM buffer are not cleared.</span>
<span class="cm"> *</span>
<span class="cm"> *   Remarks: The only error against which is protected is the &quot;Read error&quot; as result of Card removal. Only the</span>
<span class="cm"> *   last hcf_io_string need to be protected because if the first fails the second will fail as well. Checking</span>
<span class="cm"> *   for cmd_exe errors is supposed superfluous because problems in cmd_exe are already caught or will be</span>
<span class="cm"> *   caught by hcf_enable.</span>
<span class="cm"> *</span>
<span class="cm"> *   CFG_MB_INFO: copy the oldest MailBox Info Block or the &quot;null&quot; block if none available.</span>
<span class="cm"> *</span>
<span class="cm"> *   The mechanism to HCF_ASSERT on invalid typ-codes in the LTV record is based on the following strategy:</span>
<span class="cm"> *     - during the pseudo-asynchronous Hermes commands (diagnose, download) only CFG_MB_INFO is acceptable</span>
<span class="cm"> *     - some codes (e.g. CFG_TALLIES) are explicitly handled by the HCF which implies that these codes</span>
<span class="cm"> *       are valid</span>
<span class="cm"> *     - all other codes in the range 0xFC00 through 0xFFFF are passed to the Hermes.  The Hermes returns an</span>
<span class="cm"> *       LTV record with a zero value in the L-field for all Typ-codes it does not recognize. This is</span>
<span class="cm"> *       defined and intended behavior, so HCF_ASSERT does not catch on this phenomena.</span>
<span class="cm"> *     - all remaining codes are invalid and cause an ASSERT.</span>
<span class="cm"> *</span>
<span class="cm"> *.CONDITIONS</span>
<span class="cm"> * In case of USB, HCF_MAX_MSG ;?USED;? to limit the amount of data that can be retrieved via hcf_get_info.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="kt">int</span>
<span class="n">hcf_get_info</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">LTVP</span> <span class="n">ltvp</span> <span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span>         <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>
	<span class="n">hcf_16</span>      <span class="n">len</span> <span class="o">=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">hcf_16</span>      <span class="n">type</span> <span class="o">=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span><span class="p">;</span>
	<span class="n">wci_recordp</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>     <span class="c1">//destination word pointer (in LTV record)</span>
	<span class="n">hcf_16</span>      <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>              <span class="cm">/* source word pointer  Note!! DOS COM can&#39;t cope with FAR</span>
<span class="cm">					     * as a consequence MailBox must be near which is usually true anyway</span>
<span class="cm">					     */</span>
	<span class="kt">int</span>         <span class="n">i</span><span class="p">;</span>

	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_GET_INFO</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="o">==</span> <span class="n">HCF_MAGIC</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="p">);</span>
	<span class="n">HCFASSERT_INT</span><span class="p">;</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ltvp</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">HCF_MAX_LTV</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="p">)</span> <span class="p">);</span>

	<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                              <span class="c1">//default to: No Info Available</span></pre></div></td></tr>


<tr id="section-55"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-55">&#182;</a></div><p>skip decapsulation at confined descriptor</p></td><td class="code"><div class="highlight"><pre>	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span> <span class="n">q</span> <span class="o">=</span> <span class="n">xxxx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">type</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="cm">/*NOP*/</span><span class="p">;</span>

<span class="cp">#if HCF_TALLIES</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CFG_TALLIES</span> <span class="p">)</span> <span class="p">{</span>                                                    <span class="cm">/*3*/</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">hcf_action</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCF_ACT_TALLIES</span> <span class="p">);</span>
		<span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TallyLen</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_TALLIES</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CFG_MB_INFO</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBInfoLen</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span><span class="p">[</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFFFF</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//;?Probably superfluous</span>
			<span class="p">}</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span><span class="p">[</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span><span class="p">];</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span> <span class="o">+=</span> <span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">//update read pointer</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span><span class="p">[</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFFFF</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBInfoLen</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span><span class="p">[</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">q</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>                      <span class="c1">//a special or CFG_TALLIES or CFG_MB_INFO</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="n">len</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>             <span class="c1">//total size of destination (including T-field)</span>
		<span class="k">while</span> <span class="p">(</span> <span class="n">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
<span class="cp">#if (HCF_TALLIES) &amp; HCF_TALLIES_RESET</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">q</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TallyTyp</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CFG_TALLIES</span> <span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_TALLIES_RESET</span>
			<span class="n">q</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                <span class="c1">// not a special nor CFG_TALLIES nor CFG_MB_INFO</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CFG_CNTL_OPT</span> <span class="p">)</span> <span class="p">{</span>                                       <span class="c1">//read back effective options</span>
			<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span><span class="p">;</span>
<span class="cp">#if (HCF_EXT) &amp; HCF_EXT_NIC_ACCESS</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CFG_PROD_DATA</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">//only needed for some test tool on top of H-II NDIS driver</span>
			<span class="n">hcf_io</span>      <span class="n">io_port</span><span class="p">;</span>
			<span class="n">wci_bufp</span>    <span class="n">pt</span><span class="p">;</span>                 <span class="c1">//pointer with the &quot;right&quot; type, just to help ease writing macros with embedded assembly</span>
			<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_AUX_PAGE</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">PLUG_DATA_OFFSET</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">);</span>
			<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_AUX_OFFSET</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">PLUG_DATA_OFFSET</span> <span class="o">&amp;</span> <span class="mh">0x7E</span><span class="p">)</span> <span class="p">);</span>
			<span class="n">io_port</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span> <span class="o">+</span> <span class="n">HREG_AUX_DATA</span><span class="p">;</span>     <span class="c1">//to prevent side effects of the MSF-defined macro</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>                  <span class="c1">//destination char pointer (in LTV record)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">wci_bufp</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>   <span class="c1">//just to help ease writing macros with embedded assembly</span>
				<span class="n">IN_PORT_STRING_8_16</span><span class="p">(</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">i</span> <span class="p">);</span> <span class="c1">//space used by T: -1</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CFG_CMD_HCF</span> <span class="p">)</span> <span class="p">{</span>
<span class="cp">#define P ((CFG_CMD_HCF_STRCT FAR *)ltvp)</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">CFG_CMD_HCF_REG_ACCESS</span><span class="p">,</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="p">);</span>       <span class="c1">//only Hermes register access supported</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">CFG_CMD_HCF_REG_ACCESS</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&lt;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span><span class="p">,</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="p">);</span>        <span class="c1">//Check Register space</span>
				<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="n">len</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>                              <span class="c1">//RESTORE ltv length</span>
				<span class="n">P</span><span class="o">-&gt;</span><span class="n">add_info</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#undef P</span>
<span class="cp">#endif </span><span class="c1">// HCF_EXT_NIC_ACCESS</span>
<span class="cp">#if (HCF_ASSERT) &amp; HCF_ASSERT_PRINTF</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CFG_FW_PRINTF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">fw_printf</span><span class="p">(</span><span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">CFG_FW_PRINTF_STRCT</span><span class="o">*</span><span class="p">)</span><span class="n">ltvp</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_PRINTF</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">type</span> <span class="o">&gt;=</span> <span class="n">CFG_RID_FW_MIN</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-56"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-56">&#182;</a></div><p>perform decapsulation if needed</p></td><td class="code"><div class="highlight"><pre>		<span class="cm">/*17*/</span>  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCMD_ACCESS</span><span class="p">,</span> <span class="n">type</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span> <span class="o">&amp;&amp;</span>
				 <span class="p">(</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">setup_bap</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IO_IN</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">get_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">wci_bufp</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">len</span><span class="o">+</span><span class="mi">2</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_STAT</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFFFF</span> <span class="p">)</span> <span class="p">{</span>                 <span class="c1">//NIC removal test</span>
					<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">type</span> <span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
	<span class="cm">/*12*/</span>  <span class="p">}</span> <span class="k">else</span> <span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">type</span> <span class="p">)</span> <span class="cm">/*NOP*/</span><span class="p">;</span> <span class="c1">//NOP in case HCFASSERT is dummy</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_ERR_LEN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span> <span class="o">||</span> <span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_ERR_LEN</span> <span class="o">&amp;&amp;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertTrace</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">HCF_TRACE_PUT_INFO</span> <span class="p">),</span>
		   <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">type</span><span class="p">,</span> <span class="n">rc</span> <span class="p">)</span> <span class="p">);</span>                                                                <span class="cm">/*20*/</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_GET_INFO</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_get_info</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        int hcf_put_info( IFBP ifbp, LTVP ltvp )</span>
<span class="cm"> *.PURPOSE       Transfers operation and configuration information to the Card and to the HCF.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   ltvp        specifies the RID (as defined by Hermes I/F) or pseudo-RID (as defined by WCI)</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_SUCCESS</span>
<span class="cm"> *!! via cmd_exe</span>
<span class="cm"> *   HCF_ERR_NO_NIC      NIC removed during data retrieval</span>
<span class="cm"> *   HCF_ERR_TIME_OUT    Expected F/W event did not occur in time</span>
<span class="cm"> *   HCF_ERR_DEFUNCT_...</span>
<span class="cm"> *!! via download                CFG_DLNV_START &lt;= type &lt;= CFG_DL_STOP</span>
<span class="cm"> *!! via put_info                CFG_RID_CFG_MIN &lt;= type &lt;= CFG_RID_CFG_MAX</span>
<span class="cm"> *!! via put_frag</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * The L-field of the LTV-record (provided by the MSF in parameter ltvp) specifies the size of the buffer.</span>
<span class="cm"> * The L-value includes the size of the T-field, but not the size of the L-field.</span>
<span class="cm"> * The T- field specifies the RID placed in the V-field by the MSF.</span>
<span class="cm"> *</span>
<span class="cm"> * Not all CFG-codes can be used for hcf_put_info.  The following CFG-codes are valid for hcf_put_info:</span>
<span class="cm"> * o One of the CFG-codes in the group &quot;Network Parameters, Static Configuration Entities&quot;</span>
<span class="cm"> * Changes made by hcf_put_info to CFG_codes in this group will not affect the F/W</span>
<span class="cm"> * and HCF behavior until hcf_cntl_port( HCF_PORT_ENABLE) is called.</span>
<span class="cm"> * o One of the CFG-codes in the group &quot;Network Parameters, Dynamic Configuration Entities&quot;</span>
<span class="cm"> * Changes made by hcf_put_info to CFG_codes will affect the F/W and HCF behavior immediately.</span>
<span class="cm"> * o CFG_PROG.</span>
<span class="cm"> * This code is used to initiate and terminate the process to download data either to</span>
<span class="cm"> * volatile or to non-volatile RAM on the NIC as well as for the actual download.</span>
<span class="cm"> * o CFG-codes related to the HCF behavior.</span>
<span class="cm"> * The related CFG-codes are:</span>
<span class="cm"> *  - CFG_REG_MB</span>
<span class="cm"> *  - CFG_REG_ASSERT_RTNP</span>
<span class="cm"> *  - CFG_REG_INFO_LOG</span>
<span class="cm"> *  - CFG_CMD_NIC</span>
<span class="cm"> *  - CFG_CMD_DONGLE</span>
<span class="cm"> *  - CFG_CMD_HCF</span>
<span class="cm"> *  - CFG_NOTIFY</span>
<span class="cm"> *</span>
<span class="cm"> * All LTV-records &quot;unknown&quot; to the HCF are forwarded to the F/W.</span>
<span class="cm"> *</span>
<span class="cm"> * Assert fails if</span>
<span class="cm"> * - ifbp has a recognizable out-of-range value.</span>
<span class="cm"> * - ltvp is a NULL pointer.</span>
<span class="cm"> * - hcf_put_info was called without prior call to hcf_connect</span>
<span class="cm"> * - type field of the LTV-record is invalid, i.e. neither HCF nor F/W can handle the value.</span>
<span class="cm"> * - length field of the LTV-record at entry is less than 1 or exceeds MAX_LTV_SIZE.</span>
<span class="cm"> * - registering a MailBox with size less than 60 or a non-aligned buffer address is used.</span>
<span class="cm"> * - reentrancy, may be  caused by calling hcf_functions without adequate protection against</span>
<span class="cm"> *   NIC interrupts or multi-threading.</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *   Remarks:  In case of Hermes Configuration LTVs, the codes for the type are &quot;cleverly&quot; chosen to be</span>
<span class="cm"> *   identical to the RID. Hermes Configuration information is copied from the provided data structure into the</span>
<span class="cm"> *   Card.</span>
<span class="cm"> *   In case of HCF Configuration LTVs, the type values are chosen in a range which does not overlap the</span>
<span class="cm"> *   RID-range.</span>
<span class="cm"> *</span>
<span class="cm"> *20:</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>

<span class="kt">int</span>
<span class="n">hcf_put_info</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">LTVP</span> <span class="n">ltvp</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>

	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_PUT_INFO</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="o">==</span> <span class="n">HCF_MAGIC</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="p">);</span>
	<span class="n">HCFASSERT_INT</span><span class="p">;</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ltvp</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">HCF_MAX_LTV</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-57"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-57">&#182;</a></div><p>filter out all specials</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
	<span class="p">{</span>
		<span class="n">hcf_16</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">hcf_32</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">key_p</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">==</span> <span class="n">CFG_ADD_TKIP_DEFAULT_KEY</span> <span class="o">||</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">==</span> <span class="n">CFG_ADD_TKIP_MAPPED_KEY</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">key_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_32</span><span class="o">*</span><span class="p">)((</span><span class="n">CFG_ADD_TKIP_MAPPED_KEY_STRCT</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">ltvp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_mic_key</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">TX_KEY</span><span class="p">;</span>     <span class="c1">//i.e. TxKeyIndicator == 1, KeyID == 0</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">==</span> <span class="n">CFG_ADD_TKIP_DEFAULT_KEY</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">key_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_32</span><span class="o">*</span><span class="p">)((</span><span class="n">CFG_ADD_TKIP_DEFAULT_KEY_STRCT</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">ltvp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_mic_key</span><span class="p">;</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(((</span><span class="n">CFG_ADD_TKIP_DEFAULT_KEY_STRCT</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">ltvp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tkip_key_id_info</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">TX_KEY</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/* TxKeyIndicator == 1</span>
<span class="cm">					       (either really set by MSF in case of DEFAULT or faked by HCF in case of MAPPED ) */</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCntl</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span> <span class="n">HFS_TX_CNTL_MIC</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">KEY_ID</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="p">);</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxKey</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CNV_LONGP_TO_LITTLE</span><span class="p">(</span> <span class="n">key_p</span> <span class="p">);</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxKey</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CNV_LONGP_TO_LITTLE</span><span class="p">(</span> <span class="p">(</span><span class="n">key_p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
			<span class="p">}</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">KEY_ID</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxKey</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="n">CNV_LONGP_TO_LITTLE</span><span class="p">(</span> <span class="p">(</span><span class="n">key_p</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">);</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxKey</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CNV_LONGP_TO_LITTLE</span><span class="p">(</span> <span class="p">(</span><span class="n">key_p</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#define P ((CFG_REMOVE_TKIP_DEFAULT_KEY_STRCT FAR *)ltvp)</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">==</span> <span class="n">CFG_REMOVE_TKIP_MAPPED_KEY</span> <span class="p">)</span>    <span class="o">||</span>
		     <span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">==</span> <span class="n">CFG_REMOVE_TKIP_DEFAULT_KEY</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span> <span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCntl</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">KEY_ID</span> <span class="p">)</span> <span class="o">==</span> <span class="n">CNV_SHORT_TO_LITTLE</span><span class="p">(</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">tkip_key_id</span> <span class="p">)</span>
			     <span class="p">)</span>
			<span class="p">)</span> <span class="p">{</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCntl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>      <span class="c1">//disable MIC-engine</span>
<span class="cp">#undef P</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">==</span> <span class="n">CFG_PROG</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">download</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">CFG_PROG_STRCT</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">ltvp</span> <span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">switch</span> <span class="p">(</span><span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if (HCF_ASSERT) &amp; HCF_ASSERT_RT_MSF_RTN</span>
		<span class="k">case</span> <span class="n">CFG_REG_ASSERT_RTNP</span>:                                         <span class="c1">//Register MSF Routines</span>
<span class="cp">#define P ((CFG_REG_ASSERT_RTNP_STRCT FAR *)ltvp)</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertRtn</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">rtnp</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-58"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-58">&#182;</a></div><p>;? by using HCMD<em>BUSY option when calling cmd</em>exe, using a get<em>frag with length 0 just to set up the
;? BAP and calling cmd</em>cmpl, you could merge the 2 Busy waits. Whether this really helps (and what
;? would be the optimal sequence in cmd<em>exe and get</em>frag) would have to be MEASURED</p></td><td class="code"><div class="highlight"><pre>			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">HCF_ASSERT</span><span class="p">,</span> <span class="mh">0xCAF1</span> <span class="p">)</span> <span class="p">);</span>   <span class="c1">//just to proof that the complete assert machinery is working</span>
<span class="cp">#undef P</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_RT_MSF_RTN</span>
<span class="cp">#if (HCF_EXT) &amp; HCF_EXT_INFO_LOG</span>
		<span class="k">case</span> <span class="n">CFG_REG_INFO_LOG</span>:                                            <span class="c1">//Register Log filter</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RIDLogp</span> <span class="o">=</span> <span class="p">((</span><span class="n">CFG_RID_LOG_STRCT</span> <span class="n">FAR</span><span class="o">*</span><span class="p">)</span><span class="n">ltvp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">recordp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_EXT_INFO_LOG</span>
		<span class="k">case</span> <span class="n">CFG_CNTL_OPT</span>:                                                <span class="c1">//overrule option</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">USE_DMA</span> <span class="o">|</span> <span class="n">USE_16BIT</span><span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">USE_DMA</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USE_DMA</span><span class="p">;</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">|=</span>  <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">USE_16BIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">CFG_REG_MB</span>:                                                  <span class="c1">//Register MailBox</span>
<span class="cp">#define P ((CFG_REG_MB_STRCT FAR *)ltvp)</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">mb_addr</span> <span class="o">&amp;</span> <span class="mh">0x0001</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">mb_addr</span> <span class="p">);</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mb_size</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">,</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mb_size</span> <span class="p">);</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">mb_addr</span><span class="p">;</span>
			<span class="cm">/* if no MB present, size must be 0 for ;?the old;? put_info_mb to work correctly */</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBSize</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">mb_size</span><span class="p">;</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                           <span class="c1">//flag the MailBox as empty</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBInfoLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBSize</span> <span class="o">&gt;=</span> <span class="mi">60</span> <span class="o">||</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBSize</span> <span class="p">);</span>
<span class="cp">#undef P</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CFG_MB_INFO</span>:                                                 <span class="c1">//store MailBoxInfoBlock</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">put_info_mb</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">CFG_MB_INFO_STRCT</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">ltvp</span> <span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

<span class="cp">#if (HCF_EXT) &amp; HCF_EXT_NIC_ACCESS</span>
		<span class="k">case</span> <span class="n">CFG_CMD_NIC</span>:
<span class="cp">#define P ((CFG_CMD_NIC_STRCT FAR *)ltvp)</span>
			<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_PARAM_2</span><span class="p">,</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">parm2</span> <span class="p">);</span>
			<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_PARAM_1</span><span class="p">,</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">parm1</span> <span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">parm0</span> <span class="p">);</span>
			<span class="n">P</span><span class="o">-&gt;</span><span class="n">hcf_stat</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">rc</span><span class="p">;</span>
			<span class="n">P</span><span class="o">-&gt;</span><span class="n">stat</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_STAT</span> <span class="p">);</span>
			<span class="n">P</span><span class="o">-&gt;</span><span class="n">resp0</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_RESP_0</span> <span class="p">);</span>
			<span class="n">P</span><span class="o">-&gt;</span><span class="n">resp1</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_RESP_1</span> <span class="p">);</span>
			<span class="n">P</span><span class="o">-&gt;</span><span class="n">resp2</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_RESP_2</span> <span class="p">);</span>
			<span class="n">P</span><span class="o">-&gt;</span><span class="n">ifb_err_cmd</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_ErrCmd</span><span class="p">;</span>
			<span class="n">P</span><span class="o">-&gt;</span><span class="n">ifb_err_qualifier</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_ErrQualifier</span><span class="p">;</span>
<span class="cp">#undef P</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CFG_CMD_HCF</span>:
<span class="cp">#define P ((CFG_CMD_HCF_STRCT FAR *)ltvp)</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">CFG_CMD_HCF_REG_ACCESS</span><span class="p">,</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="p">);</span>       <span class="c1">//only Hermes register access supported</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">CFG_CMD_HCF_REG_ACCESS</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&lt;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span><span class="p">,</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="p">);</span>        <span class="c1">//Check Register space</span>
				<span class="n">OPW</span><span class="p">(</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">add_info</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#undef P</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_EXT_NIC_ACCESS</span>

<span class="cp">#if (HCF_ASSERT) &amp; HCF_ASSERT_PRINTF</span>
		<span class="k">case</span> <span class="n">CFG_FW_PRINTF_BUFFER_LOCATION</span>:
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FwPfBuff</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">CFG_FW_PRINTF_BUFFER_LOCATION_STRCT</span><span class="o">*</span><span class="p">)</span><span class="n">ltvp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_PRINTF</span>

		<span class="nl">default:</span>                      <span class="c1">//pass everything unknown above the &quot;FID&quot; range to the Hermes or Dongle</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">put_info</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">ltvp</span> <span class="p">);</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-59"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-59">&#182;</a></div><p>all codes between 0xFA00 and 0xFCFF are passed to Hermes</p></td><td class="code"><div class="highlight"><pre>	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_PUT_INFO</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_put_info</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        int hcf_rcv_msg( IFBP ifbp, DESC_STRCT *descp, unsigned int offset )</span>
<span class="cm"> *.PURPOSE       All: decapsulate a message.</span>
<span class="cm"> *               pre-HermesII.5: verify MIC.</span>
<span class="cm"> *               non-USB, non-DMA mode: Transfer a message from the NIC to the Host and acknowledge reception.</span>
<span class="cm"> *               USB: Transform a message from proprietary USB format to 802.3 format</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   descp       Pointer to the Descriptor List location.</span>
<span class="cm"> *   offset      USB: not used</span>
<span class="cm"> *               non-USB: specifies the beginning of the data to be obtained (0 corresponds with DestAddr field</span>
<span class="cm"> *               of frame).</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_SUCCESS         No WPA error ( or HCF_ERR_MIC already reported by hcf_service_nic)</span>
<span class="cm"> *   HCF_ERR_MIC         message contains an erroneous MIC ( HCF_SUCCESS is reported if HCF_ERR_MIC is already</span>
<span class="cm"> *                       reported by hcf_service_nic)</span>
<span class="cm"> *   HCF_ERR_NO_NIC      NIC removed during data retrieval</span>
<span class="cm"> *   HCF_ERR_DEFUNCT...</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * The Receive Message Function can be executed by the MSF to obtain the Data Info fields of the message that</span>
<span class="cm"> * is reported to be available by the Service NIC Function.</span>
<span class="cm"> *</span>
<span class="cm"> * The Receive Message Function copies the message data available in the Card memory into a buffer structure</span>
<span class="cm"> * provided by the MSF.</span>
<span class="cm"> * Only data of the message indicated by the Service NIC Function can be obtained.</span>
<span class="cm"> * Execution of the Service NIC function may result in the availability of a new message, but it definitely</span>
<span class="cm"> * makes the message reported by the preceding Service NIC function, unavailable.</span>
<span class="cm"> *</span>
<span class="cm"> * in non-USB/non-DMA mode, hcf_rcv_msg starts the copy process at the (non-negative) offset requested by the</span>
<span class="cm"> * parameter offset, relative to HFS_ADDR_DEST, e.g offset 0 starts copying from the Destination Address, the</span>
<span class="cm"> * very begin of the 802.3 frame message. Offset must either lay within the part of the 802.3 frame as stored</span>
<span class="cm"> * by hcf_service_nic in the lookahead buffer or be just behind it, i.e. the first byte not yet read.</span>
<span class="cm"> * When offset is within lookahead, data is copied from lookahead.</span>
<span class="cm"> * When offset is beyond lookahead, data is read directly from RxFS in NIC with disregard of the actual value</span>
<span class="cm"> * of offset</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE:</span>
<span class="cm"> * o at entry: look ahead buffer as passed with hcf_service_nic is still accessible and unchanged</span>
<span class="cm"> * o at exit: Receive Frame in NIC memory is released</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Starting at the byte indicated by the Offset value, the bytes are copied from the Data Info</span>
<span class="cm"> * Part of the current Receive Frame Structure to the Host memory data buffer structure</span>
<span class="cm"> * identified by descp.</span>
<span class="cm"> * The maximum value for Offset is the number of characters of the 802.3 frame read into the</span>
<span class="cm"> * look ahead buffer by hcf_service_nic (i.e. the look ahead buffer size minus</span>
<span class="cm"> * Control and 802.11 fields)</span>
<span class="cm"> * If Offset is less than the maximum value, copying starts from the look ahead buffer till the</span>
<span class="cm"> * end of that buffer is reached</span>
<span class="cm"> * Then (or if the maximum value is specified for Offset), the</span>
<span class="cm"> * message is directly copied from NIC memory to Host memory.</span>
<span class="cm"> * If an invalid (i.e. too large) offset is specified, an assert catches but the buffer contents are</span>
<span class="cm"> * undefined.</span>
<span class="cm"> * Copying stops if either:</span>
<span class="cm"> * o the end of the 802.3 frame is reached</span>
<span class="cm"> * o the Descriptor with a NULL pointer in the next_desc_addr field is reached</span>
<span class="cm"> *</span>
<span class="cm"> * When the copying stops, the receiver is ack&#39;ed, thus freeing the NIC memory where the frame is stored</span>
<span class="cm"> * As a consequence, hcf_rcv_msg can only be called once for any particular Rx frame.</span>
<span class="cm"> *</span>
<span class="cm"> * For the time being (PCI Bus mastering not yet supported), only the following fields of each</span>
<span class="cm"> * of the descriptors in the descriptor list must be set by the MSF:</span>
<span class="cm"> * o buf_cntl.buf_dim[1]</span>
<span class="cm"> * o *next_desc_addr</span>
<span class="cm"> * o *buf_addr</span>
<span class="cm"> * At return from hcf_rcv_msg, the field buf_cntl.buf_dim[0] of the used Descriptors reflects</span>
<span class="cm"> * the number of bytes in the buffer corresponding with the Descriptor.</span>
<span class="cm"> * On the last used Descriptor, buf_cntl.buf_dim[0] is less or equal to buf_cntl.buf_dim[1].</span>
<span class="cm"> * On all preceding Descriptors buf_cntl.buf_dim[0] is equal to buf_cntl.buf_dim[1].</span>
<span class="cm"> * On all succeeding (unused) Descriptors, buf_cntl.buf_dim[0] is zero.</span>
<span class="cm"> * Note: this I/F is based on the assumptions how the I/F needed for PCI Bus mastering will</span>
<span class="cm"> * be, so it may change.</span>
<span class="cm"> *</span>
<span class="cm"> * The most likely handling of HCF_ERR_NO_NIC by the MSF is to drop the already copied</span>
<span class="cm"> * data as elegantly as possible under the constraints and requirements posed by the (N)OS.</span>
<span class="cm"> * If no received Frame Structure is pending, &quot;Success&quot; rather than &quot;Read error&quot; is returned.</span>
<span class="cm"> * This error constitutes a logic flaw in the MSF</span>
<span class="cm"> * The HCF can only catch a minority of this</span>
<span class="cm"> * type of errors</span>
<span class="cm"> * Based on consistency ideas, the HCF catches none of these errors.</span>
<span class="cm"> *</span>
<span class="cm"> * Assert fails if</span>
<span class="cm"> * - ifbp has a recognizable out-of-range value</span>
<span class="cm"> * - there is no unacknowledged Rx-message available</span>
<span class="cm"> * - offset is out of range (outside look ahead buffer)</span>
<span class="cm"> * - descp is a NULL pointer</span>
<span class="cm"> * - any of the descriptors is not double word aligned</span>
<span class="cm"> * - reentrancy, may be  caused by calling hcf_functions without adequate protection</span>
<span class="cm"> *   against NIC interrupts or multi-threading.</span>
<span class="cm"> * - Interrupts are enabled.</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> * - by using unsigned int as type for offset, no need to worry about negative offsets</span>
<span class="cm"> * - Asserting on being enabled/present is superfluous, since a non-zero IFB_lal implies that hcf_service_nic</span>
<span class="cm"> *   was called and detected a Rx-message. A zero IFB_lal will set the BUF_CNT field of at least the first</span>
<span class="cm"> *   descriptor to zero.</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="kt">int</span>
<span class="n">hcf_rcv_msg</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">descp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>         <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>
	<span class="n">wci_bufp</span>    <span class="n">cp</span><span class="p">;</span>                                     <span class="c1">//char oriented working pointer</span>
	<span class="n">hcf_16</span>      <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>         <span class="n">tot_len</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>     <span class="c1">//total length</span>
	<span class="n">wci_bufp</span>    <span class="n">lap</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_lap</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>           <span class="c1">//start address in LookAhead Buffer</span>
	<span class="n">hcf_16</span>      <span class="n">lal</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_lal</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>           <span class="c1">//available data within LookAhead Buffer</span>
	<span class="n">hcf_16</span>      <span class="n">j</span><span class="p">;</span>

	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_RCV_MSG</span><span class="p">,</span> <span class="n">offset</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="o">==</span> <span class="n">HCF_MAGIC</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="p">);</span>
	<span class="n">HCFASSERT_INT</span><span class="p">;</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">descp</span><span class="p">,</span> <span class="n">HCF_TRACE_RCV_MSG</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span><span class="p">,</span> <span class="n">HCF_TRACE_RCV_MSG</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span> <span class="o">&gt;=</span> <span class="n">offset</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span> <span class="p">)</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_lal</span> <span class="o">&gt;=</span> <span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">USE_DMA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xDADA</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">tot_len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">lal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tot_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>               <span class="c1">//suppress all copying activity in the do--while loop</span>
	<span class="p">}</span>
	<span class="k">do</span> <span class="p">{</span>                                    <span class="c1">//loop over all available fragments</span></pre></div></td></tr>


<tr id="section-60"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-60">&#182;</a></div><pre><code>    ifbp-&gt;IFB_AssertLvl = P-&gt;lvl;       //TODO not yet supported so default is set in hcf_connect
</code></pre></td><td class="code"><div class="highlight"><pre>		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">((</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">descp</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">descp</span> <span class="p">);</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">;</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">tot_len</span><span class="p">,</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_SIZE</span> <span class="p">);</span>    <span class="c1">//minimum of &quot;what&#39;s` available&quot; and fragment size</span>
		<span class="n">descp</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">tot_len</span> <span class="o">-=</span> <span class="n">j</span><span class="p">;</span>                       <span class="c1">//adjust length still to go</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">lal</span> <span class="p">)</span> <span class="p">{</span>                        <span class="c1">//if lookahead Buffer not yet completely copied</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="n">lal</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span>              <span class="c1">//minimum of &quot;what&#39;s available&quot; in LookAhead and fragment size</span>
			<span class="n">lal</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>                       <span class="c1">//adjust length still available in LookAhead</span>
			<span class="n">j</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>                         <span class="c1">//adjust length still available in current fragment</span>
			<span class="cm">/*;? while loop could be improved by moving words but that is complicated on platforms with</span>
<span class="cm">			 * alignment requirements*/</span>
			<span class="k">while</span> <span class="p">(</span> <span class="n">i</span><span class="o">--</span> <span class="p">)</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">lap</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">j</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">//if LookAhead Buffer exhausted but still space in fragment, copy directly from NIC RAM</span>
			<span class="n">get_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">j</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
			<span class="n">CALC_RX_MIC</span><span class="p">(</span> <span class="n">cp</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="p">(</span> <span class="n">descp</span> <span class="o">=</span> <span class="n">descp</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxFID</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">check_mic</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>             <span class="c1">//prevents MIC error report if hcf_service_nic already consumed all</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">hcf_action</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCF_ACT_RX_ACK</span> <span class="p">);</span>       <span class="c1">//only 1 shot to get the data, so free the resources in the NIC</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span><span class="p">,</span> <span class="n">rc</span> <span class="p">);</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_RCV_MSG</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_rcv_msg</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        int hcf_send_msg( IFBP ifbp, DESC_STRCT *descp, hcf_16 tx_cntl )</span>
<span class="cm"> *.PURPOSE       Encapsulate a message and append padding and MIC.</span>
<span class="cm"> *               non-USB: Transfers the resulting message from Host to NIC and initiates transmission.</span>
<span class="cm"> *               USB: Transfer resulting message into a flat buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   descp       pointer to the DescriptorList or NULL</span>
<span class="cm"> *   tx_cntl     indicates MAC-port and (Hermes) options</span>
<span class="cm"> *                   HFS_TX_CNTL_SPECTRALINK</span>
<span class="cm"> *                   HFS_TX_CNTL_PRIO</span>
<span class="cm"> *                   HFS_TX_CNTL_TX_OK</span>
<span class="cm"> *                   HFS_TX_CNTL_TX_EX</span>
<span class="cm"> *                   HFS_TX_CNTL_TX_DELAY</span>
<span class="cm"> *                   HFS_TX_CNTL_TX_CONT</span>
<span class="cm"> *                   HCF_PORT_0               MAC Port 0 (default)</span>
<span class="cm"> *                   HCF_PORT_1 (AP only)     MAC Port 1</span>
<span class="cm"> *                   HCF_PORT_2 (AP only)     MAC Port 2</span>
<span class="cm"> *                   HCF_PORT_3 (AP only)     MAC Port 3</span>
<span class="cm"> *                   HCF_PORT_4 (AP only)     MAC Port 4</span>
<span class="cm"> *                   HCF_PORT_5 (AP only)     MAC Port 5</span>
<span class="cm"> *                   HCF_PORT_6 (AP only)     MAC Port 6</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_SUCCESS</span>
<span class="cm"> *   HCF_ERR_DEFUNCT_..</span>
<span class="cm"> *   HCF_ERR_TIME_OUT</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION:</span>
<span class="cm"> * The Send Message Function embodies 2 functions:</span>
<span class="cm"> * o transfers a message (including MAC header) from the provided buffer structure in Host memory to the Transmit</span>
<span class="cm"> * Frame Structure (TxFS) in NIC memory.</span>
<span class="cm"> * o Issue a send command to the F/W to actually transmit the contents of the TxFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Control is based on the Resource Indicator IFB_RscInd.</span>
<span class="cm"> * The Resource Indicator is maintained by the HCF and should only be interpreted but not changed by the MSF.</span>
<span class="cm"> * The MSF must check IFB_RscInd to be non-zero before executing the call to the Send Message Function.</span>
<span class="cm"> * When no resources are available, the MSF must handle the queuing of the Transmit frame and check the</span>
<span class="cm"> * Resource Indicator periodically after calling hcf_service_nic.</span>
<span class="cm"> *</span>
<span class="cm"> * The Send Message Functions transfers a message to NIC memory when it is called with a non-NULL descp.</span>
<span class="cm"> * Before the Send Message Function is invoked this way, the Resource Indicator (IFB_RscInd) must be checked.</span>
<span class="cm"> * If the Resource is not available, Send Message Function execution must be postponed until after processing of</span>
<span class="cm"> * a next hcf_service_nic it appears that the Resource has become available.</span>
<span class="cm"> * The message is copied from the buffer structure identified by descp to the NIC.</span>
<span class="cm"> * Copying stops if a NULL pointer in the next_desc_addr field is reached.</span>
<span class="cm"> * Hcf_send_msg does not check for transmit buffer overflow, because the F/W does this protection.</span>
<span class="cm"> * In case of a transmit buffer overflow, the surplus which does not fit in the buffer is simply dropped.</span>
<span class="cm"> *</span>
<span class="cm"> * The Send Message Function activates the F/W to actually send the message to the medium when the</span>
<span class="cm"> * HFS_TX_CNTL_TX_DELAY bit of the tx_cntl parameter is not set.</span>
<span class="cm"> * If the descp parameter of the current call is non-NULL, the message as represented by descp is send.</span>
<span class="cm"> * If the descp parameter of the current call is NULL, and if the preceding call of the Send Message Function had</span>
<span class="cm"> * a non-NULL descp and the preceding call had the HFS_TX_CNTL_TX_DELAY bit of tx_cntl set, then the message as</span>
<span class="cm"> * represented by the descp of the preceding call is send.</span>
<span class="cm"> *</span>
<span class="cm"> * Hcf_send_msg supports encapsulation (see HCF_ENCAP) of Ethernet-II frames.</span>
<span class="cm"> * An Ethernet-II frame is transferred to the Transmit Frame structure as an 802.3 frame.</span>
<span class="cm"> * Hcf_send_msg distinguishes between an 802.3 and an Ethernet-II frame by looking at the data length/type field</span>
<span class="cm"> * of the frame. If this field contains a value larger than 1514, the frame is considered to be an Ethernet-II</span>
<span class="cm"> * frame, otherwise it is treated as an 802.3 frame.</span>
<span class="cm"> * To ease implementation of the HCF, this type/type field must be located in the first descriptor structure,</span>
<span class="cm"> * i.e. the 1st fragment must have a size of at least 14 (to contain DestAddr, SrcAddr and Len/Type field).</span>
<span class="cm"> * An Ethernet-II frame is encapsulated by inserting a SNAP header between the addressing information and the</span>
<span class="cm"> * type field.  This insertion is transparent for the MSF.</span>
<span class="cm"> * The HCF contains a fixed table that stores a number of types. If the value specified by the type/type field</span>
<span class="cm"> * occurs in this table, Bridge Tunnel Encapsulation is used, otherwise RFC1042 encapsulation is used.</span>
<span class="cm"> * Bridge Tunnel uses    AA AA 03 00 00 F8 as SNAP header,</span>
<span class="cm"> * RFC1042 uses  AA AA 03 00 00 00 as SNAP header.</span>
<span class="cm"> * The table currently contains:</span>
<span class="cm"> * 0 0x80F3  AppleTalk Address Resolution Protocol (AARP)</span>
<span class="cm"> * 0 0x8137  IPX</span>
<span class="cm"> *</span>
<span class="cm"> * The algorithm to distinguish between 802.3 and Ethernet-II frames limits the maximum length for frames of</span>
<span class="cm"> * 802.3 frames to 1514 bytes.</span>
<span class="cm"> * Encapsulation can be suppressed by means of the system constant HCF_ENCAP, e.g. to support proprietary</span>
<span class="cm"> * protocols with 802.3 like frames with a size larger than 1514 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * In case the HCF encapsulates the frame, the number of bytes that is actually transmitted is determined by the</span>
<span class="cm"> * cumulative value of the buf_cntl.buf_dim[0] fields.</span>
<span class="cm"> * In case the HCF does not encapsulate the frame, the number of bytes that is actually transmitted is not</span>
<span class="cm"> * determined by the cumulative value of the buf_cntl.buf_dim[DESC_CNTL_CNT] fields of the desc_strct&#39;s but by</span>
<span class="cm"> * the Length field of the 802.3 frame.</span>
<span class="cm"> * If there is a conflict between the cumulative value of the buf_cntl.buf_dim[0] fields and the</span>
<span class="cm"> * 802.3 Length field the 802.3 Length field determines the number of bytes actually transmitted by the NIC while</span>
<span class="cm"> * the cumulative value of the buf_cntl.buf_dim[0] fields determines the position of the MIC, hence a mismatch</span>
<span class="cm"> * will result in MIC errors on the Receiving side.</span>
<span class="cm"> * Currently this problem is flagged on the Transmit side by an Assert.</span>
<span class="cm"> * The following fields of each of the descriptors in the descriptor list must be set by the MSF:</span>
<span class="cm"> * o buf_cntl.buf_dim[0]</span>
<span class="cm"> * o *next_desc_addr</span>
<span class="cm"> * o *buf_addr</span>
<span class="cm"> *</span>
<span class="cm"> * All bits of the tx_cntl parameter except HFS_TX_CNTL_TX_DELAY and the HCF_PORT# bits are passed to the F/W via</span>
<span class="cm"> * the HFS_TX_CNTL field of the TxFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that hcf_send_msg does not detect NIC absence.  The MSF is supposed to have its own -platform dependent-</span>
<span class="cm"> * way to recognize card removal/insertion.</span>
<span class="cm"> * The total system must be robust against card removal and there is no principal difference between card removal</span>
<span class="cm"> * just after hcf_send_msg returns but before the actual transmission took place or sometime earlier.</span>
<span class="cm"> *</span>
<span class="cm"> * Assert fails if</span>
<span class="cm"> * - ifbp has a recognizable out-of-range value</span>
<span class="cm"> * - descp is a NULL pointer</span>
<span class="cm"> * - no resources for PIF available.</span>
<span class="cm"> * - Interrupts are enabled.</span>
<span class="cm"> * - reentrancy, may be  caused by calling hcf_functions without adequate protection</span>
<span class="cm"> *   against NIC interrupts or multi-threading.</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *4: for the normal case (i.e. no HFS_TX_CNTL_TX_DELAY option active), a fid is acquired via the</span>
<span class="cm"> *   routine get_fid.  If no FID is acquired, the remainder is skipped without an error notification.  After</span>
<span class="cm"> *   all, the MSF is not supposed to call hcf_send_msg when no Resource is available.</span>
<span class="cm"> *7: The ControlField of the TxFS is written.  Since put_frag can only return the fatal Defunct or &quot;No NIC&quot;, the</span>
<span class="cm"> *   return status can be ignored because when it fails, cmd_wait will fail as well.  (see also the note on the</span>
<span class="cm"> *   need for a return code below).</span>
<span class="cm"> *   Note that HFS_TX_CNTL has different values for H-I, H-I/WPA and H-II and HFS_ADDR_DEST has different</span>
<span class="cm"> *   values for H-I (regardless of WPA) and H-II.</span>
<span class="cm"> *   By writing 17, 1 or 2 ( implying 16, 0 or 1 garbage word after HFS_TX_CNTL) the BAP just gets to</span>
<span class="cm"> *   HFS_ADDR_DEST for H-I, H-I/WPA and H-II respectively.</span>
<span class="cm"> *10: if neither encapsulation nor MIC calculation is needed, splitting the first fragment in two does not</span>
<span class="cm"> *   really help but it makes the flow easier to follow to do not optimize on this difference</span>
<span class="cm"> *</span>
<span class="cm"> *   hcf_send_msg checks whether the frame is an Ethernet-II rather than an &quot;official&quot; 802.3 frame.</span>
<span class="cm"> *   The E-II check is based on the length/type field in the MAC header. If this field has a value larger than</span>
<span class="cm"> *   1500, E-II is assumed. The implementation of this test fails if the length/type field is not in the first</span>
<span class="cm"> *   descriptor.  If E-II is recognized, a SNAP header is inserted. This SNAP header represents either RFC1042</span>
<span class="cm"> *   or Bridge-Tunnel encapsulation, depending on the return status of the support routine hcf_encap.</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *   hcf_send_msg leaves the responsibility to only send messages on enabled ports at the MSF level.</span>
<span class="cm"> *   This is considered the strategy which is sufficiently adequate for all &quot;robust&quot; MSFs, have the least</span>
<span class="cm"> *   processor utilization and being still acceptable robust at the WCI !!!!!</span>
<span class="cm"> *</span>
<span class="cm"> *   hcf_send_msg does not NEED a return value to report NIC absence or removal during the execution of</span>
<span class="cm"> *   hcf_send_msg(), because the MSF and higher layers must be able to cope anyway with the NIC being removed</span>
<span class="cm"> *   after a successful completion of hcf_send_msg() but before the actual transmission took place.</span>
<span class="cm"> *   To accommodate user expectations the current implementation does report NIC absence.</span>
<span class="cm"> *   Defunct blocks all NIC access and will (also) be reported on a number of other calls.</span>
<span class="cm"> *</span>
<span class="cm"> *   hcf_send_msg does not check for transmit buffer overflow because the Hermes does this protection.</span>
<span class="cm"> *   In case of a transmit buffer overflow, the surplus which does not fit in the buffer is simply dropped.</span>
<span class="cm"> *   Note that this possibly results in the transmission of incomplete frames.</span>
<span class="cm"> *</span>
<span class="cm"> *   After some deliberation with F/W team, it is decided that - being in the twilight zone of not knowing</span>
<span class="cm"> *   whether the problem at hand is an MSF bug, HCF buf, F/W bug, H/W malfunction or even something else - there</span>
<span class="cm"> *   is no &quot;best thing to do&quot; in case of a failing send, hence the HCF considers the TxFID ownership to be taken</span>
<span class="cm"> *   over by the F/W and hopes for an Allocate event in due time</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="kt">int</span>
<span class="n">hcf_send_msg</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">DESC_STRCT</span> <span class="o">*</span><span class="n">descp</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">tx_cntl</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>         <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>
	<span class="n">DESC_STRCT</span>  <span class="o">*</span><span class="n">p</span> <span class="cm">/* = descp*/</span><span class="p">;</span>        <span class="c1">//working pointer</span>
	<span class="n">hcf_16</span>      <span class="n">len</span><span class="p">;</span>                    <span class="c1">// total byte count</span>
	<span class="n">hcf_16</span>      <span class="n">i</span><span class="p">;</span>

	<span class="n">hcf_16</span>      <span class="n">fid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="o">||</span> <span class="n">descp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">USE_DMA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xDADB</span> <span class="p">);</span>

	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_SEND_MSG</span><span class="p">,</span> <span class="n">tx_cntl</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="o">==</span> <span class="n">HCF_MAGIC</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="p">);</span>
	<span class="n">HCFASSERT_INT</span><span class="p">;</span>
	<span class="cm">/* obnoxious c:/hcf/hcf.c(1480) : warning C4769: conversion of near pointer to long integer,</span>
<span class="cm">	 * so skip */</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">((</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">descp</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">descp</span> <span class="p">);</span>
<span class="cp">#if HCF_ASSERT</span>
	<span class="p">{</span>   <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">comp_id</span> <span class="o">==</span> <span class="n">COMP_ID_FW_AP</span> <span class="o">?</span> <span class="n">tx_cntl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HFS_TX_CNTL_PORT</span> <span class="o">:</span> <span class="n">tx_cntl</span><span class="p">;</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HCF_TX_CNTL_MASK</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tx_cntl</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">descp</span> <span class="p">)</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TxFID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>               <span class="c1">//cancel a pre-put message</span>

	<span class="cm">/* the following initialization code is redundant for a pre-put message</span>
<span class="cm">	 * but moving it inside the &quot;if fid&quot; logic makes the merging with the</span>
<span class="cm">	 * USB flow awkward</span>
<span class="cm">	 */</span>
<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
	<span class="n">tx_cntl</span> <span class="o">|=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCntl</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>
	<span class="n">fid</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TxFID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fid</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">fid</span> <span class="o">=</span> <span class="n">get_fid</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">)</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>        <span class="cm">/* 4 */</span>
		<span class="cm">/* skip the next compound statement if:</span>
<span class="cm">		   - pre-put message or</span>
<span class="cm">		   - no fid available (which should never occur if the MSF adheres to the WCI)</span>
<span class="cm">		*/</span>
	<span class="p">{</span>       <span class="c1">// to match the closing curly bracket of above &quot;if&quot; in case of HCF_TYPE_USB</span></pre></div></td></tr>


<tr id="section-61"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-61">&#182;</a></div><p>DO NOT !!! HCFASSERT( rc == HCF_SUCCESS, rc )                                             /* 20 */</p></td><td class="code"><div class="highlight"><pre>		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">descp</span><span class="p">;</span>
		<span class="k">do</span> <span class="n">len</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span><span class="p">;</span> <span class="k">while</span> <span class="p">(</span> <span class="p">(</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">descp</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-62"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-62">&#182;</a></div><p>obnoxious hcf.c(1480) : warning C4769: conversion of near pointer to long integer</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/*7*/</span>   <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setup_bap</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">HFS_TX_CNTL</span><span class="p">,</span> <span class="n">IO_OUT</span> <span class="p">);</span>
<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_TX_DELAY</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span> <span class="n">descp</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="o">^</span> <span class="p">(</span> <span class="n">tx_cntl</span> <span class="o">&amp;</span> <span class="n">HFS_TX_CNTL_TX_DELAY</span> <span class="p">),</span> <span class="n">tx_cntl</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">tx_cntl</span> <span class="o">&amp;</span> <span class="n">HFS_TX_CNTL_TX_DELAY</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_cntl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HFS_TX_CNTL_TX_DELAY</span><span class="p">;</span>       <span class="c1">//!!HFS_TX_CNTL_TX_DELAY no longer available</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TxFID</span> <span class="o">=</span> <span class="n">fid</span><span class="p">;</span>
			<span class="n">fid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                <span class="c1">//!!fid no longer available, be careful when modifying code</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_TX_DELAY</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_DATA_1</span><span class="p">,</span> <span class="n">tx_cntl</span> <span class="p">)</span> <span class="p">;</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_DATA_1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">&gt;=</span> <span class="mi">14</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="p">);</span>
		                                <span class="cm">/* assume DestAddr/SrcAddr/Len/Type ALWAYS contained in 1st fragment</span>
<span class="cm">		                                 * otherwise life gets too cumbersome for MIC and Encapsulation !!!!!!!!</span>
<span class="cm">		 if ( p-&gt;BUF_CNT &gt;= 14 ) {   alternatively: add a safety escape !!!!!!!!!!!! }   */</span>

		<span class="n">CALC_TX_MIC</span><span class="p">(</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>        <span class="c1">//initialize MIC</span>
	<span class="cm">/*10*/</span>  <span class="n">put_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">,</span> <span class="n">HCF_DASA_SIZE</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span> <span class="c1">//write DA, SA with MIC calculation</span>
		<span class="n">CALC_TX_MIC</span><span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">,</span> <span class="n">HCF_DASA_SIZE</span> <span class="p">);</span>      <span class="c1">//MIC over DA, SA</span>
		<span class="n">CALC_TX_MIC</span><span class="p">(</span> <span class="n">null_addr</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>        <span class="c1">//MIC over (virtual) priority field</span></pre></div></td></tr>


<tr id="section-63"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-63">&#182;</a></div><p>calculate total length ;? superfluous unless CCX or Encapsulation</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if (HCF_ENCAP) == HCF_ENC</span></pre></div></td></tr>


<tr id="section-64"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-64">&#182;</a></div><p>;?        HCFASSERT( len &lt;= HCF<em>MAX</em>MSG, len );</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">snap_header</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">snap_header</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hcf_encap</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">HCF_DASA_SIZE</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">ENC_NONE</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_DATA_1</span><span class="p">,</span> <span class="n">CNV_END_SHORT</span><span class="p">(</span> <span class="n">len</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">snap_header</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-65"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-65">&#182;</a></div><p>if encapsulation needed</p></td><td class="code"><div class="highlight"><pre>			<span class="n">put_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">snap_header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">snap_header</span><span class="p">)</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
			<span class="n">CALC_TX_MIC</span><span class="p">(</span> <span class="n">snap_header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">snap_header</span><span class="p">)</span> <span class="p">);</span>    <span class="c1">//MIC over 6 byte SNAP</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">HCF_DASA_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif </span><span class="c1">// HCF_ENC</span>
		<span class="p">{</span>
			<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_DATA_1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">wci_recordp</span><span class="p">)</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">HCF_DASA_SIZE</span><span class="p">]</span> <span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-66"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-66">&#182;</a></div><p>write length (with SNAP-header,Type, without //DA,SA,Length ) no MIC calc.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">put_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">-</span> <span class="n">i</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
		<span class="n">CALC_TX_MIC</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="o">-</span> <span class="n">i</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-67"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-67">&#182;</a></div><p>write splice with MIC calculation</p></td><td class="code"><div class="highlight"><pre>		<span class="k">while</span> <span class="p">(</span> <span class="p">(</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_desc_addr</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* obnoxious c:/hcf/hcf.c(1480) : warning C4769: conversion of near pointer to long integer,</span>
<span class="cm">			 * so skip */</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">((</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">p</span> <span class="p">);</span>
			<span class="n">put_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
			<span class="n">CALC_TX_MIC</span><span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">BUF_CNT</span> <span class="p">);</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-68"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-68">&#182;</a></div><p>complete 1st fragment starting with Type with MIC calculation</p></td><td class="code"><div class="highlight"><pre>		<span class="n">put_frag_finalize</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">fid</span> <span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*16*/</span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCMD_BUSY</span> <span class="o">|</span> <span class="n">HCMD_TX</span> <span class="o">|</span> <span class="n">HCMD_RECL</span><span class="p">,</span> <span class="n">fid</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TxFID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* probably this (i.e. no RscInd AND &quot;HREG_EV_ALLOC&quot;) at this point in time occurs so infrequent,</span>
<span class="cm">		 * that it might just as well be acceptable to skip this</span>
<span class="cm">		 * &quot;optimization&quot; code and handle that additional interrupt once in a while</span>
<span class="cm">		 */</span></pre></div></td></tr>


<tr id="section-69"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-69">&#182;</a></div><p>do the remaining fragments with MIC calculation</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/*20*/</span>  <span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="o">=</span> <span class="n">get_fid</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-70"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-70">&#182;</a></div><p>pad message, finalize MIC calculation and write MIC to NIC</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span></pre></div></td></tr>


<tr id="section-71"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-71">&#182;</a></div><p>180 degree error in logic ;? #if ALLOC_15</p></td><td class="code"><div class="highlight"><pre>	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_SEND_MSG</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_send_msg</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.MODULE        int hcf_service_nic( IFBP ifbp, wci_bufp bufp, unsigned int len )</span>
<span class="cm"> *.PURPOSE       Services (most) NIC events.</span>
<span class="cm"> *               Provides received message</span>
<span class="cm"> *               Provides status information.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *  In non-DMA mode:</span>
<span class="cm"> *   bufp        address of char buffer, sufficiently large to hold the first part of the RxFS up through HFS_TYPE</span>
<span class="cm"> *   len         length in bytes of buffer specified by bufp</span>
<span class="cm"> *               value between HFS_TYPE + 2 and HFS_ADDR_DEST + HCF_MAX_MSG</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_SUCCESS</span>
<span class="cm"> *   HCF_ERR_MIC message contains an erroneous MIC (only if frame fits completely in bufp)</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> *</span>
<span class="cm"> * MSF-accessible fields of Result Block</span>
<span class="cm"> * - IFB_RxLen           0 or Frame size.</span>
<span class="cm"> * - IFB_MBInfoLen       0 or the L-field of the oldest MBIB.</span>
<span class="cm"> * - IFB_RscInd</span>
<span class="cm"> * - IFB_HCF_Tallies     updated if a corresponding event occurred.</span>
<span class="cm"> * - IFB_NIC_Tallies     updated if a Tally Info frame received from the NIC.</span>
<span class="cm"> * - IFB_DmaPackets</span>
<span class="cm"> * - IFB_TxFsStat</span>
<span class="cm"> * - IFB_TxFsSwSup</span>
<span class="cm"> * - IFB_LinkStat        reflects new link status or 0x0000 if no change relative to previous hcf_service_nic call.</span>
<span class="cm">or</span>
<span class="cm">* - IFB_LinkStat        link status, 0x8000 reflects change relative to previous hcf_service_nic call.</span>
<span class="cm">*</span>
<span class="cm">* When IFB_MBInfoLen is non-zero, at least one MBIB is available.</span>
<span class="cm">*</span>
<span class="cm">* IFB_RxLen reflects the number of received bytes in 802.3 view (Including DestAddr, SrcAddr and Length,</span>
<span class="cm">* excluding MIC-padding, MIC and sum check) of active Rx Frame Structure. If no Rx Data s available, IFB_RxLen</span>
<span class="cm">* equals 0x0000.</span>
<span class="cm">* Repeated execution causes the Service NIC Function to provide information about subsequently received</span>
<span class="cm">* messages, irrespective whether a hcf_rcv_msg or hcf_action(HCF_ACT_RX) is performed in between.</span>
<span class="cm">*</span>
<span class="cm">* When IFB_RxLen is non-zero, a Received Frame Structure is available to be routed to the protocol stack.</span>
<span class="cm">* When Monitor Mode is not active, this is guaranteed to be an error-free non-WMP frame.</span>
<span class="cm">* In case of Monitor Mode, it may also be a frame with an error or a WMP frame.</span>
<span class="cm">* Erroneous frames have a non-zero error-sub field in the HFS_STAT field in the look ahead buffer.</span>
<span class="cm">*</span>
<span class="cm">* If a Receive message is available in NIC RAM, the Receive Frame Structure is (partly) copied from the NIC to</span>
<span class="cm">* the buffer identified by bufp.</span>
<span class="cm">* Copying stops either after len bytes or when the complete 802.3 frame is copied.</span>
<span class="cm">* During the copying the message is decapsulated (if appropriate).</span>
<span class="cm">* If the frame is read completely by hcf_service_nic (i.e. the frame fits completely in the lookahead buffer),</span>
<span class="cm">* the frame is automatically ACK&#39;ed to the F/W and still available via the look ahead buffer and hcf_rcv_msg.</span>
<span class="cm">* Only if the frame is read completely by hcf_service_nic, hcf_service_nic checks the MIC and sets the return</span>
<span class="cm">* status accordingly.  In this case, hcf_rcv_msg does not check the MIC.</span>
<span class="cm">*</span>
<span class="cm">* The MIC calculation algorithm works more efficient if the length of the look ahead buffer is</span>
<span class="cm">* such that it fits exactly 4 n bytes of the 802.3 frame, i.e. len == HFS_ADDR_DEST + 4*n.</span>
<span class="cm">*</span>
<span class="cm">* The Service NIC Function supports the NIC event service handling process.</span>
<span class="cm">* It performs the appropriate actions to service the NIC, such that the event cause is eliminated and related</span>
<span class="cm">* information is saved.</span>
<span class="cm">* The Service NIC Function is executed by the MSF ISR or polling routine as first step to determine the event</span>
<span class="cm">* cause(s).  It is the responsibility of the MSF to perform all not directly NIC related interrupt service</span>
<span class="cm">* actions, e.g. in a PC environment this includes servicing the PIC, and managing the Processor Interrupt</span>
<span class="cm">* Enabling/Disabling.</span>
<span class="cm">* In case of a polled based system, the Service NIC Function must be executed &quot;frequently&quot;.</span>
<span class="cm">* The Service NIC Function may have side effects related to the Mailbox and Resource Indicator (IFB_RscInd).</span>
<span class="cm">*</span>
<span class="cm">* hcf_service_nic returns:</span>
<span class="cm">* - The length of the data in the available MBIB (IFB_MBInfoLen)</span>
<span class="cm">* - Changes in the link status (IFB_LinkStat)</span>
<span class="cm">* - The length of the data in the available Receive Frame Structure (IFB_RxLen)</span>
<span class="cm">* - updated IFB_RscInd</span>
<span class="cm">* - Updated Tallies</span>
<span class="cm">*</span>
<span class="cm">* hcf_service_nic is presumed to neither interrupt other HCF-tasks nor to be interrupted by other HCF-tasks.</span>
<span class="cm">* A way to achieve this is to precede hcf_service_nic as well as all other HCF-tasks with a call to</span>
<span class="cm">* hcf_action to disable the card interrupts and, after all work is completed, with a call to hcf_action to</span>
<span class="cm">* restore (which is not necessarily the same as enabling) the card interrupts.</span>
<span class="cm">* In case of a polled environment, it is assumed that the MSF programmer is sufficiently familiar with the</span>
<span class="cm">* specific requirements of that environment to translate the interrupt strategy to a polled strategy.</span>
<span class="cm">*</span>
<span class="cm">* hcf_service_nic services the following Hermes events:</span>
<span class="cm">* - HREG_EV_INFO        Asynchronous Information Frame</span>
<span class="cm">* - HREG_EV_INFO_DROP   WMAC did not have sufficient RAM to build Unsolicited Information Frame</span>
<span class="cm">* - HREG_EV_TX_EXC      (if applicable, i.e. selected via HCF_EXT_INT_TX_EX bit of HCF_EXT)</span>
<span class="cm">* - HREG_EV_SLEEP_REQ   (if applicable, i.e. selected via HCF_DDS/HCF_CDS bit of HCF_SLEEP)</span>
<span class="cm">* ** in non_DMA mode</span>
<span class="cm">* - HREG_EV_ALLOC       Asynchronous part of Allocation/Reclaim completed while out of resources at</span>
<span class="cm">*                       completion of hcf_send_msg/notify</span>
<span class="cm">* - HREG_EV_RX          the detection of the availability of received messages</span>
<span class="cm">*                       including WaveLAN Management Protocol (WMP) message processing</span>
<span class="cm">* ** in DMA mode</span>
<span class="cm">* - HREG_EV_RDMAD</span>
<span class="cm">* - HREG_EV_TDMAD</span>
<span class="cm">*!! hcf_service_nic does not service the following Hermes events:</span>
<span class="cm">*!!     HREG_EV_TX          (the &quot;OK&quot; Tx Event) is no longer supported by the WCI, if it occurs it is unclear</span>
<span class="cm">*!!                         what the cause is, so no meaningful strategy is available. Not acking the bit is</span>
<span class="cm">*!!                         probably the best help that can be given to the debugger.</span>
<span class="cm">*!!     HREG_EV_CMD         handled in cmd_wait.</span>
<span class="cm">*!!     HREG_EV_FW_DMA      (i.e. HREG_EV_RXDMA, HREG_EV_TXDMA and_EV_LPESC) are either not used or used</span>
<span class="cm">*!!                         between the F/W and the DMA engine.</span>
<span class="cm">*!!     HREG_EV_ACK_REG_READY is only applicable for H-II (i.e. not HII.5 and up, see DAWA)</span>
<span class="cm">*</span>
<span class="cm">*   If, in non-DMA mode, a Rx message is available, its length is reflected by the IFB_RxLen field of the IFB.</span>
<span class="cm">*   This length reflects the data itself and the Destination Address, Source Address and DataLength/Type field</span>
<span class="cm">*   but not the SNAP-header in case of decapsulation by the HCF.  If no message is available, IFB_RxLen is</span>
<span class="cm">*   zero.  Former versions of the HCF handled WMP messages and supported a &quot;monitor&quot; mode in hcf_service_nic,</span>
<span class="cm">*   which deposited certain or all Rx messages in the MailBox. The responsibility to handle these frames is</span>
<span class="cm">*   moved to the MSF. The HCF offers as supports hcf_put_info with CFG_MB_INFO as parameter to emulate the old</span>
<span class="cm">*   implementation under control of the MSF.</span>
<span class="cm">*</span>
<span class="cm">* **Rx Buffer free strategy</span>
<span class="cm">*   When hcf_service_nic reports the availability of a non-DMA message, the MSF can access that message by</span>
<span class="cm">*   means of hcf_rcv_msg. It must be prevented that the LAN Controller writes new data in the NIC buffer</span>
<span class="cm">*   before the MSF is finished with the current message. The NIC buffer is returned to the LAN Controller</span>
<span class="cm">*   when:</span>
<span class="cm">*    - the complete frame fits in the lookahead buffer or</span>
<span class="cm">*    - hcf_rcv_msg is called or</span>
<span class="cm">*    - hcf_action with HCF_ACT_RX is called or</span>
<span class="cm">*    - hcf_service_nic is called again</span>
<span class="cm">*   It can be reasoned that hcf_action( INT_ON ) should not be given before the MSF has completely processed</span>
<span class="cm">*   a reported Rx-frame. The reason is that the INT_ON action is guaranteed to cause a (Rx-)interrupt (the</span>
<span class="cm">*   MSF is processing a Rx-frame, hence the Rx-event bit in the Hermes register must be active). This</span>
<span class="cm">*   interrupt will cause hcf_service_nic to be called, which will cause the ack-ing of the &quot;last&quot; Rx-event</span>
<span class="cm">*   to the Hermes, causing the Hermes to discard the associated NIC RAM buffer.</span>
<span class="cm">* Assert fails if</span>
<span class="cm">* - ifbp is zero or other recognizable out-of-range value.</span>
<span class="cm">* - hcf_service_nic is called without a prior call to hcf_connect.</span>
<span class="cm">* - interrupts are enabled.</span>
<span class="cm">* - reentrancy, may be  caused by calling hcf_functions without adequate protection</span>
<span class="cm">*   against NIC interrupts or multi-threading.</span>
<span class="cm">*</span>
<span class="cm">*</span>
<span class="cm">*.DIAGRAM</span>
<span class="cm">*1: IFB_LinkStat is cleared, if a LinkStatus frame is received, IFB_LinkStat will be updated accordingly</span>
<span class="cm">*   by isr_info.</span>
<span class="cm">or</span>
<span class="cm">*1: IFB_LinkStat change indication is cleared. If a LinkStatus frame is received, IFB_LinkStat will be updated</span>
<span class="cm">*   accordingly by isr_info.</span>
<span class="cm">*2: IFB_RxLen must be cleared before the NIC presence check otherwise:</span>
<span class="cm">*    -  this value may stay non-zero if the NIC is pulled out at an inconvenient moment.</span>
<span class="cm">*    -  the RxAck on a zero-FID needs a zero-value for IFB_RxLen to work</span>
<span class="cm">*    Note that as side-effect of the hcf_action call, the remainder of Rx related info is re-initialized as</span>
<span class="cm">*    well.</span>
<span class="cm">*4: In case of Defunct mode, the information supplied by Hermes is unreliable, so the body of</span>
<span class="cm">*   hcf_service_nic is skipped. Since hcf_cntl turns into a NOP if Primary or Station F/W is incompatible,</span>
<span class="cm">*   hcf_service_nic is also skipped in those cases.</span>
<span class="cm">*   To prevent that hcf_service_nic reports bogus information to the MSF with all - possibly difficult to</span>
<span class="cm">*   debug - undesirable side effects, it is paramount to check the NIC presence. In former days the presence</span>
<span class="cm">*   test was based on the Hermes register HREG_SW_0. Since in HCF_ACT_INT_OFF is chosen for strategy based on</span>
<span class="cm">*   HREG_EV_STAT, this is now also used in hcf_service_nic. The motivation to change strategy is partly</span>
<span class="cm">*   due to inconsistent F/W implementations with respect to HREG_SW_0 manipulation around reset and download.</span>
<span class="cm">*   Note that in polled environments Card Removal is not detected by INT_OFF which makes the check in</span>
<span class="cm">*   hcf_service_nic even more important.</span>
<span class="cm">*8: The event status register of the Hermes is sampled</span>
<span class="cm">*   The assert checks for unexpected events ;?????????????????????????????????????.</span>
<span class="cm">*    - HREG_EV_INFO_DROP is explicitly excluded from the acceptable HREG_EV_STAT bits because it indicates</span>
<span class="cm">*      a too heavily loaded system.</span>
<span class="cm">*    - HREG_EV_ACK_REG_READY is 0x0000 for H-I (and hopefully H-II.5)</span>
<span class="cm">*</span>
<span class="cm">*</span>
<span class="cm">*   HREG_EV_TX_EXC is accepted (via HREG_EV_TX_EXT) if and only if HCF_EXT_INT_TX_EX set in the HCF_EXT</span>
<span class="cm">*   definition at compile time.</span>
<span class="cm">*   The following activities are handled:</span>
<span class="cm">*    -  Alloc events are handled by hcf_send_msg (and notify). Only if there is no &quot;spare&quot; resource, the</span>
<span class="cm">*       alloc event is superficially serviced by hcf_service_nic to create a pseudo-resource with value</span>
<span class="cm">*       0x001. This value is recognized by get_fid (called by hcf_send_msg and notify) where the real</span>
<span class="cm">*       TxFid is retrieved and the Hermes is acked and - hopefully - the &quot;normal&quot; case with a spare TxFid</span>
<span class="cm">*       in IFB_RscInd is restored.</span>
<span class="cm">*    -  Info drop events are handled by incrementing a tally</span>
<span class="cm">*    -  LinkEvent (including solicited and unsolicited tallies) are handled by procedure isr_info.</span>
<span class="cm">*   -   TxEx (if selected at compile time) is handled by copying the significant part of the TxFS</span>
<span class="cm">*       into the IFB for further processing by the MSF.</span>
<span class="cm">*       Note the complication of the zero-FID protection sub-scheme in DAWA.</span>
<span class="cm">*   Note, the Ack of all of above events is handled at the end of hcf_service_nic</span>
<span class="cm">*16: In case of  non-DMA ( either not compiled in or due to a run-time choice):</span>
<span class="cm">*   If an Rx-frame is available, first the FID of that frame is read, including the complication of the</span>
<span class="cm">*   zero-FID protection sub-scheme in DAWA. Note that such a zero-FID is acknowledged at the end of</span>
<span class="cm">*   hcf_service_nic and that this depends on the IFB_RxLen initialization in the begin of hcf_service_nic.</span>
<span class="cm">*   The Assert validates the HCF assumption about Hermes implementation upon which the range of</span>
<span class="cm">*   Pseudo-RIDs is based.</span>
<span class="cm">*   Then the control fields up to the start of the 802.3 frame are read from the NIC into the lookahead buffer.</span>
<span class="cm">*   The status field is converted to native Endianness.</span>
<span class="cm">*   The length is, after implicit Endianness conversion if needed, and adjustment for the 14 bytes of the</span>
<span class="cm">*   802.3 MAC header, stored in IFB_RxLen.</span>
<span class="cm">*   In MAC Monitor mode, 802.11 control frames with a TOTAL length of 14 are received, so without this</span>
<span class="cm">*   length adjustment, IFB_RxLen could not be used to distinguish these frames from &quot;no frame&quot;.</span>
<span class="cm">*   No MIC calculation processes are associated with the reading of these Control fields.</span>
<span class="cm">*26: This length test feels like superfluous robustness against malformed frames, but it turned out to be</span>
<span class="cm">*   needed in the real (hostile) world.</span>
<span class="cm">*   The decapsulation check needs sufficient data to represent DA, SA, L, SNAP and Type which amounts to</span>
<span class="cm">*   22 bytes. In MAC Monitor mode, 802.11 control frames with a smaller length are received. To prevent</span>
<span class="cm">*   that the implementation goes haywire, a check on the length is needed.</span>
<span class="cm">*   The actual decapsulation takes place on the fly in the copying process by overwriting the SNAP header.</span>
<span class="cm">*   Note that in case of decapsulation the SNAP header is not passed to the MSF, hence IFB_RxLen must be</span>
<span class="cm">*   compensated for the SNAP header length.</span>
<span class="cm">*   The 22 bytes needed for decapsulation are (more than) sufficient for the exceptional handling of the</span>
<span class="cm">*   MIC algorithm of the L-field (replacing the 2 byte L-field with 4 0x00 bytes).</span>
<span class="cm">*30: The 12 in the no-WPA branch corresponds with the get_frag, the 2 with the IPW of the WPA branch</span>
<span class="cm">*32: If Hermes reported MIC-presence, than the MIC engine is initialized with the non-dummy MIC calculation</span>
<span class="cm">*   routine address and appropriate key.</span>
<span class="cm">*34: The 8 bytes after the DA, SA, L are read and it is checked whether decapsulation is needed i.e.:</span>
<span class="cm">*     - the Hermes reported Tunnel encapsulation or</span>
<span class="cm">*     - the Hermes reported 1042 Encapsulation and hcf_encap reports that the HCF would not have used</span>
<span class="cm">*       1042 as the encapsulation mechanism</span>
<span class="cm">*   Note that the first field of the RxFS in bufp has Native Endianness due to the conversion done by the</span>
<span class="cm">*   BE_PAR in get_frag.</span>
<span class="cm">*36: The Type field is the only word kept (after moving) of the just read 8 bytes, it is moved to the</span>
<span class="cm">*   L-field.  The original L-field and 6 byte SNAP header are discarded, so IFB_RxLen and buf_addr must</span>
<span class="cm">*   be adjusted by 8.</span>
<span class="cm">*40: Determine how much of the frame (starting with DA) fits in the Lookahead buffer, then read the not-yet</span>
<span class="cm">*   read data into the lookahead buffer.</span>
<span class="cm">*   If the lookahead buffer contains the complete message, check the MIC. The majority considered this</span>
<span class="cm">*   I/F more appropriate then have the MSF call hcf_get_data only to check the MIC.</span>
<span class="cm">*44: Since the complete message is copied from NIC RAM to PC RAM, the Rx can be acknowledged to the Hermes</span>
<span class="cm">*   to optimize the flow ( a better chance to get new Rx data in the next pass through hcf_service_nic ).</span>
<span class="cm">*   This acknowledgement can not be done via hcf_action( HCF_ACT_RX_ACK ) because this also clears</span>
<span class="cm">*   IFB_RxLEN thus corrupting the I/F to the MSF.</span>
<span class="cm">*;?: In case of DMA (compiled in and activated):</span>


<span class="cm">*54: Limiting the number of places where the F/W is acked (e.g. the merging of the Rx-ACK with the other</span>
<span class="cm">*   ACKs), is supposed to diminish the potential of race conditions in the F/W.</span>
<span class="cm">*   Note 1: The CMD event is acknowledged in cmd_cmpl</span>
<span class="cm">*   Note 2: HREG_EV_ACK_REG_READY is 0x0000 for H-I (and hopefully H-II.5)</span>
<span class="cm">*   Note 3: The ALLOC event is acknowledged in get_fid (except for the initialization flow)</span>
<span class="cm">*</span>
<span class="cm">*.NOTICE</span>
<span class="cm">* The Non-DMA HREG_EV_RX is handled different compared with the other F/W events.</span>
<span class="cm">* The HREG_EV_RX event is acknowledged by the first hcf_service_nic call after the</span>
<span class="cm">* hcf_service_nic call that reported the occurrence of this event.</span>
<span class="cm">* This acknowledgment</span>
<span class="cm">* makes the next Receive Frame Structure (if any) available.</span>
<span class="cm">* An updated IFB_RxLen</span>
<span class="cm">* field reflects this availability.</span>
<span class="cm">*</span>
<span class="cm">*.NOTICE</span>
<span class="cm">* The minimum size for Len must supply space for:</span>
<span class="cm">* - an F/W dependent number of bytes of Control Info field including the 802.11 Header field</span>
<span class="cm">* - Destination Address</span>
<span class="cm">* - Source Address</span>
<span class="cm">* - Length field</span>
<span class="cm">* - [ SNAP Header]</span>
<span class="cm">* - [ Ethernet-II Type]</span>
<span class="cm">* This results in 68 for Hermes-I and 80 for Hermes-II</span>
<span class="cm">* This way the minimum amount of information is available needed by the HCF to determine whether the frame</span>
<span class="cm">* must be decapsulated.</span>
<span class="cm">*.ENDDOC                END DOCUMENTATION</span>
<span class="cm">*</span>
<span class="cm">************************************************************************************************************/</span>
<span class="kt">int</span>
<span class="n">hcf_service_nic</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">wci_bufp</span> <span class="n">bufp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span>         <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>
	<span class="n">hcf_16</span>      <span class="n">stat</span><span class="p">;</span>
	<span class="n">wci_bufp</span>    <span class="n">buf_addr</span><span class="p">;</span>
	<span class="n">hcf_16</span>      <span class="n">i</span><span class="p">;</span>

	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_SERVICE_NIC</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IntOffCnt</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="o">==</span> <span class="n">HCF_MAGIC</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Magic</span> <span class="p">);</span>
	<span class="n">HCFASSERT_INT</span><span class="p">;</span>

	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_LinkStat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// ;? to be obsoleted ASAP                                              /* 1*/</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DSLinkStat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CFG_LINK_STAT_CHANGE</span><span class="p">;</span>                                                  <span class="cm">/* 1*/</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">hcf_action</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCF_ACT_RX_ACK</span> <span class="p">);</span>                                                       <span class="cm">/* 2*/</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span> <span class="p">)</span> <span class="p">)</span> <span class="o">!=</span> <span class="mh">0xFFFF</span> <span class="p">)</span> <span class="p">{</span>                    <span class="cm">/* 4*/</span>
<span class="cm">/*		IF_NOT_DMA( HCFASSERT( !( stat &amp; ~HREG_EV_BASIC_MASK, stat ) )</span>
<span class="cm"> *		IF_NOT_USE_DMA( HCFASSERT( !( stat &amp; ~HREG_EV_BASIC_MASK, stat ) )</span>
<span class="cm"> *		IF_USE_DMA( HCFASSERT( !( stat &amp; ~( HREG_EV_BASIC_MASK ^ ( HREG_EV_...DMA.... ), stat ) )</span>
<span class="cm"> */</span>
		                                                                                        <span class="cm">/* 8*/</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stat</span> <span class="o">&amp;</span> <span class="n">HREG_EV_ALLOC</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">//Note: IFB_RscInd is ALWAYS 1 for DMA</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">IF_TALLY</span><span class="p">(</span> <span class="k">if</span> <span class="p">(</span> <span class="n">stat</span> <span class="o">&amp;</span> <span class="n">HREG_EV_INFO_DROP</span> <span class="p">)</span> <span class="p">{</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HCF_Tallies</span><span class="p">.</span><span class="n">NoBufInfo</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
<span class="cp">#if (HCF_EXT) &amp; HCF_EXT_INT_TICK</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">stat</span> <span class="o">&amp;</span> <span class="n">HREG_EV_TICK</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TickCnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#if 0</span><span class="c"> // (HCF_SLEEP) &amp; HCF_DDS</span>
<span class="c">		if ( ifbp-&gt;IFB_TickCnt == 3 &amp;&amp; ( ifbp-&gt;IFB_DSLinkStat &amp; CFG_LINK_STAT_CONNECTED ) == 0 ) {</span>
<span class="c">			CFG_DDS_TICK_TIME_STRCT ltv;</span></pre></div></td></tr>


<tr id="section-72"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-72">&#182;</a></div><h1>endif // ALLOC_15</h1></td><td class="code"><div class="highlight"><pre><span class="c">			hcf_action( ifbp, HCF_ACT_SLEEP );</span>
<span class="c">			ifbp-&gt;IFB_DSLinkStat |= CFG_LINK_STAT_DS_OOR; //set OutOfRange</span>
<span class="c">			ltv.len = 2;</span>
<span class="c">			ltv.typ = CFG_DDS_TICK_TIME;</span>
<span class="c">			ltv.tick_time = ( ( ifbp-&gt;IFB_DSLinkStat &amp; CFG_LINK_STAT_TIMER ) + 0x10 ) *64; //78 is more right</span>
<span class="c">			hcf_put_info( ifbp, (LTVP)&amp;ltv );</span>
<span class="c">			printk( &quot;&lt;5&gt;Preparing for sleep, link_status: %04X, timer : %d\n&quot;,</span>
<span class="c">				ifbp-&gt;IFB_DSLinkStat, ltv.tick_time );//;?remove me 1 day</span>
<span class="c">			ifbp-&gt;IFB_TickCnt++; //;?just to make sure we do not keep on printing above message</span>
<span class="c">			if ( ltv.tick_time &lt; 300 * 125 ) ifbp-&gt;IFB_DSLinkStat += 0x0010;</span>

<span class="c">		}</span>
<span class="cp">#endif // HCF_DDS</span>
<span class="cp">#endif </span><span class="c1">// HCF_EXT_INT_TICK</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">stat</span> <span class="o">&amp;</span> <span class="n">HREG_EV_INFO</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">isr_info</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#if (HCF_EXT) &amp; HCF_EXT_INT_TX_EX</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">stat</span> <span class="o">&amp;</span> <span class="n">HREG_EV_TX_EXT</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_TX_COMPL_FID</span> <span class="p">)</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="cm">/*DAWA*/</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">DAWA_ZERO_FID</span><span class="p">(</span> <span class="n">HREG_TX_COMPL_FID</span> <span class="p">);</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setup_bap</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IO_IN</span> <span class="p">);</span>
			<span class="n">get_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TxFsStat</span><span class="p">,</span> <span class="n">HFS_SWSUP</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_EXT_INT_TX_EX</span></pre></div></td></tr>


<tr id="section-73"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-73">&#182;</a></div><p>HCFASSERT( level::ifbp->IFB<em>RscInd, ifbp->IFB</em>RscInd );</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if HCF_DMA</span>
		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">USE_DMA</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">//!! be aware of the logical indentations</span>
<span class="cp">#endif </span><span class="c1">// HCF_DMA</span>
		<span class="cm">/*16*/</span>  <span class="k">if</span> <span class="p">(</span> <span class="n">stat</span> <span class="o">&amp;</span> <span class="n">HREG_EV_RX</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxFID</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_RX_FID</span> <span class="p">)</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">//if 0 then DAWA_ACK</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">bufp</span><span class="p">,</span> <span class="n">len</span> <span class="p">);</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="n">HFS_DAT</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">len</span> <span class="p">);</span>
				<span class="n">DAWA_ZERO_FID</span><span class="p">(</span> <span class="n">HREG_RX_FID</span> <span class="p">);</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxFID</span> <span class="o">&lt;</span> <span class="n">CFG_PROD_DATA</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxFID</span><span class="p">);</span>
				<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setup_bap</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxFID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IO_IN</span> <span class="p">);</span>
				<span class="n">get_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">bufp</span><span class="p">,</span> <span class="n">HFS_ADDR_DEST</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_lap</span> <span class="o">=</span> <span class="n">buf_addr</span> <span class="o">=</span> <span class="n">bufp</span> <span class="o">+</span> <span class="n">HFS_ADDR_DEST</span><span class="p">;</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">bufp</span><span class="p">[</span><span class="n">HFS_DAT_LEN</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">bufp</span><span class="p">[</span><span class="n">HFS_DAT_LEN</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
			<span class="cm">/*26*/</span>  <span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span> <span class="o">&gt;=</span> <span class="mi">22</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">// convenient for MIC calculation (5 DWs + 1 &quot;skipped&quot; W)</span></pre></div></td></tr>


<tr id="section-74"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-74">&#182;</a></div><p>2 second period (with 1 tick uncertanty) in not-connected mode -->go into DS_OOR</p></td><td class="code"><div class="highlight"><pre>				<span class="cm">/*30*/</span>  <span class="n">get_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">buf_addr</span><span class="p">,</span> <span class="mi">22</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
				<span class="cm">/*32*/</span>  <span class="n">CALC_RX_MIC</span><span class="p">(</span> <span class="n">bufp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>        <span class="c1">//.  initialize MIC</span>
					<span class="n">CALC_RX_MIC</span><span class="p">(</span> <span class="n">buf_addr</span><span class="p">,</span> <span class="n">HCF_DASA_SIZE</span> <span class="p">);</span> <span class="c1">//.  MIC over DA, SA</span>
					<span class="n">CALC_RX_MIC</span><span class="p">(</span> <span class="n">null_addr</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>    <span class="c1">//.  MIC over (virtual) priority field</span>
					<span class="n">CALC_RX_MIC</span><span class="p">(</span> <span class="n">buf_addr</span><span class="o">+</span><span class="mi">14</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>  <span class="c1">//.  skip Len, MIC over SNAP,Type or 8 data bytes)</span>
					<span class="n">buf_addr</span> <span class="o">+=</span> <span class="mi">22</span><span class="p">;</span>
<span class="cp">#if (HCF_ENCAP) == HCF_ENC</span>
					<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="n">HFS_DAT</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">snap_header</span><span class="p">),</span> <span class="n">len</span> <span class="p">);</span>
				<span class="cm">/*34*/</span>  <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">wci_recordp</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">[</span><span class="n">HFS_STAT</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">HFS_STAT_MSG_TYPE</span> <span class="o">|</span> <span class="n">HFS_STAT_ERR</span> <span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">HFS_STAT_TUNNEL</span> <span class="o">||</span>
					     <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">HFS_STAT_1042</span> <span class="o">&amp;&amp;</span> <span class="n">hcf_encap</span><span class="p">(</span> <span class="p">(</span><span class="n">wci_bufp</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">[</span><span class="n">HFS_TYPE</span><span class="p">]</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">ENC_TUNNEL</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-75"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-75">&#182;</a></div><p>!rlav DMA engine will handle the rx event, not the driver</p></td><td class="code"><div class="highlight"><pre>				<span class="cm">/*36*/</span>  <span class="n">bufp</span><span class="p">[</span><span class="n">HFS_LEN</span>  <span class="p">]</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">[</span><span class="n">HFS_TYPE</span>  <span class="p">];</span>
						<span class="n">bufp</span><span class="p">[</span><span class="n">HFS_LEN</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">[</span><span class="n">HFS_TYPE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span></pre></div></td></tr>


<tr id="section-76"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-76">&#182;</a></div><p>.  get DA,SA,Len/Type and (SNAP,Type or 8 data bytes)</p></td><td class="code"><div class="highlight"><pre>						<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span> <span class="o">-=</span> <span class="p">(</span><span class="n">HFS_TYPE</span> <span class="o">-</span> <span class="n">HFS_LEN</span><span class="p">);</span>
						<span class="n">buf_addr</span> <span class="o">-=</span> <span class="p">(</span> <span class="n">HFS_TYPE</span> <span class="o">-</span> <span class="n">HFS_LEN</span> <span class="p">);</span> <span class="c1">// this happens to bring us at a DW boundary of 36</span>
					<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_ENC</span>
				<span class="p">}</span>
			<span class="cm">/*40*/</span>  <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_lal</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">len</span> <span class="o">-</span> <span class="n">HFS_ADDR_DEST</span><span class="p">),</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span> <span class="p">);</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_lal</span> <span class="o">-</span> <span class="p">(</span> <span class="n">buf_addr</span> <span class="o">-</span> <span class="p">(</span> <span class="n">bufp</span> <span class="o">+</span> <span class="n">HFS_ADDR_DEST</span> <span class="p">)</span> <span class="p">);</span>
				<span class="n">get_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">buf_addr</span><span class="p">,</span> <span class="n">i</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
				<span class="n">CALC_RX_MIC</span><span class="p">(</span> <span class="n">buf_addr</span><span class="p">,</span> <span class="n">i</span> <span class="p">);</span>
<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_lal</span> <span class="o">==</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span> <span class="p">)</span> <span class="p">{</span>
					<span class="n">rc</span> <span class="o">=</span> <span class="n">check_mic</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>
				<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>
			<span class="cm">/*44*/</span>  <span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">-</span> <span class="n">HFS_ADDR_DEST</span> <span class="o">&gt;=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxLen</span> <span class="p">)</span> <span class="p">{</span>
					<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RxFID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* IFB_RxFID is cleared, so  you do not get another Rx_Ack at next entry of hcf_service_nic */</span>
					<span class="n">stat</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="o">~</span><span class="n">HREG_EV_RX</span><span class="p">;</span>    <span class="c1">//don&#39;t ack Rx if processing not yet completed</span>
				<span class="p">}</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-77"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-77">&#182;</a></div><p>.  copy E-II Type to 802.3 LEN field</p></td><td class="code"><div class="highlight"><pre>		<span class="n">IF_USE_DMA</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DmaPackets</span> <span class="o">|=</span> <span class="n">stat</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">HREG_EV_RDMAD</span> <span class="o">|</span> <span class="n">HREG_EV_TDMAD</span> <span class="p">)</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-78"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-78">&#182;</a></div><p>.  discard Snap by overwriting with data</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/*54*/</span>  <span class="n">stat</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="o">~</span><span class="p">(</span> <span class="n">HREG_EV_SLEEP_REQ</span> <span class="o">|</span> <span class="n">HREG_EV_CMD</span> <span class="o">|</span> <span class="n">HREG_EV_ACK_REG_READY</span> <span class="o">|</span> <span class="n">HREG_EV_ALLOC</span> <span class="o">|</span> <span class="n">HREG_EV_FW_DMA</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-79"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-79">&#182;</a></div><p>in case of DMA: signal availability of rx and/or tx packets to MSF</p></td><td class="code"><div class="highlight"><pre>		<span class="n">IF_USE_DMA</span><span class="p">(</span> <span class="n">stat</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="o">~</span><span class="n">HREG_EV_RX</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">stat</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">DAWA_ACK</span><span class="p">(</span> <span class="n">stat</span> <span class="p">);</span>   <span class="cm">/*DAWA*/</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_SERVICE_NIC</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// hcf_service_nic</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> ************************** H C F   S U P P O R T   R O U T I N E S ******************************************</span>
<span class="cm"> ************************************************************************************************************/</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     void calc_mic( hcf_32* p, hcf_32 m )</span>
<span class="cm"> *.PURPOSE       calculate MIC on a quad byte.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   p           address of the MIC</span>
<span class="cm"> *   m           32 bit value to be processed by the MIC calculation engine</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * calc_mic is the implementation of the MIC algorithm. It is a monkey-see monkey-do copy of</span>
<span class="cm"> * Michael::appendByte()</span>
<span class="cm"> * of Appendix C of ..........</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>

<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>

<span class="cp">#define ROL32( A, n ) ( ((A) &lt;&lt; (n)) | ( ((A)&gt;&gt;(32-(n)))  &amp; ( (1UL &lt;&lt; (n)) - 1 ) ) )</span>
<span class="cp">#define ROR32( A, n ) ROL32( (A), 32-(n) )</span>

<span class="cp">#define L   *p</span>
<span class="cp">#define R   *(p+1)</span>

<span class="kt">void</span>
<span class="n">calc_mic</span><span class="p">(</span> <span class="n">hcf_32</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">hcf_32</span> <span class="n">m</span> <span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if HCF_BIG_ENDIAN</span>
	<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_BIG_ENDIAN</span>
	<span class="n">L</span> <span class="o">^=</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">R</span> <span class="o">^=</span> <span class="n">ROL32</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="mi">17</span> <span class="p">);</span>
	<span class="n">L</span> <span class="o">+=</span> <span class="n">R</span><span class="p">;</span>
	<span class="n">R</span> <span class="o">^=</span> <span class="p">((</span><span class="n">L</span> <span class="o">&amp;</span> <span class="mh">0xff00ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">L</span> <span class="o">&amp;</span> <span class="mh">0x00ff00ff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">L</span> <span class="o">+=</span> <span class="n">R</span><span class="p">;</span>
	<span class="n">R</span> <span class="o">^=</span> <span class="n">ROL32</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
	<span class="n">L</span> <span class="o">+=</span> <span class="n">R</span><span class="p">;</span>
	<span class="n">R</span> <span class="o">^=</span> <span class="n">ROR32</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
	<span class="n">L</span> <span class="o">+=</span> <span class="n">R</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// calc_mic</span>
<span class="cp">#undef R</span>
<span class="cp">#undef L</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>



<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     void calc_mic_rx_frag( IFBP ifbp, wci_bufp p, int len )</span>
<span class="cm"> *.PURPOSE       calculate MIC on a single fragment.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   bufp        (byte) address of buffer</span>
<span class="cm"> *   len         length in bytes of buffer specified by bufp</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * calc_mic_rx_frag ........</span>
<span class="cm"> *</span>
<span class="cm"> * The MIC is located in the IFB.</span>
<span class="cm"> * The MIC is separate for Tx and Rx, thus allowing hcf_send_msg to occur between hcf_service_nic and</span>
<span class="cm"> * hcf_rcv_msg.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="kt">void</span>
<span class="n">calc_mic_rx_frag</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">wci_bufp</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">union</span> <span class="p">{</span> <span class="n">hcf_32</span> <span class="n">x32</span><span class="p">;</span> <span class="n">hcf_16</span> <span class="n">x16</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">hcf_8</span> <span class="n">x8</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="p">}</span> <span class="n">x</span><span class="p">;</span> <span class="c1">//* area to accumulate 4 bytes input for MIC engine</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>                              <span class="c1">//initialize MIC housekeeping</span>
		<span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">wci_recordp</span><span class="p">)</span><span class="o">&amp;</span><span class="n">p</span><span class="p">[</span><span class="n">HFS_STAT</span><span class="p">];</span>
		<span class="cm">/* i = CNV_SHORTP_TO_LITTLE(&amp;p[HFS_STAT]); should not be neede to prevent alignment poroblems</span>
<span class="cm">		 * since len == -1 if and only if p is lookahaead buffer which MUST be word aligned</span>
<span class="cm">		 * to be re-investigated by NvR</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">HFS_STAT_MIC</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxCarry</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>          <span class="c1">//suppress MIC calculation</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxCarry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-80"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-80">&#182;</a></div><p>rlav : pending HREG<em>EV</em>RDMAD or HREG<em>EV</em>TDMAD events get acknowledged here.</p></td><td class="code"><div class="highlight"><pre>			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">HFS_STAT_MIC_KEY_ID</span> <span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">;</span>  <span class="cm">/* coincidentally no shift needed for i itself */</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CNV_LONG_TO_LITTLE</span><span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxKey</span><span class="p">[</span><span class="n">i</span>  <span class="p">]);</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CNV_LONG_TO_LITTLE</span><span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxKey</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxCarry</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">x</span><span class="p">.</span><span class="n">x32</span> <span class="o">=</span> <span class="n">CNV_LONGP_TO_LITTLE</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxCarry</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">len</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxCarry</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">while</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxCarry</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="p">)</span> <span class="p">{</span>      <span class="c1">//note for hcf_16 applies: 0xFFFF &gt; 4</span>
				<span class="n">x</span><span class="p">.</span><span class="n">x8</span><span class="p">[</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxCarry</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
				<span class="n">len</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">while</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxCarry</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">{</span>   <span class="c1">//contrived so we have only 1 call to calc_mic so we could bring it in-line</span>
			<span class="n">calc_mic</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRx</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">x32</span> <span class="p">);</span>
			<span class="n">x</span><span class="p">.</span><span class="n">x32</span> <span class="o">=</span> <span class="n">CNV_LONGP_TO_LITTLE</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRxCarry</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="c1">// calc_mic_rx_frag</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>


<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     void calc_mic_tx_frag( IFBP ifbp, wci_bufp p, int len )</span>
<span class="cm"> *.PURPOSE       calculate MIC on a single fragment.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   bufp        (byte) address of buffer</span>
<span class="cm"> *   len         length in bytes of buffer specified by bufp</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * calc_mic_tx_frag ........</span>
<span class="cm"> *</span>
<span class="cm"> * The MIC is located in the IFB.</span>
<span class="cm"> * The MIC is separate for Tx and Rx, thus allowing hcf_send_msg to occur between hcf_service_nic and</span>
<span class="cm"> * hcf_rcv_msg.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="kt">void</span>
<span class="n">calc_mic_tx_frag</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">wci_bufp</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">union</span> <span class="p">{</span> <span class="n">hcf_32</span> <span class="n">x32</span><span class="p">;</span> <span class="n">hcf_16</span> <span class="n">x16</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">hcf_8</span> <span class="n">x8</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="p">}</span> <span class="n">x</span><span class="p">;</span> <span class="c1">//* area to accumulate 4 bytes input for MIC engine</span></pre></div></td></tr>


<tr id="section-81"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-81">&#182;</a></div><p>a positive mask would be easier to understand /<em>54</em>/  stat &amp;= (hcf<em>16)~( HREG</em>EV<em>SLEEP</em>REQ | HREG<em>EV</em>CMD | HREG<em>EV</em>ACK<em>REG</em>READY | HREG<em>EV</em>ALLOC | HREG<em>EV</em>FW_DMA );</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-82"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-82">&#182;</a></div><ul>
<li>Note that "coincidentally" the bit positions used in HFS_STAT</li>
<li>correspond with the offset of the key in IFB_MICKey</li>
</ul></td><td class="code"><div class="highlight"><pre>		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCarry</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-83"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-83">&#182;</a></div><p>if initialization request</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCntl</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-84"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-84">&#182;</a></div><p>.  presume MIC calculation disabled</p></td><td class="code"><div class="highlight"><pre>			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCarry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-85"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-85">&#182;</a></div><p>.  if MIC calculation enabled</p></td><td class="code"><div class="highlight"><pre>			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CNV_LONG_TO_LITTLE</span><span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxKey</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="cm">/*Tx always uses Key 0 */</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CNV_LONG_TO_LITTLE</span><span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxKey</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-86"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-86">&#182;</a></div><p>.  .  clear MIC carry</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-87"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-87">&#182;</a></div><p>.  .  initialize MIC-engine</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCarry</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-88"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-88">&#182;</a></div><p>else</p></td><td class="code"><div class="highlight"><pre>			<span class="n">x</span><span class="p">.</span><span class="n">x32</span> <span class="o">=</span> <span class="n">CNV_LONGP_TO_LITTLE</span><span class="p">(</span><span class="n">p</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-89"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-89">&#182;</a></div><p>.  if MIC enabled (Tx) / if MIC present (Rx)
.  and no carry from previous calc<em>mic</em>frag</p></td><td class="code"><div class="highlight"><pre>			<span class="n">p</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-90"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-90">&#182;</a></div><p>.  .  preset accu with 4 bytes from buffer</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-91"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-91">&#182;</a></div><p>.  .  adjust pointer accordingly</p></td><td class="code"><div class="highlight"><pre>				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCarry</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">len</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-92"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-92">&#182;</a></div><p>.  .  if buffer contained less then 4 bytes</p></td><td class="code"><div class="highlight"><pre>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-93"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-93">&#182;</a></div><p>.  .  .  promote valid bytes in accu to carry
.  .  .  flag accu to contain incomplete double word</p></td><td class="code"><div class="highlight"><pre>				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCarry</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-94"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-94">&#182;</a></div><p>.  .  else</p></td><td class="code"><div class="highlight"><pre>				<span class="n">len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-95"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-95">&#182;</a></div><p>.  .  .  flag accu to contain complete double word</p></td><td class="code"><div class="highlight"><pre>		<span class="p">}</span> <span class="k">else</span> <span class="k">while</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCarry</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="p">)</span> <span class="p">{</span>      <span class="cm">/* note for hcf_16 applies: 0xFFFF &gt; 4 */</span>
				<span class="n">x</span><span class="p">.</span><span class="n">x8</span><span class="p">[</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCarry</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
				<span class="n">len</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-96"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-96">&#182;</a></div><p>.  .  adjust remaining buffer length</p></td><td class="code"><div class="highlight"><pre>		<span class="k">while</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCarry</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-97"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-97">&#182;</a></div><p>.  else if MIC enabled
.  and if carry bytes from previous calc<em>mic</em>tx_frag
.  .  move (1-3) bytes from carry into accu</p></td><td class="code"><div class="highlight"><pre>			<span class="n">calc_mic</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTx</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">x32</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-98"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-98">&#182;</a></div><p>.  while accu contains complete double word
.  and MIC enabled</p></td><td class="code"><div class="highlight"><pre>			<span class="n">x</span><span class="p">.</span><span class="n">x32</span> <span class="o">=</span> <span class="n">CNV_LONGP_TO_LITTLE</span><span class="p">(</span><span class="n">p</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-99"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-99">&#182;</a></div><p>.  .  pass accu to MIC engine</p></td><td class="code"><div class="highlight"><pre>			<span class="n">p</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-100"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-100">&#182;</a></div><p>.  .  copy next 4 bytes from buffer to accu</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCarry</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">len</span><span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-101"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-101">&#182;</a></div><p>.  .  adjust buffer pointer</p></td><td class="code"><div class="highlight"><pre>			<span class="n">len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="c1">// calc_mic_tx_frag</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>


<span class="cp">#if HCF_PROT_TIME</span>
<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     void calibrate( IFBP ifbp )</span>
<span class="cm"> *.PURPOSE       calibrates the S/W protection counter against the Hermes Timer tick.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * calibrates the S/W protection counter against the Hermes Timer tick</span>
<span class="cm"> * IFB_TickIni is the value used to initialize the S/W protection counter such that the expiration period</span>
<span class="cm"> * more or less independent of the processor speed. If IFB_TickIni is not yet calibrated, it is done now.</span>
<span class="cm"> * This calibration is &quot;reasonably&quot; accurate because the Hermes is in a quiet state as a result of the</span>
<span class="cm"> * Initialize command.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *1: IFB_TickIni is initialized at INI_TICK_INI by hcf_connect. If calibrate succeeds, IFB_TickIni is</span>
<span class="cm"> *   guaranteed to be changed. As a consequence there will be only 1 shot at calibration (regardless of the</span>
<span class="cm"> *   number of init calls) under normal circumstances.</span>
<span class="cm"> *2: Calibration is done HCF_PROT_TIME_CNT times. This diminish the effects of jitter and interference,</span>
<span class="cm"> *   especially in a pre-emptive environment. HCF_PROT_TIME_CNT is in the range of 16 through 32 and derived</span>
<span class="cm"> *   from the HCF_PROT_TIME specified by the MSF programmer. The divisor needed to scale HCF_PROT_TIME into the</span>
<span class="cm"> *   16-32 range, is used as a multiplicator after the calibration, to scale the found value back to the</span>
<span class="cm"> *   requested range. This way a compromise is achieved between accuracy and duration of the calibration</span>
<span class="cm"> *   process.</span>
<span class="cm"> *3: Acknowledge the Timer Tick Event.</span>
<span class="cm"> *   Each cycle is limited to at most INI_TICK_INI samples of the TimerTick status of the Hermes.</span>
<span class="cm"> *   Since the start of calibrate is unrelated to the Hermes Internal Timer, the first interval may last from 0</span>
<span class="cm"> *   to the normal interval, all subsequent intervals should be the full length of the Hermes Tick interval.</span>
<span class="cm"> *   The Hermes Timer Tick is not reprogrammed by the HCF, hence it is running at the default of 10 k</span>
<span class="cm"> *   microseconds.</span>
<span class="cm"> *4: If the Timer Tick Event is continuously up (prot_cnt still has the value INI_TICK_INI) or no Timer Tick</span>
<span class="cm"> *   Event occurred before the protection counter expired, reset IFB_TickIni to INI_TICK_INI,</span>
<span class="cm"> *   set the defunct bit of IFB_CardStat (thus rendering the Hermes inoperable) and exit the calibrate routine.</span>
<span class="cm"> *8: ifbp-&gt;IFB_TickIni is multiplied to scale the found value back to the requested range as explained under 2.</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> * o Although there are a number of viewpoints possible, calibrate() uses as error strategy that a single</span>
<span class="cm"> *   failure of the Hermes TimerTick is considered fatal.</span>
<span class="cm"> * o There is no hard and concrete time-out value defined for Hermes activities. The default 1 seconds is</span>
<span class="cm"> *   believed to be sufficiently &quot;relaxed&quot; for real life and to be sufficiently short to be still useful in an</span>
<span class="cm"> *   environment with humans.</span>
<span class="cm"> * o Note that via IFB_DefunctStat time outs in cmd_wait and in hcfio_string block all Hermes access till the</span>
<span class="cm"> *   next init so functions which call a mix of cmd_wait and hcfio_string only need to check the return status</span>
<span class="cm"> *   of the last call</span>
<span class="cm"> * o The return code is preset at Time out.</span>
<span class="cm"> *   The additional complication that no calibrated value for the protection count can be assumed since</span>
<span class="cm"> *   calibrate() does not yet have determined a calibrated value (a catch 22), is handled by setting the</span>
<span class="cm"> *   initial value at INI_TICK_INI (by hcf_connect). This approach is considered safe, because:</span>
<span class="cm"> *     - the HCF does not use the pipeline mechanism of Hermes commands.</span>
<span class="cm"> *     - the likelihood of failure (the only time when protection count is relevant) is small.</span>
<span class="cm"> *     - the time will be sufficiently large on a fast machine (busy bit drops on good NIC before counter</span>
<span class="cm"> *       expires)</span>
<span class="cm"> *     - the time will be sufficiently small on a slow machine (counter expires on bad NIC before the end user</span>
<span class="cm"> *       switches the power off in despair</span>
<span class="cm"> *   The time needed to wrap a 32 bit counter around is longer than many humans want to wait, hence the more or</span>
<span class="cm"> *   less arbitrary value of 0x40000L is chosen, assuming it does not take too long on an XT and is not too</span>
<span class="cm"> *   short on a scream-machine.</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>
<span class="n">calibrate</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>     <span class="n">cnt</span> <span class="o">=</span> <span class="n">HCF_PROT_TIME_CNT</span><span class="p">;</span>
	<span class="n">hcf_32</span>  <span class="n">prot_cnt</span><span class="p">;</span>

	<span class="n">HCFTRACE</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCF_TRACE_CALIBRATE</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TickIni</span> <span class="o">==</span> <span class="n">INI_TICK_INI</span> <span class="p">)</span> <span class="p">{</span>                                                  <span class="cm">/*1*/</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TickIni</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                                  <span class="cm">/*2*/</span>
		<span class="k">while</span> <span class="p">(</span> <span class="n">cnt</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">prot_cnt</span> <span class="o">=</span> <span class="n">INI_TICK_INI</span><span class="p">;</span>
			<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_EV_ACK</span><span class="p">,</span> <span class="n">HREG_EV_TICK</span> <span class="p">);</span>                                               <span class="cm">/*3*/</span>
			<span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">HREG_EV_TICK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">prot_cnt</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TickIni</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">prot_cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">prot_cnt</span> <span class="o">==</span> <span class="n">INI_TICK_INI</span> <span class="p">)</span> <span class="p">{</span>                              <span class="cm">/*4*/</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TickIni</span> <span class="o">=</span> <span class="n">INI_TICK_INI</span><span class="p">;</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DefunctStat</span> <span class="o">=</span> <span class="n">HCF_ERR_DEFUNCT_TIMER</span><span class="p">;</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">|=</span> <span class="n">CARD_STAT_DEFUNCT</span><span class="p">;</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">prot_cnt</span> <span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_TickIni</span> <span class="o">&lt;&lt;=</span> <span class="n">HCF_PROT_TIME_SHFT</span><span class="p">;</span>                                               <span class="cm">/*8*/</span>
	<span class="p">}</span>
	<span class="n">HCFTRACE</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCF_TRACE_CALIBRATE</span> <span class="o">|</span> <span class="n">HCF_TRACE_EXIT</span> <span class="p">);</span>
<span class="p">}</span> <span class="c1">// calibrate</span>
<span class="cp">#endif </span><span class="c1">// HCF_PROT_TIME</span>


<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     int check_mic( IFBP ifbp )</span>
<span class="cm"> *.PURPOSE       verifies the MIC of a received non-USB frame.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_SUCCESS</span>
<span class="cm"> *   HCF_ERR_MIC</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *4: test whether or not a MIC is reported by the Hermes</span>
<span class="cm"> *14: the calculated MIC and the received MIC are compared, the return status is set when there is a mismatch</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="kt">int</span>
<span class="n">check_mic</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>     <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>
	<span class="n">hcf_32</span> <span class="n">x32</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>              <span class="c1">//* area to save rcvd 8 bytes MIC</span></pre></div></td></tr>


<tr id="section-102"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-102">&#182;</a></div><p>.  .  if buffer contained less then 4 bytes
.  .  .  promote valid bytes in accu to carry
.  .  .  flag accu to contain incomplete double word</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="n">wci_recordp</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_lap</span><span class="p">[</span><span class="o">-</span><span class="n">HFS_ADDR_DEST</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">HFS_STAT_MIC</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-103"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-103">&#182;</a></div><p>.  .  adjust remaining buffer length</p></td><td class="code"><div class="highlight"><pre>		<span class="n">CALC_RX_MIC</span><span class="p">(</span> <span class="n">mic_pad</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>                  <span class="c1">//.  process up to 3 remaining bytes of data and append 5 to 8 bytes of padding to MIC calculation</span>
		<span class="n">get_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">wci_bufp</span><span class="p">)</span><span class="n">x32</span><span class="p">,</span> <span class="mi">8</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="c1">//.  get 8 byte MIC from NIC</span></pre></div></td></tr>


<tr id="section-104"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-104">&#182;</a></div><p>if MIC present in RxFS</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/*14*/</span>  <span class="k">if</span> <span class="p">(</span> <span class="n">x32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">CNV_LITTLE_TO_LONG</span><span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span>
		     <span class="n">x32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">CNV_LITTLE_TO_LONG</span><span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICRx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>     <span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_ERR_MIC</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-105"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-105">&#182;</a></div><p>or if ( ifbp->IFB_MICRxCarry != 0xFFFF )</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// check_mic</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     int cmd_cmpl( IFBP ifbp )</span>
<span class="cm"> *.PURPOSE       waits for Hermes Command Completion.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   IFB_DefunctStat</span>
<span class="cm"> *   HCF_ERR_TIME_OUT</span>
<span class="cm"> *   HCF_ERR_DEFUNCT_CMD_SEQ</span>
<span class="cm"> *   HCF_SUCCESS</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *2: Once cmd_cmpl is called, the Busy option bit in IFB_Cmd must be cleared</span>
<span class="cm"> *4: If Status register and command code don&#39;t match either:</span>
<span class="cm"> *    - the Hermes and Host are out of sync ( a fatal error)</span>
<span class="cm"> *    - error bits are reported via the Status Register.</span>
<span class="cm"> *   Out of sync is considered fatal and brings the HCF in Defunct mode</span>
<span class="cm"> *   Errors reported via the Status Register should be caused by sequence violations in Hermes command</span>
<span class="cm"> *   sequences and hence these bugs should have been found during engineering testing. Since there is no</span>
<span class="cm"> *   strategy to cope with this problem, it might as well be ignored at run time. Note that for any particular</span>
<span class="cm"> *   situation where a strategy is formulated to handle the consequences of a particular bug causing a</span>
<span class="cm"> *   particular Error situation reported via the Status Register, the bug should be removed rather than adding</span>
<span class="cm"> *   logic to cope with the consequences of the bug.</span>
<span class="cm"> *   There have been HCF versions where an error report via the Status Register even brought the HCF in defunct</span>
<span class="cm"> *   mode (although it was not yet named like that at that time). This is particular undesirable behavior for a</span>
<span class="cm"> *   general library.</span>
<span class="cm"> *   Simply reporting the error (as &quot;interesting&quot;) is debatable. There also have been HCF versions with this</span>
<span class="cm"> *   strategy using the &quot;vague&quot; HCF_FAILURE code.</span>
<span class="cm"> *   The error is reported via:</span>
<span class="cm"> *    - MiscErr tally of the HCF Tally set</span>
<span class="cm"> *    - the (informative) fields IFB_ErrCmd and IFB_ErrQualifier</span>
<span class="cm"> *    - the assert mechanism</span>
<span class="cm"> *8: Here the Defunct case and the Status error are separately treated</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>
<span class="n">cmd_cmpl</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">)</span>
<span class="p">{</span>

	<span class="n">PROT_CNT_INI</span><span class="p">;</span>
	<span class="kt">int</span>     <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>
	<span class="n">hcf_16</span>  <span class="n">stat</span><span class="p">;</span>

	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_CMD_CPL</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Cmd</span> <span class="p">);</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HCMD_BUSY</span><span class="p">;</span>                                                <span class="cm">/* 2 */</span>
	<span class="n">HCF_WAIT_WHILE</span><span class="p">(</span> <span class="p">(</span><span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HREG_EV_CMD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>                  <span class="cm">/* 4 */</span>
	<span class="n">stat</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_STAT</span> <span class="p">);</span>
<span class="cp">#if HCF_PROT_TIME</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">prot_cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">IF_TALLY</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HCF_Tallies</span><span class="p">.</span><span class="n">MiscErr</span><span class="o">++</span> <span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_ERR_TIME_OUT</span><span class="p">;</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Cmd</span> <span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif </span><span class="c1">// HCF_PROT_TIME</span>
	<span class="p">{</span>
		<span class="n">DAWA_ACK</span><span class="p">(</span> <span class="n">HREG_EV_CMD</span> <span class="p">);</span>
	<span class="cm">/*4*/</span>   <span class="k">if</span> <span class="p">(</span> <span class="n">stat</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Cmd</span> <span class="o">&amp;</span> <span class="n">HCMD_CMD_CODE</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*8*/</span>   <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">stat</span> <span class="o">^</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Cmd</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">HCMD_CMD_CODE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DefunctStat</span> <span class="o">=</span> <span class="n">HCF_ERR_DEFUNCT_CMD_SEQ</span><span class="p">;</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">|=</span> <span class="n">CARD_STAT_DEFUNCT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">IF_TALLY</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HCF_Tallies</span><span class="p">.</span><span class="n">MiscErr</span><span class="o">++</span> <span class="p">);</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_ErrCmd</span> <span class="o">=</span> <span class="n">stat</span><span class="p">;</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_ErrQualifier</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_RESP_0</span> <span class="p">);</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_PARAM_0</span> <span class="p">),</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Cmd</span> <span class="p">)</span> <span class="p">);</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_ErrQualifier</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_ErrCmd</span> <span class="p">)</span> <span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_CMD_CPL</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// cmd_cmpl</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     int cmd_exe( IFBP ifbp, int cmd_code, int par_0 )</span>
<span class="cm"> *.PURPOSE       Executes synchronous part of Hermes Command and - optionally - waits for Command Completion.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   cmd_code</span>
<span class="cm"> *   par_0</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   IFB_DefunctStat</span>
<span class="cm"> *   HCF_ERR_DEFUNCT_CMD_SEQ</span>
<span class="cm"> *   HCF_SUCCESS</span>
<span class="cm"> *   HCF_ERR_TO_BE_ADDED &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * Executes synchronous Hermes Command and waits for Command Completion</span>
<span class="cm"> *</span>
<span class="cm"> * The general HCF strategy is to wait for command completion. As a consequence:</span>
<span class="cm"> * - the read of the busy bit before writing the command register is superfluous</span>
<span class="cm"> * - the Hermes requirement that no Inquiry command may be executed if there is still an unacknowledged</span>
<span class="cm"> *   Inquiry command outstanding, is automatically met.</span>
<span class="cm"> * The Tx command uses the &quot;Busy&quot; bit in the cmd_code parameter to deviate from this general HCF strategy.</span>
<span class="cm"> * The idea is that by not busy-waiting on completion of this frequently used command the processor</span>
<span class="cm"> * utilization is diminished while using the busy-wait on all other seldom used commands the flow is kept</span>
<span class="cm"> * simple.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *1: skip the body of cmd_exe when in defunct mode or when - based on the S/W Support register write and</span>
<span class="cm"> *   read back test - there is apparently no NIC.</span>
<span class="cm"> *   Note: we gave up on the &quot;old&quot; strategy to write the S/W Support register at magic only when needed. Due to</span>
<span class="cm"> *   the intricateness of Hermes F/W varieties ( which behave differently as far as corruption of the S/W</span>
<span class="cm"> *   Support register is involved), the increasing number of Hermes commands which do an implicit initialize</span>
<span class="cm"> *   (thus modifying the S/W Support register) and the workarounds of some OS/Support S/W induced aspects (e.g.</span>
<span class="cm"> *   the System Soft library at WinNT which postpones the actual mapping of I/O space up to 30 seconds after</span>
<span class="cm"> *   giving the go-ahead), the &quot;magic&quot; strategy is now reduced to a simple write and read back. This means that</span>
<span class="cm"> *   problems like a bug tramping over the memory mapped Hermes registers will no longer be noticed as side</span>
<span class="cm"> *   effect of the S/W Support register check.</span>
<span class="cm"> *2: check whether the preceding command skipped the busy wait and if so, check for command completion</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>

<span class="n">HCF_STATIC</span> <span class="kt">int</span>
<span class="n">cmd_exe</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">cmd_code</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">par_0</span> <span class="p">)</span> <span class="c1">//if HCMD_BUSY of cmd_code set, then do NOT wait for completion</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_CMD_EXE</span><span class="p">,</span> <span class="n">cmd_code</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">(</span><span class="n">cmd_code</span> <span class="o">&amp;</span> <span class="n">HCMD_CMD_CODE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HCMD_TX</span> <span class="o">||</span> <span class="n">cmd_code</span> <span class="o">&amp;</span> <span class="n">HCMD_BUSY</span><span class="p">,</span> <span class="n">cmd_code</span> <span class="p">);</span> <span class="c1">//Tx must have Busy bit set</span>
	<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_SW_0</span><span class="p">,</span> <span class="n">HCF_MAGIC</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_SW_0</span> <span class="p">)</span> <span class="o">==</span> <span class="n">HCF_MAGIC</span> <span class="p">)</span> <span class="p">{</span>                                                      <span class="cm">/* 1 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DefunctStat</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_ERR_NO_NIC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-106"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-106">&#182;</a></div><p>.  if calculated and received MIC do not match
.  .  set status at HCF<em>ERR</em>MIC</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/*2*/</span>   <span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Cmd</span> <span class="o">&amp;</span> <span class="n">HCMD_BUSY</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd_cmpl</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>
		<span class="p">}</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_PARAM_0</span><span class="p">,</span> <span class="n">par_0</span> <span class="p">);</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_CMD</span><span class="p">,</span> <span class="n">cmd_code</span> <span class="o">&amp;~</span><span class="n">HCMD_BUSY</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_Cmd</span> <span class="o">=</span> <span class="n">cmd_code</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">cmd_code</span> <span class="o">&amp;</span> <span class="n">HCMD_BUSY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>    <span class="c1">//;?is this a hot idea, better MEASURE performance impact</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd_cmpl</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">rc</span><span class="p">,</span> <span class="n">cmd_code</span> <span class="p">)</span> <span class="p">);</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_CMD_EXE</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// cmd_exe</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     int download( IFBP ifbp, CFG_PROG_STRCT FAR *ltvp )</span>
<span class="cm"> *.PURPOSE       downloads F/W image into NIC and initiates execution of the downloaded F/W.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   ltvp        specifies the pseudo-RID (as defined by WCI)</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *1: First, Ack everything to unblock a (possibly) blocked cmd pipe line</span>
<span class="cm"> *   Note 1: it is very likely that an Alloc event is pending and very well possible that a (Send) Cmd event is</span>
<span class="cm"> *   pending</span>
<span class="cm"> *   Note 2: it is assumed that this strategy takes away the need to ack every conceivable event after an</span>
<span class="cm"> *   Hermes Initialize</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>
<span class="n">download</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">CFG_PROG_STRCT</span> <span class="n">FAR</span> <span class="o">*</span><span class="n">ltvp</span> <span class="p">)</span>                     <span class="c1">//Hermes-II download (volatile only)</span>
<span class="p">{</span>
	<span class="n">hcf_16</span>              <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>                 <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>
	<span class="n">wci_bufp</span>            <span class="n">cp</span><span class="p">;</span>
	<span class="n">hcf_io</span>              <span class="n">io_port</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span> <span class="o">+</span> <span class="n">HREG_AUX_DATA</span><span class="p">;</span>

	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_DL</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="p">);</span>
<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_PRELOADED</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="p">);</span>
<span class="cp">#else</span></pre></div></td></tr>


<tr id="section-107"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-107">&#182;</a></div><p>return status</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DLMode</span> <span class="o">==</span> <span class="n">CFG_PROG_STOP</span> <span class="o">&amp;&amp;</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">CFG_PROG_VOLATILE</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-108"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-108">&#182;</a></div><p>;?is this a hot idea, better MEASURE performance impact</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/*1*/</span>   <span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_EV_ACK</span><span class="p">,</span> <span class="o">~</span><span class="n">HREG_EV_SLEEP_REQ</span> <span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCMD_INI</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  <span class="cm">/* HCMD_INI can not be part of init() because that is called on</span>
<span class="cm">						     * other occasions as well */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">init</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-109"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-109">&#182;</a></div><p>if initial "program" LTV</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">CFG_PROG_STOP</span> <span class="o">&amp;&amp;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DLMode</span> <span class="o">==</span> <span class="n">CFG_PROG_VOLATILE</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-110"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-110">&#182;</a></div><p>.  switch Hermes to initial mode</p></td><td class="code"><div class="highlight"><pre>		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_PARAM_1</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">nic_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCMD_EXECUTE</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">nic_addr</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">init</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>  <span class="cm">/*;? do we really want to skip init if cmd_exe failed, i.e.</span>
<span class="cm">					     *   IFB_FW_Comp_Id is than possibly incorrect */</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-111"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-111">&#182;</a></div><p>if final "program" LTV</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-112"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-112">&#182;</a></div><p>.  start tertiary (or secondary)</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if 0</span><span class="c">   //;? as long as the next if contains a hard coded 0, might as well leave it out even more obvious</span>
<span class="c">		if ( 0 /*len is definitely not want we want;?*/ &amp;&amp; ltvp-&gt;mode == CFG_PROG_SEEPROM_READBACK ) {</span>
<span class="c">			OPW( HREG_PARAM_1, (hcf_16)(ltvp-&gt;nic_addr &gt;&gt; 16) );</span>
<span class="c">			OPW( HREG_PARAM_2, (hcf_16)((ltvp-&gt;len - 4) &lt;&lt; 1) );</span></pre></div></td></tr>


<tr id="section-113"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-113">&#182;</a></div><p>else (non-final)</p></td><td class="code"><div class="highlight"><pre><span class="c">			rc = cmd_exe( ifbp, HCMD_PROGRAM | ltvp-&gt;mode, (hcf_16)ltvp-&gt;nic_addr );</span></pre></div></td></tr>


<tr id="section-114"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-114">&#182;</a></div><p>.  if mode == Readback SEEPROM</p></td><td class="code"><div class="highlight"><pre><span class="c">			OPW( HREG_AUX_PAGE,   IPW( HREG_RESP_1) );</span>
<span class="c">			OPW( HREG_AUX_OFFSET, IPW( HREG_RESP_0) );</span></pre></div></td></tr>


<tr id="section-115"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-115">&#182;</a></div><p>.  .  perform Hermes prog cmd with appropriate mode bits</p></td><td class="code"><div class="highlight"><pre><span class="c">			i = ( IPW( HREG_RESP_2 ) + 1 ) / 2;  // i contains max buffer size in words, a probably not very useful piece of information ;?</span>
<span class="c">/*Nico&#39;s code based on i is the &quot;real amount of data available&quot;</span>
<span class="c">			if ( ltvp-&gt;len - 4 &lt; i ) rc = HCF_ERR_LEN;</span>
<span class="c">			else ltvp-&gt;len = i + 4;</span>
<span class="c">*/</span>
<span class="c">/* Rolands code based on the idea that a MSF should not ask for more than is available</span></pre></div></td></tr>


<tr id="section-116"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-116">&#182;</a></div><p>.  .  set up NIC RAM addressability according Resp0-1</p></td><td class="code"><div class="highlight"><pre><span class="c">			if ( ltvp-&gt;len - 4 &gt; i ) {</span>
<span class="c">				rc = HCF_ERR_LEN;</span>
<span class="c">				ltvp-&gt;len = i + 4;</span>
<span class="c">			}</span>
<span class="c">*/</span></pre></div></td></tr>


<tr id="section-117"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-117">&#182;</a></div><p>.  .  set up L-field of LTV according Resp2</p></td><td class="code"><div class="highlight"><pre><span class="c">			cp = (wci_bufp)ltvp-&gt;host_addr;                     /*IN_PORT_STRING_8_16 macro may modify its parameters*/</span>
<span class="c">			i = ltvp-&gt;len - 4;</span>
<span class="c">			IN_PORT_STRING_8_16( io_port, cp, i );      //!!!WORD length, cp MUST be a char pointer // $$ char</span></pre></div></td></tr>


<tr id="section-118"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-118">&#182;</a></div><p>check if number of bytes requested exceeds max buffer size</p></td><td class="code"><div class="highlight"><pre><span class="c">		} else</span>
<span class="cp">#endif //;? as long as the above if contains a hard coded 0, might as well leave it out even more obvious</span>
		<span class="p">{</span>                               <span class="c1">//.  .  get number of words to program</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">segment_size</span><span class="p">,</span> <span class="o">*</span><span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">host_addr</span> <span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">segment_size</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-119"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-119">&#182;</a></div><p>.  .  copy data from NIC via AUX port to LTV</p></td><td class="code"><div class="highlight"><pre>			<span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="n">wci_bufp</span><span class="p">)</span><span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">host_addr</span><span class="p">;</span>                     <span class="c1">//OUT_PORT_STRING_8_16 macro may modify its parameters</span></pre></div></td></tr>


<tr id="section-120"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-120">&#182;</a></div><p>.  else (non-final programming)</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">CFG_PROG_VOLATILE</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-121"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-121">&#182;</a></div><p>.  .  copy data (words) from LTV via AUX port to NIC</p></td><td class="code"><div class="highlight"><pre>				<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_AUX_PAGE</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">nic_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span> <span class="o">|</span> <span class="p">(</span><span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">nic_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span> <span class="p">)</span> <span class="p">);</span>
				<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_AUX_OFFSET</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">nic_addr</span> <span class="o">&amp;</span> <span class="mh">0x007E</span><span class="p">)</span> <span class="p">);</span>
				<span class="n">OUT_PORT_STRING_8_16</span><span class="p">(</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">i</span> <span class="p">);</span>     <span class="c1">//!!!WORD length, cp MUST be a char pointer</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DLMode</span> <span class="o">=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>                  <span class="c1">//save state in IFB_DLMode</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_PRELOADED</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span><span class="p">,</span> <span class="n">rc</span> <span class="p">);</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_DL</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// download</span>


<span class="cp">#if (HCF_ASSERT) &amp; HCF_ASSERT_PRINTF</span>
<span class="cm">/**************************************************</span>
<span class="cm"> * Certain Hermes-II firmware versions can generate</span>
<span class="cm"> * debug information. This debug information is</span>
<span class="cm"> * contained in a buffer in nic-RAM, and can be read</span>
<span class="cm"> * via the aux port.</span>
<span class="cm"> **************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>
<span class="n">fw_printf</span><span class="p">(</span><span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">CFG_FW_PRINTF_STRCT</span> <span class="n">FAR</span> <span class="o">*</span><span class="n">ltvp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>
	<span class="n">hcf_16</span> <span class="n">fw_cnt</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-122"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-122">&#182;</a></div><p>.  .  if mode == volatile programming</p></td><td class="code"><div class="highlight"><pre>	<span class="n">hcf_32</span> <span class="n">DbMsgBuffer</span><span class="p">;</span>
	<span class="n">CFG_FW_PRINTF_BUFFER_LOCATION_STRCT</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FwPfBuff</span><span class="p">;</span>
	<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">DbMsgSize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-123"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-123">&#182;</a></div><p>.  .  .  set up NIC RAM addressability via AUX port</p></td><td class="code"><div class="highlight"><pre>		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_AUX_PAGE</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">DbMsgCount</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">);</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_AUX_OFFSET</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">DbMsgCount</span> <span class="o">&amp;</span> <span class="mh">0x7E</span><span class="p">)</span> <span class="p">);</span>
		<span class="n">fw_cnt</span> <span class="o">=</span> <span class="p">((</span><span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_AUX_DATA</span><span class="p">)</span> <span class="o">&gt;&gt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">DbMsgSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">fw_cnt</span> <span class="o">!=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DbgPrintF_Cnt</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-124"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-124">&#182;</a></div><p>hcf<em>32 DbMsgBuffer = 0x29D2, DbMsgCount= 0x000029D0;
hcf</em>16 DbMsgSize=0x00000080;</p></td><td class="code"><div class="highlight"><pre>			<span class="n">DbMsgBuffer</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">DbMsgBuffer</span> <span class="o">+</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DbgPrintF_Cnt</span> <span class="o">*</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// each entry is 3 words</span>
			<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_AUX_PAGE</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">DbMsgBuffer</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">);</span>
			<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_AUX_OFFSET</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">DbMsgBuffer</span> <span class="o">&amp;</span> <span class="mh">0x7E</span><span class="p">)</span> <span class="p">);</span>
			<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">msg_id</span>     <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span><span class="n">HREG_AUX_DATA</span><span class="p">);</span>
			<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">msg_par</span>    <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span><span class="n">HREG_AUX_DATA</span><span class="p">);</span>
			<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">msg_tstamp</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span><span class="n">HREG_AUX_DATA</span><span class="p">);</span>
			<span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DbgPrintF_Cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DbgPrintF_Cnt</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">DbMsgSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_PRINTF</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     hcf_16 get_fid( IFBP ifbp )</span>
<span class="cm"> *.PURPOSE       get allocated FID for either transmit or notify.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   0   no FID available</span>
<span class="cm"> *   &lt;&gt;0 FID number</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *   The preference is to use a &quot;pending&quot; alloc. If no alloc is pending, then - if available - the &quot;spare&quot; FID</span>
<span class="cm"> *   is used.</span>
<span class="cm"> *   If the spare FID is used, IFB_RscInd (representing the spare FID) must be cleared</span>
<span class="cm"> *   If the pending alloc is used, the alloc event must be acknowledged to the Hermes.</span>
<span class="cm"> *   In case the spare FID was depleted and the IFB_RscInd has been &quot;faked&quot; as pseudo resource with a 0x0001</span>
<span class="cm"> *   value by hcf_service_nic, IFB_RscInd has to be &quot;corrected&quot; again to its 0x0000 value.</span>
<span class="cm"> *</span>
<span class="cm"> *   Note that due to the Hermes-II H/W problems which are intended to be worked around by DAWA, the Alloc bit</span>
<span class="cm"> *   in the Event register is no longer a reliable indication of the presence/absence of a FID. The &quot;Clear FID&quot;</span>
<span class="cm"> *   part of the DAWA logic, together with the choice of the definition of the return information from get_fid,</span>
<span class="cm"> *   handle this automatically, i.e. without additional code in get_fid.</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="n">hcf_16</span>
<span class="nf">get_fid</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">)</span>
<span class="p">{</span>

	<span class="n">hcf_16</span> <span class="n">fid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#if ( (HCF_TYPE) &amp; HCF_TYPE_HII5 ) == 0</span>
	<span class="n">PROT_CNT_INI</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_HII5</span>

	<span class="n">IF_DMA</span><span class="p">(</span> <span class="n">HCFASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">USE_DMA</span><span class="p">),</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span><span class="p">)</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HREG_EV_ALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fid</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_ALLOC_FID</span> <span class="p">);</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="p">);</span>
		<span class="n">DAWA_ZERO_FID</span><span class="p">(</span> <span class="n">HREG_ALLOC_FID</span> <span class="p">);</span>
<span class="cp">#if ( (HCF_TYPE) &amp; HCF_TYPE_HII5 ) == 0</span>
		<span class="n">HCF_WAIT_WHILE</span><span class="p">(</span> <span class="p">(</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">HREG_EV_ACK_REG_READY</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">prot_cnt</span><span class="p">,</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span> <span class="p">)</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_HII5</span>
		<span class="n">DAWA_ACK</span><span class="p">(</span> <span class="n">HREG_EV_ALLOC</span> <span class="p">);</span>          <span class="c1">//!!note that HREG_EV_ALLOC is written only once</span></pre></div></td></tr>


<tr id="section-125"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-125">&#182;</a></div><p>first, check the counter in nic-RAM and compare it to the latest counter value of the HCF</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-126"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-126">&#182;</a></div><pre><code>    DbgPrint("fw_cnt=%d IFB_DbgPrintF_Cnt=%d\n", fw_cnt, ifbp-&gt;IFB_DbgPrintF_Cnt);
</code></pre></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-127"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-127">&#182;</a></div><p>180 degree error in logic ;? #if ALLOC_15</p></td><td class="code"><div class="highlight"><pre>		<span class="n">fid</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-128"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-128">&#182;</a></div><h1>endif // ALLOC_15</h1></td><td class="code"><div class="highlight"><pre>		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fid</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// get_fid</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     void get_frag( IFBP ifbp, wci_bufp bufp, int len BE_PAR( int word_len ) )</span>
<span class="cm"> *.PURPOSE       reads with 16/32 bit I/O via BAP1 port from NIC RAM to Host memory.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   bufp        (byte) address of buffer</span>
<span class="cm"> *   len         length in bytes of buffer specified by bufp</span>
<span class="cm"> *   word_len    Big Endian only: number of leading bytes to swap in pairs</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * process the single byte (if applicable) read by the previous get_frag and copy len (or len-1) bytes from</span>
<span class="cm"> * NIC to bufp.</span>
<span class="cm"> * On a Big Endian platform, the parameter word_len controls the number of leading bytes whose endianness is</span>
<span class="cm"> * converted (i.e. byte swapped)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *10: The PCMCIA card can be removed in the middle of the transfer. By depositing a &quot;magic number&quot; in the</span>
<span class="cm"> *   HREG_SW_0 register of the Hermes at initialization time and by verifying this register, it can be</span>
<span class="cm"> *   determined whether the card is still present. The return status is set accordingly.</span>
<span class="cm"> *   Clearing the buffer is a (relative) cheap way to prevent that failing I/O results in run-away behavior</span>
<span class="cm"> *   because the garbage in the buffer is interpreted by the caller irrespective of the return status (e.g.</span>
<span class="cm"> *   hcf_service_nic has this behavior).</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *   It turns out DOS ODI uses zero length fragments. The HCF code can cope with it, but as a consequence, no</span>
<span class="cm"> *   Assert on len is possible</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>
<span class="nf">get_frag</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">wci_bufp</span> <span class="n">bufp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span> <span class="n">BE_PAR</span><span class="p">(</span> <span class="kt">int</span> <span class="n">word_len</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">hcf_io</span>      <span class="n">io_port</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span> <span class="o">+</span> <span class="n">HREG_DATA_1</span><span class="p">;</span>   <span class="c1">//BAP data register</span>
	<span class="n">wci_bufp</span>    <span class="n">p</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">;</span>                                   <span class="c1">//working pointer</span>
	<span class="kt">int</span>         <span class="n">i</span><span class="p">;</span>                                          <span class="c1">//prevent side effects from macro</span>
	<span class="kt">int</span>         <span class="n">j</span><span class="p">;</span>

	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">((</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">bufp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HCF_ALIGN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">bufp</span> <span class="p">);</span>

<span class="cm">/*1:    here recovery logic for intervening BAP access between hcf_service_nic and hcf_rcv_msg COULD be added</span>
<span class="cm"> *  if current access is RxInitial</span>
<span class="cm"> *  .  persistent_offset += len</span>
<span class="cm"> */</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-129"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-129">&#182;</a></div><p>180 degree error in logic ;? #if ALLOC_15</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryIn</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-130"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-130">&#182;</a></div><h1>endif // ALLOC_15</h1></td><td class="code"><div class="highlight"><pre>		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_8</span><span class="p">)(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryIn</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-131"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-131">&#182;</a></div><p>if buffer length > 0 and carry from previous get_frag</p></td><td class="code"><div class="highlight"><pre>		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryIn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if (HCF_IO) &amp; HCF_IO_32BITS</span></pre></div></td></tr>


<tr id="section-132"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-132">&#182;</a></div><p>.  move carry to buffer
.  adjust buffer length and pointer accordingly</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">USE_16BIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">6</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">hcf_32</span> <span class="n">FAR</span>  <span class="o">*</span><span class="n">p4</span><span class="p">;</span> <span class="c1">//prevent side effects from macro</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>           <span class="c1">//.  if buffer at least word aligned</span>
			<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mh">0x2</span> <span class="p">)</span> <span class="p">{</span>            <span class="c1">//.  .  if buffer not double word aligned</span></pre></div></td></tr>


<tr id="section-133"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-133">&#182;</a></div><p>.  clear carry flag</p></td><td class="code"><div class="highlight"><pre>				<span class="o">*</span><span class="p">(</span><span class="n">wci_recordp</span><span class="p">)</span><span class="n">p</span> <span class="o">=</span> <span class="n">IN_PORT_WORD</span><span class="p">(</span> <span class="n">io_port</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-134"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-134">&#182;</a></div><p>skip zero-length I/O, single byte I/O and I/O not worthwhile (i.e. less than 6 bytes)for DW logic
if buffer length >= 6 and 32 bits I/O support</p></td><td class="code"><div class="highlight"><pre>				<span class="n">p</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">i</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-135"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-135">&#182;</a></div><p>.  .  .  read single word to get double word aligned</p></td><td class="code"><div class="highlight"><pre>			<span class="n">p4</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_32</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
			<span class="n">IN_PORT_STRING_32</span><span class="p">(</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-136"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-136">&#182;</a></div><p>.  .  .  adjust buffer length and pointer accordingly</p></td><td class="code"><div class="highlight"><pre>			<span class="n">p</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x0003</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">&amp;=</span> <span class="mh">0x0003</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_IO_32BITS</span></pre></div></td></tr>


<tr id="section-137"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-137">&#182;</a></div><p>.  .  read as many double word as possible</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-138"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-138">&#182;</a></div><p>.  .  adjust buffer length and pointer accordingly</p></td><td class="code"><div class="highlight"><pre>		<span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">IN_PORT_STRING_8_16</span><span class="p">(</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-139"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-139">&#182;</a></div><p>if no 32-bit support OR byte aligned OR 1-3 bytes left</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x0001</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-140"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-140">&#182;</a></div><p>.  read as many word as possible in "alignment safe" way</p></td><td class="code"><div class="highlight"><pre>			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryIn</span> <span class="o">=</span> <span class="n">IN_PORT_WORD</span><span class="p">(</span> <span class="n">io_port</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-141"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-141">&#182;</a></div><p>.  if 1 byte left</p></td><td class="code"><div class="highlight"><pre>			<span class="n">bufp</span><span class="p">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_8</span><span class="p">)</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryIn</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-142"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-142">&#182;</a></div><p>.  .  read 1 word</p></td><td class="code"><div class="highlight"><pre>			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryIn</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#if HCF_BIG_ENDIAN</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">word_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">word_len</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">word_len</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="n">word_len</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">word_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">((</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">bufp</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">bufp</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">word_len</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">,</span> <span class="n">MERGE2</span><span class="p">(</span> <span class="n">word_len</span><span class="p">,</span> <span class="n">len</span> <span class="p">)</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-143"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-143">&#182;</a></div><p>.  .  store LSB in last char of buffer</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="n">word_len</span> <span class="p">)</span> <span class="p">{</span>                               <span class="c1">//.  if there is anything to convert</span>
		<span class="n">hcf_8</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>                                <span class="c1">//.  .  convert the 1st hcf_16</span>
		<span class="n">bufp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">bufp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">word_len</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>                       <span class="c1">//.  .  if there is to convert more than 1 word ( i.e 2 )</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>                            <span class="c1">//.  .  .  convert the 2nd hcf_16</span>
			<span class="n">bufp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="n">bufp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_BIG_ENDIAN</span>
<span class="p">}</span> <span class="c1">// get_frag</span>

<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     int init( IFBP ifbp )</span>
<span class="cm"> *.PURPOSE       Handles common initialization aspects (H-I init, calibration, config.mngmt, allocation).</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_ERR_INCOMP_PRI</span>
<span class="cm"> *   HCF_ERR_INCOMP_FW</span>
<span class="cm"> *   HCF_ERR_TIME_OUT</span>
<span class="cm"> *   &gt;&gt;hcf_get_info</span>
<span class="cm"> *       HCF_ERR_NO_NIC</span>
<span class="cm"> *       HCF_ERR_LEN</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * init will successively:</span>
<span class="cm"> * - in case of a (non-preloaded) H-I, initialize the NIC</span>
<span class="cm"> * - calibrate the S/W protection timer against the Hermes Timer</span>
<span class="cm"> * - collect HSI, &quot;active&quot; F/W Configuration Management Information</span>
<span class="cm"> * - in case active F/W is Primary F/W: collect Primary F/W Configuration Management Information</span>
<span class="cm"> * - check HSI and Primary F/W compatibility with the HCF</span>
<span class="cm"> * - in case active F/W is Station or AP F/W: check Station or AP F/W compatibility with the HCF</span>
<span class="cm"> * - in case active F/W is not Primary F/W: allocate FIDs to be used in transmit/notify process</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *2: drop all error status bits in IFB_CardStat since they are expected to be re-evaluated.</span>
<span class="cm"> *4: Ack everything except HREG_EV_SLEEP_REQ. It is very likely that an Alloc event is pending and</span>
<span class="cm"> *   very well possible that a Send Cmd event is pending. Acking HREG_EV_SLEEP_REQ is handled by hcf_action(</span>
<span class="cm"> *   HCF_ACT_INT_ON ) !!!</span>
<span class="cm"> *10: Calibrate the S/W time-out protection mechanism by calling calibrate(). Note that possible errors</span>
<span class="cm"> *   in the calibration process are nor reported by init but will show up via the defunct mechanism in</span>
<span class="cm"> *   subsequent hcf-calls.</span>
<span class="cm"> *14: usb_check_comp() is called to have the minimal visual clutter for the legacy H-I USB dongle</span>
<span class="cm"> *   compatibility check.</span>
<span class="cm"> *16: The following configuration management related information is retrieved from the NIC:</span>
<span class="cm"> *    - HSI supplier</span>
<span class="cm"> *    - F/W Identity</span>
<span class="cm"> *    - F/W supplier</span>
<span class="cm"> *    if appropriate:</span>
<span class="cm"> *    - PRI Identity</span>
<span class="cm"> *    - PRI supplier</span>
<span class="cm"> *    appropriate means on H-I: always</span>
<span class="cm"> *    and on H-II if F/W supplier reflects a primary (i.e. only after an Hermes Reset or Init</span>
<span class="cm"> *    command).</span>
<span class="cm"> *    QUESTION ;? !!!!!! should, For each of the above RIDs the Endianness is converted to native Endianness.</span>
<span class="cm"> *    Only the return code of the first hcf_get_info is used. All hcf_get_info calls are made, regardless of</span>
<span class="cm"> *    the success or failure of the 1st hcf_get_info. The assumptions are:</span>
<span class="cm"> *     - if any call fails, they all fail, so remembering the result of the 1st call is adequate</span>
<span class="cm"> *     - a failing call will overwrite the L-field with a 0x0000 value, which services both as an</span>
<span class="cm"> *       error indication for the values cached in the IFB as making mmd_check_comp fail.</span>
<span class="cm"> *    In case of H-I, when getting the F/W identity fails, the F/W is assumed to be H-I AP F/W pre-dating</span>
<span class="cm"> *    version 9.0 and the F/W Identity and Supplier are faked accordingly.</span>
<span class="cm"> *    In case of H-II, the Primary, Station and AP Identity are merged into a single F/W Identity.</span>
<span class="cm"> *    The same applies to the Supplier information. As a consequence the PRI information can no longer be</span>
<span class="cm"> *    retrieved when a Tertiary runs. To accommodate MSFs and Utilities who depend on PRI information being</span>
<span class="cm"> *    available at any time, this information is cached in the IFB. In this cache the generic &quot;F/W&quot; value of</span>
<span class="cm"> *    the typ-fields is overwritten with the specific (legacy) &quot;PRI&quot; values. To actually re-route the (legacy)</span>
<span class="cm"> *    PRI request via hcf_get_info, the xxxx-table must be set.  In case of H-I, this caching, modifying and</span>
<span class="cm"> *    re-routing is not needed because PRI information is always available directly from the NIC. For</span>
<span class="cm"> *    consistency the caching fields in the IFB are filled with the PRI information anyway.</span>
<span class="cm"> *18: mdd_check_comp() is called to check the Supplier Variant and Range of the Host-S/W I/F (HSI) and the</span>
<span class="cm"> *   Primary Firmware Variant and Range against the Top and Bottom level supported by this HCF.  If either of</span>
<span class="cm"> *   these tests fails, the CARD_STAT_INCOMP_PRI bit of IFB_CardStat is set</span>
<span class="cm"> *   Note: There should always be a primary except during production, so this makes the HCF in its current form</span>
<span class="cm"> *   unsuitable for manufacturing test systems like the FTS. This can be remedied by an adding a test like</span>
<span class="cm"> *   ifbp-&gt;IFB_PRISup.id == COMP_ID_PRI</span>
<span class="cm"> *20: In case there is Tertiary F/W and this F/W is Station F/W, the Supplier Variant and Range of the Station</span>
<span class="cm"> *   Firmware function as retrieved from the Hermes is checked against the Top and Bottom level supported by</span>
<span class="cm"> *   this HCF.</span>
<span class="cm"> *   Note: ;? the tertiary F/W compatibility checks could be moved to the DHF, which already has checked the</span>
<span class="cm"> *   CFI and MFI compatibility of the image with the NIC before the image was downloaded.</span>
<span class="cm"> *28: In case of non-Primary F/W: allocates and acknowledge a (TX or Notify) FID and allocates without</span>
<span class="cm"> *   acknowledge another (TX or Notify) FID (the so-called 1.5 alloc scheme) with the following steps:</span>
<span class="cm"> *   - execute the allocate command by calling cmd_exe</span>
<span class="cm"> *   - wait till either the alloc event or a time-out occurs</span>
<span class="cm"> *   - regardless whether the alloc event occurs, call get_fid to</span>
<span class="cm"> *     - read the FID and save it in IFB_RscInd to be used as &quot;spare FID&quot;</span>
<span class="cm"> *     - acknowledge the alloc event</span>
<span class="cm"> *     - do another &quot;half&quot; allocate to complete the &quot;1.5 Alloc scheme&quot;</span>
<span class="cm"> *     Note that above 3 steps do not harm and thus give the &quot;cheapest&quot; acceptable strategy.</span>
<span class="cm"> *     If a time-out occurred, then report time out status (after all)</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>
<span class="nf">init</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>

	<span class="n">HCFLOGENTRY</span><span class="p">(</span> <span class="n">HCF_TRACE_INIT</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                                         <span class="cm">/* 2*/</span>
	<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_EV_ACK</span><span class="p">,</span> <span class="o">~</span><span class="n">HREG_EV_SLEEP_REQ</span> <span class="p">);</span>                                             <span class="cm">/* 4*/</span>
	<span class="n">IF_PROT_TIME</span><span class="p">(</span> <span class="n">calibrate</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">)</span> <span class="p">);</span>                                                  <span class="cm">/*10*/</span>
<span class="cp">#if 0</span><span class="c"> // OOR</span>
<span class="c">	ifbp-&gt;IFB_FWIdentity.len = 2;                           //misuse the IFB space for a put</span>
<span class="c">	ifbp-&gt;IFB_FWIdentity.typ = CFG_TICK_TIME;</span>
<span class="c">	ifbp-&gt;IFB_FWIdentity.comp_id = (1000*1000)/1024 + 1;    //roughly 1 second</span>
<span class="c">	hcf_put_info( ifbp, (LTVP)&amp;ifbp-&gt;IFB_FWIdentity.len );</span>
<span class="cp">#endif // OOR</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CFG_FW_IDENTITY_STRCT</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">CFG_FW_IDENTITY</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hcf_get_info</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">LTVP</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">len</span> <span class="p">);</span>
<span class="cm">/* ;? conversion should not be needed for mmd_check_comp */</span>
<span class="cp">#if HCF_BIG_ENDIAN</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">comp_id</span>       <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">comp_id</span> <span class="p">);</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">variant</span>       <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">variant</span> <span class="p">);</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">version_major</span> <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">version_major</span> <span class="p">);</span>
	<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">version_minor</span> <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">version_minor</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_BIG_ENDIAN</span>
<span class="cp">#if defined MSF_COMPONENT_ID                                                                        </span><span class="cm">/*14*/</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span> <span class="p">)</span> <span class="p">{</span>                                                                      <span class="cm">/*16*/</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CFG_SUP_RANGE_STRCT</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">CFG_NIC_HSI_SUP_RANGE</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">hcf_get_info</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">LTVP</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">len</span> <span class="p">);</span>
<span class="cm">/* ;? conversion should not be needed for mmd_check_comp , BUT according to a report of a BE-user it is</span>
<span class="cm"> * should be resolved in the WARP release</span>
<span class="cm"> * since some compilers make ugly but unnecessary code of these instructions even for LE,</span>
<span class="cm"> * it is conditionally compiled */</span>
<span class="cp">#if HCF_BIG_ENDIAN</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">role</span>    <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">role</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">id</span>      <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">id</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">variant</span> <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">variant</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">bottom</span>  <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">bottom</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">top</span>     <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">.</span><span class="n">top</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_BIG_ENDIAN</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CFG_SUP_RANGE_STRCT</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">CFG_FW_SUP_RANGE</span><span class="p">;</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">hcf_get_info</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">LTVP</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">len</span> <span class="p">);</span>
<span class="cm">/* ;? conversion should not be needed for mmd_check_comp */</span>
<span class="cp">#if HCF_BIG_ENDIAN</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">role</span>    <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">role</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">id</span>      <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">id</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">variant</span> <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">variant</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">bottom</span>  <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">bottom</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">top</span>     <span class="o">=</span> <span class="n">CNV_LITTLE_TO_SHORT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">top</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_BIG_ENDIAN</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">COMP_ID_PRI</span> <span class="p">)</span> <span class="p">{</span>                                              <span class="cm">/* 20*/</span>
			<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">CFG_FW_IDENTITY_STRCT</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CFG_SUP_RANGE_STRCT</span> <span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span> <span class="n">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">((</span><span class="n">hcf_8</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_PRIIdentity</span><span class="p">))[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">hcf_8</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">))[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_PRIIdentity</span><span class="p">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">CFG_PRI_IDENTITY</span><span class="p">;</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_PRISup</span><span class="p">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">CFG_PRI_SUP_RANGE</span><span class="p">;</span>
			<span class="n">xxxx</span><span class="p">[</span><span class="n">xxxx_PRI_IDENTITY_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_PRIIdentity</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
			<span class="n">xxxx</span><span class="p">[</span><span class="n">xxxx_PRI_IDENTITY_OFFSET</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_PRISup</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">mmd_check_comp</span><span class="p">(</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cfg_drv_act_ranges_hsi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HSISup</span><span class="p">)</span>                 <span class="cm">/* 22*/</span>
<span class="cp">#if ( (HCF_TYPE) &amp; HCF_TYPE_PRELOADED ) == 0</span></pre></div></td></tr>


<tr id="section-144"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-144">&#182;</a></div><p>.  .  save MSB in carry, set carry flag</p></td><td class="code"><div class="highlight"><pre>		     <span class="o">||</span> <span class="o">!</span><span class="n">mmd_check_comp</span><span class="p">(</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cfg_drv_act_ranges_pri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_PRISup</span><span class="p">)</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_PRELOADED</span>
			<span class="p">)</span> <span class="p">{</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">=</span> <span class="n">CARD_STAT_INCOMP_PRI</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_ERR_INCOMP_PRI</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">COMP_ID_STA</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mmd_check_comp</span><span class="p">(</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cfg_drv_act_ranges_sta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">)</span> <span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">COMP_ID_APF</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mmd_check_comp</span><span class="p">(</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cfg_drv_act_ranges_apf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWSup</span><span class="p">)</span> <span class="p">)</span>
			<span class="p">)</span> <span class="p">{</span>                                                                                  <span class="cm">/* 24 */</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">|=</span> <span class="n">CARD_STAT_INCOMP_FW</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_ERR_INCOMP_FW</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// MSF_COMPONENT_ID</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span> <span class="o">&amp;&amp;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_FWIdentity</span><span class="p">.</span><span class="n">comp_id</span> <span class="o">&gt;=</span> <span class="n">COMP_ID_FW_STA</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">PROT_CNT_INI</span><span class="p">;</span>
		<span class="cm">/**************************************************************************************</span>
<span class="cm">		 * rlav: the DMA engine needs the host to cause a &#39;hanging alloc event&#39; for it to consume.</span>
<span class="cm">		 * not sure if this is the right spot in the HCF, thinking about hcf_enable...</span>
<span class="cm">		 **************************************************************************************/</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCMD_ALLOC</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-145"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-145">&#182;</a></div><p>see put<em>frag for an alternative implementation, but be careful about what are int's and what are
hcf</em>16's</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">HCF_WAIT_WHILE</span><span class="p">(</span> <span class="p">(</span><span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">HREG_EV_ALLOC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
			<span class="n">IF_PROT_TIME</span><span class="p">(</span> <span class="n">HCFASSERT</span><span class="p">(</span><span class="n">prot_cnt</span><span class="p">,</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_EV_STAT</span> <span class="p">))</span> <span class="p">);</span>
<span class="cp">#if HCF_DMA</span>
			<span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">USE_DMA</span> <span class="p">)</span> <span class="p">)</span>
<span class="cp">#endif </span><span class="c1">// HCF_DMA</span>
			<span class="p">{</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span> <span class="o">=</span> <span class="n">get_fid</span><span class="p">(</span> <span class="n">ifbp</span> <span class="p">);</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RscInd</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
				<span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCMD_ALLOC</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
				<span class="n">IF_PROT_TIME</span><span class="p">(</span> <span class="k">if</span> <span class="p">(</span> <span class="n">prot_cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_ERR_TIME_OUT</span> <span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-146"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-146">&#182;</a></div><p>;? the PRI compatibility check is only relevant for DHF</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span>

	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span><span class="p">,</span> <span class="n">rc</span> <span class="p">);</span>
	<span class="n">HCFLOGEXIT</span><span class="p">(</span> <span class="n">HCF_TRACE_INIT</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// init</span>

<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     void isr_info( IFBP ifbp )</span>
<span class="cm"> *.PURPOSE       handles link events.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *1: First the FID number corresponding with the InfoEvent is determined.</span>
<span class="cm"> *   Note the complication of the zero-FID protection sub-scheme in DAWA.</span>
<span class="cm"> *   Next the L-field and the T-field are fetched into scratch buffer info.</span>
<span class="cm"> *2: In case of tallies, the 16 bits Hermes values are accumulated in the IFB into 32 bits values. Info[0]</span>
<span class="cm"> *   is (expected to be) HCF_NIC_TAL_CNT + 1. The contraption &quot;while ( info[0]-- &gt;1 )&quot; rather than</span>
<span class="cm"> *   &quot;while ( --info[0] )&quot; is used because it is dangerous to determine the length of the Value field by</span>
<span class="cm"> *   decrementing info[0]. As a result of a bug in some version of the F/W, info[0] may be 0, resulting</span>
<span class="cm"> *   in a very long loop in the pre-decrement logic.</span>
<span class="cm"> *4: In case of a link status frame, the information is copied to the IFB field IFB_linkStat</span>
<span class="cm"> *6: All other than Tallies (including &quot;unknown&quot; ones) are checked against the selection set by the MSF</span>
<span class="cm"> *   via CFG_RID_LOG. If a match is found or the selection set has the wild-card type (i.e non-NULL buffer</span>
<span class="cm"> *   pointer at the terminating zero-type), the frame is copied to the (type-specific) log buffer.</span>
<span class="cm"> *   Note that to accumulate tallies into IFB AND to log them or to log a frame when a specific match occures</span>
<span class="cm"> *   AND based on the wild-card selection, you have to call setup_bap again after the 1st copy.</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>
<span class="nf">isr_info</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">hcf_16</span>  <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fid</span><span class="p">;</span>
<span class="cp">#if (HCF_EXT) &amp; HCF_EXT_INFO_LOG</span>
	<span class="n">RID_LOGP</span>    <span class="n">ridp</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_RIDLogp</span><span class="p">;</span>   <span class="c1">//NULL or pointer to array of RID_LOG structures (terminated by zero typ)</span>
<span class="cp">#endif </span><span class="c1">// HCF_EXT_INFO_LOG</span>

	<span class="n">HCFTRACE</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCF_TRACE_ISR_INFO</span> <span class="p">);</span>                                                               <span class="cm">/* 1 */</span>
	<span class="n">fid</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_INFO_FID</span> <span class="p">);</span>
	<span class="n">DAWA_ZERO_FID</span><span class="p">(</span> <span class="n">HREG_INFO_FID</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">fid</span> <span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setup_bap</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IO_IN</span> <span class="p">);</span>
		<span class="n">get_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">wci_bufp</span><span class="p">)</span><span class="n">info</span><span class="p">,</span> <span class="mi">4</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">);</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">HCF_MAX_LTV</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">);</span>  <span class="c1">//;? a smaller value makes more sense</span>
<span class="cp">#if (HCF_TALLIES) &amp; HCF_TALLIES_NIC     </span><span class="c1">//Hermes tally support</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">CFG_TALLIES</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">hcf_32</span>  <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="cm">/*2*/</span>   <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">HCF_NIC_TAL_CNT</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">HCF_NIC_TAL_CNT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_32</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_NIC_Tallies</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span> <span class="o">&gt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">+=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_DATA_1</span> <span class="p">);</span>  <span class="c1">//request may return zero length</span>
		<span class="p">}</span>
		<span class="k">else</span>
<span class="cp">#endif </span><span class="c1">// HCF_TALLIES_NIC</span>
		<span class="p">{</span>
		<span class="cm">/*4*/</span>   <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">CFG_LINK_STAT</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_LinkStat</span> <span class="o">=</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_DATA_1</span> <span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#if (HCF_EXT) &amp; HCF_EXT_INFO_LOG</span>
		<span class="cm">/*6*/</span>   <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">ridp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ridp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">==</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span> <span class="n">ridp</span><span class="o">-&gt;</span><span class="n">bufp</span> <span class="p">)</span> <span class="p">{</span>
						<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ridp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ridp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="p">);</span>
						<span class="n">ridp</span><span class="o">-&gt;</span><span class="n">bufp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">ridp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>     <span class="c1">//save L</span>
						<span class="n">ridp</span><span class="o">-&gt;</span><span class="n">bufp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>                        <span class="c1">//save T</span>
						<span class="n">get_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">wci_bufp</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ridp</span><span class="o">-&gt;</span><span class="n">bufp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="n">ridp</span><span class="o">-&gt;</span><span class="n">bufp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
					<span class="p">}</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ridp</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_EXT_INFO_LOG</span>
		<span class="p">}</span>
		<span class="n">HCFTRACE</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCF_TRACE_ISR_INFO</span> <span class="o">|</span> <span class="n">HCF_TRACE_EXIT</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// isr_info</span></pre></div></td></tr>


<tr id="section-147"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-147">&#182;</a></div><p>180 degree error in logic ;? #if ALLOC<em>15
    ifbp->IFB</em>RscInd = 1;   //let's hope that by the time hcf<em>send</em>msg isa called, there will be a FID</p>

<h1>else</h1></td><td class="code"><div class="highlight"><pre><span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     void mdd_assert( IFBP ifbp, unsigned int line_number, hcf_32 q )</span>
<span class="cm"> *.PURPOSE       filters assert on level and interfaces to the MSF supplied msf_assert routine.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   line_number line number of the line which caused the assert</span>
<span class="cm"> *   q           qualifier, additional information which may give a clue about the problem</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> * mdd_assert has been through a turmoil, renaming hcf_assert to assert and hcf_assert again and supporting off</span>
<span class="cm"> * and on being called from the MSF level and other ( immature ) ModularDriverDevelopment modules like DHF and</span>
<span class="cm"> * MMD.</span>
<span class="cm"> * !!!! The assert routine is not an hcf_..... routine in the sense that it may be called by the MSF,</span>
<span class="cm"> *      however it is called from mmd.c and dhf.c, so it must be external.</span>
<span class="cm"> *      To prevent namespace pollution it needs a prefix, to prevent that MSF programmers think that</span>
<span class="cm"> *      they are allowed to call the assert logic, the prefix HCF can&#39;t be used, so MDD is selected!!!!</span>
<span class="cm"> *</span>
<span class="cm"> * When called from the DHF module the line number is incremented by DHF_FILE_NAME_OFFSET and when called from</span>
<span class="cm"> * the MMD module by MMD_FILE_NAME_OFFSET.</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="cp">#if HCF_ASSERT</span>
<span class="kt">void</span>
<span class="nf">mdd_assert</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line_number</span><span class="p">,</span> <span class="n">hcf_32</span> <span class="n">q</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">hcf_16</span>  <span class="n">run_time_flag</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertLvl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">run_time_flag</span> <span class="cm">/* &gt; ;?????? */</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">//prevent recursive behavior, later to be extended to level filtering</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertQualifier</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertLine</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">line_number</span><span class="p">;</span>
<span class="cp">#if (HCF_ASSERT) &amp; ( HCF_ASSERT_LNK_MSF_RTN | HCF_ASSERT_RT_MSF_RTN )</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertRtn</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertRtn</span><span class="p">(</span> <span class="n">line_number</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertTrace</span><span class="p">,</span> <span class="n">q</span> <span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_LNK_MSF_RTN / HCF_ASSERT_RT_MSF_RTN</span>
<span class="cp">#if (HCF_ASSERT) &amp; HCF_ASSERT_SW_SUP</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_SW_2</span><span class="p">,</span> <span class="n">line_number</span> <span class="p">);</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_SW_2</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertTrace</span> <span class="p">);</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_SW_2</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">q</span> <span class="p">);</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_SW_2</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)(</span><span class="n">q</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="p">)</span> <span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_SW_SUP</span>

<span class="cp">#if (HCF_ASSERT) &amp; HCF_ASSERT_MB</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertLvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                    <span class="c1">// prevent recursive behavior</span>
		<span class="n">hcf_put_info</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">LTVP</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertStrct</span> <span class="p">);</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_AssertLvl</span> <span class="o">=</span> <span class="n">run_time_flag</span><span class="p">;</span>                        <span class="c1">// restore appropriate filter level</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_MB</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="c1">// mdd_assert</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     void put_frag( IFBP ifbp, wci_bufp bufp, int len BE_PAR( int word_len ) )</span>
<span class="cm"> *.PURPOSE       writes with 16/32 bit I/O via BAP1 port from Host memory to NIC RAM.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   bufp        (byte) address of buffer</span>
<span class="cm"> *   len         length in bytes of buffer specified by bufp</span>
<span class="cm"> *   word_len    Big Endian only: number of leading bytes to swap in pairs</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * process the single byte (if applicable) not yet written by the previous put_frag and copy len</span>
<span class="cm"> * (or len-1) bytes from bufp to NIC.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *   It turns out DOS ODI uses zero length fragments. The HCF code can cope with it, but as a consequence, no</span>
<span class="cm"> *   Assert on len is possible</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>
<span class="nf">put_frag</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">wci_bufp</span> <span class="n">bufp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span> <span class="n">BE_PAR</span><span class="p">(</span> <span class="kt">int</span> <span class="n">word_len</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">hcf_io</span>      <span class="n">io_port</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_IOBase</span> <span class="o">+</span> <span class="n">HREG_DATA_1</span><span class="p">;</span>   <span class="c1">//BAP data register</span>
	<span class="kt">int</span>         <span class="n">i</span><span class="p">;</span>                                          <span class="c1">//prevent side effects from macro</span>
	<span class="n">hcf_16</span>      <span class="n">j</span><span class="p">;</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="p">((</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">bufp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HCF_ALIGN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">bufp</span> <span class="p">);</span>
<span class="cp">#if HCF_BIG_ENDIAN</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">word_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">word_len</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">word_len</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="n">word_len</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">word_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">((</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">bufp</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">bufp</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">word_len</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">word_len</span><span class="p">,</span> <span class="n">len</span> <span class="p">)</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">word_len</span> <span class="p">)</span> <span class="p">{</span>                                   <span class="c1">//if there is anything to convert</span></pre></div></td></tr>


<tr id="section-148"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-148">&#182;</a></div><h1>endif // ALLOC_15</h1></td><td class="code"><div class="highlight"><pre>		<span class="n">j</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">bufp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">OUT_PORT_WORD</span><span class="p">(</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-149"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-149">&#182;</a></div><h1>endif // HCF<em>TALLIES</em>NIC</h1>

<p>/<em>4</em>/    if ( info[1] == CFG<em>LINK</em>STAT ) {
         ifbp->IFB<em>DSLinkStat = IPW( HREG</em>DATA<em>1 ) | CFG</em>LINK<em>STAT</em>CHANGE;   //corrupts BAP !! ;?
         ifbp->IFB<em>LinkStat = ifbp->IFB</em>DSLinkStat &amp; CFG<em>LINK</em>STAT<em>FW; //;? to be obsoleted
         printk( "&lt;4>linkstatus: %04x\n", ifbp->IFB</em>DSLinkStat );        //;?remove me 1 day</p>

<h1>if (HCF<em>SLEEP) &amp; HCF</em>DDS</h1>

<pre><code>     if ( ( ifbp-&gt;IFB_DSLinkStat &amp; CFG_LINK_STAT_CONNECTED ) == 0 ) {    //even values are disconnected etc.
         ifbp-&gt;IFB_TickCnt = 0;              //start 2 second period (with 1 tick uncertanty)
         printk( "&lt;5&gt;isr_info: AwaitConnection phase started, IFB_TickCnt = 0\n" );      //;?remove me 1 day
     }
</code></pre>

<h1>endif // HCF_DDS</h1>

<pre><code> }
</code></pre>

<h1>if (HCF<em>EXT) &amp; HCF</em>EXT<em>INFO</em>LOG</h1>

<p>/<em>6</em>/    while ( 1 ) {
         if ( ridp->typ == 0 || ridp->typ == info[1] ) {
             if ( ridp->bufp ) {
                 HCFASSERT( ridp->len >= 2, ridp->typ );
                 (void)setup<em>bap( ifbp, fid, 2, IO</em>IN );         //restore BAP for tallies, linkstat and specific type followed by wild card
                 ridp->bufp[0] = min( ridp->len - 1, info[0] );  //save L
                 get<em>frag( ifbp, (wci</em>bufp)&amp;ridp->bufp[1], ridp->bufp[0]*2 BE<em>PAR(0) );
             }
             break; //;?this break is no longer needed due to setup</em>bap but lets concentrate on DDS first
         }
         ridp++;
     }</p>

<h1>endif // HCF<em>EXT</em>INFO_LOG</h1>

<p>}
 HCFTRACE( ifbp, HCF<em>TRACE</em>ISR<em>INFO | HCF</em>TRACE_EXIT );</p>

<p>return;
} // isr_info</p></td><td class="code"><div class="highlight"><pre>		<span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">bufp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">word_len</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>           <span class="c1">//.  if there is to convert more than 1 word ( i.e 2 )</span></pre></div></td></tr>


<tr id="section-150"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-150">&#182;</a></div><p>.  convert and write the 1st hcf_16</p></td><td class="code"><div class="highlight"><pre>			<span class="n">j</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">bufp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>   <span class="cm">/*bufp is already incremented by 2*/</span>
			<span class="n">OUT_PORT_WORD</span><span class="p">(</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-151"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-151">&#182;</a></div><p>.  update pointer and counter accordingly</p></td><td class="code"><div class="highlight"><pre>			<span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">bufp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_BIG_ENDIAN</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryOut</span> <span class="p">)</span> <span class="p">{</span>                    <span class="c1">//skip zero-length</span>
		<span class="n">j</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">bufp</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryOut</span> <span class="o">&amp;</span> <span class="mh">0xFF</span> <span class="p">);</span>
		<span class="n">OUT_PORT_WORD</span><span class="p">(</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span>
		<span class="n">bufp</span><span class="o">++</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">;</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryOut</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if (HCF_IO) &amp; HCF_IO_32BITS</span></pre></div></td></tr>


<tr id="section-152"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-152">&#182;</a></div><p>.  .  convert and write the 2nd hcf_16</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CntlOpt</span> <span class="o">&amp;</span> <span class="n">USE_16BIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">6</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">hcf_32</span> <span class="n">FAR</span>  <span class="o">*</span><span class="n">p4</span><span class="p">;</span> <span class="c1">//prevent side effects from macro</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">bufp</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>            <span class="c1">//.  if buffer at least word aligned</span>
			<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">hcf_32</span><span class="p">)</span><span class="n">bufp</span> <span class="o">&amp;</span> <span class="mh">0x2</span> <span class="p">)</span> <span class="p">{</span>             <span class="c1">//.  .  if buffer not double word aligned</span></pre></div></td></tr>


<tr id="section-153"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-153">&#182;</a></div><p>.  .  update pointer and counter accordingly</p></td><td class="code"><div class="highlight"><pre>				<span class="n">j</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">wci_recordp</span><span class="p">)</span><span class="n">bufp</span><span class="p">;</span>     <span class="c1">//just to help ease writing macros with embedded assembly</span>
				<span class="n">OUT_PORT_WORD</span><span class="p">(</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-154"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-154">&#182;</a></div><p>skip zero-length I/O, single byte I/O and I/O not worthwhile (i.e. less than 6 bytes)for DW logic
if buffer length >= 6 and 32 bits I/O support</p></td><td class="code"><div class="highlight"><pre>				<span class="n">bufp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-155"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-155">&#182;</a></div><p>.  .  .  write a single word to get double word aligned</p></td><td class="code"><div class="highlight"><pre>			<span class="n">p4</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_32</span> <span class="n">FAR</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">i</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
			<span class="n">OUT_PORT_STRING_32</span><span class="p">(</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span></pre></div></td></tr>


<tr id="section-156"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-156">&#182;</a></div><p>.  .  .  adjust buffer length and pointer accordingly</p></td><td class="code"><div class="highlight"><pre>			<span class="n">bufp</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x0003</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">&amp;=</span> <span class="mh">0x0003</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_IO_32BITS</span></pre></div></td></tr>


<tr id="section-157"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-157">&#182;</a></div><p>.  .  write as many double word as possible</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-158"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-158">&#182;</a></div><p>.  .  adjust buffer length and pointer accordingly</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x0001</span> <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-159"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-159">&#182;</a></div><p>if no 32-bit support OR byte aligned OR 1 word left</p></td><td class="code"><div class="highlight"><pre>			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryOut</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">bufp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="mh">0x0100</span><span class="p">;</span>    <span class="c1">//note that i and bufp are always simultaneously modified, &amp;bufp[i-1] is invariant</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-160"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-160">&#182;</a></div><p>.  if odd number of bytes left</p></td><td class="code"><div class="highlight"><pre>		<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcf_16</span><span class="p">)</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">OUT_PORT_STRING_8_16</span><span class="p">(</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">bufp</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="c1">// put_frag</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     void put_frag_finalize( IFBP ifbp )</span>
<span class="cm"> *.PURPOSE       cleanup after put_frag for trailing odd byte and MIC transfer to NIC.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS       N.A.</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * finalize the MIC calculation with the padding pattern, output the last byte (if applicable)</span>
<span class="cm"> * of the message and the MIC to the TxFS</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *2: 1 byte of the last put_frag may be still in IFB_CarryOut ( the put_frag carry holder ), so ........</span>
<span class="cm"> *   1 - 3 bytes of the last put_frag may be still in IFB_tx_32 ( the MIC engine carry holder ), so ........</span>
<span class="cm"> *   The call to the MIC calculation routine feeds these remaining bytes (if any) of put_frag and the</span>
<span class="cm"> *   just as many bytes of the padding as needed to the MIC calculation engine. Note that the &quot;unneeded&quot; pad</span>
<span class="cm"> *   bytes simply end up in the MIC engine carry holder and are never used.</span>
<span class="cm"> *8: write the remainder of the MIC and possible some garbage to NIC RAM</span>
<span class="cm"> *   Note: i is always 4 (a loop-invariant of the while in point 2)</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">void</span>
<span class="nf">put_frag_finalize</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span> <span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTxCarry</span> <span class="o">!=</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>      <span class="c1">//if MIC calculation active</span>
		<span class="n">CALC_TX_MIC</span><span class="p">(</span> <span class="n">mic_pad</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>               <span class="c1">//.  feed (up to 8 bytes of) virtual padding to MIC engine</span></pre></div></td></tr>


<tr id="section-161"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-161">&#182;</a></div><p>.  .  save left over byte (before bufp is corrupted) in carry, set carry flag</p></td><td class="code"><div class="highlight"><pre>		<span class="n">put_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">wci_bufp</span><span class="p">)</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MICTx</span><span class="p">,</span> <span class="mi">8</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_TYPE_WPA</span>
	<span class="n">put_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">null_addr</span><span class="p">,</span> <span class="mi">1</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>   <span class="c1">//write (possibly) trailing data or MIC byte</span>
<span class="p">}</span> <span class="c1">// put_frag_finalize</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     int put_info( IFBP ifbp, LTVP ltvp )</span>
<span class="cm"> *.PURPOSE       support routine to handle the &quot;basic&quot; task of hcf_put_info to pass RIDs to the NIC.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   ltvp        address in NIC RAM where LVT-records are located</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_SUCCESS</span>
<span class="cm"> *   &gt;&gt;put_frag</span>
<span class="cm"> *   &gt;&gt;cmd_wait</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *20: do not write RIDs to NICs which have incompatible Firmware</span>
<span class="cm"> *24: If the RID does not exist, the L-field is set to zero.</span>
<span class="cm"> *   Note that some RIDs can not be read, e.g. the pseudo RIDs for direct Hermes commands and CFG_DEFAULT_KEYS</span>
<span class="cm"> *28: If the RID is written successful, pass it to the NIC by means of an Access Write command</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *   The mechanism to HCF_ASSERT on invalid typ-codes in the LTV record is based on the following strategy:</span>
<span class="cm"> *     - some codes (e.g. CFG_REG_MB) are explicitly handled by the HCF which implies that these codes</span>
<span class="cm"> *       are valid. These codes are already consumed by hcf_put_info.</span>
<span class="cm"> *     - all other codes are passed to the Hermes. Before the put action is executed, hcf_get_info is called</span>
<span class="cm"> *       with an LTV record with a value of 1 in the L-field and the intended put action type in the Typ-code</span>
<span class="cm"> *       field. If the put action type is valid, it is also valid as a get action type code - except</span>
<span class="cm"> *       for CFG_DEFAULT_KEYS and CFG_ADD_TKIP_DEFAULT_KEY - so the HCF_ASSERT logic of hcf_get_info should</span>
<span class="cm"> *       not catch.</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>
<span class="nf">put_info</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">LTVP</span> <span class="n">ltvp</span>  <span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>

	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span><span class="p">,</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="p">)</span> <span class="p">);</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">CFG_RID_CFG_MIN</span> <span class="o">&lt;=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">&amp;&amp;</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">&lt;=</span> <span class="n">CFG_RID_CFG_MAX</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>                                                             <span class="cm">/* 20*/</span>
	     <span class="p">(</span> <span class="p">(</span> <span class="n">CFG_RID_CFG_MIN</span> <span class="o">&lt;=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span>    <span class="o">&amp;&amp;</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="o">&lt;=</span> <span class="n">CFG_RID_CFG_MAX</span> <span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span> <span class="n">CFG_RID_ENG_MIN</span> <span class="o">&lt;=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="cm">/* &amp;&amp; ltvp-&gt;typ &lt;= 0xFFFF */</span>       <span class="p">)</span>     <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
<span class="cp">#if HCF_ASSERT </span><span class="c1">//FCC8, FCB0, FCB4, FCB6, FCB7, FCB8, FCC0, FCC4, FCBC, FCBD, FCBE, FCBF</span>
		<span class="p">{</span>
			<span class="n">hcf_16</span>     <span class="n">t</span> <span class="o">=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span><span class="p">;</span>
			<span class="n">LTV_STRCT</span>  <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span> <span class="p">};</span>                                                          <span class="cm">/*24*/</span>
			<span class="n">hcf_get_info</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">LTVP</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span> <span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">x</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			     <span class="p">(</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_DEFAULT_KEYS</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_ADD_TKIP_DEFAULT_KEY</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_REMOVE_TKIP_DEFAULT_KEY</span> <span class="o">&amp;&amp;</span>
			       <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_ADD_TKIP_MAPPED_KEY</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_REMOVE_TKIP_MAPPED_KEY</span> <span class="o">&amp;&amp;</span>
			       <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_HANDOVER_ADDR</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_DISASSOCIATE_ADDR</span> <span class="o">&amp;&amp;</span>
			       <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_FCBC</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_FCBD</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_FCBE</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_FCBF</span> <span class="o">&amp;&amp;</span>
			       <span class="n">t</span> <span class="o">!=</span> <span class="n">CFG_DEAUTHENTICATE_ADDR</span>
				     <span class="p">)</span>
				<span class="p">)</span> <span class="p">{</span>
				<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">setup_bap</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IO_OUT</span> <span class="p">);</span>
		<span class="n">put_frag</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="p">(</span><span class="n">wci_bufp</span><span class="p">)</span><span class="n">ltvp</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">BE_PAR</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">);</span>
	<span class="cm">/*28*/</span>  <span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd_exe</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCMD_ACCESS</span> <span class="o">+</span> <span class="n">HCMD_ACCESS_WRITE</span><span class="p">,</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">typ</span> <span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// put_info</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     int put_info_mb( IFBP ifbp, CFG_MB_INFO_STRCT FAR * ltvp )</span>
<span class="cm"> *.PURPOSE       accumulates a ( series of) buffers into a single Info block into the MailBox.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp        address of the Interface Block</span>
<span class="cm"> *   ltvp        address of structure specifying the &quot;type&quot; and the fragments of the information to be synthesized</span>
<span class="cm"> *               as an LTV into the MailBox</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> * If the data does not fit (including no MailBox is available), the IFB_MBTally is incremented and an</span>
<span class="cm"> * error status is returned.</span>
<span class="cm"> * HCF_ASSERT does not catch.</span>
<span class="cm"> * Calling put_info_mb when their is no MailBox available, is considered a design error in the MSF.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that there is always at least 1 word of unused space in the mail box.</span>
<span class="cm"> * As a consequence:</span>
<span class="cm"> * - no problem in pointer arithmetic (MB_RP == MB_WP means unambiguously mail box is completely empty</span>
<span class="cm"> * - There is always free space to write an L field with a value of zero after each MB_Info block.  This</span>
<span class="cm"> *   allows for an easy scan mechanism in the &quot;get MB_Info block&quot; logic.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *1: Calculate L field of the MBIB, i.e. 1 for the T-field + the cumulative length of the fragments.</span>
<span class="cm"> *2: The free space in the MailBox is calculated (2a: free part from Write Ptr to Read Ptr, 2b: free part</span>
<span class="cm"> *   turns out to wrap around) . If this space suffices to store the number of words reflected by len (T-field</span>
<span class="cm"> *   + Value-field) plus the additional MailBox Info L-field + a trailing 0 to act as the L-field of a trailing</span>
<span class="cm"> *   dummy or empty LTV record, then a MailBox Info block is build in the MailBox consisting of</span>
<span class="cm"> *     - the value len in the first word</span>
<span class="cm"> *     - type in the second word</span>
<span class="cm"> *     - a copy of the contents of the fragments in the second and higher word</span>
<span class="cm"> *</span>
<span class="cm"> *4: Since put_info_mb() can more or less directly be called from the MSF level, the I/F must be robust</span>
<span class="cm"> *   against out-of-range variables. As failsafe coding, the MB update is skipped by changing tlen to 0 if</span>
<span class="cm"> *   len == 0; This will indirectly cause an assert as result of the violation of the next if clause.</span>
<span class="cm"> *6: Check whether the free space in MailBox suffices (this covers the complete absence of the MailBox).</span>
<span class="cm"> *   Note that len is unsigned, so even MSF I/F violation works out O.K.</span>
<span class="cm"> *   The &#39;2&#39; in the expression &quot;len+2&quot; is used because 1 word is needed for L itself and 1 word is needed</span>
<span class="cm"> *   for the zero-sentinel</span>
<span class="cm"> *8: update MailBox Info length report to MSF with &quot;oldest&quot; MB Info Block size. Be careful here, if you get</span>
<span class="cm"> *   here before the MailBox is registered, you can&#39;t read from the buffer addressed by IFB_MBp (it is the</span>
<span class="cm"> *   Null buffer) so don&#39;t move this code till the end of this routine but keep it where there is garuanteed</span>
<span class="cm"> *   a buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *.NOTICE</span>
<span class="cm"> *   boundary testing depends on the fact that IFB_MBSize is guaranteed to be zero if no MailBox is present,</span>
<span class="cm"> *   and to a lesser degree, that IFB_MBWp = IFB_MBRp = 0</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>

<span class="n">HCF_STATIC</span> <span class="kt">int</span>
<span class="nf">put_info_mb</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">CFG_MB_INFO_STRCT</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">ltvp</span> <span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span>         <span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_SUCCESS</span><span class="p">;</span>
	<span class="n">hcf_16</span>      <span class="n">i</span><span class="p">;</span>                      <span class="c1">//work counter</span>
	<span class="n">hcf_16</span>      <span class="o">*</span><span class="n">dp</span><span class="p">;</span>                    <span class="c1">//destination pointer (in MailBox)</span>
	<span class="n">wci_recordp</span> <span class="n">sp</span><span class="p">;</span>                     <span class="c1">//source pointer</span>
	<span class="n">hcf_16</span>      <span class="n">len</span><span class="p">;</span>                    <span class="c1">//total length to copy to MailBox</span>
	<span class="n">hcf_16</span>      <span class="n">tlen</span><span class="p">;</span>                   <span class="c1">//free length/working length/offset in WMP frame</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>  <span class="c1">//;?not sufficient</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>                   <span class="c1">//!!!be careful, don&#39;t get into an endless recursion</span>
	<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBSize</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                                                                                            <span class="cm">/* 1 */</span>
	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">frag_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">frag_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">frag_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span> <span class="o">&gt;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">tlen</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span> <span class="o">-</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span><span class="p">;</span>                                                         <span class="cm">/* 2a*/</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span> <span class="o">==</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// optimize Wrapping</span>
		<span class="p">}</span>
		<span class="n">tlen</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBSize</span> <span class="o">-</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span><span class="p">;</span>                                                       <span class="cm">/* 2b*/</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">tlen</span> <span class="o">&lt;=</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>    <span class="c1">//if trailing space is too small but</span></pre></div></td></tr>


<tr id="section-162"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-162">&#182;</a></div><p>.  write as many word as possible in "alignment safe" way</p></td><td class="code"><div class="highlight"><pre>			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span><span class="p">[</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>                 <span class="c1">//flag dummy LTV to fill the trailing space</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                     <span class="c1">//reset WritePointer to begin of MailBox</span>
			<span class="n">tlen</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span><span class="p">;</span>                                  <span class="c1">//get new available space size</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span><span class="p">[</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">tlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//;? what is this good for</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">tlen</span> <span class="p">){</span>                                                                             <span class="cm">/* 6 */</span></pre></div></td></tr>


<tr id="section-163"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-163">&#182;</a></div><p>.  write (possibly) trailing byte + (most of) MIC</p></td><td class="code"><div class="highlight"><pre>		<span class="n">IF_TALLY</span><span class="p">(</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_HCF_Tallies</span><span class="p">.</span><span class="n">NoBufMB</span><span class="o">++</span> <span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">HCF_ERR_LEN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dp</span><span class="o">++</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>                                    <span class="c1">//write Len (= size of T+V in words to MB_Info block</span>
		<span class="o">*</span><span class="n">dp</span><span class="o">++</span> <span class="o">=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">base_typ</span><span class="p">;</span>                         <span class="c1">//write Type to MB_Info block</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>                      <span class="c1">//update WritePointer of MailBox</span>
		<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">frag_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>                <span class="c1">// process each of the fragments</span>
			<span class="n">sp</span> <span class="o">=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">frag_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">frag_addr</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">ltvp</span><span class="o">-&gt;</span><span class="n">frag_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">frag_len</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span> <span class="n">len</span><span class="o">--</span> <span class="p">)</span> <span class="o">*</span><span class="n">dp</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">sp</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span><span class="p">[</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBWp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>              <span class="c1">//to assure get_info for CFG_MB_INFO stops</span>
		<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBInfoLen</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBp</span><span class="p">[</span><span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_MBRp</span><span class="p">];</span>                                            <span class="cm">/* 8 */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// put_info_mb</span>


<span class="cm">/************************************************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *.SUBMODULE     int setup_bap( IFBP ifbp, hcf_16 fid, int offset, int type )</span>
<span class="cm"> *.PURPOSE       set up data access to NIC RAM via BAP_1.</span>
<span class="cm"> *</span>
<span class="cm"> *.ARGUMENTS</span>
<span class="cm"> *   ifbp            address of I/F Block</span>
<span class="cm"> *   fid             FID/RID</span>
<span class="cm"> *   offset          !!even!! offset in FID/RID</span>
<span class="cm"> *   type            IO_IN, IO_OUT</span>
<span class="cm"> *</span>
<span class="cm"> *.RETURNS</span>
<span class="cm"> *   HCF_SUCCESS                 O.K</span>
<span class="cm"> *   HCF_ERR_NO_NIC              card is removed</span>
<span class="cm"> *   HCF_ERR_DEFUNCT_TIME_OUT    Fatal malfunction detected</span>
<span class="cm"> *   HCF_ERR_DEFUNCT_.....       if and only if IFB_DefunctStat &lt;&gt; 0</span>
<span class="cm"> *</span>
<span class="cm"> *.DESCRIPTION</span>
<span class="cm"> *</span>
<span class="cm"> * A non-zero return status indicates:</span>
<span class="cm"> * - the NIC is considered nonoperational, e.g. due to a time-out of some Hermes activity in the past</span>
<span class="cm"> * - BAP_1 could not properly be initialized</span>
<span class="cm"> * - the card is removed before completion of the data transfer</span>
<span class="cm"> * In all other cases, a zero is returned.</span>
<span class="cm"> * BAP Initialization failure indicates an H/W error which is very likely to signal complete H/W failure.</span>
<span class="cm"> * Once a BAP Initialization failure has occurred all subsequent interactions with the Hermes will return a</span>
<span class="cm"> * &quot;defunct&quot; status till the Hermes is re-initialized by means of an hcf_connect.</span>
<span class="cm"> *</span>
<span class="cm"> * A BAP is a set of registers (Offset, Select and Data) offering read/write access to a particular FID or</span>
<span class="cm"> * RID. This access is based on a auto-increment feature.</span>
<span class="cm"> * There are two BAPs but these days the HCF uses only BAP_1 and leaves BAP_0 to the PCI Busmastering H/W.</span>
<span class="cm"> *</span>
<span class="cm"> * The BAP-mechanism is based on the Busy bit in the Offset register (see the Hermes definition). The waiting</span>
<span class="cm"> * for Busy must occur between writing the Offset register and accessing the Data register. The</span>
<span class="cm"> * implementation to wait for the Busy bit drop after each write to the Offset register, implies that the</span>
<span class="cm"> * requirement that the Busy bit is low  before the Select register is written, is automatically met.</span>
<span class="cm"> * BAP-setup may be time consuming (e.g. 380 usec for large offsets occurs frequently). The wait for Busy bit</span>
<span class="cm"> * drop is protected by a loop counter, which is initialized with IFB_TickIni, which is calibrated in init.</span>
<span class="cm"> *</span>
<span class="cm"> * The NIC I/F is optimized for word transfer and can only handle word transfer at a word boundary in NIC</span>
<span class="cm"> * RAM. The intended solution for transfer of a single byte has multiple H/W flaws. There have been different</span>
<span class="cm"> * S/W Workaround strategies. RID access is hcf_16 based by &quot;nature&quot;, so no byte access problems.  For Tx/Rx</span>
<span class="cm"> * FID access,  the byte logic became obsolete by absorbing it in the double word oriented nature of the MIC</span>
<span class="cm"> * feature.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *.DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *2: the test on rc checks whether the HCF went into &quot;defunct&quot; mode ( e.g. BAP initialization or a call to</span>
<span class="cm"> *   cmd_wait did ever fail).</span>
<span class="cm"> *4: the select register and offset register are set</span>
<span class="cm"> *   the offset register is monitored till a successful condition (no busy bit) is detected or till the</span>
<span class="cm"> *   (calibrated) protection counter expires</span>
<span class="cm"> *   If the counter expires, this is reflected in IFB_DefunctStat, so all subsequent calls to setup_bap fail</span>
<span class="cm"> *   immediately ( see 2)</span>
<span class="cm"> *6: initialization of the carry as used by pet/get_frag</span>
<span class="cm"> *8: HREG_OFFSET_ERR is ignored as error because:</span>
<span class="cm"> *    a: the Hermes is robust against it</span>
<span class="cm"> *    b: it is not known what causes it (probably a bug), hence no strategy can be specified which level is</span>
<span class="cm"> *       to handle this error in which way. In the past, it could be induced by the MSF level, e.g. by calling</span>
<span class="cm"> *       hcf_rcv_msg while there was no Rx-FID available. Since this is an MSF-error which is caught by ASSERT,</span>
<span class="cm"> *       there is no run-time action required by the HCF.</span>
<span class="cm"> *   Lumping the Offset error in with the Busy bit error, as has been done in the past turns out to be a</span>
<span class="cm"> *   disaster or a life saver, just depending on what the cause of the error is. Since no prediction can be</span>
<span class="cm"> *   done about the future, it is &quot;felt&quot; to be the best strategy to ignore this error. One day the code was</span>
<span class="cm"> *   accompanied by the following comment:</span>
<span class="cm"> *   //  ignore HREG_OFFSET_ERR, someone, supposedly the MSF programmer ;) made a bug. Since we don&#39;t know</span>
<span class="cm"> *   //  what is going on, we might as well go on - under management pressure - by ignoring it</span>
<span class="cm"> *</span>
<span class="cm"> *.ENDDOC                          END DOCUMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************************************************/</span>
<span class="n">HCF_STATIC</span> <span class="kt">int</span>
<span class="nf">setup_bap</span><span class="p">(</span> <span class="n">IFBP</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">hcf_16</span> <span class="n">fid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">PROT_CNT_INI</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">HCFTRACE</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCF_TRACE_STRIO</span> <span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DefunctStat</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">HCF_SUCCESS</span><span class="p">)</span> <span class="p">{</span>                                        <span class="cm">/*2*/</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_SELECT_1</span><span class="p">,</span> <span class="n">fid</span> <span class="p">);</span>                                                              <span class="cm">/*4*/</span>
		<span class="n">OPW</span><span class="p">(</span> <span class="n">HREG_OFFSET_1</span><span class="p">,</span> <span class="n">offset</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">type</span> <span class="o">==</span> <span class="n">IO_IN</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryIn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CarryOut</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">HCF_WAIT_WHILE</span><span class="p">(</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_OFFSET_1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HCMD_BUSY</span> <span class="p">);</span>
		<span class="n">HCFASSERT</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="n">IPW</span><span class="p">(</span> <span class="n">HREG_OFFSET_1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HREG_OFFSET_ERR</span> <span class="p">),</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">fid</span><span class="p">,</span> <span class="n">offset</span> <span class="p">)</span> <span class="p">);</span>         <span class="cm">/*8*/</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">prot_cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">HCFASSERT</span><span class="p">(</span> <span class="n">DO_ASSERT</span><span class="p">,</span> <span class="n">MERGE_2</span><span class="p">(</span> <span class="n">fid</span><span class="p">,</span> <span class="n">offset</span> <span class="p">)</span> <span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_DefunctStat</span> <span class="o">=</span> <span class="n">HCF_ERR_DEFUNCT_TIME_OUT</span><span class="p">;</span>
			<span class="n">ifbp</span><span class="o">-&gt;</span><span class="n">IFB_CardStat</span> <span class="o">|=</span> <span class="n">CARD_STAT_DEFUNCT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">HCFTRACE</span><span class="p">(</span> <span class="n">ifbp</span><span class="p">,</span> <span class="n">HCF_TRACE_STRIO</span> <span class="o">|</span> <span class="n">HCF_TRACE_EXIT</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// setup_bap</span>

</pre></div></td></tr>


<tr id="section-164"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-164">&#182;</a></div><p>leading space is sufficiently large</p></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>


<tr id="section-165"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-165">&#182;</a></div><p>Do Not ASSERT, this is a normal condition</p></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
