<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › wlags49_h2 › hcfcfg.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hcfcfg.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>vim:tw=110:ts=4:</p></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef HCFCFG_H</span>
<span class="cp">#define HCFCFG_H 1</span>

<span class="cm">/*************************************************************************************************************</span>
<span class="cm">*</span>
<span class="cm">* FILE	 : hcfcfg.tpl // hcfcfg.h</span>
<span class="cm">*</span>
<span class="cm">* DATE   : $Date: 2004/08/05 11:47:10 $   $Revision: 1.6 $</span>
<span class="cm">* Original: 2004/04/08 15:18:16    Revision: 1.40      Tag: t20040408_01</span>
<span class="cm">* Original: 2004/04/01 15:32:55    Revision: 1.38      Tag: t7_20040401_01</span>
<span class="cm">* Original: 2004/03/10 15:39:28    Revision: 1.34      Tag: t20040310_01</span>
<span class="cm">* Original: 2004/03/03 14:10:12    Revision: 1.32      Tag: t20040304_01</span>
<span class="cm">* Original: 2004/03/02 09:27:12    Revision: 1.30      Tag: t20040302_03</span>
<span class="cm">* Original: 2004/02/24 13:00:28    Revision: 1.25      Tag: t20040224_01</span>
<span class="cm">* Original: 2004/02/18 17:13:57    Revision: 1.23      Tag: t20040219_01</span>
<span class="cm">*</span>
<span class="cm">* AUTHOR : Nico Valster</span>
<span class="cm">*</span>
<span class="cm">* DESC   : HCF Customization Macros</span>
<span class="cm">* hcfcfg.tpl list all #defines which must be specified to:</span>
<span class="cm">*   adjust the HCF functions defined in HCF.C to the characteristics of a specific environment</span>
<span class="cm">*		o maximum sizes for messages</span>
<span class="cm">*		o Endianess</span>
<span class="cm">*	Compiler specific macros</span>
<span class="cm">*		o port I/O macros</span>
<span class="cm">*		o type definitions</span>
<span class="cm">*</span>
<span class="cm">* By copying HCFCFG.TPL to HCFCFG.H and -if needed- modifying the #defines the WCI functionality can be</span>
<span class="cm">* tailored</span>
<span class="cm">*</span>
<span class="cm">* Supported environments:</span>
<span class="cm">* WVLAN_41	Miniport								NDIS 3.1</span>
<span class="cm">* WVLAN_42	Packet									Microsoft Visual C 1.5</span>
<span class="cm">* WVLAN_43	16 bits DOS ODI							Microsoft Visual C 1.5</span>
<span class="cm">* WVLAN_44	32 bits ODI (__NETWARE_386__)			WATCOM</span>
<span class="cm">* WVLAN_45	MAC_OS									MPW?, Symantec?</span>
<span class="cm">* WVLAN_46	Windows CE (_WIN32_WCE)					Microsoft ?</span>
<span class="cm">* WVLAN_47	LINUX  (__LINUX__)						GCC, discarded, based on GPL&#39;ed HCF-light</span>
<span class="cm">* WVLAN_48	Miniport								NDIS 5</span>
<span class="cm">* WVLAN_49	LINUX  (__LINUX__)						GCC, originally based on pre-compiled HCF_library</span>
<span class="cm">* 													migrated to use the HCF sources when Lucent Technologies</span>
<span class="cm">* 													brought the HCF module under GPL</span>
<span class="cm">* WVLAN_51	Miniport USB							NDIS 5</span>
<span class="cm">* WVLAN_52	Miniport								NDIS 4</span>
<span class="cm">* WVLAN_53	VxWorks END Station driver</span>
<span class="cm">* WVLAN_54	VxWorks END Access Point driver</span>
<span class="cm">* WVLAN_81	WavePoint								BORLAND C</span>
<span class="cm">* WCITST	Inhouse test tool						Microsoft Visual C 1.5</span>
<span class="cm">* WSU		WaveLAN Station Update					Microsoft Visual C ??</span>
<span class="cm">* SCO UNIX	not yet actually used ?					?</span>
<span class="cm">* __ppc		OEM supplied							?</span>
<span class="cm">* _AM29K	OEM supplied							?</span>
<span class="cm">* ?			OEM supplied							Microtec Research 80X86 Compiler</span>
<span class="cm">*</span>
<span class="cm">**************************************************************************************************************</span>
<span class="cm">*</span>
<span class="cm">*</span>
<span class="cm">* SOFTWARE LICENSE</span>
<span class="cm">*</span>
<span class="cm">* This software is provided subject to the following terms and conditions,</span>
<span class="cm">* which you should read carefully before using the software.  Using this</span>
<span class="cm">* software indicates your acceptance of these terms and conditions.  If you do</span>
<span class="cm">* not agree with these terms and conditions, do not use the software.</span>
<span class="cm">*</span>
<span class="cm">* COPYRIGHT © 1994 - 1995	by AT&amp;T.				All Rights Reserved</span>
<span class="cm">* COPYRIGHT © 1996 - 2000 by Lucent Technologies.	All Rights Reserved</span>
<span class="cm">* COPYRIGHT © 2001 - 2004	by Agere Systems Inc.	All Rights Reserved</span>
<span class="cm">* All rights reserved.</span>
<span class="cm">*</span>
<span class="cm">* Redistribution and use in source or binary forms, with or without</span>
<span class="cm">* modifications, are permitted provided that the following conditions are met:</span>
<span class="cm">*</span>
<span class="cm">* . Redistributions of source code must retain the above copyright notice, this</span>
<span class="cm">*    list of conditions and the following Disclaimer as comments in the code as</span>
<span class="cm">*    well as in the documentation and/or other materials provided with the</span>
<span class="cm">*    distribution.</span>
<span class="cm">*</span>
<span class="cm">* . Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="cm">*    this list of conditions and the following Disclaimer in the documentation</span>
<span class="cm">*    and/or other materials provided with the distribution.</span>
<span class="cm">*</span>
<span class="cm">* . Neither the name of Agere Systems Inc. nor the names of the contributors</span>
<span class="cm">*    may be used to endorse or promote products derived from this software</span>
<span class="cm">*    without specific prior written permission.</span>
<span class="cm">*</span>
<span class="cm">* Disclaimer</span>
<span class="cm">*</span>
<span class="cm">* THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,</span>
<span class="cm">* INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF</span>
<span class="cm">* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY</span>
<span class="cm">* USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN</span>
<span class="cm">* RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY</span>
<span class="cm">* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="cm">* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm">* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="cm">* ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT</span>
<span class="cm">* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
<span class="cm">* OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
<span class="cm">* DAMAGE.</span>
<span class="cm">*</span>
<span class="cm">*</span>
<span class="cm">*************************************************************************************************************/</span>

<span class="cm">/*	Alignment</span>
<span class="cm">*	Some platforms can access words on odd boundaries (with possibly an performance impact), at other</span>
<span class="cm">*	platforms such an access may result in a memory access violation.</span>
<span class="cm">*	It is assumed that everywhere where the HCF casts a char pointer into a word pointer, the alignment</span>
<span class="cm">*	criteria are met. This put some restrictions on the MSF, which are assumed to be &quot;automatically&quot; fulfilled</span>
<span class="cm">*	at the applicable platforms</span>
<span class="cm">*	To assert this assumption, the macro HCF_ALIGN can be defined. The default value is 1, meaning byte</span>
<span class="cm">*	alignment (or no alignment), a value of 2 means word alignment, a value of 4 means double word alignment</span>
<span class="cm">*/</span>

<span class="cm">/*****************************    IN_PORT_STRING_8_16  S a m p l e s *****************************************</span>


<span class="cm">//DIVIDER</span>
<span class="cm">#define IN_PORT_STRING_8_16( port, addr, n) while ( n-- ) 	\</span>
<span class="cm">	{ *(hcf_16 FAR*)addr = IN_PORT_WORD( port ); ((hcf_8 FAR*)addr)+=2; }</span>


<span class="cm">//DIVIDER</span>
<span class="cm">#define IN_PORT_STRING_8_16( port, addr, n)	while ( n-- )	 \</span>
<span class="cm">	{ hcf_16 i = IN_PORT_WORD(port); *((hcf_8 FAR*)addr)++ = (hcf_8)i; *((hcf_8 FAR*)addr)++ = (hcf_8)(i&gt;&gt;8);}</span>


<span class="cm">//DIVIDER</span>
<span class="cm">#define IN_PORT_STRING_8_16( port, addr, len) __asm		\</span>
<span class="cm">{														\</span>
<span class="cm">	__asm push di										\</span>
<span class="cm">	__asm push es										\</span>
<span class="cm">	__asm mov cx,len									\</span>
<span class="cm">	__asm les di,addr									\</span>
<span class="cm">	__asm mov dx,port									\</span>
<span class="cm">	__asm rep insw										\</span>
<span class="cm">	__asm pop es										\</span>
<span class="cm">	__asm pop di										\</span>
<span class="cm">}</span>


<span class="cm">*****************************   OUT_PORT_STRING_8_16  S a m p l e s ******************************************</span>


<span class="cm">//DIVIDER</span>
<span class="cm">#define OUT_PORT_STRING_8_16( port, addr, n)	while ( n-- ) \</span>
<span class="cm">	{ OUT_PORT_WORD( port, *(hcf_16 FAR*)addr ) ; ((hcf_8 FAR*)addr)+=2; }</span>


<span class="cm">//DIVIDER</span>
<span class="cm">#define OUT_PORT_STRING_8_16( port, addr, n)	while ( n-- ) \</span>
<span class="cm">	{ OUT_PORT_WORD( port, *((hcf_8 FAR*)addr) | *(((hcf_8 FAR*)addr)+1)&lt;&lt;8  ); (hcf_8 FAR*)addr+=2; }</span>


<span class="cm">//DIVIDER</span>
<span class="cm">#define OUT_PORT_STRING_8_16( port, addr, len) __asm	\</span>
<span class="cm">{														\</span>
<span class="cm">	__asm push si										\</span>
<span class="cm">	__asm push ds										\</span>
<span class="cm">	__asm mov cx,len									\</span>
<span class="cm">	__asm lds si,addr									\</span>
<span class="cm">	__asm mov dx,port									\</span>
<span class="cm">	__asm rep outsw										\</span>
<span class="cm">	__asm pop ds										\</span>
<span class="cm">	__asm pop si										\</span>
<span class="cm">}</span>

<span class="cm">*************************************************************************************************************/</span>


<span class="cm">/************************************************************************************************/</span>
<span class="cm">/******************  C O M P I L E R   S P E C I F I C   M A C R O S  ***************************/</span>
<span class="cm">/************************************************************************************************/</span>
<span class="cm">/*************************************************************************************************</span>
<span class="cm">*</span>
<span class="cm">*			!!!!!!!!!!!!!!!!!!!!!!!!! Note to the HCF-implementor !!!!!!!!!!!!!!!!!!!!!!!!!</span>
<span class="cm">*			!!!! Do not call these macros with parameters which introduce side effects !!!!</span>
<span class="cm">*			!!!!!!!!!!!!!!!!!!!!!!!!! Note to the HCF-implementor !!!!!!!!!!!!!!!!!!!!!!!!!</span>
<span class="cm">*</span>
<span class="cm">*</span>
<span class="cm">* By selecting the appropriate Macro definitions by means of modifying the &quot;#ifdef 0/1&quot; lines, the HCF can be</span>
<span class="cm">* adjusted for the I/O characteristics of a specific compiler</span>
<span class="cm">*</span>
<span class="cm">* If needed the macros can be modified or replaced with definitions appropriate for your personal platform.</span>
<span class="cm">* If you need to make such changes it is appreciated if you inform Agere Systems</span>
<span class="cm">* That way the changes can become part of the next release of the WCI</span>
<span class="cm">*</span>
<span class="cm">* For convenience of the MSF-programmer, all macros are allowed to modify their parameters (although some</span>
<span class="cm">* might argue that this would constitute bad coding practice). This has its implications on the HCF, e.g. as a</span>
<span class="cm">* consequence these macros should not be called with parameters which have side effects, e.g auto-increment.</span>
<span class="cm">*</span>
<span class="cm">* in the Microsoft implementation of inline assembly it is O.K. to corrupt all flags except the direction flag</span>
<span class="cm">* and to corrupt all registers except the segment registers and EDI, ESI, ESP and EBP (or their 16 bits</span>
<span class="cm">* equivalents).  Other environments may have other constraints</span>
<span class="cm">*</span>
<span class="cm">* in the Intel environment it is O.K to have a word (as a 16 bits quantity) at a byte boundary, hence</span>
<span class="cm">* IN_/OUT_PORT_STRING_8_16 can move words between PC-memory and NIC-memory with as only constraint that the</span>
<span class="cm">* words are on a word boundary in NIC-memory. This does not hold true for all conceivable environments, e.g.</span>
<span class="cm">* an Motorola 68xxx does not allow this. Probably/hopefully the boundary conditions imposed by these type of</span>
<span class="cm">* platforms prevent this case from materializing.  If this is not the case, OUT_PORT_STRING_8_16 must be coded</span>
<span class="cm">* by combining two Host memory hcf_8 values at a time to a single hcf_16 value to be passed to the NIC and</span>
<span class="cm">* IN_PORT_STRING_8_16 the single hcf_16 retrieved from the NIC must be split in two hcf_8 values to be stored</span>
<span class="cm">* in Host memory (see the sample code above)</span>
<span class="cm">*</span>
<span class="cm">*	The prototypes and functional description of the macros are:</span>
<span class="cm">*</span>
<span class="cm">*	hcf_16	IN_PORT_WORD( hcf_16 port )</span>
<span class="cm">*			Reads a word (16 bits) from the specified port</span>
<span class="cm">*</span>
<span class="cm">*	void	OUT_PORT_WORD( hcf_16 port, hcf_16 value)</span>
<span class="cm">*			Writes a word (16 bits) to the specified port</span>
<span class="cm">*</span>
<span class="cm">*	hcf_16	IN_PORT_DWORD( hcf_16 port )</span>
<span class="cm">*			Reads a dword (32 bits) from the specified port</span>
<span class="cm">*</span>
<span class="cm">*	void	OUT_PORT_DWORD( hcf_16 port, hcf_32 value)</span>
<span class="cm">*			Writes a dword (32 bits) to the specified port</span>
<span class="cm">*</span>
<span class="cm">*	void	IN_PORT_STRING_8_16( port, addr, len)</span>
<span class="cm">*			Reads len number of words (16 bits) from NIC memory via the specified port to the (FAR)</span>
<span class="cm">*			byte-pointer addr in PC-RAM</span>
<span class="cm">*			Note that len specifies the number of words, NOT the number of bytes</span>
<span class="cm">*			!!!NOTE, although len specifies the number of words, addr MUST be a char pointer NOTE!!!</span>
<span class="cm">*			See also the common notes for IN_PORT_STRING_8_16 and OUT_PORT_STRING_8_16</span>
<span class="cm">*</span>
<span class="cm">*	void	OUT_PORT_STRING_8_16( port, addr, len)</span>
<span class="cm">*			Writes len number of words (16 bits) from the (FAR) byte-pointer addr in PC-RAM via the specified</span>
<span class="cm">*			port to NIC memory</span>
<span class="cm">*			Note that len specifies the number of words, NOT the number of bytes.</span>
<span class="cm">*			!!!NOTE, although len specifies the number of words, addr MUST be a char pointer NOTE!!!</span>
<span class="cm">*</span>
<span class="cm">*			The peculiar combination of word-length and char pointers for IN_PORT_STRING_8_16 as well as</span>
<span class="cm">*			OUT_PORT_STRING_8_16 is justified by the assumption that it offers a more optimal algorithm</span>
<span class="cm">*</span>
<span class="cm">*	void	IN_PORT_STRING_32( port, addr, len)</span>
<span class="cm">*			Reads len number of double-words (32 bits) from NIC memory via the specified port to the (FAR)</span>
<span class="cm">*			double-word address addr in PC-RAM</span>
<span class="cm">*</span>
<span class="cm">*	void	OUT_PORT_STRING_32( port, addr, len)</span>
<span class="cm">*			Writes len number of double-words (32 bits) from the (FAR) double-word address addr in PC-RAM via</span>
<span class="cm">*			the specified port to NIC memory</span>
<span class="cm">*</span>
<span class="cm">*			!!!!!!!!!!!!!!!!!!!!!!!!! Note to the HCF-implementor !!!!!!!!!!!!!!!!!!!!!!!!!</span>
<span class="cm">*			!!!! Do not call these macros with parameters which introduce side effects !!!!</span>
<span class="cm">*			!!!!!!!!!!!!!!!!!!!!!!!!! Note to the HCF-implementor !!!!!!!!!!!!!!!!!!!!!!!!!</span>
<span class="cm">*</span>
<span class="cm">*************************************************************************************************/</span>

<span class="cm">/****************************  define INT Types  ******************************/</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">hcf_8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span>			<span class="n">hcf_16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">hcf_32</span><span class="p">;</span>

<span class="cm">/****************************  define I/O Types  ******************************/</span>
<span class="cp">#define HCF_IO_MEM     			0x0001	</span><span class="c1">// memory mapped I/O	( 0: Port I/O )</span>
<span class="cp">#define HCF_IO_32BITS   	  	0x0002 	</span><span class="c1">// 32Bits support		( 0: only 16 Bits I/O)</span>

<span class="cm">/****************************** #define HCF_TYPE ********************************/</span>
<span class="cp">#define HCF_TYPE_NONE			0x0000	</span><span class="c1">// No type</span>
<span class="cp">#define HCF_TYPE_WPA			0x0001	</span><span class="c1">// WPA support</span>
<span class="cp">#define HCF_TYPE_USB			0x0002	</span><span class="c1">// reserved (USB Dongle driver support)</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>C implementation which let the processor handle the word-at-byte-boundary problem</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define HCF_TYPE_WARP			0x0008	</span><span class="c1">// WARP F/W</span>
<span class="cp">#define HCF_TYPE_PRELOADED		0x0040	</span><span class="c1">// pre-loaded F/W</span>
<span class="cp">#define HCF_TYPE_HII5			0x0080	</span><span class="c1">// Hermes-2.5 H/W</span>
<span class="cp">#define HCF_TYPE_CCX			0x0100	</span><span class="c1">// CKIP</span>
<span class="cp">#define HCF_TYPE_BEAGLE_HII5	0x0200	</span><span class="c1">// Beagle Hermes-2.5 H/W</span>
<span class="cp">#define HCF_TYPE_TX_DELAY		0x4000	</span><span class="c1">// Delayed transmission ( non-DMA only)</span>

<span class="cm">/****************************** #define HCF_ASSERT ******************************/</span>
<span class="cp">#define HCF_ASSERT_NONE			0x0000	</span><span class="c1">// No assert support</span>
<span class="cp">#define HCF_ASSERT_PRINTF		0x0001	</span><span class="c1">// Hermes generated debug info</span>
<span class="cp">#define HCF_ASSERT_SW_SUP		0x0002	</span><span class="c1">// logging via Hermes support register</span>
<span class="cp">#define HCF_ASSERT_MB			0x0004	</span><span class="c1">// logging via Mailbox</span>
<span class="cp">#define HCF_ASSERT_RT_MSF_RTN	0x4000	</span><span class="c1">// dynamically binding of msf_assert routine</span>
<span class="cp">#define HCF_ASSERT_LNK_MSF_RTN	0x8000	</span><span class="c1">// statically binding of msf_assert routine</span>

<span class="cm">/****************************** #define HCF_ENCAP *******************************/</span>
<span class="cp">#define HCF_ENC_NONE			0x0000	</span><span class="c1">// No encapsulation support</span>
<span class="cp">#define HCF_ENC					0x0001	</span><span class="c1">// HCF handles En-/Decapsulation</span>
<span class="cp">#define HCF_ENC_SUP				0x0002	</span><span class="c1">// HCF supports MSF to handle En-/Decapsulation</span>

<span class="cm">/****************************** #define HCF_EXT *********************************/</span>
<span class="cp">#define HCF_EXT_NONE			0x0000	</span><span class="c1">// No expanded features</span>
<span class="cp">#define HCF_EXT_INFO_LOG		0x0001	</span><span class="c1">// logging of Hermes Info frames</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>C implementation which handles the word-at-byte-boundary problem</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define HCF_EXT_INT_TX_EX		0x0004	</span><span class="c1">// monitoring unsuccessful Tx message</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Assembler implementation</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define HCF_EXT_TALLIES_FW		0x0010	</span><span class="c1">// support for up to 32 Hermes Engineering tallies</span>
<span class="cp">#define HCF_EXT_TALLIES_HCF		0x0020	</span><span class="c1">// support for up to 8 HCF Engineering tallies</span>
<span class="cp">#define HCF_EXT_NIC_ACCESS		0x0040	</span><span class="c1">// direct access via Aux-ports and to Hermes registers and commands</span>
<span class="cp">#define HCF_EXT_MB				0x0080	</span><span class="c1">// MailBox code expanded</span>
<span class="cp">#define HCF_EXT_IFB_STRCT 		0x0100	</span><span class="c1">// MSF custom pointer in IFB</span>
<span class="cp">#define HCF_EXT_DESC_STRCT 		0x0200	</span><span class="c1">// MSF custom pointer in Descriptor</span>
<span class="cp">#define HCF_EXT_TX_CONT			0x4000	</span><span class="c1">// Continuous transmit test</span>
<span class="cp">#define HCF_EXT_INT_TICK		0x8000	</span><span class="c1">// enables TimerTick interrupt generation</span>

<span class="cm">/****************************** #define HCF_SLEEP *******************************/</span>
<span class="cp">#define HCF_DDS					0x0001	</span><span class="c1">// Disconnected Deep Sleep</span>
<span class="cp">#define HCF_CDS					0x0002	</span><span class="c1">// Connected Deep Sleep</span>

<span class="cm">/****************************** #define HCF_TALLIES ******************************/</span>
<span class="cp">#define HCF_TALLIES_NONE		0x0000	</span><span class="c1">// No tally support</span>
<span class="cp">#define HCF_TALLIES_NIC			0x0001	</span><span class="c1">// Hermes Tallies accumulated in IFB</span>
<span class="cp">#define HCF_TALLIES_HCF			0x0002	</span><span class="c1">// HCF Tallies accumulated in IFB</span>
<span class="cp">#define HCF_TALLIES_RESET		0x8000	</span><span class="c1">// Tallies in IFB are reset when reported via hcf_get_info</span>

<span class="cm">/************************************************************************************************/</span>
<span class="cm">/******************************************  L I N U X  *****************************************/</span>
<span class="cm">/************************************************************************************************/</span>

<span class="cp">#ifdef WVLAN_49</span>
<span class="cp">#include &lt;asm/io.h&gt;</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>C implementation which let the processor handle the word-at-byte-boundary problem</p></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;wl_version.h&gt;</span>

<span class="cm">/* The following macro ensures that no symbols are exported, minimizing the chance of a symbol</span>
<span class="cm">   collision in the kernel */</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>C implementation which handles the word-at-byte-boundary problem</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Assembler implementation</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define HCF_SLEEP (HCF_CDS)</span>

<span class="cm">/* Note: Non-WARP firmware all support WPA. However the original Agere</span>
<span class="cm"> * linux driver does not enable WPA. Enabling WPA here causes whatever</span>
<span class="cm"> * preliminary WPA logic to be included, some of which may be specific</span>
<span class="cm"> * to HERMESI.</span>
<span class="cm"> *</span>
<span class="cm"> * Various comment are clear that WARP and WPA are not compatible</span>
<span class="cm"> * (which may just mean WARP does WPA in a different fashion).</span>
<span class="cm"> */</span>

<span class="cm">/* #define HCF_TYPE    (HCF_TYPE_HII5|HCF_TYPE_STA|HCF_TYPE_AP) */</span>
<span class="cp">#ifdef HERMES25</span>
<span class="cp">#ifdef WARP</span>
<span class="cp">#define HCF_TYPE    ( HCF_TYPE_WARP | HCF_TYPE_HII5 )</span>
<span class="cp">#else</span>
<span class="cp">#define HCF_TYPE    (HCF_TYPE_HII5 | HCF_TYPE_WPA)</span>
<span class="cp">#endif </span><span class="cm">/* WARP */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define HCF_TYPE    HCF_TYPE_WPA</span>
<span class="cp">#endif </span><span class="cm">/* HERMES25 */</span><span class="cp"></span>

<span class="cp">#ifdef ENABLE_DMA</span>
<span class="cp">#define HCF_DMA		1</span>
<span class="cp">#endif </span><span class="c1">// ENABLE_DMA</span>

<span class="cm">/* We now need a switch to include support for the Mailbox and other necessary extensions */</span>
<span class="cp">#define HCF_EXT ( HCF_EXT_MB | HCF_EXT_INFO_LOG | HCF_EXT_INT_TICK )</span><span class="c1">//get deepsleep exercise going</span>

<span class="cm">/* ;? The Linux MSF still uses these definitions; define it here until it&#39;s removed */</span>
<span class="cp">#ifndef HCF_TYPE_HII</span>
<span class="cp">#define HCF_TYPE_HII 0x0004</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef HCF_TYPE_AP</span>
<span class="cp">#define HCF_TYPE_AP  0x0010</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef HCF_TYPE_STA</span>
<span class="cp">#define HCF_TYPE_STA 0x0020</span>
<span class="cp">#endif  </span><span class="c1">// HCF_TYPE_STA</span>

<span class="cm">/* Guarantees word alignment */</span>
<span class="cp">#define HCF_ALIGN		2</span>

<span class="cm">/* Endian macros CNV_INT_TO_LITTLE() and CNV_LITTLE_TO_INT() were renamed to</span>
<span class="cm">   CNV_SHORT_TO_LITTLE() and CNV_LITTLE_TO_SHORT() */</span>
<span class="cp">#ifndef CNV_INT_TO_LITTLE</span>
<span class="cp">#define CNV_INT_TO_LITTLE   CNV_SHORT_TO_LITTLE</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CNV_LITTLE_TO_INT</span>
<span class="cp">#define CNV_LITTLE_TO_INT   CNV_LITTLE_TO_SHORT</span>
<span class="cp">#endif</span>

<span class="cp">#define	HCF_ERR_BUSY			0x06</span>

<span class="cm">/* UIL defines were removed from the HCF */</span>
<span class="cp">#define UIL_SUCCESS					HCF_SUCCESS</span>
<span class="cp">#define UIL_ERR_TIME_OUT			HCF_ERR_TIME_OUT</span>
<span class="cp">#define UIL_ERR_NO_NIC				HCF_ERR_NO_NIC</span>
<span class="cp">#define UIL_ERR_LEN					HCF_ERR_LEN</span>
<span class="cp">#define UIL_ERR_MIN					HCF_ERR_MAX	</span><span class="cm">/*end of HCF errors which are passed through to UIL</span>
<span class="cm">												  *** ** *** ****** ***** *** ****** ******* ** ***  */</span><span class="cp"></span>
<span class="cp">#define UIL_ERR_IN_USE				0x44</span>
<span class="cp">#define UIL_ERR_WRONG_IFB			0x46</span>
<span class="cp">#define UIL_ERR_MAX					0x7F		</span><span class="cm">/*upper boundary of UIL errors without HCF-pendant</span>
<span class="cm">                                                  ***** ******** ** *** ****** ******* *** *******  */</span><span class="cp"></span>
<span class="cp">#define UIL_ERR_BUSY			    HCF_ERR_BUSY</span>
<span class="cp">#define UIL_ERR_DIAG_1			    HCF_ERR_DIAG_1</span>
<span class="cp">#define UIL_FAILURE					0xFF	</span><span class="cm">/* 20010705 nv this relick should be eridicated */</span><span class="cp"></span>
<span class="cp">#define UIL_ERR_PIF_CONFLICT		0x40	</span><span class="c1">//obsolete</span>
<span class="cp">#define UIL_ERR_INCOMP_DRV			0x41	</span><span class="c1">//obsolete</span>
<span class="cp">#define UIL_ERR_DOS_CALL			0x43	</span><span class="c1">//obsolete</span>
<span class="cp">#define UIL_ERR_NO_DRV				0x42	</span><span class="c1">//obsolete</span>
<span class="cp">#define UIL_ERR_NSTL				0x45	</span><span class="c1">//obsolete</span>



<span class="cp">#if 0</span><span class="c">  //;? #ifdef get this going LATER HERMES25</span>
<span class="c">#define HCF_IO              HCF_IO_32BITS</span>
<span class="c">#define HCF_DMA             1</span>
<span class="c">#define HCF_DESC_STRCT_EXT  4</span>

<span class="c">/* Switch for BusMaster DMA support. Note that the above define includes the DMA-specific HCF</span>
<span class="c">   code in the build. This define sets the MSF to use DMA; if ENABLE_DMA is not defined, then</span>
<span class="c">   port I/O will be used in the build */</span>
<span class="cp">#ifndef BUS_PCMCIA</span>
<span class="c">#define ENABLE_DMA</span>
<span class="cp">#endif  // USE_PCMCIA</span>

<span class="cp">#endif  // HERMES25</span>


<span class="cm">/* Overrule standard WaveLAN Packet Size when in DMA mode */</span>
<span class="cp">#ifdef ENABLE_DMA</span>
<span class="cp">#define HCF_MAX_PACKET_SIZE 2304</span>
<span class="cp">#else</span>
<span class="cp">#define HCF_MAX_PACKET_SIZE 1514</span>
<span class="cp">#endif  </span><span class="c1">// ENABLE_DMA</span>

<span class="cm">/* The following sets the component ID, as well as the versioning. See also wl_version.h */</span>
<span class="cp">#define	MSF_COMPONENT_ID	COMP_ID_LINUX</span>

<span class="cp">#define	MSF_COMPONENT_VAR			DRV_VARIANT</span>
<span class="cp">#define MSF_COMPONENT_MAJOR_VER     DRV_MAJOR_VERSION</span>
<span class="cp">#define MSF_COMPONENT_MINOR_VER     DRV_MINOR_VERSION</span>

<span class="cm">/* Define the following to turn on assertions in the HCF */</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><h1>define HCF<em>TYPE</em>HII            0x0004  // Hermes-II, to discriminate H-I and H-II CFG<em>HCF</em>OPT_STRCT</h1></td><td class="code"><div class="highlight"><pre><span class="cp">#define HCF_ASSERT			HCF_ASSERT_LNK_MSF_RTN	</span><span class="c1">// statically binding of msf_assert routine</span>

<span class="cp">#ifdef USE_BIG_ENDIAN</span>
<span class="cp">#define HCF_BIG_ENDIAN  1</span>
<span class="cp">#else</span>
<span class="cp">#define HCF_BIG_ENDIAN  0</span>
<span class="cp">#endif  </span><span class="cm">/* USE_BIG_ENDIAN */</span><span class="cp"></span>

<span class="cm">/* Define the following if your system uses memory-mapped IO */</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><h1>define HCF<em>EXT</em>INT<em>TX</em>OK        0x0002  // RESERVED!!! monitoring successful Tx message</h1></td><td class="code"><div class="highlight"><pre><span class="cm">/* The following defines the standard macros required by the HCF to move data to/from the card */</span>
<span class="cp">#define IN_PORT_BYTE(port)			((hcf_8)inb( (hcf_io)(port) ))</span>
<span class="cp">#define IN_PORT_WORD(port)			((hcf_16)inw( (hcf_io)(port) ))</span>
<span class="cp">#define OUT_PORT_BYTE(port, value)	(outb( (hcf_8) (value), (hcf_io)(port) ))</span>
<span class="cp">#define OUT_PORT_WORD(port, value)	(outw((hcf_16) (value), (hcf_io)(port) ))</span>

<span class="cp">#define IN_PORT_STRING_16(port, dst, n)    insw((hcf_io)(port), dst, n)</span>
<span class="cp">#define OUT_PORT_STRING_16(port, src, n)   outsw((hcf_io)(port), src, n)</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><h1>define HCF<em>EXT</em>MON_MODE        0x0008  // LEGACY</h1></td><td class="code"><div class="highlight"><pre><span class="cp">#define IN_PORT_STRING_32(port, dst, n)   insl((port), (dst), (n))</span>
<span class="cp">#define OUT_PORT_STRING_32(port, src, n)  outsl((port), (src), (n))</span>
<span class="cp">#define IN_PORT_HCF32(port)          inl( (hcf_io)(port) )</span>
<span class="cp">#define OUT_PORT_HCF32(port, value)  outl((hcf_32)(value), (hcf_io)(port) )</span>

<span class="cp">#define IN_PORT_DWORD(port)          IN_PORT_HCF32(port)</span>
<span class="cp">#define OUT_PORT_DWORD(port, value)  OUT_PORT_HCF32(port, value)</span>

<span class="cp">#define  IN_PORT_STRING_8_16(port, addr, len)	IN_PORT_STRING_16(port, addr, len)</span>
<span class="cp">#define  OUT_PORT_STRING_8_16(port, addr, len)	OUT_PORT_STRING_16(port, addr, len)</span>

<span class="cp">#ifndef CFG_SCAN_CHANNELS_2GHZ</span>
<span class="cp">#define CFG_SCAN_CHANNELS_2GHZ 0xFCC2</span>
<span class="cp">#endif </span><span class="cm">/* CFG_SCAN_CHANNELS_2GHZ */</span><span class="cp"></span>

<span class="cp">#define HCF_MAX_MSG 1600 </span><span class="c1">//get going ;?</span>
<span class="cp">#endif	</span><span class="c1">// WVLAN_49</span>

<span class="cm">/************************************************************************************************************/</span>
<span class="cm">/***********************************                                   **************************************/</span>
<span class="cm">/************************************************************************************************************/</span>
<span class="cp">#if ! defined 	HCF_ALIGN</span>
<span class="cp">#define 		HCF_ALIGN			1		</span><span class="c1">//default to no alignment</span>
<span class="cp">#endif </span><span class="c1">// 		HCF_ALIGN</span>

<span class="cp">#if ! defined 	HCF_ASSERT</span>
<span class="cp">#define 		HCF_ASSERT			0</span>
<span class="cp">#endif </span><span class="c1">//		HCF_ASSERT</span>

<span class="cp">#if ! defined	HCF_BIG_ENDIAN</span>
<span class="cp">#define 		HCF_BIG_ENDIAN		0</span>
<span class="cp">#endif </span><span class="c1">// 		HCF_BIG_ENDIAN</span>

<span class="cp">#if ! defined	HCF_DMA</span>
<span class="cp">#define 		HCF_DMA				0</span>
<span class="cp">#endif </span><span class="c1">// 		HCF_DMA</span>

<span class="cp">#if ! defined	HCF_ENCAP</span>
<span class="cp">#define			HCF_ENCAP			HCF_ENC</span>
<span class="cp">#endif </span><span class="c1">//		HCF_ENCAP</span>

<span class="cp">#if ! defined	HCF_EXT</span>
<span class="cp">#define			HCF_EXT				0</span>
<span class="cp">#endif </span><span class="c1">//		HCF_EXT</span>

<span class="cp">#if ! defined	HCF_INT_ON</span>
<span class="cp">#define			HCF_INT_ON			1</span>
<span class="cp">#endif </span><span class="c1">//		HCF_INT_ON</span>

<span class="cp">#if ! defined	HCF_IO</span>
<span class="cp">#define			HCF_IO				0		</span><span class="c1">//default 16 bits support only, port I/O</span>
<span class="cp">#endif </span><span class="c1">//		HCF_IO</span>

<span class="cp">#if ! defined	HCF_LEGACY</span>
<span class="cp">#define			HCF_LEGACY			0</span>
<span class="cp">#endif </span><span class="c1">//		HCF_LEGACY</span>

<span class="cp">#if ! defined	HCF_MAX_LTV</span>
<span class="cp">#define 		HCF_MAX_LTV			1200	</span><span class="c1">// sufficient for all known purposes</span>
<span class="cp">#endif </span><span class="c1">//		HCF_MAX_LTV</span>

<span class="cp">#if ! defined	HCF_PROT_TIME</span>
<span class="cp">#define 		HCF_PROT_TIME		100		</span><span class="c1">// number of 10K microsec protection timer against H/W malfunction</span>
<span class="cp">#endif </span><span class="c1">// 		HCF_PROT_TIME</span>

<span class="cp">#if ! defined	HCF_SLEEP</span>
<span class="cp">#define			HCF_SLEEP			0</span>
<span class="cp">#endif </span><span class="c1">//		HCF_SLEEP</span>

<span class="cp">#if ! defined	HCF_TALLIES</span>
<span class="cp">#define			HCF_TALLIES			( HCF_TALLIES_NIC | HCF_TALLIES_HCF )</span>
<span class="cp">#endif </span><span class="c1">//		HCF_TALLIES</span>

<span class="cp">#if ! defined 	HCF_TYPE</span>
<span class="cp">#define 		HCF_TYPE 			0</span>
<span class="cp">#endif </span><span class="c1">//		HCF_TYPE</span>

<span class="cp">#if				HCF_BIG_ENDIAN</span>
<span class="cp">#undef			HCF_BIG_ENDIAN</span>
<span class="cp">#define			HCF_BIG_ENDIAN		1		</span><span class="c1">//just for convenience of generating cfg_hcf_opt</span>
<span class="cp">#endif </span><span class="c1">//	 	HCF_BIG_ENDIAN</span>

<span class="cp">#if				HCF_DMA</span>
<span class="cp">#undef			HCF_DMA</span>
<span class="cp">#define			HCF_DMA				1		</span><span class="c1">//just for convenience of generating cfg_hcf_opt</span>
<span class="cp">#endif </span><span class="c1">//		HCF_DMA</span>

<span class="cp">#if				HCF_INT_ON</span>
<span class="cp">#undef			HCF_INT_ON</span>
<span class="cp">#define			HCF_INT_ON			1		</span><span class="c1">//just for convenience of generating cfg_hcf_opt</span>
<span class="cp">#endif </span><span class="c1">//		HCF_INT_ON</span>


<span class="cp">#if ! defined IN_PORT_STRING_8_16</span>
<span class="cp">#define  IN_PORT_STRING_8_16(port, addr, len)	IN_PORT_STRING_16(port, addr, len)</span>
<span class="cp">#define  OUT_PORT_STRING_8_16(port, addr, len)	OUT_PORT_STRING_16(port, addr, len)</span>
<span class="cp">#endif </span><span class="c1">// IN_PORT_STRING_8_16</span>

<span class="cm">/************************************************************************************************/</span>
<span class="cm">/**********                                                                         *************/</span>
<span class="cm">/************************************************************************************************/</span>

<span class="cp">#if ! defined	FAR</span>
<span class="cp">#define 		FAR						</span><span class="c1">// default to flat 32-bits code</span>
<span class="cp">#endif </span><span class="c1">// 		FAR</span>

<span class="k">typedef</span> <span class="n">hcf_8</span>  <span class="n">FAR</span> <span class="o">*</span><span class="n">wci_bufp</span><span class="p">;</span>			<span class="c1">// segmented 16-bits or flat 32-bits pointer to 8 bits unit</span>
<span class="k">typedef</span> <span class="n">hcf_16</span> <span class="n">FAR</span> <span class="o">*</span><span class="n">wci_recordp</span><span class="p">;</span>		<span class="c1">// segmented 16-bits or flat 32-bits pointer to 16 bits unit</span>

<span class="cm">/*	I/O Address size</span>
<span class="cm">*	Platforms which use port mapped I/O will (in general) have a 64k I/O space, conveniently expressed in a</span>
<span class="cm">*	16-bits quantity</span>
<span class="cm">*	Platforms which use memory mapped I/O will (in general) have an I/O space much larger than 64k, and need a</span>
<span class="cm">*	32-bits quantity to express the I/O base</span>
<span class="cm">*/</span>

<span class="cp">#if HCF_IO &amp; HCF_IO_MEM</span>
<span class="k">typedef</span> <span class="n">hcf_32</span> <span class="n">hcf_io</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="n">hcf_16</span> <span class="n">hcf_io</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">//HCF_IO</span>

<span class="cp">#if 	HCF_PROT_TIME &gt; 128</span>
<span class="cp">#define HCF_PROT_TIME_SHFT	3</span>
<span class="cp">#define HCF_PROT_TIME_DIV	8</span>
<span class="cp">#elif 	HCF_PROT_TIME &gt; 64</span>
<span class="cp">#define HCF_PROT_TIME_SHFT	2</span>
<span class="cp">#define HCF_PROT_TIME_DIV	4</span>
<span class="cp">#elif 	HCF_PROT_TIME &gt; 32</span>
<span class="cp">#define HCF_PROT_TIME_SHFT	1</span>
<span class="cp">#define HCF_PROT_TIME_DIV	2</span>
<span class="cp">#else </span><span class="c1">//HCF_PROT_TIME &gt;= 19</span>
<span class="cp">#define HCF_PROT_TIME_SHFT	0</span>
<span class="cp">#define HCF_PROT_TIME_DIV	1</span>
<span class="cp">#endif</span>

<span class="cp">#define HCF_PROT_TIME_CNT (HCF_PROT_TIME / HCF_PROT_TIME_DIV)</span>


<span class="cm">/************************************************************************************************************/</span>
<span class="cm">/******************************************* . . . . . . . . .  *********************************************/</span>
<span class="cm">/************************************************************************************************************/</span>

<span class="cm">/* MSF_COMPONENT_ID is used to define the CFG_IDENTITY_STRCT in HCF.C</span>
<span class="cm">* CFG_IDENTITY_STRCT is defined in HCF.C purely based on convenience arguments.</span>
<span class="cm">* The HCF can not have the knowledge to determine the ComponentId field of the Identity record (aka as</span>
<span class="cm">* Version Record), therefore the MSF part of the Drivers must supply this value via the System Constant</span>
<span class="cm">* MSF_COMPONENT_ID.</span>
<span class="cm">* There is a set of values predefined in MDD.H (format COMP_ID_.....)</span>
<span class="cm">*</span>
<span class="cm">* Note that taking MSF_COMPONENT_ID as a default value for DUI_COMPAT_VAR is purely an implementation</span>
<span class="cm">* convenience, the numerical values of these two quantities have none functional relationship whatsoever.</span>
<span class="cm">*/</span>

<span class="cp">#if defined	MSF_COMPONENT_ID</span>

<span class="cp">#if ! defined	DUI_COMPAT_VAR</span>
<span class="cp">#define			DUI_COMPAT_VAR		MSF_COMPONENT_ID</span>
<span class="cp">#endif </span><span class="c1">//		DUI_COMPAT_VAR</span>

<span class="cp">#if ! defined	DUI_COMPAT_BOT		</span><span class="c1">//;?this way utilities can lower as well raise the bottom</span>
<span class="cp">#define			DUI_COMPAT_BOT		8</span>
<span class="cp">#endif </span><span class="c1">//		DUI_COMPAT_BOT</span>

<span class="cp">#if ! defined	DUI_COMPAT_TOP		</span><span class="c1">//;?this way utilities can lower as well raise the top</span>
<span class="cp">#define			DUI_COMPAT_TOP       8</span>
<span class="cp">#endif </span><span class="c1">//		DUI_COMPAT_TOP</span>

<span class="cp">#endif </span><span class="c1">// MSF_COMPONENT_ID</span>

<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_HII5</span>

<span class="cp">#if ! defined	HCF_HSI_VAR_5</span>
<span class="cp">#define			HCF_HSI_VAR_5</span>
<span class="cp">#endif </span><span class="c1">//		HCF_HSI_VAR_5</span>

<span class="cp">#if ! defined	HCF_APF_VAR_4</span>
<span class="cp">#define			HCF_APF_VAR_4</span>
<span class="cp">#endif </span><span class="c1">//		HCF_APF_VAR_4</span>

<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WARP</span>
<span class="cp">#if ! defined	HCF_STA_VAR_4</span>
<span class="cp">#define			HCF_STA_VAR_4</span>
<span class="cp">#endif </span><span class="c1">//		HCF_STA_VAR_4</span>
<span class="cp">#else</span>
<span class="cp">#if ! defined	HCF_STA_VAR_2</span>
<span class="cp">#define			HCF_STA_VAR_2</span>
<span class="cp">#endif </span><span class="c1">//		HCF_STA_VAR_2</span>
<span class="cp">#endif</span>

<span class="cp">#if defined HCF_HSI_VAR_4</span>
<span class="nl">err:</span> <span class="n">HSI</span> <span class="n">variants</span> <span class="mi">4</span> <span class="n">correspond</span> <span class="n">with</span> <span class="n">HII</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_HSI_VAR_4</span>

<span class="cp">#else</span>

<span class="cp">#if ! defined	HCF_HSI_VAR_4</span>
<span class="cp">#define			HCF_HSI_VAR_4		</span><span class="c1">//Hermes-II all types (for the time being!)</span>
<span class="cp">#endif </span><span class="c1">//		HCF_HSI_VAR_4</span>

<span class="cp">#if ! defined	HCF_APF_VAR_2</span>
<span class="cp">#define 		HCF_APF_VAR_2</span>
<span class="cp">#endif </span><span class="c1">//		HCF_APF_VAR_2</span>

<span class="cp">#if ! defined	HCF_STA_VAR_2</span>
<span class="cp">#define			HCF_STA_VAR_2</span>
<span class="cp">#endif </span><span class="c1">//		HCF_STA_VAR_2</span>

<span class="cp">#endif </span><span class="c1">// HCF_TYPE_HII5</span>

<span class="cp">#if ! defined	HCF_PRI_VAR_3</span>
<span class="cp">#define		HCF_PRI_VAR_3</span>
<span class="cp">#endif </span><span class="c1">//		HCF_PRI_VAR_3</span>

<span class="cp">#if defined HCF_HSI_VAR_1 || defined HCF_HSI_VAR_2 || defined HCF_HSI_VAR_3</span>
<span class="nl">err:</span> <span class="n">HSI</span> <span class="n">variants</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="n">and</span> <span class="mi">3</span> <span class="n">correspond</span> <span class="n">with</span> <span class="n">H</span><span class="o">-</span><span class="n">I</span> <span class="n">only</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_HSI_VAR_1, HCF_HSI_VAR_2, HCF_HSI_VAR_3</span>

<span class="cp">#if defined HCF_PRI_VAR_1 || defined HCF_PRI_VAR_2</span>
<span class="nl">err:</span> <span class="n">primary</span> <span class="n">variants</span> <span class="mi">1</span> <span class="n">and</span> <span class="mi">2</span> <span class="n">correspond</span> <span class="n">with</span> <span class="n">H</span><span class="o">-</span><span class="n">I</span> <span class="n">only</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_PRI_VAR_1 / HCF_PRI_VAR_2</span>


<span class="cm">/************************************************************************************************************/</span>
<span class="cm">/******************************************* . . . . . . . . .  *********************************************/</span>
<span class="cm">/************************************************************************************************************/</span>


<span class="cm">/* The BASED customization macro is used to resolves the SS!=DS conflict for the Interrupt Service logic in</span>
<span class="cm"> * DOS Drivers. Due to the cumbersomeness of mixing C and assembler local BASED variables still end up in the</span>
<span class="cm"> * wrong segment. The workaround is that the HCF uses only global BASED variables or IFB-based variables.</span>
<span class="cm"> * The &quot;BASED&quot; construction (supposedly) only amounts to something in the small memory model.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the whole BASED rigmarole is needlessly complicated because both the Microsoft Compiler and</span>
<span class="cm"> * Linker are unnecessary restrictive in what far pointer manipulation they allow</span>
<span class="cm"> */</span>

<span class="cp">#if ! defined	BASED</span>
<span class="cp">#define 		BASED</span>
<span class="cp">#endif </span><span class="c1">//		BASED</span>

<span class="cp">#if ! defined	EXTERN_C</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="cp">#define			EXTERN_C extern &quot;C&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define			EXTERN_C</span>
<span class="cp">#endif </span><span class="c1">// __cplusplus</span>
<span class="cp">#endif </span><span class="c1">//		EXTERN_C</span>

<span class="cp">#if ! defined	NULL</span>
<span class="cp">#define			NULL	((void *) 0)</span>
<span class="cp">#endif </span><span class="c1">//		NULL</span>

<span class="cp">#if ! defined	TEXT</span>
<span class="cp">#define			TEXT(x)	x</span>
<span class="cp">#endif </span><span class="c1">//		TEXT</span>

<span class="cm">/************************************************************************************************************/</span>
<span class="cm">/*********************** C O N F L I C T   D E T E C T I O N  &amp;  R E S O L U T I O N ************************/</span>
<span class="cm">/************************************************************************************************************/</span>
<span class="cp">#if HCF_ALIGN != 1 &amp;&amp; HCF_ALIGN != 2 &amp;&amp; HCF_ALIGN != 4 &amp;&amp; HCF_ALIGN != 8</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_ALIGN</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_ALIGN</span>

<span class="cp">#if (HCF_ASSERT) &amp; ~( HCF_ASSERT_PRINTF | HCF_ASSERT_SW_SUP | HCF_ASSERT_MB | HCF_ASSERT_RT_MSF_RTN | \</span>
<span class="cp">					  HCF_ASSERT_LNK_MSF_RTN )</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_ASSERT</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT</span>

<span class="cp">#if (HCF_ASSERT) &amp; HCF_ASSERT_MB &amp;&amp; ! ( (HCF_EXT) &amp; HCF_EXT_MB )		</span><span class="c1">//detect potential conflict</span>
<span class="nl">err:</span> <span class="n">these</span> <span class="n">macros</span> <span class="n">are</span> <span class="n">not</span> <span class="n">used</span> <span class="n">consistently</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_ASSERT_MB / HCF_EXT_MB</span>

<span class="cp">#if HCF_BIG_ENDIAN != 0 &amp;&amp; HCF_BIG_ENDIAN != 1</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_BIG_ENDIAN</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_BIG_ENDIAN</span>

<span class="cp">#if HCF_DMA != 0 &amp;&amp; HCF_DMA != 1</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_DMA</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_DMA</span>

<span class="cp">#if (HCF_ENCAP) &amp; ~( HCF_ENC | HCF_ENC_SUP )</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_ENCAP</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_ENCAP</span>

<span class="cp">#if (HCF_EXT) &amp; ~( HCF_EXT_INFO_LOG | HCF_EXT_INT_TX_EX | HCF_EXT_TALLIES_FW | HCF_EXT_TALLIES_HCF	| \</span>
<span class="cp">				   HCF_EXT_NIC_ACCESS | HCF_EXT_MB | HCF_EXT_INT_TICK | \</span>
<span class="cp">				   HCF_EXT_IFB_STRCT | HCF_EXT_DESC_STRCT | HCF_EXT_TX_CONT )</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_EXT</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_EXT</span>

<span class="cp">#if HCF_INT_ON != 0 &amp;&amp; HCF_INT_ON != 1</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_INT_ON</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_INT_ON</span>

<span class="cp">#if (HCF_IO) &amp; ~( HCF_IO_MEM | HCF_IO_32BITS )</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_IO</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_IO</span>

<span class="cp">#if HCF_LEGACY != 0 &amp;&amp; HCF_LEGACY != 1</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_LEGACY</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_LEGACY</span>

<span class="cp">#if HCF_MAX_LTV &lt; 16 || HCF_MAX_LTV &gt; 2304</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_MAX_LTV</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_MAX_LTV</span>

<span class="cp">#if HCF_PROT_TIME != 0 &amp;&amp; ( HCF_PROT_TIME &lt; 19 || 256 &lt; HCF_PROT_TIME )</span>
<span class="nl">err:</span> <span class="n">below</span> <span class="n">minimum</span> <span class="mf">.08</span> <span class="n">second</span> <span class="n">required</span> <span class="n">by</span> <span class="n">Hermes</span> <span class="n">or</span> <span class="n">possibly</span> <span class="n">above</span> <span class="n">hcf_32</span> <span class="n">capacity</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_PROT_TIME</span>

<span class="cp">#if (HCF_SLEEP) &amp; ~( HCF_CDS | HCF_DDS )</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_SLEEP</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_SLEEP</span>

<span class="cp">#if (HCF_SLEEP) &amp;&amp; ! (HCF_INT_ON)</span>
<span class="nl">err:</span> <span class="n">these</span> <span class="n">macros</span> <span class="n">are</span> <span class="n">not</span> <span class="n">used</span> <span class="n">consistently</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_SLEEP / HCF_INT_ON</span>

<span class="cp">#if (HCF_SLEEP) &amp;&amp; ! ( (HCF_EXT) &amp; HCF_EXT_INT_TICK )</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><h1>include <linux/module.h></h1></td><td class="code"><div class="highlight"><pre><span class="cp">#endif </span><span class="c1">// HCF_SLEEP / HCF_EXT_INT_TICK</span>

<span class="cp">#if (HCF_TALLIES) &amp; ~( HCF_TALLIES_HCF | HCF_TALLIES_NIC | HCF_TALLIES_RESET ) || \</span>
<span class="cp">	(HCF_TALLIES) == HCF_TALLIES_RESET</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_TALLIES</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// HCF_TALLIES</span>

<span class="cp">#if (HCF_TYPE) &amp; ~(HCF_TYPE_WPA | HCF_TYPE_USB | HCF_TYPE_PRELOADED | HCF_TYPE_HII5 | HCF_TYPE_WARP | \</span>
<span class="cp">		HCF_TYPE_CCX </span><span class="cm">/* | HCF_TYPE_TX_DELAY */</span><span class="cp"> )</span>
<span class="nl">err:</span> <span class="n">invalid</span> <span class="n">value</span> <span class="k">for</span> <span class="n">HCF_TYPE</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">//HCF_TYPE</span>

<span class="cp">#if (HCF_TYPE) &amp; HCF_TYPE_WARP &amp;&amp; (HCF_TYPE) &amp; HCF_TYPE_WPA</span>
<span class="nl">err:</span> <span class="n">at</span> <span class="n">most</span> <span class="mi">1</span> <span class="n">of</span> <span class="n">these</span> <span class="n">macros</span> <span class="n">should</span> <span class="n">be</span> <span class="n">defined</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">//HCF_TYPE_WARP / HCF_TYPE_WPA</span>

<span class="cp">#endif </span><span class="c1">//HCFCFG_H</span>

</pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>EXPORT<em>NO</em>SYMBOLS;  //;?this place seems not appropriately to me</p></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><h1>define HCF<em>SLEEP (HCF</em>CDS | HCF_DDS )</h1></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><h1>define HCF_ASSERT  0x8000</h1></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><h1>define HCF<em>MEM</em>IO</h1></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><h1>define IN<em>PORT</em>STRINGL(port, dst, n)   insl((port), (dst), (n))</h1>

<h1>define OUT<em>PORT</em>STRINGL(port, src, n)  outsl((port), (src), (n))</h1></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>;? err: these macros are not used consistently;</p></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
