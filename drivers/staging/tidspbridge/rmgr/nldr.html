<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › rmgr › nldr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>nldr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * nldr.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * DSP/BIOS Bridge dynamic + overlay Node loader.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>

<span class="cp">#include &lt;dspbridge/dbdefs.h&gt;</span>

<span class="cm">/* Platform manager */</span>
<span class="cp">#include &lt;dspbridge/cod.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dev.h&gt;</span>

<span class="cm">/* Resource manager */</span>
<span class="cp">#include &lt;dspbridge/dbll.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dbdcd.h&gt;</span>
<span class="cp">#include &lt;dspbridge/rmm.h&gt;</span>
<span class="cp">#include &lt;dspbridge/uuidutil.h&gt;</span>

<span class="cp">#include &lt;dspbridge/nldr.h&gt;</span>
<span class="cp">#include &lt;linux/lcm.h&gt;</span>

<span class="cm">/* Name of section containing dynamic load mem */</span>
<span class="cp">#define DYNMEMSECT  &quot;.dspbridge_mem&quot;</span>

<span class="cm">/* Name of section containing dependent library information */</span>
<span class="cp">#define DEPLIBSECT  &quot;.dspbridge_deplibs&quot;</span>

<span class="cm">/* Max depth of recursion for loading node&#39;s dependent libraries */</span>
<span class="cp">#define MAXDEPTH	    5</span>

<span class="cm">/* Max number of persistent libraries kept by a node */</span>
<span class="cp">#define MAXLIBS	 5</span>

<span class="cm">/*</span>
<span class="cm"> *  Defines for extracting packed dynamic load memory requirements from two</span>
<span class="cm"> *  masks.</span>
<span class="cm"> *  These defines must match node.cdb and dynm.cdb</span>
<span class="cm"> *  Format of data/code mask is:</span>
<span class="cm"> *   uuuuuuuu|fueeeeee|fudddddd|fucccccc|</span>
<span class="cm"> *  where</span>
<span class="cm"> *      u = unused</span>
<span class="cm"> *      cccccc = preferred/required dynamic mem segid for create phase data/code</span>
<span class="cm"> *      dddddd = preferred/required dynamic mem segid for delete phase data/code</span>
<span class="cm"> *      eeeeee = preferred/req. dynamic mem segid for execute phase data/code</span>
<span class="cm"> *      f = flag indicating if memory is preferred or required:</span>
<span class="cm"> *	  f = 1 if required, f = 0 if preferred.</span>
<span class="cm"> *</span>
<span class="cm"> *  The 6 bits of the segid are interpreted as follows:</span>
<span class="cm"> *</span>
<span class="cm"> *  If the 6th bit (bit 5) is not set, then this specifies a memory segment</span>
<span class="cm"> *  between 0 and 31 (a maximum of 32 dynamic loading memory segments).</span>
<span class="cm"> *  If the 6th bit (bit 5) is set, segid has the following interpretation:</span>
<span class="cm"> *      segid = 32 - Any internal memory segment can be used.</span>
<span class="cm"> *      segid = 33 - Any external memory segment can be used.</span>
<span class="cm"> *      segid = 63 - Any memory segment can be used (in this case the</span>
<span class="cm"> *		   required/preferred flag is irrelevant).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Maximum allowed dynamic loading memory segments */</span>
<span class="cp">#define MAXMEMSEGS      32</span>

<span class="cp">#define MAXSEGID	3	</span><span class="cm">/* Largest possible (real) segid */</span><span class="cp"></span>
<span class="cp">#define MEMINTERNALID   32	</span><span class="cm">/* Segid meaning use internal mem */</span><span class="cp"></span>
<span class="cp">#define MEMEXTERNALID   33	</span><span class="cm">/* Segid meaning use external mem */</span><span class="cp"></span>
<span class="cp">#define NULLID	  63		</span><span class="cm">/* Segid meaning no memory req/pref */</span><span class="cp"></span>
<span class="cp">#define FLAGBIT	 7		</span><span class="cm">/* 7th bit is pref./req. flag */</span><span class="cp"></span>
<span class="cp">#define SEGMASK	 0x3f		</span><span class="cm">/* Bits 0 - 5 */</span><span class="cp"></span>

<span class="cp">#define CREATEBIT	0	</span><span class="cm">/* Create segid starts at bit 0 */</span><span class="cp"></span>
<span class="cp">#define DELETEBIT	8	</span><span class="cm">/* Delete segid starts at bit 8 */</span><span class="cp"></span>
<span class="cp">#define EXECUTEBIT      16	</span><span class="cm">/* Execute segid starts at bit 16 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  Masks that define memory type.  Must match defines in dynm.cdb.</span>
<span class="cm"> */</span>
<span class="cp">#define DYNM_CODE	0x2</span>
<span class="cp">#define DYNM_DATA	0x4</span>
<span class="cp">#define DYNM_CODEDATA   (DYNM_CODE | DYNM_DATA)</span>
<span class="cp">#define DYNM_INTERNAL   0x8</span>
<span class="cp">#define DYNM_EXTERNAL   0x10</span>

<span class="cm">/*</span>
<span class="cm"> *  Defines for packing memory requirement/preference flags for code and</span>
<span class="cm"> *  data of each of the node&#39;s phases into one mask.</span>
<span class="cm"> *  The bit is set if the segid is required for loading code/data of the</span>
<span class="cm"> *  given phase. The bit is not set, if the segid is preferred only.</span>
<span class="cm"> *</span>
<span class="cm"> *  These defines are also used as indeces into a segid array for the node.</span>
<span class="cm"> *  eg node&#39;s segid[CREATEDATAFLAGBIT] is the memory segment id that the</span>
<span class="cm"> *  create phase data is required or preferred to be loaded into.</span>
<span class="cm"> */</span>
<span class="cp">#define CREATEDATAFLAGBIT   0</span>
<span class="cp">#define CREATECODEFLAGBIT   1</span>
<span class="cp">#define EXECUTEDATAFLAGBIT  2</span>
<span class="cp">#define EXECUTECODEFLAGBIT  3</span>
<span class="cp">#define DELETEDATAFLAGBIT   4</span>
<span class="cp">#define DELETECODEFLAGBIT   5</span>
<span class="cp">#define MAXFLAGS	    6</span>

    <span class="cm">/*</span>
<span class="cm">     *  These names may be embedded in overlay sections to identify which</span>
<span class="cm">     *  node phase the section should be overlayed.</span>
<span class="cm"> */</span>
<span class="cp">#define PCREATE	 &quot;create&quot;</span>
<span class="cp">#define PDELETE	 &quot;delete&quot;</span>
<span class="cp">#define PEXECUTE	&quot;execute&quot;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_equal_uuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">uuid1</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">uuid2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">uuid1</span><span class="p">,</span> <span class="n">uuid2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_uuid</span><span class="p">));</span>
<span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     *  ======== mem_seg_info ========</span>
<span class="cm">     *  Format of dynamic loading memory segment info in coff file.</span>
<span class="cm">     *  Must match dynm.h55.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mem_seg_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">segid</span><span class="p">;</span>		<span class="cm">/* Dynamic loading memory segment number */</span>
	<span class="n">u32</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* Mask of DYNM_CODE, DYNM_INTERNAL, etc. */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== lib_node ========</span>
<span class="cm"> *  For maintaining a tree of library dependencies.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lib_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">lib</span><span class="p">;</span>	<span class="cm">/* The library */</span>
	<span class="n">u16</span> <span class="n">dep_libs</span><span class="p">;</span>		<span class="cm">/* Number of dependent libraries */</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="o">*</span><span class="n">dep_libs_tree</span><span class="p">;</span>	<span class="cm">/* Dependent libraries of lib */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== ovly_sect ========</span>
<span class="cm"> *  Information needed to overlay a section.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">next_sect</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sect_load_addr</span><span class="p">;</span>	<span class="cm">/* Load address of section */</span>
	<span class="n">u32</span> <span class="n">sect_run_addr</span><span class="p">;</span>	<span class="cm">/* Run address of section */</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* Size of section */</span>
	<span class="n">u16</span> <span class="n">page</span><span class="p">;</span>		<span class="cm">/* DBL_CODE, DBL_DATA */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== ovly_node ========</span>
<span class="cm"> *  For maintaining a list of overlay nodes, with sections that need to be</span>
<span class="cm"> *  overlayed for each of the nodes phases.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ovly_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="n">uuid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">node_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">create_sects_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">delete_sects_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">execute_sects_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">other_sects_list</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">create_sects</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">delete_sects</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">execute_sects</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">other_sects</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">create_ref</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">delete_ref</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">execute_ref</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">other_ref</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== nldr_object ========</span>
<span class="cm"> *  Overlay loader object.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nldr_object</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">;</span>	<span class="cm">/* Device object */</span>
	<span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">dcd_mgr</span><span class="p">;</span>	<span class="cm">/* Proc/Node data manager */</span>
	<span class="k">struct</span> <span class="n">dbll_tar_obj</span> <span class="o">*</span><span class="n">dbll</span><span class="p">;</span>	<span class="cm">/* The DBL loader */</span>
	<span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">base_lib</span><span class="p">;</span>	<span class="cm">/* Base image library */</span>
	<span class="k">struct</span> <span class="n">rmm_target_obj</span> <span class="o">*</span><span class="n">rmm</span><span class="p">;</span>	<span class="cm">/* Remote memory manager for DSP */</span>
	<span class="k">struct</span> <span class="n">dbll_fxns</span> <span class="n">ldr_fxns</span><span class="p">;</span>	<span class="cm">/* Loader function table */</span>
	<span class="k">struct</span> <span class="n">dbll_attrs</span> <span class="n">ldr_attrs</span><span class="p">;</span>	<span class="cm">/* attrs to pass to loader functions */</span>
	<span class="n">nldr_ovlyfxn</span> <span class="n">ovly_fxn</span><span class="p">;</span>	<span class="cm">/* &quot;write&quot; for overlay nodes */</span>
	<span class="n">nldr_writefxn</span> <span class="n">write_fxn</span><span class="p">;</span>	<span class="cm">/* &quot;write&quot; for dynamic nodes */</span>
	<span class="k">struct</span> <span class="n">ovly_node</span> <span class="o">*</span><span class="n">ovly_table</span><span class="p">;</span>	<span class="cm">/* Table of overlay nodes */</span>
	<span class="n">u16</span> <span class="n">ovly_nodes</span><span class="p">;</span>		<span class="cm">/* Number of overlay nodes in base */</span>
	<span class="n">u16</span> <span class="n">ovly_nid</span><span class="p">;</span>		<span class="cm">/* Index for tracking overlay nodes */</span>
	<span class="n">u16</span> <span class="n">dload_segs</span><span class="p">;</span>		<span class="cm">/* Number of dynamic load mem segs */</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">seg_table</span><span class="p">;</span>		<span class="cm">/* memtypes of dynamic memory segs</span>
<span class="cm">				 * indexed by segid</span>
<span class="cm">				 */</span>
	<span class="n">u16</span> <span class="n">dsp_mau_size</span><span class="p">;</span>	<span class="cm">/* Size of DSP MAU */</span>
	<span class="n">u16</span> <span class="n">dsp_word_size</span><span class="p">;</span>	<span class="cm">/* Size of DSP word */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== nldr_nodeobject ========</span>
<span class="cm"> *  Dynamic node object. This object is created when a node is allocated.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">;</span>	<span class="cm">/* Dynamic loader handle */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv_ref</span><span class="p">;</span>		<span class="cm">/* Handle to pass to dbl_write_fxn */</span>
	<span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="n">uuid</span><span class="p">;</span>	<span class="cm">/* Node&#39;s UUID */</span>
	<span class="n">bool</span> <span class="n">dynamic</span><span class="p">;</span>		<span class="cm">/* Dynamically loaded node? */</span>
	<span class="n">bool</span> <span class="n">overlay</span><span class="p">;</span>		<span class="cm">/* Overlay node? */</span>
	<span class="n">bool</span> <span class="o">*</span><span class="n">phase_split</span><span class="p">;</span>	<span class="cm">/* Multiple phase libraries? */</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="n">root</span><span class="p">;</span>	<span class="cm">/* Library containing node phase */</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="n">create_lib</span><span class="p">;</span>	<span class="cm">/* Library with create phase lib */</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="n">execute_lib</span><span class="p">;</span>	<span class="cm">/* Library with execute phase lib */</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="n">delete_lib</span><span class="p">;</span>	<span class="cm">/* Library with delete phase lib */</span>
	<span class="cm">/* libs remain loaded until Delete */</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="n">pers_lib_table</span><span class="p">[</span><span class="n">MAXLIBS</span><span class="p">];</span>
	<span class="n">s32</span> <span class="n">pers_libs</span><span class="p">;</span>		<span class="cm">/* Number of persistent libraries */</span>
	<span class="cm">/* Path in lib dependency tree */</span>
	<span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">lib_path</span><span class="p">[</span><span class="n">MAXDEPTH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">;</span>	<span class="cm">/* Node phase currently being loaded */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Dynamic loading memory segments for data and code of each phase.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">seg_id</span><span class="p">[</span><span class="n">MAXFLAGS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Mask indicating whether each mem segment specified in seg_id[]</span>
<span class="cm">	 *  is preferred or required.</span>
<span class="cm">	 *  For example</span>
<span class="cm">	 *  	if (code_data_flag_mask &amp; (1 &lt;&lt; EXECUTEDATAFLAGBIT)) != 0,</span>
<span class="cm">	 *  then it is required to load execute phase data into the memory</span>
<span class="cm">	 *  specified by seg_id[EXECUTEDATAFLAGBIT].</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">code_data_flag_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Dynamic loader function table */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dbll_fxns</span> <span class="n">ldr_fxns</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">(</span><span class="n">dbll_close_fxn</span><span class="p">)</span> <span class="n">dbll_close</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_create_fxn</span><span class="p">)</span> <span class="n">dbll_create</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_delete_fxn</span><span class="p">)</span> <span class="n">dbll_delete</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_exit_fxn</span><span class="p">)</span> <span class="n">dbll_exit</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_get_attrs_fxn</span><span class="p">)</span> <span class="n">dbll_get_attrs</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_get_addr_fxn</span><span class="p">)</span> <span class="n">dbll_get_addr</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_get_c_addr_fxn</span><span class="p">)</span> <span class="n">dbll_get_c_addr</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_get_sect_fxn</span><span class="p">)</span> <span class="n">dbll_get_sect</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_init_fxn</span><span class="p">)</span> <span class="n">dbll_init</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_load_fxn</span><span class="p">)</span> <span class="n">dbll_load</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_open_fxn</span><span class="p">)</span> <span class="n">dbll_open</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_read_sect_fxn</span><span class="p">)</span> <span class="n">dbll_read_sect</span><span class="p">,</span>
	<span class="p">(</span><span class="n">dbll_unload_fxn</span><span class="p">)</span> <span class="n">dbll_unload</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">add_ovly_info</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dbll_sect_info</span> <span class="o">*</span><span class="n">sect_info</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">add_ovly_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">uuid_obj</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">dsp_dcdobjtype</span> <span class="n">obj_type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">add_ovly_sect</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">**</span><span class="n">lst</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dbll_sect_info</span> <span class="o">*</span><span class="n">sect_inf</span><span class="p">,</span>
				<span class="n">bool</span> <span class="o">*</span><span class="n">exists</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">fake_ovly_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_address</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">,</span>
			   <span class="n">s32</span> <span class="n">mtype</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">free_sects</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">phase_sects</span><span class="p">,</span> <span class="n">u16</span> <span class="n">alloc_num</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">get_symbol_value</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">parg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rmm_handle</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">sym_name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dbll_sym_val</span> <span class="o">**</span><span class="n">sym</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">load_lib</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">lib_node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="n">uuid</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">root_prstnt</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">**</span><span class="n">lib_path</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">,</span> <span class="n">u16</span> <span class="n">depth</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">load_ovly</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">remote_alloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">ref</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mem_sect</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">align</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dsp_address</span><span class="p">,</span>
			       <span class="n">s32</span> <span class="n">segmnt_id</span><span class="p">,</span>
			       <span class="n">s32</span> <span class="n">req</span><span class="p">,</span> <span class="n">bool</span> <span class="n">reserve</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">remote_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">ref</span><span class="p">,</span> <span class="n">u16</span> <span class="n">space</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">reserve</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">unload_lib</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">lib_node</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">unload_ovly</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">find_in_persistent_lib_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">lib</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== nldr_allocate ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nldr_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv_ref</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">dcd_nodeprops</span> <span class="o">*</span><span class="n">node_props</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">**</span><span class="n">nldr_nodeobj</span><span class="p">,</span>
			 <span class="n">bool</span> <span class="o">*</span><span class="n">pf_phase_split</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Initialize handle in case of failure */</span>
	<span class="o">*</span><span class="n">nldr_nodeobj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Allocate node object */</span>
	<span class="n">nldr_node_obj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nldr_node_obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase_split</span> <span class="o">=</span> <span class="n">pf_phase_split</span><span class="p">;</span>
		<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="p">;</span>
		<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">priv_ref</span> <span class="o">=</span> <span class="n">priv_ref</span><span class="p">;</span>
		<span class="cm">/* Save node&#39;s UUID. */</span>
		<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">uuid</span> <span class="o">=</span> <span class="n">node_props</span><span class="o">-&gt;</span><span class="n">ndb_props</span><span class="p">.</span><span class="n">ui_node_id</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Determine if node is a dynamically loaded node from</span>
<span class="cm">		 *  ndb_props.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">load_type</span> <span class="o">==</span> <span class="n">NLDR_DYNAMICLOAD</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Dynamic node */</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">dynamic</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Extract memory requirements from ndb_props masks</span>
<span class="cm">			 */</span>
			<span class="cm">/* Create phase */</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">seg_id</span><span class="p">[</span><span class="n">CREATEDATAFLAGBIT</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span>
			    <span class="p">(</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">data_mem_seg_mask</span> <span class="o">&gt;&gt;</span> <span class="n">CREATEBIT</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="n">SEGMASK</span><span class="p">;</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">code_data_flag_mask</span> <span class="o">|=</span>
			    <span class="p">((</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">data_mem_seg_mask</span> <span class="o">&gt;&gt;</span>
			      <span class="p">(</span><span class="n">CREATEBIT</span> <span class="o">+</span> <span class="n">FLAGBIT</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">CREATEDATAFLAGBIT</span><span class="p">;</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">seg_id</span><span class="p">[</span><span class="n">CREATECODEFLAGBIT</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span>
			    <span class="p">(</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">code_mem_seg_mask</span> <span class="o">&gt;&gt;</span>
			     <span class="n">CREATEBIT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SEGMASK</span><span class="p">;</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">code_data_flag_mask</span> <span class="o">|=</span>
			    <span class="p">((</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">code_mem_seg_mask</span> <span class="o">&gt;&gt;</span>
			      <span class="p">(</span><span class="n">CREATEBIT</span> <span class="o">+</span> <span class="n">FLAGBIT</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">CREATECODEFLAGBIT</span><span class="p">;</span>
			<span class="cm">/* Execute phase */</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">seg_id</span><span class="p">[</span><span class="n">EXECUTEDATAFLAGBIT</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span>
			    <span class="p">(</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">data_mem_seg_mask</span> <span class="o">&gt;&gt;</span>
			     <span class="n">EXECUTEBIT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SEGMASK</span><span class="p">;</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">code_data_flag_mask</span> <span class="o">|=</span>
			    <span class="p">((</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">data_mem_seg_mask</span> <span class="o">&gt;&gt;</span>
			      <span class="p">(</span><span class="n">EXECUTEBIT</span> <span class="o">+</span> <span class="n">FLAGBIT</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			    <span class="n">EXECUTEDATAFLAGBIT</span><span class="p">;</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">seg_id</span><span class="p">[</span><span class="n">EXECUTECODEFLAGBIT</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span>
			    <span class="p">(</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">code_mem_seg_mask</span> <span class="o">&gt;&gt;</span>
			     <span class="n">EXECUTEBIT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SEGMASK</span><span class="p">;</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">code_data_flag_mask</span> <span class="o">|=</span>
			    <span class="p">((</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">code_mem_seg_mask</span> <span class="o">&gt;&gt;</span>
			      <span class="p">(</span><span class="n">EXECUTEBIT</span> <span class="o">+</span> <span class="n">FLAGBIT</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			    <span class="n">EXECUTECODEFLAGBIT</span><span class="p">;</span>
			<span class="cm">/* Delete phase */</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">seg_id</span><span class="p">[</span><span class="n">DELETEDATAFLAGBIT</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span>
			    <span class="p">(</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">data_mem_seg_mask</span> <span class="o">&gt;&gt;</span> <span class="n">DELETEBIT</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="n">SEGMASK</span><span class="p">;</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">code_data_flag_mask</span> <span class="o">|=</span>
			    <span class="p">((</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">data_mem_seg_mask</span> <span class="o">&gt;&gt;</span>
			      <span class="p">(</span><span class="n">DELETEBIT</span> <span class="o">+</span> <span class="n">FLAGBIT</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">DELETEDATAFLAGBIT</span><span class="p">;</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">seg_id</span><span class="p">[</span><span class="n">DELETECODEFLAGBIT</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span>
			    <span class="p">(</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">code_mem_seg_mask</span> <span class="o">&gt;&gt;</span>
			     <span class="n">DELETEBIT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SEGMASK</span><span class="p">;</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">code_data_flag_mask</span> <span class="o">|=</span>
			    <span class="p">((</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">code_mem_seg_mask</span> <span class="o">&gt;&gt;</span>
			      <span class="p">(</span><span class="n">DELETEBIT</span> <span class="o">+</span> <span class="n">FLAGBIT</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">DELETECODEFLAGBIT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Non-dynamically loaded nodes are part of the</span>
<span class="cm">			 * base image */</span>
			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">lib</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">base_lib</span><span class="p">;</span>
			<span class="cm">/* Check for overlay node */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node_props</span><span class="o">-&gt;</span><span class="n">load_type</span> <span class="o">==</span> <span class="n">NLDR_OVLYLOAD</span><span class="p">)</span>
				<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">overlay</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="o">*</span><span class="n">nldr_nodeobj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="p">)</span><span class="n">nldr_node_obj</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Cleanup on failure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">nldr_node_obj</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== nldr_create ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nldr_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">**</span><span class="n">nldr</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">nldr_attrs</span> <span class="o">*</span><span class="n">pattrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">cod_mgr</span><span class="p">;</span>	<span class="cm">/* COD manager */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">psz_coff_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">sz_zl_file</span><span class="p">[</span><span class="n">COD_MAXPATHLENGTH</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dbll_attrs</span> <span class="n">save_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dbll_attrs</span> <span class="n">new_attrs</span><span class="p">;</span>
	<span class="n">dbll_flags</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_entry</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dload_segs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_seg_info</span> <span class="o">*</span><span class="n">mem_info_obj</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmm_segment</span> <span class="o">*</span><span class="n">rmm_segs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Allocate dynamic loader object */</span>
	<span class="n">nldr_obj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nldr_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>
		<span class="cm">/* warning, lazy status checking alert! */</span>
		<span class="n">dev_get_cod_mgr</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cod_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cod_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_loader</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dbll</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_base_lib</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">base_lib</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">cod_get_base_name</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="n">sz_zl_file</span><span class="p">,</span>
							<span class="n">COD_MAXPATHLENGTH</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* end lazy status checking */</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dsp_mau_size</span> <span class="o">=</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">dsp_mau_size</span><span class="p">;</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span> <span class="o">=</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span><span class="p">;</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span> <span class="o">=</span> <span class="n">ldr_fxns</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">init_fxn</span><span class="p">()))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Create the DCD Manager */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dcd_create_manager</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">);</span>

	<span class="cm">/* Get dynamic loading memory sections from base lib */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_sect_fxn</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">base_lib</span><span class="p">,</span>
						    <span class="n">DYNMEMSECT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_addr</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">ul_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">psz_coff_buf</span> <span class="o">=</span>
				<span class="n">kzalloc</span><span class="p">(</span><span class="n">ul_len</span> <span class="o">*</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dsp_mau_size</span><span class="p">,</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">psz_coff_buf</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Ok to not have dynamic loading memory */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ul_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: failed - no dynamic loading mem &quot;</span>
				<span class="s">&quot;segments: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">ul_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read section containing dynamic load mem segments */</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">read_sect_fxn</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">base_lib</span><span class="p">,</span>
						     <span class="n">DYNMEMSECT</span><span class="p">,</span> <span class="n">psz_coff_buf</span><span class="p">,</span>
						     <span class="n">ul_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">ul_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Parse memory segment data */</span>
		<span class="n">dload_segs</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">psz_coff_buf</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dload_segs</span> <span class="o">&gt;</span> <span class="n">MAXMEMSEGS</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Parse dynamic load memory segments */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">dload_segs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rmm_segs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmm_segment</span><span class="p">)</span> <span class="o">*</span> <span class="n">dload_segs</span><span class="p">,</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">seg_table</span> <span class="o">=</span>
				<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">dload_segs</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rmm_segs</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">seg_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dload_segs</span> <span class="o">=</span> <span class="n">dload_segs</span><span class="p">;</span>
			<span class="n">mem_info_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mem_seg_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">psz_coff_buf</span> <span class="o">+</span>
							       <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dload_segs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rmm_segs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="n">mem_info_obj</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
				<span class="n">rmm_segs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">mem_info_obj</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
				<span class="n">rmm_segs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">seg_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">mem_info_obj</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
					<span class="s">&quot;(proc) DLL MEMSEGMENT: %d, &quot;</span>
					<span class="s">&quot;Base: 0x%x, Length: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">rmm_segs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">,</span> <span class="n">rmm_segs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Create Remote memory manager */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">rmm_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">rmm</span><span class="p">,</span> <span class="n">rmm_segs</span><span class="p">,</span> <span class="n">dload_segs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set the alloc, free, write functions for loader */</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_attrs_fxn</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dbll</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">save_attrs</span><span class="p">);</span>
		<span class="n">new_attrs</span> <span class="o">=</span> <span class="n">save_attrs</span><span class="p">;</span>
		<span class="n">new_attrs</span><span class="p">.</span><span class="n">alloc</span> <span class="o">=</span> <span class="p">(</span><span class="n">dbll_alloc_fxn</span><span class="p">)</span> <span class="n">remote_alloc</span><span class="p">;</span>
		<span class="n">new_attrs</span><span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="p">(</span><span class="n">dbll_free_fxn</span><span class="p">)</span> <span class="n">remote_free</span><span class="p">;</span>
		<span class="n">new_attrs</span><span class="p">.</span><span class="n">sym_lookup</span> <span class="o">=</span> <span class="p">(</span><span class="n">dbll_sym_lookup</span><span class="p">)</span> <span class="n">get_symbol_value</span><span class="p">;</span>
		<span class="n">new_attrs</span><span class="p">.</span><span class="n">sym_handle</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="p">;</span>
		<span class="n">new_attrs</span><span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="p">(</span><span class="n">dbll_write_fxn</span><span class="p">)</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">;</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_fxn</span> <span class="o">=</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">ovly</span><span class="p">;</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">write_fxn</span> <span class="o">=</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">;</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_attrs</span> <span class="o">=</span> <span class="n">new_attrs</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rmm_segs</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">psz_coff_buf</span><span class="p">);</span>

	<span class="cm">/* Get overlay nodes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">cod_get_base_name</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="n">sz_zl_file</span><span class="p">,</span> <span class="n">COD_MAXPATHLENGTH</span><span class="p">);</span>
		<span class="cm">/* lazy check */</span>
		<span class="cm">/* First count number of overlay nodes */</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">dcd_get_objects</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">,</span> <span class="n">sz_zl_file</span><span class="p">,</span>
				    <span class="n">add_ovly_node</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">nldr_obj</span><span class="p">);</span>
		<span class="cm">/* Now build table of overlay nodes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Allocate table for overlay nodes */</span>
			<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span> <span class="o">=</span>
					<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ovly_node</span><span class="p">)</span> <span class="o">*</span>
					<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nodes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="cm">/* Put overlay nodes in the table */</span>
			<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">dcd_get_objects</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">,</span> <span class="n">sz_zl_file</span><span class="p">,</span>
						 <span class="n">add_ovly_node</span><span class="p">,</span>
						 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">nldr_obj</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Do a fake reload of the base image to get overlay section info */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">save_attrs</span><span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">fake_ovly_write</span><span class="p">;</span>
		<span class="n">save_attrs</span><span class="p">.</span><span class="n">log_write</span> <span class="o">=</span> <span class="n">add_ovly_info</span><span class="p">;</span>
		<span class="n">save_attrs</span><span class="p">.</span><span class="n">log_write_handle</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="p">;</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">DBLL_CODE</span> <span class="o">|</span> <span class="n">DBLL_DATA</span> <span class="o">|</span> <span class="n">DBLL_SYMB</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">load_fxn</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">base_lib</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">save_attrs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">nldr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="p">)</span><span class="n">nldr_obj</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nldr_obj</span><span class="p">)</span>
			<span class="n">nldr_delete</span><span class="p">((</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="p">)</span><span class="n">nldr_obj</span><span class="p">);</span>

		<span class="o">*</span><span class="n">nldr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME:Temp. Fix. Must be removed */</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== nldr_delete ========</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nldr_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">ovly_section</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">exit_fxn</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">rmm</span><span class="p">)</span>
		<span class="n">rmm_delete</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">rmm</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">seg_table</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">)</span>
		<span class="n">dcd_destroy_manager</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">);</span>

	<span class="cm">/* Free overlay node information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ovly_section</span> <span class="o">=</span>
			    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">create_sects_list</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">ovly_section</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">next_sect</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ovly_section</span><span class="p">);</span>
				<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ovly_section</span> <span class="o">=</span>
			    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">delete_sects_list</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">ovly_section</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">next_sect</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ovly_section</span><span class="p">);</span>
				<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ovly_section</span> <span class="o">=</span>
			    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">execute_sects_list</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">ovly_section</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">next_sect</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ovly_section</span><span class="p">);</span>
				<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">other_sects_list</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">ovly_section</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">next_sect</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ovly_section</span><span class="p">);</span>
				<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">nldr_obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== nldr_get_fxn_addr ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nldr_get_fxn_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">str_fxn</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dbll_sym_val</span> <span class="o">*</span><span class="n">dbll_sym</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">status1</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="n">root</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

	<span class="n">nldr_obj</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">;</span>
	<span class="cm">/* Called from node_create(), node_delete(), or node_run(). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">dynamic</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NLDR_CREATE</span>:
			<span class="n">root</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">create_lib</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NLDR_EXECUTE</span>:
			<span class="n">root</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">execute_lib</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NLDR_DELETE</span>:
			<span class="n">root</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">delete_lib</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* for Overlay nodes or non-split Dynamic nodes */</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status1</span> <span class="o">=</span>
	    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_c_addr_fxn</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">lib</span><span class="p">,</span> <span class="n">str_fxn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbll_sym</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status1</span><span class="p">)</span>
		<span class="n">status1</span> <span class="o">=</span>
		    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_addr_fxn</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">lib</span><span class="p">,</span> <span class="n">str_fxn</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">dbll_sym</span><span class="p">);</span>

	<span class="cm">/* If symbol not found, check dependent libraries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">.</span><span class="n">dep_libs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status1</span> <span class="o">=</span>
			    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_addr_fxn</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">dep_libs_tree</span>
							    <span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">,</span> <span class="n">str_fxn</span><span class="p">,</span>
							    <span class="o">&amp;</span><span class="n">dbll_sym</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status1</span> <span class="o">=</span>
				    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span>
				    <span class="n">get_c_addr_fxn</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">dep_libs_tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">,</span>
						   <span class="n">str_fxn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbll_sym</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Symbol found */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Check persistent libraries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status1</span> <span class="o">=</span>
			    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span>
			    <span class="n">get_addr_fxn</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_lib_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">,</span>
					 <span class="n">str_fxn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbll_sym</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status1</span> <span class="o">=</span>
				    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span>
				    <span class="n">get_c_addr_fxn</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_lib_table</span>
						   <span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">,</span> <span class="n">str_fxn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbll_sym</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Symbol found */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">dbll_sym</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== nldr_get_rmm_manager ========</span>
<span class="cm"> *  Given a NLDR object, retrieve RMM Manager Handle</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nldr_get_rmm_manager</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rmm_target_obj</span> <span class="o">**</span><span class="n">rmm_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="n">nldr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nldr</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">rmm_mgr</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">rmm</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">rmm_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== nldr_load ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nldr_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
		     <span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="n">lib_uuid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nldr_obj</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">dynamic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span><span class="p">;</span>

		<span class="n">lib_uuid</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">;</span>

		<span class="cm">/* At this point, we may not know if node is split into</span>
<span class="cm">		 * different libraries. So we&#39;ll go ahead and load the</span>
<span class="cm">		 * library, and then save the pointer to the appropriate</span>
<span class="cm">		 * location after we know. */</span>

		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">load_lib</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">lib_uuid</span><span class="p">,</span>
			     <span class="nb">false</span><span class="p">,</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">lib_path</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">NLDR_CREATE</span>:
					<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">create_lib</span> <span class="o">=</span>
					    <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">case</span> <span class="n">NLDR_EXECUTE</span>:
					<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">execute_lib</span> <span class="o">=</span>
					    <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">case</span> <span class="n">NLDR_DELETE</span>:
					<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">delete_lib</span> <span class="o">=</span>
					    <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="nl">default:</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">overlay</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">load_ovly</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="n">phase</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== nldr_unload ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nldr_unload</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
		       <span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="o">*</span><span class="n">root_lib</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nldr_node_obj</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">dynamic</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">NLDR_CREATE</span>:
					<span class="n">root_lib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">create_lib</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">NLDR_EXECUTE</span>:
					<span class="n">root_lib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">execute_lib</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">NLDR_DELETE</span>:
					<span class="n">root_lib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">delete_lib</span><span class="p">;</span>
					<span class="cm">/* Unload persistent libraries */</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span><span class="p">;</span>
					     <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">unload_lib</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span>
							   <span class="n">pers_lib_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
					<span class="p">}</span>
					<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Unload main library */</span>
				<span class="n">root_lib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">root_lib</span><span class="p">)</span>
				<span class="n">unload_lib</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="n">root_lib</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">overlay</span><span class="p">)</span>
				<span class="n">unload_ovly</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="n">phase</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== add_ovly_info ========</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_ovly_info</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dbll_sect_info</span> <span class="o">*</span><span class="n">sect_info</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">node_name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sect_name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">sect_exists</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">seps</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pch</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="p">)</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Is this an overlay section (load address != run address)? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">sect_load_addr</span> <span class="o">==</span> <span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">sect_run_addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* Find the node it belongs to */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_name</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node_name</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">sect_name</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">node_name</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Found the node */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nodes</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* Determine which phase this section belongs to */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pch</span> <span class="o">=</span> <span class="n">sect_name</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">*</span><span class="n">pch</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pch</span> <span class="o">!=</span> <span class="n">seps</span><span class="p">;</span> <span class="n">pch</span><span class="o">++</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch</span><span class="o">++</span><span class="p">;</span>		<span class="cm">/* Skip over the &#39;:&#39; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">pch</span><span class="p">,</span> <span class="n">PCREATE</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">PCREATE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">add_ovly_sect</span><span class="p">(</span><span class="n">nldr_obj</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span>
					  <span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">create_sects_list</span><span class="p">,</span>
					  <span class="n">sect_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sect_exists</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sect_exists</span><span class="p">)</span>
				<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">create_sects</span><span class="o">++</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">pch</span><span class="p">,</span> <span class="n">PDELETE</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">PDELETE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">add_ovly_sect</span><span class="p">(</span><span class="n">nldr_obj</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span>
					  <span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">delete_sects_list</span><span class="p">,</span>
					  <span class="n">sect_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sect_exists</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sect_exists</span><span class="p">)</span>
				<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">delete_sects</span><span class="o">++</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">pch</span><span class="p">,</span> <span class="n">PEXECUTE</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">PEXECUTE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">add_ovly_sect</span><span class="p">(</span><span class="n">nldr_obj</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span>
					  <span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">execute_sects_list</span><span class="p">,</span>
					  <span class="n">sect_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sect_exists</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sect_exists</span><span class="p">)</span>
				<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">execute_sects</span><span class="o">++</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Put in &quot;other&quot; sectins */</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">add_ovly_sect</span><span class="p">(</span><span class="n">nldr_obj</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span>
					  <span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">other_sects_list</span><span class="p">,</span>
					  <span class="n">sect_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sect_exists</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sect_exists</span><span class="p">)</span>
				<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">other_sects</span><span class="o">++</span><span class="p">;</span>

		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== add_ovly_node =========</span>
<span class="cm"> *  Callback function passed to dcd_get_objects.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_ovly_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">uuid_obj</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">dsp_dcdobjtype</span> <span class="n">obj_type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="p">)</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">node_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dcd_genericobj</span> <span class="n">obj_def</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">obj_type</span> <span class="o">!=</span> <span class="n">DSP_DCDNODETYPE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span>
	    <span class="n">dcd_get_object_def</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">,</span> <span class="n">uuid_obj</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">obj_def</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* If overlay node, add to the list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj_def</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">load_type</span> <span class="o">==</span> <span class="n">NLDR_OVLYLOAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nodes</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Add node to table */</span>
			<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nid</span><span class="p">].</span><span class="n">uuid</span> <span class="o">=</span>
			    <span class="o">*</span><span class="n">uuid_obj</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span>
			    <span class="n">strlen</span><span class="p">(</span><span class="n">obj_def</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">ndb_props</span><span class="p">.</span><span class="n">ac_name</span><span class="p">);</span>
			<span class="n">node_name</span> <span class="o">=</span> <span class="n">obj_def</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">ndb_props</span><span class="p">.</span><span class="n">ac_name</span><span class="p">;</span>
			<span class="n">pbuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">strncpy</span><span class="p">(</span><span class="n">pbuf</span><span class="p">,</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
				<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nid</span><span class="p">].</span>
				    <span class="n">node_name</span> <span class="o">=</span> <span class="n">pbuf</span><span class="p">;</span>
				<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nid</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* These were allocated in dcd_get_object_def */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">obj_def</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_create_phase_fxn</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">obj_def</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_execute_phase_fxn</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">obj_def</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_delete_phase_fxn</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">obj_def</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_i_alg_name</span><span class="p">);</span>

<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== add_ovly_sect ========</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_ovly_sect</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">**</span><span class="n">lst</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dbll_sect_info</span> <span class="o">*</span><span class="n">sect_inf</span><span class="p">,</span>
				<span class="n">bool</span> <span class="o">*</span><span class="n">exists</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">new_sect</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">last_sect</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">ovly_section</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">last_sect</span> <span class="o">=</span> <span class="o">*</span><span class="n">lst</span><span class="p">;</span>
	<span class="o">*</span><span class="n">exists</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ovly_section</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Make sure section has not already been added. Multiple</span>
<span class="cm">		 *  &#39;write&#39; calls may be made to load the section.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">sect_load_addr</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Already added */</span>
			<span class="o">*</span><span class="n">exists</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">last_sect</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="p">;</span>
		<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">next_sect</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ovly_section</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* New section */</span>
		<span class="n">new_sect</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ovly_sect</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_sect</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">new_sect</span><span class="o">-&gt;</span><span class="n">sect_load_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="n">new_sect</span><span class="o">-&gt;</span><span class="n">sect_run_addr</span> <span class="o">=</span> <span class="n">sect_inf</span><span class="o">-&gt;</span><span class="n">sect_run_addr</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">sect_inf</span><span class="o">-&gt;</span><span class="n">sect_load_addr</span><span class="p">);</span>
			<span class="n">new_sect</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">new_sect</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">sect_inf</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Add to the list */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">lst</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* First in the list */</span>
				<span class="o">*</span><span class="n">lst</span> <span class="o">=</span> <span class="n">new_sect</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">last_sect</span><span class="o">-&gt;</span><span class="n">next_sect</span> <span class="o">=</span> <span class="n">new_sect</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== fake_ovly_write ========</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">fake_ovly_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_address</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">,</span>
			   <span class="n">s32</span> <span class="n">mtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== free_sects ========</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_sects</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">phase_sects</span><span class="p">,</span> <span class="n">u16</span> <span class="n">alloc_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">ovly_section</span> <span class="o">=</span> <span class="n">phase_sects</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ovly_section</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">alloc_num</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &#39;Deallocate&#39; */</span>
		<span class="cm">/* segid - page not supported yet */</span>
		<span class="cm">/* Reserved memory */</span>
		<span class="n">ret</span> <span class="o">=</span>
		    <span class="n">rmm_free</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">rmm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">sect_run_addr</span><span class="p">,</span>
			     <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">next_sect</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== get_symbol_value ========</span>
<span class="cm"> *  Find symbol in library&#39;s base image.  If not there, check dependent</span>
<span class="cm"> *  libraries.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">get_symbol_value</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">parg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rmm_handle</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">sym_name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dbll_sym_val</span> <span class="o">**</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="p">)</span><span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="p">)</span><span class="n">rmm_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lib_node</span> <span class="o">*</span><span class="p">)</span><span class="n">parg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* check the base image */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_addr_fxn</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">base_lib</span><span class="p">,</span>
						 <span class="n">sym_name</span><span class="p">,</span> <span class="n">sym</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_c_addr_fxn</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">base_lib</span><span class="p">,</span>
							<span class="n">sym_name</span><span class="p">,</span> <span class="n">sym</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check in root lib itself. If the library consists of</span>
<span class="cm">	 *  multiple object files linked together, some symbols in the</span>
<span class="cm">	 *  library may need to be resolved.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_addr_fxn</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">,</span>
							 <span class="n">sym</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_c_addr_fxn</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">,</span>
							      <span class="n">sym_name</span><span class="p">,</span> <span class="n">sym</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check in root lib&#39;s dependent libraries, but not dependent</span>
<span class="cm">	 *  libraries&#39; dependents.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_addr_fxn</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span>
							    <span class="n">dep_libs_tree</span>
							    <span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">,</span>
							    <span class="n">sym_name</span><span class="p">,</span> <span class="n">sym</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span>
				    <span class="n">get_c_addr_fxn</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs_tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">,</span>
						   <span class="n">sym_name</span><span class="p">,</span> <span class="n">sym</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Symbol found */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check in persistent libraries</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span>
			    <span class="n">get_addr_fxn</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_lib_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">,</span>
					 <span class="n">sym_name</span><span class="p">,</span> <span class="n">sym</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">get_c_addr_fxn</span>
				    <span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_lib_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">,</span>
				     <span class="n">sym_name</span><span class="p">,</span> <span class="n">sym</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Symbol found */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== load_lib ========</span>
<span class="cm"> *  Recursively load library and all its dependent libraries. The library</span>
<span class="cm"> *  we&#39;re loading is specified by a uuid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_lib</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">lib_node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="n">uuid</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">root_prstnt</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">**</span><span class="n">lib_path</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">,</span> <span class="n">u16</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nd_libs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Number of dependent libraries */</span>
	<span class="n">u16</span> <span class="n">np_libs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Number of persistent libraries */</span>
	<span class="n">u16</span> <span class="n">nd_libs_loaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Number of dep. libraries loaded */</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dw_buf_size</span> <span class="o">=</span> <span class="n">NLDR_MAXPATHLENGTH</span><span class="p">;</span>
	<span class="n">dbll_flags</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">DBLL_SYMB</span> <span class="o">|</span> <span class="n">DBLL_CODE</span> <span class="o">|</span> <span class="n">DBLL_DATA</span> <span class="o">|</span> <span class="n">DBLL_DYNAMIC</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dbll_attrs</span> <span class="n">new_attrs</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">psz_file_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">dep_lib_uui_ds</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="o">*</span><span class="n">persistent_dep_libs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">lib_status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="o">*</span><span class="n">dep_lib</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="n">MAXDEPTH</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Error */</span>
	<span class="p">}</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Allocate a buffer for library file name of size DBL_MAXPATHLENGTH */</span>
	<span class="n">psz_file_name</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">DBLL_MAXPATHLENGTH</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psz_file_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get the name of the library */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">dcd_get_library_name</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span>
						 <span class="n">dcd_mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">psz_file_name</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">dw_buf_size</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span>
						 <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Dependent libraries are registered with a phase */</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">dcd_get_library_name</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span>
						 <span class="n">dcd_mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">psz_file_name</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">dw_buf_size</span><span class="p">,</span> <span class="n">NLDR_NOPHASE</span><span class="p">,</span>
						 <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Open the library, don&#39;t load symbols */</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">open_fxn</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dbll</span><span class="p">,</span> <span class="n">psz_file_name</span><span class="p">,</span>
						<span class="n">DBLL_NOLOAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Done with file name */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">psz_file_name</span><span class="p">);</span>

	<span class="cm">/* Check to see if library not already loaded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">root_prstnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lib_status</span> <span class="o">=</span>
		    <span class="n">find_in_persistent_lib_array</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">);</span>
		<span class="cm">/* Close library */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lib_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">close_fxn</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for circular dependencies. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span> <span class="o">==</span> <span class="n">lib_path</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="cm">/* This condition could be checked by a</span>
<span class="cm">				 * tool at build time. */</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Add library to current path in dependency tree */</span>
		<span class="n">lib_path</span><span class="p">[</span><span class="n">depth</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">;</span>
		<span class="n">depth</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Get number of dependent libraries */</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">dcd_get_num_dep_libs</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd_libs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np_libs</span><span class="p">,</span> <span class="n">phase</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">))</span>
			<span class="n">np_libs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* nd_libs = #of dependent libraries */</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs</span> <span class="o">=</span> <span class="n">nd_libs</span> <span class="o">-</span> <span class="n">np_libs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd_libs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dep_lib_uui_ds</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_uuid</span><span class="p">)</span> <span class="o">*</span>
							<span class="n">nd_libs</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="n">persistent_dep_libs</span> <span class="o">=</span>
				<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">bool</span><span class="p">)</span> <span class="o">*</span> <span class="n">nd_libs</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dep_lib_uui_ds</span> <span class="o">||</span> <span class="o">!</span><span class="n">persistent_dep_libs</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Allocate arrays for dependent lib UUIDs,</span>
<span class="cm">				 * lib nodes */</span>
				<span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs_tree</span> <span class="o">=</span> <span class="n">kzalloc</span>
						<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lib_node</span><span class="p">)</span> <span class="o">*</span>
						<span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs_tree</span><span class="p">))</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Get the dependent library UUIDs */</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">dcd_get_dep_libs</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span>
						     <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uuid</span><span class="p">,</span>
						     <span class="n">nd_libs</span><span class="p">,</span> <span class="n">dep_lib_uui_ds</span><span class="p">,</span>
						     <span class="n">persistent_dep_libs</span><span class="p">,</span>
						     <span class="n">phase</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Recursively load dependent libraries.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nd_libs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If root library is NOT persistent, and dep library</span>
<span class="cm">			 * is, then record it.  If root library IS persistent,</span>
<span class="cm">			 * the deplib is already included */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root_prstnt</span> <span class="o">&amp;&amp;</span> <span class="n">persistent_dep_libs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
			    <span class="o">*</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MAXLIBS</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Allocate library outside of phase */</span>
				<span class="n">dep_lib</span> <span class="o">=</span>
				    <span class="o">&amp;</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_lib_table</span>
				    <span class="p">[</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span><span class="p">];</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">root_prstnt</span><span class="p">)</span>
					<span class="n">persistent_dep_libs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

				<span class="cm">/* Allocate library within phase */</span>
				<span class="n">dep_lib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs_tree</span><span class="p">[</span><span class="n">nd_libs_loaded</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">load_lib</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="n">dep_lib</span><span class="p">,</span>
					  <span class="n">dep_lib_uui_ds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					  <span class="n">persistent_dep_libs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lib_path</span><span class="p">,</span>
					  <span class="n">phase</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="n">root_prstnt</span> <span class="o">&amp;&amp;</span> <span class="n">persistent_dep_libs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
				    <span class="o">*</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
					<span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">persistent_dep_libs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span>
					    <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">nd_libs_loaded</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Now we can load the root library */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_attrs</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_attrs</span><span class="p">;</span>
		<span class="n">new_attrs</span><span class="p">.</span><span class="n">sym_arg</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
		<span class="n">new_attrs</span><span class="p">.</span><span class="n">rmm_handle</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="p">;</span>
		<span class="n">new_attrs</span><span class="p">.</span><span class="n">input_params</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">priv_ref</span><span class="p">;</span>
		<span class="n">new_attrs</span><span class="p">.</span><span class="n">base_image</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">load_fxn</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_attrs</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  In case of failure, unload any dependent libraries that</span>
<span class="cm">	 *  were loaded, and close the root library.</span>
<span class="cm">	 *  (Persistent libraries are unloaded from the very top)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">!=</span> <span class="n">NLDR_EXECUTE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">unload_lib</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_lib_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nd_libs_loaded</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">unload_lib</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs_tree</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">)</span>
			<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">close_fxn</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="cm">/* Going up one node in the dependency tree */</span>
	<span class="n">depth</span><span class="o">--</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dep_lib_uui_ds</span><span class="p">);</span>
	<span class="n">dep_lib_uui_ds</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">persistent_dep_libs</span><span class="p">);</span>
	<span class="n">persistent_dep_libs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== load_ovly ========</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_ovly</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_node</span> <span class="o">*</span><span class="n">po_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">phase_sects</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">other_sects_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">alloc_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">other_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">ref_count</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">other_ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">ovly_section</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Find the node in the table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_equal_uuid</span>
		    <span class="p">(</span><span class="o">&amp;</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">uuid</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Found it */</span>
			<span class="n">po_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">po_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NLDR_CREATE</span>:
		<span class="n">ref_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">po_node</span><span class="o">-&gt;</span><span class="n">create_ref</span><span class="p">);</span>
		<span class="n">other_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">po_node</span><span class="o">-&gt;</span><span class="n">other_ref</span><span class="p">);</span>
		<span class="n">phase_sects</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">create_sects_list</span><span class="p">;</span>
		<span class="n">other_sects_list</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">other_sects_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NLDR_EXECUTE</span>:
		<span class="n">ref_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">po_node</span><span class="o">-&gt;</span><span class="n">execute_ref</span><span class="p">);</span>
		<span class="n">phase_sects</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">execute_sects_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NLDR_DELETE</span>:
		<span class="n">ref_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">po_node</span><span class="o">-&gt;</span><span class="n">delete_ref</span><span class="p">);</span>
		<span class="n">phase_sects</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">delete_sects_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref_count</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ref_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* &#39;Allocate&#39; memory for overlay sections of this phase */</span>
	<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">phase_sects</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ovly_section</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* allocate *//* page not supported yet */</span>
		<span class="cm">/* reserve *//* align */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">rmm_alloc</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">rmm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="p">(</span><span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">sect_run_addr</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">next_sect</span><span class="p">;</span>
			<span class="n">alloc_num</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other_ref</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">other_ref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &#39;Allocate&#39; memory for other overlay sections</span>
<span class="cm">		 * (create phase) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">other_sects_list</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">ovly_section</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* page not supported *//* align */</span>
				<span class="cm">/* reserve */</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">rmm_alloc</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">rmm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					      <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="p">(</span><span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">sect_run_addr</span><span class="p">),</span>
					      <span class="nb">true</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">next_sect</span><span class="p">;</span>
					<span class="n">other_alloc</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ref_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Load sections for this phase */</span>
			<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">phase_sects</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">ovly_section</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bytes</span> <span class="o">=</span>
				    <span class="p">(</span><span class="o">*</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_fxn</span><span class="p">)</span> <span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span>
							   <span class="n">priv_ref</span><span class="p">,</span>
							   <span class="n">ovly_section</span><span class="o">-&gt;</span>
							   <span class="n">sect_run_addr</span><span class="p">,</span>
							   <span class="n">ovly_section</span><span class="o">-&gt;</span>
							   <span class="n">sect_load_addr</span><span class="p">,</span>
							   <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
							   <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">!=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

				<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">next_sect</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other_ref</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">other_ref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Load other sections (create phase) */</span>
			<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">other_sects_list</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">ovly_section</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bytes</span> <span class="o">=</span>
				    <span class="p">(</span><span class="o">*</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_fxn</span><span class="p">)</span> <span class="p">(</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span>
							   <span class="n">priv_ref</span><span class="p">,</span>
							   <span class="n">ovly_section</span><span class="o">-&gt;</span>
							   <span class="n">sect_run_addr</span><span class="p">,</span>
							   <span class="n">ovly_section</span><span class="o">-&gt;</span>
							   <span class="n">sect_load_addr</span><span class="p">,</span>
							   <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
							   <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">!=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

				<span class="n">ovly_section</span> <span class="o">=</span> <span class="n">ovly_section</span><span class="o">-&gt;</span><span class="n">next_sect</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &#39;Deallocate&#39; memory */</span>
		<span class="n">free_sects</span><span class="p">(</span><span class="n">nldr_obj</span><span class="p">,</span> <span class="n">phase_sects</span><span class="p">,</span> <span class="n">alloc_num</span><span class="p">);</span>
		<span class="n">free_sects</span><span class="p">(</span><span class="n">nldr_obj</span><span class="p">,</span> <span class="n">other_sects_list</span><span class="p">,</span> <span class="n">other_alloc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ref_count</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ref_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">other_ref</span><span class="p">)</span>
			<span class="o">*</span><span class="n">other_ref</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== remote_alloc ========</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">remote_alloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">ref</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mem_sect</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">align</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dsp_address</span><span class="p">,</span>
			       <span class="n">s32</span> <span class="n">segmnt_id</span><span class="p">,</span> <span class="n">s32</span> <span class="n">req</span><span class="p">,</span>
			       <span class="n">bool</span> <span class="n">reserve</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">hnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="p">)</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmm_target_obj</span> <span class="o">*</span><span class="n">rmm</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mem_phase_bit</span> <span class="o">=</span> <span class="n">MAXFLAGS</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">segid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mem_sect_type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">word_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmm_addr</span> <span class="o">*</span><span class="n">rmm_addr_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rmm_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">dsp_address</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">mem_load_req</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>	<span class="cm">/* Set to fail */</span>
	<span class="n">nldr_obj</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">;</span>
	<span class="n">rmm</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">rmm</span><span class="p">;</span>
	<span class="cm">/* Convert size to DSP words */</span>
	<span class="n">word_size</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span> <span class="o">-</span>
	     <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span><span class="p">;</span>
	<span class="cm">/* Modify memory &#39;align&#39; to account for DSP cache line size */</span>
	<span class="n">align</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">GEM_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: memory align to 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">segmnt_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rmm_addr_obj</span><span class="o">-&gt;</span><span class="n">segid</span> <span class="o">=</span> <span class="n">segmnt_id</span><span class="p">;</span>
		<span class="n">segid</span> <span class="o">=</span> <span class="n">segmnt_id</span><span class="p">;</span>
		<span class="n">mem_load_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NLDR_CREATE</span>:
			<span class="n">mem_phase_bit</span> <span class="o">=</span> <span class="n">CREATEDATAFLAGBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NLDR_DELETE</span>:
			<span class="n">mem_phase_bit</span> <span class="o">=</span> <span class="n">DELETEDATAFLAGBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NLDR_EXECUTE</span>:
			<span class="n">mem_phase_bit</span> <span class="o">=</span> <span class="n">EXECUTEDATAFLAGBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem_sect</span> <span class="o">==</span> <span class="n">DBLL_CODE</span><span class="p">)</span>
			<span class="n">mem_phase_bit</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mem_phase_bit</span> <span class="o">&lt;</span> <span class="n">MAXFLAGS</span><span class="p">)</span>
			<span class="n">segid</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">seg_id</span><span class="p">[</span><span class="n">mem_phase_bit</span><span class="p">];</span>

		<span class="cm">/* Determine if there is a memory loading requirement */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">code_data_flag_mask</span> <span class="o">&gt;&gt;</span> <span class="n">mem_phase_bit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
			<span class="n">mem_load_req</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">mem_sect_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">mem_sect</span> <span class="o">==</span> <span class="n">DBLL_CODE</span><span class="p">)</span> <span class="o">?</span> <span class="n">DYNM_CODE</span> <span class="o">:</span> <span class="n">DYNM_DATA</span><span class="p">;</span>

	<span class="cm">/* Find an appropriate segment based on mem_sect */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">segid</span> <span class="o">==</span> <span class="n">NULLID</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No memory requirements of preferences */</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">segid</span> <span class="o">&lt;=</span> <span class="n">MAXSEGID</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Attempt to allocate from segid first. */</span>
		<span class="n">rmm_addr_obj</span><span class="o">-&gt;</span><span class="n">segid</span> <span class="o">=</span> <span class="n">segid</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">rmm_alloc</span><span class="p">(</span><span class="n">rmm</span><span class="p">,</span> <span class="n">segid</span><span class="p">,</span> <span class="n">word_size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">dsp_address</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Unable allocate from segment %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">segid</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* segid &gt; MAXSEGID ==&gt; Internal or external memory */</span>
		<span class="cm">/*  Check for any internal or external memory segment,</span>
<span class="cm">		 *  depending on segid. */</span>
		<span class="n">mem_sect_type</span> <span class="o">|=</span> <span class="n">segid</span> <span class="o">==</span> <span class="n">MEMINTERNALID</span> <span class="o">?</span>
		    <span class="n">DYNM_INTERNAL</span> <span class="o">:</span> <span class="n">DYNM_EXTERNAL</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dload_segs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">seg_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mem_sect_type</span><span class="p">)</span> <span class="o">!=</span>
			    <span class="n">mem_sect_type</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">rmm_alloc</span><span class="p">(</span><span class="n">rmm</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">word_size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span>
					<span class="n">dsp_address</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Save segid for freeing later */</span>
				<span class="n">rmm_addr_obj</span><span class="o">-&gt;</span><span class="n">segid</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">func_cont:</span>
	<span class="cm">/* Haven&#39;t found memory yet, attempt to find any segment that works */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mem_load_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Preferred segment unavailable, trying &quot;</span>
			<span class="s">&quot;another</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dload_segs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* All bits of mem_sect_type must be set */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">seg_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mem_sect_type</span><span class="p">)</span> <span class="o">!=</span>
			    <span class="n">mem_sect_type</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">rmm_alloc</span><span class="p">(</span><span class="n">rmm</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">word_size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span>
					   <span class="n">dsp_address</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Save segid */</span>
				<span class="n">rmm_addr_obj</span><span class="o">-&gt;</span><span class="n">segid</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remote_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">ref</span><span class="p">,</span> <span class="n">u16</span> <span class="n">space</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_address</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="n">bool</span> <span class="n">reserve</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="p">)</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmm_target_obj</span> <span class="o">*</span><span class="n">rmm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">word_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>	<span class="cm">/* Set to fail */</span>

	<span class="n">rmm</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">rmm</span><span class="p">;</span>

	<span class="cm">/* Convert size to DSP words */</span>
	<span class="n">word_size</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span> <span class="o">-</span>
	     <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rmm_free</span><span class="p">(</span><span class="n">rmm</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">dsp_address</span><span class="p">,</span> <span class="n">word_size</span><span class="p">,</span> <span class="n">reserve</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== unload_lib ========</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unload_lib</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">lib_node</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dbll_attrs</span> <span class="n">new_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>


	<span class="cm">/* Unload dependent libraries */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">unload_lib</span><span class="p">(</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs_tree</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">new_attrs</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_attrs</span><span class="p">;</span>
	<span class="n">new_attrs</span><span class="p">.</span><span class="n">rmm_handle</span> <span class="o">=</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">rmm</span><span class="p">;</span>
	<span class="n">new_attrs</span><span class="p">.</span><span class="n">input_params</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">priv_ref</span><span class="p">;</span>
	<span class="n">new_attrs</span><span class="p">.</span><span class="n">base_image</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">new_attrs</span><span class="p">.</span><span class="n">sym_arg</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Unload the root library */</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">unload_fxn</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_attrs</span><span class="p">);</span>
		<span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ldr_fxns</span><span class="p">.</span><span class="n">close_fxn</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lib</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Free dependent library list */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs_tree</span><span class="p">);</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">dep_libs_tree</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== unload_ovly ========</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unload_ovly</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_node</span> <span class="o">*</span><span class="n">po_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">phase_sects</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ovly_sect</span> <span class="o">*</span><span class="n">other_sects_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">alloc_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">other_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">ref_count</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">other_ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Find the node in the table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_nodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_equal_uuid</span>
		    <span class="p">(</span><span class="o">&amp;</span><span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">uuid</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Found it */</span>
			<span class="n">po_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">nldr_obj</span><span class="o">-&gt;</span><span class="n">ovly_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">po_node</span><span class="p">)</span>
		<span class="cm">/* TODO: Should we print warning here? */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NLDR_CREATE</span>:
		<span class="n">ref_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">po_node</span><span class="o">-&gt;</span><span class="n">create_ref</span><span class="p">);</span>
		<span class="n">phase_sects</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">create_sects_list</span><span class="p">;</span>
		<span class="n">alloc_num</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">create_sects</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NLDR_EXECUTE</span>:
		<span class="n">ref_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">po_node</span><span class="o">-&gt;</span><span class="n">execute_ref</span><span class="p">);</span>
		<span class="n">phase_sects</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">execute_sects_list</span><span class="p">;</span>
		<span class="n">alloc_num</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">execute_sects</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NLDR_DELETE</span>:
		<span class="n">ref_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">po_node</span><span class="o">-&gt;</span><span class="n">delete_ref</span><span class="p">);</span>
		<span class="n">other_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">po_node</span><span class="o">-&gt;</span><span class="n">other_ref</span><span class="p">);</span>
		<span class="n">phase_sects</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">delete_sects_list</span><span class="p">;</span>
		<span class="cm">/* &#39;Other&#39; overlay sections are unloaded in the delete phase */</span>
		<span class="n">other_sects_list</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">other_sects_list</span><span class="p">;</span>
		<span class="n">alloc_num</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">delete_sects</span><span class="p">;</span>
		<span class="n">other_alloc</span> <span class="o">=</span> <span class="n">po_node</span><span class="o">-&gt;</span><span class="n">other_sects</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref_count</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">ref_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ref_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">other_ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">other_ref</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref_count</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">ref_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &#39;Deallocate&#39; memory */</span>
		<span class="n">free_sects</span><span class="p">(</span><span class="n">nldr_obj</span><span class="p">,</span> <span class="n">phase_sects</span><span class="p">,</span> <span class="n">alloc_num</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other_ref</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">other_ref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_sects</span><span class="p">(</span><span class="n">nldr_obj</span><span class="p">,</span> <span class="n">other_sects_list</span><span class="p">,</span> <span class="n">other_alloc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== find_in_persistent_lib_array ========</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">find_in_persistent_lib_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">lib</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_libs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lib</span> <span class="o">==</span> <span class="n">nldr_node_obj</span><span class="o">-&gt;</span><span class="n">pers_lib_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE</span>
<span class="cm">/**</span>
<span class="cm"> * nldr_find_addr() - Find the closest symbol to the given address based on</span>
<span class="cm"> *		dynamic node object.</span>
<span class="cm"> *</span>
<span class="cm"> * @nldr_node:		Dynamic node object</span>
<span class="cm"> * @sym_addr:		Given address to find the dsp symbol</span>
<span class="cm"> * @offset_range:		offset range to look for dsp symbol</span>
<span class="cm"> * @offset_output:		Symbol Output address</span>
<span class="cm"> * @sym_name:		String with the dsp symbol</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function finds the node library for a given address and</span>
<span class="cm"> *	retrieves the dsp symbol by calling dbll_find_dsp_symbol.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nldr_find_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sym_addr</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">offset_range</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">offset_output</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sym_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">status1</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lib_node</span> <span class="n">root</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%x, 0x%x, 0x%x, 0x%x,  %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">nldr_node</span><span class="p">,</span>
			<span class="n">sym_addr</span><span class="p">,</span> <span class="n">offset_range</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">offset_output</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nldr_node</span><span class="o">-&gt;</span><span class="n">dynamic</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">nldr_node</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">nldr_node</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NLDR_CREATE</span>:
			<span class="n">root</span> <span class="o">=</span> <span class="n">nldr_node</span><span class="o">-&gt;</span><span class="n">create_lib</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NLDR_EXECUTE</span>:
			<span class="n">root</span> <span class="o">=</span> <span class="n">nldr_node</span><span class="o">-&gt;</span><span class="n">execute_lib</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NLDR_DELETE</span>:
			<span class="n">root</span> <span class="o">=</span> <span class="n">nldr_node</span><span class="o">-&gt;</span><span class="n">delete_lib</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* for Overlay nodes or non-split Dynamic nodes */</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">nldr_node</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status1</span> <span class="o">=</span> <span class="n">dbll_find_dsp_symbol</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">lib</span><span class="p">,</span> <span class="n">sym_addr</span><span class="p">,</span>
			<span class="n">offset_range</span><span class="p">,</span> <span class="n">offset_output</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">);</span>

	<span class="cm">/* If symbol not found, check dependent libraries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status1</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">.</span><span class="n">dep_libs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status1</span> <span class="o">=</span> <span class="n">dbll_find_dsp_symbol</span><span class="p">(</span>
				<span class="n">root</span><span class="p">.</span><span class="n">dep_libs_tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">,</span> <span class="n">sym_addr</span><span class="p">,</span>
				<span class="n">offset_range</span><span class="p">,</span> <span class="n">offset_output</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status1</span><span class="p">)</span>
				<span class="cm">/* Symbol found */</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="cm">/* Check persistent libraries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status1</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nldr_node</span><span class="o">-&gt;</span><span class="n">pers_libs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status1</span> <span class="o">=</span> <span class="n">dbll_find_dsp_symbol</span><span class="p">(</span>
				<span class="n">nldr_node</span><span class="o">-&gt;</span><span class="n">pers_lib_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lib</span><span class="p">,</span> <span class="n">sym_addr</span><span class="p">,</span>
				<span class="n">offset_range</span><span class="p">,</span> <span class="n">offset_output</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status1</span><span class="p">)</span>
				<span class="cm">/* Symbol found */</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Address 0x%x not found in range %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">sym_addr</span><span class="p">,</span> <span class="n">offset_range</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
