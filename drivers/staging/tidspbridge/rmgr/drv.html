<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › rmgr › drv.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>drv.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drv.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * DSP/BIOS Bridge resource allocation module.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="cm">/*  ----------------------------------- Host OS */</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>

<span class="cm">/*  ----------------------------------- DSP/BIOS Bridge */</span>
<span class="cp">#include &lt;dspbridge/dbdefs.h&gt;</span>

<span class="cm">/*  ----------------------------------- This */</span>
<span class="cp">#include &lt;dspbridge/drv.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dev.h&gt;</span>

<span class="cp">#include &lt;dspbridge/node.h&gt;</span>
<span class="cp">#include &lt;dspbridge/proc.h&gt;</span>
<span class="cp">#include &lt;dspbridge/strm.h&gt;</span>
<span class="cp">#include &lt;dspbridge/nodepriv.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspchnl.h&gt;</span>
<span class="cp">#include &lt;dspbridge/resourcecleanup.h&gt;</span>

<span class="cm">/*  ----------------------------------- Defines, Data Structures, Typedefs */</span>
<span class="k">struct</span> <span class="n">drv_object</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dev_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dev_node_string</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  This is the Device Extension. Named with the Prefix</span>
<span class="cm"> *  DRV_ since it is living in this module</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drv_ext</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">sz_string</span><span class="p">[</span><span class="n">MAXREGPATHLENGTH</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*  ----------------------------------- Globals */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">ext_phys_mem_pool_enabled</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ext_phys_mem_pool</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">phys_mem_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phys_mem_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">virt_mem_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_phys_alloc_ptr</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ext_phys_mem_pool</span> <span class="n">ext_mem_pool</span><span class="p">;</span>

<span class="cm">/*  ----------------------------------- Function Prototypes */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">request_bridge_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>


<span class="cm">/* GPP PROCESS CLEANUP CODE */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">drv_proc_free_node_res</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* Allocate and add a node resource element</span>
<span class="cm">* This function is called from .Node_Allocate. */</span>
<span class="kt">int</span> <span class="nf">drv_insert_node_res_element</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node_resource</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">process_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">**</span><span class="n">node_res_obj</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">**</span><span class="p">)</span><span class="n">node_resource</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="p">)</span><span class="n">process_ctxt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="o">*</span><span class="n">node_res_obj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_res_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">node_res_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">node_res_obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">hnode</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span> <span class="o">*</span><span class="n">node_res_obj</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">node_res_obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: OUT OF MEMORY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span> <span class="o">*</span><span class="n">node_res_obj</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">node_res_obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: FAILED, IDR is FULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">node_res_obj</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Release all Node resources and its context</span>
<span class="cm"> * Actual Node De-Allocation */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">drv_proc_free_node_res</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">*</span><span class="n">node_res_obj</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node_res_obj</span><span class="o">-&gt;</span><span class="n">node_allocated</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_state</span> <span class="o">=</span> <span class="n">node_get_state</span><span class="p">(</span><span class="n">node_res_obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_state</span> <span class="o">&lt;=</span> <span class="n">NODE_DELETING</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">node_state</span> <span class="o">==</span> <span class="n">NODE_RUNNING</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">node_state</span> <span class="o">==</span> <span class="n">NODE_PAUSED</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">node_state</span> <span class="o">==</span> <span class="n">NODE_TERMINATING</span><span class="p">))</span>
				<span class="n">node_terminate</span>
				    <span class="p">(</span><span class="n">node_res_obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>

			<span class="n">node_delete</span><span class="p">(</span><span class="n">node_res_obj</span><span class="p">,</span> <span class="n">ctxt</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Release all Mapped and Reserved DMM resources */</span>
<span class="kt">int</span> <span class="nf">drv_remove_all_dmm_res_elements</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">process_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="p">)</span><span class="n">process_ctxt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">temp_map</span><span class="p">,</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_rsv_object</span> <span class="o">*</span><span class="n">temp_rsv</span><span class="p">,</span> <span class="o">*</span><span class="n">rsv_obj</span><span class="p">;</span>

	<span class="cm">/* Free DMM mapped memory resources */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">temp_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">dmm_map_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_un_map</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dsp_addr</span><span class="p">,</span> <span class="n">ctxt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: proc_un_map failed!&quot;</span>
			       <span class="s">&quot; status = 0x%xn&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Free DMM reserved memory resources */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rsv_obj</span><span class="p">,</span> <span class="n">temp_rsv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">dmm_rsv_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_un_reserve_memory</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
						<span class="n">rsv_obj</span><span class="o">-&gt;</span><span class="n">dsp_reserved_addr</span><span class="p">,</span>
						<span class="n">ctxt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: proc_un_reserve_memory failed!&quot;</span>
			       <span class="s">&quot; status = 0x%xn&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Update Node allocation status */</span>
<span class="kt">void</span> <span class="nf">drv_proc_node_update_status</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">node_resource</span><span class="p">,</span> <span class="n">s32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">*</span><span class="n">node_res_obj</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">*</span><span class="p">)</span><span class="n">node_resource</span><span class="p">;</span>
	<span class="n">node_res_obj</span><span class="o">-&gt;</span><span class="n">node_allocated</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Update Node Heap status */</span>
<span class="kt">void</span> <span class="nf">drv_proc_node_update_heap_status</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">node_resource</span><span class="p">,</span> <span class="n">s32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">*</span><span class="n">node_res_obj</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">*</span><span class="p">)</span><span class="n">node_resource</span><span class="p">;</span>
	<span class="n">node_res_obj</span><span class="o">-&gt;</span><span class="n">heap_allocated</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Release all Node resources and its context</span>
<span class="cm">* This is called from .bridge_release.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_remove_all_node_res_elements</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">process_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="n">process_ctxt</span><span class="p">;</span>

	<span class="n">idr_for_each</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span> <span class="n">drv_proc_free_node_res</span><span class="p">,</span> <span class="n">ctxt</span><span class="p">);</span>
	<span class="n">idr_destroy</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate the STRM resource element</span>
<span class="cm">* This is called after the actual resource is allocated</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_proc_insert_strm_res_element</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">stream_obj</span><span class="p">,</span>
					    <span class="kt">void</span> <span class="o">*</span><span class="n">strm_res</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">process_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">strm_res_object</span> <span class="o">**</span><span class="n">pstrm_res</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">strm_res_object</span> <span class="o">**</span><span class="p">)</span><span class="n">strm_res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="p">)</span><span class="n">process_ctxt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pstrm_res</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_res_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pstrm_res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">pstrm_res</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">=</span> <span class="n">stream_obj</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span> <span class="o">*</span><span class="n">pstrm_res</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">pstrm_res</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: OUT OF MEMORY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span> <span class="o">*</span><span class="n">pstrm_res</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">pstrm_res</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: FAILED, IDR is FULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">drv_proc_free_strm_res</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">process_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="n">process_ctxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">strm_res_object</span> <span class="o">*</span><span class="n">strm_res</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stream_info</span> <span class="n">strm_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_streaminfo</span> <span class="n">user</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">**</span><span class="n">ap_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dw_arg</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ul_buf_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strm_res</span><span class="o">-&gt;</span><span class="n">num_bufs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ap_buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">((</span><span class="n">strm_res</span><span class="o">-&gt;</span><span class="n">num_bufs</span> <span class="o">*</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap_buffer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">strm_free_buffer</span><span class="p">(</span><span class="n">strm_res</span><span class="p">,</span>
						  <span class="n">ap_buffer</span><span class="p">,</span>
						  <span class="n">strm_res</span><span class="o">-&gt;</span><span class="n">num_bufs</span><span class="p">,</span>
						  <span class="n">ctxt</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ap_buffer</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">strm_info</span><span class="p">.</span><span class="n">user_strm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">user</span><span class="p">;</span>
	<span class="n">user</span><span class="p">.</span><span class="n">number_bufs_in_stream</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">strm_get_info</span><span class="p">(</span><span class="n">strm_res</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">strm_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">strm_info</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">number_bufs_in_stream</span><span class="o">--</span><span class="p">)</span>
		<span class="n">strm_reclaim</span><span class="p">(</span><span class="n">strm_res</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_bytes</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ul_buf_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dw_arg</span><span class="p">);</span>
	<span class="n">strm_close</span><span class="p">(</span><span class="n">strm_res</span><span class="p">,</span> <span class="n">ctxt</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Release all Stream resources and its context</span>
<span class="cm">* This is called from .bridge_release.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_remove_all_strm_res_elements</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">process_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="n">process_ctxt</span><span class="p">;</span>

	<span class="n">idr_for_each</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span> <span class="n">drv_proc_free_strm_res</span><span class="p">,</span> <span class="n">ctxt</span><span class="p">);</span>
	<span class="n">idr_destroy</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Updating the stream resource element */</span>
<span class="kt">int</span> <span class="nf">drv_proc_update_strm_res</span><span class="p">(</span><span class="n">u32</span> <span class="n">num_bufs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">strm_resources</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">strm_res_object</span> <span class="o">**</span><span class="n">strm_res</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">strm_res_object</span> <span class="o">**</span><span class="p">)</span><span class="n">strm_resources</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">strm_res</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">num_bufs</span> <span class="o">=</span> <span class="n">num_bufs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* GPP PROCESS CLEANUP CODE END */</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== = drv_create ======== =</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      DRV Object gets created only once during Driver Loading.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">**</span><span class="n">drv_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">pdrv_object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="n">pdrv_object</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdrv_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Create and Initialize List of device objects */</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdrv_object</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdrv_object</span><span class="o">-&gt;</span><span class="n">dev_node_string</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Store the DRV Object in the driver data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv_datap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pdrv_object</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to store DRV object</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">drv_obj</span> <span class="o">=</span> <span class="n">pdrv_object</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Free the DRV Object */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pdrv_object</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== = drv_destroy ======== =</span>
<span class="cm"> *  purpose:</span>
<span class="cm"> *      Invoked during bridge de-initialization</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">driver_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">pdrv_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="p">)</span><span class="n">driver_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pdrv_object</span><span class="p">);</span>
	<span class="cm">/* Update the DRV Object in the driver data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_datap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to store DRV object</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_get_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Given a index, returns a handle to DevObject from the list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_get_dev_object</span><span class="p">(</span><span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">hdrv_obj</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">**</span><span class="n">device_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span><span class="n">drv_get_first_dev_object</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_obj</span> <span class="o">=</span>
		    <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span><span class="n">drv_get_next_dev_object</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">dev_obj</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">device_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_obj</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">device_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_get_first_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the first Device Object handle from an internal linked list of</span>
<span class="cm"> *      of DEV_OBJECTs maintained by DRV.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">drv_get_first_dev_object</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dw_dev_object</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">pdrv_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_datap</span> <span class="o">&amp;&amp;</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdrv_obj</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdrv_obj</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">))</span>
			<span class="n">dw_dev_object</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pdrv_obj</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to retrieve the object handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dw_dev_object</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== DRV_GetFirstDevNodeString ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the first Device Extension from an internal linked list of</span>
<span class="cm"> *      of Pointer to dev_node Strings maintained by DRV.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">drv_get_first_dev_extension</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dw_dev_extension</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">pdrv_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_datap</span> <span class="o">&amp;&amp;</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdrv_obj</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdrv_obj</span><span class="o">-&gt;</span><span class="n">dev_node_string</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dw_dev_extension</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pdrv_obj</span><span class="o">-&gt;</span><span class="n">dev_node_string</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to retrieve the object handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dw_dev_extension</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_get_next_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the next Device Object handle from an internal linked list of</span>
<span class="cm"> *      of DEV_OBJECTs maintained by DRV, after having previously called</span>
<span class="cm"> *      drv_get_first_dev_object() and zero or more DRV_GetNext.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">drv_get_next_dev_object</span><span class="p">(</span><span class="n">u32</span> <span class="n">hdev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dw_next_dev_object</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">pdrv_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_datap</span> <span class="o">&amp;&amp;</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdrv_obj</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdrv_obj</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="n">hdev_obj</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_is_last</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdrv_obj</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dw_next_dev_object</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to retrieve the object handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dw_next_dev_object</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_get_next_dev_extension ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the next Device Extension from an internal linked list of</span>
<span class="cm"> *      of pointer to DevNodeString maintained by DRV, after having previously</span>
<span class="cm"> *      called drv_get_first_dev_extension() and zero or more</span>
<span class="cm"> *      drv_get_next_dev_extension().</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">drv_get_next_dev_extension</span><span class="p">(</span><span class="n">u32</span> <span class="n">dev_extension</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dw_dev_extension</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">pdrv_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_datap</span> <span class="o">&amp;&amp;</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdrv_obj</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdrv_obj</span><span class="o">-&gt;</span><span class="n">dev_node_string</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_extension</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_is_last</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdrv_obj</span><span class="o">-&gt;</span><span class="n">dev_node_string</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dw_dev_extension</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to retrieve the object handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dw_dev_extension</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_insert_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Insert a DevObject into the list of Manager object.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_insert_dev_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">driver_obj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">pdrv_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="p">)</span><span class="n">driver_obj</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">((</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdrv_object</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_remove_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Search for and remove a DeviceObject from the given list of DRV</span>
<span class="cm"> *      objects.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_remove_dev_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">driver_obj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">pdrv_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="p">)</span><span class="n">driver_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">cur_elem</span><span class="p">;</span>

	<span class="cm">/* Search list for p_proc_object: */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">cur_elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdrv_object</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If found, remove it. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span><span class="n">cur_elem</span> <span class="o">==</span> <span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="n">cur_elem</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_request_resources ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Requests  resources from the OS.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_request_resources</span><span class="p">(</span><span class="n">u32</span> <span class="n">dw_context</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dev_node_strg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">pdrv_object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_ext</span> <span class="o">*</span><span class="n">pszdev_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate memory to hold the string. This will live until</span>
<span class="cm">	 *  it is freed in the Release resources. Update the driver object</span>
<span class="cm">	 *  list.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_datap</span> <span class="o">||</span> <span class="o">!</span><span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pdrv_object</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pszdev_node</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">drv_ext</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pszdev_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">strncpy</span><span class="p">(</span><span class="n">pszdev_node</span><span class="o">-&gt;</span><span class="n">sz_string</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dw_context</span><span class="p">,</span> <span class="n">MAXREGPATHLENGTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">pszdev_node</span><span class="o">-&gt;</span><span class="n">sz_string</span><span class="p">[</span><span class="n">MAXREGPATHLENGTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="cm">/* Update the Driver Object List */</span>
			<span class="o">*</span><span class="n">dev_node_strg</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pszdev_node</span><span class="o">-&gt;</span><span class="n">sz_string</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pszdev_node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">pdrv_object</span><span class="o">-&gt;</span><span class="n">dev_node_string</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="o">*</span><span class="n">dev_node_strg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Failed to get Driver Object from Registry&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dev_node_strg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_release_resources ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Releases  resources from the OS.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_release_resources</span><span class="p">(</span><span class="n">u32</span> <span class="n">dw_context</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">hdrv_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_ext</span> <span class="o">*</span><span class="n">pszdev_node</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Irrespective of the status go ahead and clean it</span>
<span class="cm">	 *  The following will over write the status.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pszdev_node</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drv_ext</span> <span class="o">*</span><span class="p">)</span><span class="n">drv_get_first_dev_extension</span><span class="p">();</span>
	     <span class="n">pszdev_node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">pszdev_node</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drv_ext</span> <span class="o">*</span><span class="p">)</span>
	     <span class="n">drv_get_next_dev_extension</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">pszdev_node</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">pszdev_node</span> <span class="o">==</span> <span class="n">dw_context</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Found it */</span>
			<span class="cm">/* Delete from the Driver object list */</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pszdev_node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">pszdev_node</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== request_bridge_resources ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Reserves shared memory for bridge.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">request_bridge_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">host_res</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/* num_mem_windows must not be more than CFG_MAXMEMREGISTERS */</span>
	<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">num_mem_windows</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* First window is for DSP internal memory */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;mem_base[0] 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;mem_base[3] 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;dmmu_base %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">);</span>

	<span class="cm">/* for 24xx base port is not mapping the mamory for DSP</span>
<span class="cm">	 * internal memory TODO Do a ioremap here */</span>
	<span class="cm">/* Second window is for DSP external memory shared with MPU */</span>

	<span class="cm">/* These are hard-coded values */</span>
	<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">birq_registers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">birq_attrib</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">offset_for_monitor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">chnl_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* CHNL_MAXCHANNELS */</span>
	<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">num_chnls</span> <span class="o">=</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">;</span>
	<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">chnl_buf_size</span> <span class="o">=</span> <span class="mh">0x400</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_request_bridge_res_dsp ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Reserves shared memory for bridge.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drv_request_bridge_res_dsp</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">phost_resources</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">host_res</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dw_buff_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">shm_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="n">dw_buff_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg_hostres</span><span class="p">);</span>

	<span class="n">host_res</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">dw_buff_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_res</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">request_bridge_resources</span><span class="p">(</span><span class="n">host_res</span><span class="p">);</span>
		<span class="cm">/* num_mem_windows must not be more than CFG_MAXMEMREGISTERS */</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">num_mem_windows</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">OMAP_DSP_MEM1_BASE</span><span class="p">,</span>
							 <span class="n">OMAP_DSP_MEM1_SIZE</span><span class="p">);</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">OMAP_DSP_MEM2_BASE</span><span class="p">,</span>
							 <span class="n">OMAP_DSP_MEM2_SIZE</span><span class="p">);</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">OMAP_DSP_MEM3_BASE</span><span class="p">,</span>
							 <span class="n">OMAP_DSP_MEM3_SIZE</span><span class="p">);</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">per_base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">OMAP_PER_CM_BASE</span><span class="p">,</span>
						<span class="n">OMAP_PER_CM_SIZE</span><span class="p">);</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">per_pm_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">OMAP_PER_PRM_BASE</span><span class="p">,</span>
							 <span class="n">OMAP_PER_PRM_SIZE</span><span class="p">);</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">core_pm_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">OMAP_CORE_PRM_BASE</span><span class="p">,</span>
							  <span class="n">OMAP_CORE_PRM_SIZE</span><span class="p">);</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">dmmu_base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">OMAP_DMMU_BASE</span><span class="p">,</span>
						 <span class="n">OMAP_DMMU_SIZE</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;mem_base[0] 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;mem_base[1] 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;mem_base[2] 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;mem_base[3] 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;mem_base[4] 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;dmmu_base %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">);</span>

		<span class="n">shm_size</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">shm_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shm_size</span> <span class="o">&gt;=</span> <span class="mh">0x10000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Allocate Physically contiguous,</span>
<span class="cm">			 * non-cacheable  memory */</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">mem_alloc_phys_mem</span><span class="p">(</span><span class="n">shm_size</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">dma_addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;shm reservation Failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_length</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shm_size</span><span class="p">;</span>
				<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_phys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dma_addr</span><span class="p">;</span>

				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Bridge shm address 0x%x &quot;</span>
					<span class="s">&quot;dma_addr %x size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
					<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
					<span class="n">dma_addr</span><span class="p">,</span> <span class="n">shm_size</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* These are hard-coded values */</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">birq_registers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">birq_attrib</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">offset_for_monitor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">chnl_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* CHNL_MAXCHANNELS */</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">num_chnls</span> <span class="o">=</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">;</span>
			<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">chnl_buf_size</span> <span class="o">=</span> <span class="mh">0x400</span><span class="p">;</span>
			<span class="n">dw_buff_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg_hostres</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">phost_resources</span> <span class="o">=</span> <span class="n">host_res</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* End Mem alloc */</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_ext_phys_pool_init</span><span class="p">(</span><span class="n">u32</span> <span class="n">pool_phys_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pool_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pool_virt_base</span><span class="p">;</span>

	<span class="cm">/* get the virtual address for the physical memory pool passed */</span>
	<span class="n">pool_virt_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">pool_phys_base</span><span class="p">,</span> <span class="n">pool_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">pool_virt_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: external physical memory map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ext_phys_mem_pool_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">phys_mem_base</span> <span class="o">=</span> <span class="n">pool_phys_base</span><span class="p">;</span>
		<span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">phys_mem_size</span> <span class="o">=</span> <span class="n">pool_size</span><span class="p">;</span>
		<span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">virt_mem_base</span> <span class="o">=</span> <span class="n">pool_virt_base</span><span class="p">;</span>
		<span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">next_phys_alloc_ptr</span> <span class="o">=</span> <span class="n">pool_phys_base</span><span class="p">;</span>
		<span class="n">ext_phys_mem_pool_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_ext_phys_pool_release</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext_phys_mem_pool_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">virt_mem_base</span><span class="p">));</span>
		<span class="n">ext_phys_mem_pool_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== mem_ext_phys_mem_alloc ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *     Allocate physically contiguous, uncached memory from external memory pool</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">mem_ext_phys_mem_alloc</span><span class="p">(</span><span class="n">u32</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">align</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">phys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">new_alloc_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">virt_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">align</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">align</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">phys_mem_base</span> <span class="o">+</span> <span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">phys_mem_size</span><span class="p">)</span>
		     <span class="o">-</span> <span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">next_phys_alloc_ptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phys_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">next_phys_alloc_ptr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">new_alloc_ptr</span> <span class="o">=</span> <span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">next_phys_alloc_ptr</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">new_alloc_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">next_phys_alloc_ptr</span><span class="p">)</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">new_alloc_ptr</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">&lt;=</span>
		    <span class="p">(</span><span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">phys_mem_base</span> <span class="o">+</span> <span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">phys_mem_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* we can allocate */</span>
			<span class="o">*</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">new_alloc_ptr</span><span class="p">;</span>
			<span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">next_phys_alloc_ptr</span> <span class="o">=</span>
			    <span class="n">new_alloc_ptr</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">virt_addr</span> <span class="o">=</span>
			    <span class="n">ext_mem_pool</span><span class="p">.</span><span class="n">virt_mem_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_alloc_ptr</span> <span class="o">-</span>
							  <span class="n">ext_mem_pool</span><span class="p">.</span>
							  <span class="n">phys_mem_base</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">virt_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== mem_alloc_phys_mem ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Allocate physically contiguous, uncached memory</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">mem_alloc_phys_mem</span><span class="p">(</span><span class="n">u32</span> <span class="n">byte_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">align_mask</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">physical_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va_mem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pa_mem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">byte_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext_phys_mem_pool_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">va_mem</span> <span class="o">=</span> <span class="n">mem_ext_phys_mem_alloc</span><span class="p">(</span><span class="n">byte_size</span><span class="p">,</span> <span class="n">align_mask</span><span class="p">,</span>
							<span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pa_mem</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">va_mem</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">byte_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pa_mem</span><span class="p">,</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">va_mem</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">physical_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">physical_address</span> <span class="o">=</span> <span class="n">pa_mem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">va_mem</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== mem_free_phys_mem ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Free the given block of physically contiguous memory.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mem_free_phys_mem</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">virtual_address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">physical_address</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">byte_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext_phys_mem_pool_enabled</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">byte_size</span><span class="p">,</span> <span class="n">virtual_address</span><span class="p">,</span>
				  <span class="n">physical_address</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
