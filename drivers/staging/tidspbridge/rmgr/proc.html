<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › rmgr › proc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>proc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * proc.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Processor interface at the driver level.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cm">/* ------------------------------------ Host OS */</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>

<span class="cm">/*  ----------------------------------- DSP/BIOS Bridge */</span>
<span class="cp">#include &lt;dspbridge/dbdefs.h&gt;</span>

<span class="cm">/*  ----------------------------------- OS Adaptation Layer */</span>
<span class="cp">#include &lt;dspbridge/ntfy.h&gt;</span>
<span class="cp">#include &lt;dspbridge/sync.h&gt;</span>
<span class="cm">/*  ----------------------------------- Bridge Driver */</span>
<span class="cp">#include &lt;dspbridge/dspdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspdeh.h&gt;</span>
<span class="cm">/*  ----------------------------------- Platform Manager */</span>
<span class="cp">#include &lt;dspbridge/cod.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dev.h&gt;</span>
<span class="cp">#include &lt;dspbridge/procpriv.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dmm.h&gt;</span>

<span class="cm">/*  ----------------------------------- Resource Manager */</span>
<span class="cp">#include &lt;dspbridge/mgr.h&gt;</span>
<span class="cp">#include &lt;dspbridge/node.h&gt;</span>
<span class="cp">#include &lt;dspbridge/nldr.h&gt;</span>
<span class="cp">#include &lt;dspbridge/rmm.h&gt;</span>

<span class="cm">/*  ----------------------------------- Others */</span>
<span class="cp">#include &lt;dspbridge/dbdcd.h&gt;</span>
<span class="cp">#include &lt;dspbridge/msg.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspioctl.h&gt;</span>
<span class="cp">#include &lt;dspbridge/drv.h&gt;</span>

<span class="cm">/*  ----------------------------------- This */</span>
<span class="cp">#include &lt;dspbridge/proc.h&gt;</span>
<span class="cp">#include &lt;dspbridge/pwr.h&gt;</span>

<span class="cp">#include &lt;dspbridge/resourcecleanup.h&gt;</span>
<span class="cm">/*  ----------------------------------- Defines, Data Structures, Typedefs */</span>
<span class="cp">#define MAXCMDLINELEN       255</span>
<span class="cp">#define PROC_ENVPROCID      &quot;PROC_ID=%d&quot;</span>
<span class="cp">#define MAXPROCIDLEN	(8 + 5)</span>
<span class="cp">#define PROC_DFLT_TIMEOUT   10000	</span><span class="cm">/* Time out in milliseconds */</span><span class="cp"></span>
<span class="cp">#define PWR_TIMEOUT	 500	</span><span class="cm">/* Sleep/wake timout in msec */</span><span class="cp"></span>
<span class="cp">#define EXTEND	      &quot;_EXT_END&quot;	</span><span class="cm">/* Extmem end addr in DSP binary */</span><span class="cp"></span>

<span class="cp">#define DSP_CACHE_LINE 128</span>

<span class="cp">#define BUFMODE_MASK	(3 &lt;&lt; 14)</span>

<span class="cm">/* Buffer modes from DSP perspective */</span>
<span class="cp">#define RBUF		0x4000		</span><span class="cm">/* Input buffer */</span><span class="cp"></span>
<span class="cp">#define WBUF		0x8000		</span><span class="cm">/* Output Buffer */</span><span class="cp"></span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span>

<span class="cm">/*  ----------------------------------- Globals */</span>

<span class="cm">/* The proc_object structure. */</span>
<span class="k">struct</span> <span class="n">proc_object</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>	<span class="cm">/* Link to next proc_object */</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">;</span>	<span class="cm">/* Device this PROC represents */</span>
	<span class="n">u32</span> <span class="n">process</span><span class="p">;</span>		<span class="cm">/* Process owning this Processor */</span>
	<span class="k">struct</span> <span class="n">mgr_object</span> <span class="o">*</span><span class="n">mgr_obj</span><span class="p">;</span>	<span class="cm">/* Manager Object Handle */</span>
	<span class="n">u32</span> <span class="n">attach_count</span><span class="p">;</span>	<span class="cm">/* Processor attach count */</span>
	<span class="n">u32</span> <span class="n">processor_id</span><span class="p">;</span>	<span class="cm">/* Processor number */</span>
	<span class="n">u32</span> <span class="n">timeout</span><span class="p">;</span>		<span class="cm">/* Time out count */</span>
	<span class="k">enum</span> <span class="n">dsp_procstate</span> <span class="n">proc_state</span><span class="p">;</span>	<span class="cm">/* Processor state */</span>
	<span class="n">u32</span> <span class="n">unit</span><span class="p">;</span>		<span class="cm">/* DDSP unit number */</span>
	<span class="n">bool</span> <span class="n">is_already_attached</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">					 * True if the Device below has</span>
<span class="cm">					 * GPP Client attached</span>
<span class="cm">					 */</span>
	<span class="k">struct</span> <span class="n">ntfy_object</span> <span class="o">*</span><span class="n">ntfy_obj</span><span class="p">;</span>	<span class="cm">/* Manages  notifications */</span>
	<span class="cm">/* Bridge Context Handle */</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">bridge_context</span><span class="p">;</span>
	<span class="cm">/* Function interface to Bridge driver */</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">last_coff</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">proc_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">proc_lock</span><span class="p">);</span>	<span class="cm">/* For critical sections */</span>

<span class="cm">/*  ----------------------------------- Function Prototypes */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">proc_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">proc_obj</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">get_envp_count</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">**</span><span class="n">prepend_envp</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">new_envp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">,</span> <span class="n">s32</span> <span class="n">envp_elems</span><span class="p">,</span>
			   <span class="n">s32</span> <span class="n">cnew_envp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sz_var</span><span class="p">);</span>

<span class="cm">/* remember mapping information */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="nf">add_mapping_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">mpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">num_usr_pgs</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: adding map info: mpu_addr 0x%x virt 0x%x size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">mpu_addr</span><span class="p">,</span>
						<span class="n">dsp_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">map_obj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_map_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: kzalloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num_usr_pgs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span>
							<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: kzalloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">map_obj</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">mpu_addr</span> <span class="o">=</span> <span class="n">mpu_addr</span><span class="p">;</span>
	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dsp_addr</span> <span class="o">=</span> <span class="n">dsp_addr</span><span class="p">;</span>
	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">num_usr_pgs</span> <span class="o">=</span> <span class="n">num_usr_pgs</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_map_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_map_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_map_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">map_obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_exact_map_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dsp_addr</span> <span class="o">==</span> <span class="n">dsp_addr</span> <span class="o">&amp;&amp;</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: addr match (0x%x), size don&#39;t (0x%x != 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">dsp_addr</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dsp_addr</span> <span class="o">==</span> <span class="n">dsp_addr</span> <span class="o">&amp;&amp;</span>
		<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_mapping_information</span><span class="p">(</span><span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: looking for virt 0x%x size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
							<span class="n">dsp_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_map_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_map_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: candidate: mpu_addr 0x%x virt 0x%x size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">,</span>
							<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">mpu_addr</span><span class="p">,</span>
							<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dsp_addr</span><span class="p">,</span>
							<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">match_exact_map_obj</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">dsp_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: match, deleting map info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">.</span><span class="n">sg</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">map_obj</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: candidate didn&#39;t match</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: failed to find given map info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_map_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_containing_map_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">mpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">map_obj_end</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">mpu_addr</span> <span class="o">+</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mpu_addr</span> <span class="o">&gt;=</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">mpu_addr</span> <span class="o">&amp;&amp;</span>
		<span class="n">mpu_addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">map_obj_end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="nf">find_containing_mapping</span><span class="p">(</span>
				<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">mpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: looking for mpu_addr 0x%x size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
						<span class="n">mpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_map_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_map_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: candidate: mpu_addr 0x%x virt 0x%x size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span>
						<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">mpu_addr</span><span class="p">,</span>
						<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dsp_addr</span><span class="p">,</span>
						<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_containing_map_obj</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">mpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: match!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: no match!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">map_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_map_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">map_obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_first_page_in_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mpu_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mapped_base_page</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">mpu_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">requested_base_page</span> <span class="o">=</span> <span class="n">mpu_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pg_index</span> <span class="o">=</span> <span class="n">requested_base_page</span> <span class="o">-</span> <span class="n">mapped_base_page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pg_index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pg_index</span> <span class="o">&gt;=</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">num_usr_pgs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: failed (got %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">pg_index</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: first page is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">pg_index</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pg_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">get_mapping_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">,</span>
								<span class="kt">int</span> <span class="n">pg_i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: looking for pg_i %d, num_usr_pgs: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
					<span class="n">pg_i</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">num_usr_pgs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pg_i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pg_i</span> <span class="o">&gt;=</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">num_usr_pgs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: requested pg_i %d is out of mapped range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">pg_i</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">pg_i</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_attach ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Prepare for communication with a particular DSP processor, and return</span>
<span class="cm"> *      a handle to the processor object.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">proc_attach</span><span class="p">(</span><span class="n">u32</span> <span class="n">processor_id</span><span class="p">,</span>
	    <span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_processorattrin</span> <span class="o">*</span><span class="n">attr_in</span><span class="p">,</span>
	    <span class="kt">void</span> <span class="o">**</span><span class="n">ph_processor</span><span class="p">,</span> <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mgr_object</span> <span class="o">*</span><span class="n">hmgr_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">hdrv_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">dev_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ph_processor</span> <span class="o">=</span> <span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the Driver and Manager Object Handles */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_datap</span> <span class="o">||</span> <span class="o">!</span><span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span> <span class="o">||</span> <span class="o">!</span><span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">mgr_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to get object handles</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hdrv_obj</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">;</span>
		<span class="n">hmgr_obj</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">mgr_object</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get the Device Object */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">drv_get_dev_object</span><span class="p">(</span><span class="n">processor_id</span><span class="p">,</span> <span class="n">hdrv_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdev_obj</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_dev_type</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* If we made it this far, create the Proceesor object: */</span>
	<span class="n">p_proc_object</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="cm">/* Fill out the Processor Object: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>
	<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">mgr_obj</span> <span class="o">=</span> <span class="n">hmgr_obj</span><span class="p">;</span>
	<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">processor_id</span> <span class="o">=</span> <span class="n">dev_type</span><span class="p">;</span>
	<span class="cm">/* Store TGID instead of process handle */</span>
	<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">process</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">proc_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr_in</span><span class="p">)</span>
		<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">PROC_DFLT_TIMEOUT</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_intf_fxns</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* Create the Notification Object */</span>
	<span class="cm">/* This is created with no event mask, no notify mask</span>
<span class="cm">	 * and no valid handle to the notification. They all get</span>
<span class="cm">	 * filled up when proc_register_notify is called */</span>
	<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ntfy_object</span><span class="p">),</span>
							<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span>
		<span class="n">ntfy_init</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Insert the Processor Object into the DEV List.</span>
<span class="cm">		 * Return handle to this Processor Object:</span>
<span class="cm">		 * Find out if the Device is already attached to a</span>
<span class="cm">		 * Processor. If so, return AlreadyAttached status */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_insert_proc_object</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
						<span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">p_proc_object</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">p_proc_object</span><span class="o">-&gt;</span>
						<span class="n">is_already_attached</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">is_already_attached</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ntfy_delete</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ph_processor</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p_proc_object</span><span class="p">;</span>
			<span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">processor</span> <span class="o">=</span> <span class="o">*</span><span class="n">ph_processor</span><span class="p">;</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">proc_notify_clients</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">,</span>
						  <span class="n">DSP_PROCESSORATTACH</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t leak memory if status is failed */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_exec_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">exec_file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">dev_type</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="n">dev_get_dev_type</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">dev_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exec_file</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_type</span> <span class="o">==</span> <span class="n">DSP_UNIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_datap</span> <span class="o">||</span> <span class="o">!</span><span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">base_img</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">base_img</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">strcpy</span><span class="p">(</span><span class="n">exec_file</span><span class="p">,</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">base_img</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev_type</span> <span class="o">==</span> <span class="n">IVA_UNIT</span> <span class="o">&amp;&amp;</span> <span class="n">iva_img</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">iva_img</span><span class="p">);</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">exec_file</span><span class="p">,</span> <span class="n">iva_img</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_auto_start ======== =</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      A Particular device gets loaded with the default image</span>
<span class="cm"> *      if the AutoStart flag is set.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to the Device</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:   On Successful Loading</span>
<span class="cm"> *      -EPERM  General Failure</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      hdev_obj != NULL</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_auto_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">sz_exec_file</span><span class="p">[</span><span class="n">MAXCMDLINELEN</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">mgr_object</span> <span class="o">*</span><span class="n">hmgr_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">dev_type</span><span class="p">;</span>

	<span class="cm">/* Create a Dummy PROC Object */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_datap</span> <span class="o">||</span> <span class="o">!</span><span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">mgr_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to retrieve the object handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hmgr_obj</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">mgr_object</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p_proc_object</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>
	<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">mgr_obj</span> <span class="o">=</span> <span class="n">hmgr_obj</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_intf_fxns</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

	<span class="cm">/* Stop the Device, put it into standby mode */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_stop</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

	<span class="cm">/* Get the default executable for this board... */</span>
	<span class="n">dev_get_dev_type</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">dev_type</span><span class="p">);</span>
	<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">processor_id</span> <span class="o">=</span> <span class="n">dev_type</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">get_exec_file</span><span class="p">(</span><span class="n">dev_node_obj</span><span class="p">,</span> <span class="n">hdev_obj</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sz_exec_file</span><span class="p">),</span>
			       <span class="n">sz_exec_file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sz_exec_file</span><span class="p">;</span>
		<span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* ...and try to load it: */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_load</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="n">argv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">proc_start</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">last_coff</span><span class="p">);</span>
	<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">last_coff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">func_cont:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">);</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_ctrl ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Pass control information to the GPP device driver managing the</span>
<span class="cm"> *      DSP processor.</span>
<span class="cm"> *</span>
<span class="cm"> *      This will be an OEM-only function, and not part of the DSP/BIOS Bridge</span>
<span class="cm"> *      application developer&#39;s API.</span>
<span class="cm"> *      Call the bridge_dev_ctrl fxn with the Argument. This is a Synchronous</span>
<span class="cm"> *      Operation. arg can be null.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_ctrl</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dw_cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dsp_cbdata</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="n">hprocessor</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* intercept PWR deep sleep command */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dw_cmd</span> <span class="o">==</span> <span class="n">BRDIOCTL_DEEPSLEEP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">cb_data</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">pwr_sleep_dsp</span><span class="p">(</span><span class="n">PWR_DEEPSLEEP</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* intercept PWR emergency sleep command */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dw_cmd</span> <span class="o">==</span> <span class="n">BRDIOCTL_EMERGENCYSLEEP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">cb_data</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">pwr_sleep_dsp</span><span class="p">(</span><span class="n">PWR_EMERGENCYDEEPSLEEP</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dw_cmd</span> <span class="o">==</span> <span class="n">PWR_DEEPSLEEP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* timeout = arg-&gt;cb_data; */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">pwr_sleep_dsp</span><span class="p">(</span><span class="n">PWR_DEEPSLEEP</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* intercept PWR wake commands */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dw_cmd</span> <span class="o">==</span> <span class="n">BRDIOCTL_WAKEUP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">cb_data</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">pwr_wake_dsp</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dw_cmd</span> <span class="o">==</span> <span class="n">PWR_WAKEUP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* timeout = arg-&gt;cb_data; */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">pwr_wake_dsp</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
		    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">dev_cntrl</span><span class="p">)</span>
				      <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">dw_cmd</span><span class="p">,</span>
				       <span class="n">arg</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_detach ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Destroys the  Processor Object. Removes the notification from the Dev</span>
<span class="cm"> *      List.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Notify the Client */</span>
		<span class="n">ntfy_notify</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">DSP_PROCESSORDETACH</span><span class="p">);</span>
		<span class="cm">/* Remove the notification memory */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfy_delete</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">last_coff</span><span class="p">);</span>
		<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">last_coff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* Remove the Proc from the DEV List */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dev_remove_proc_object</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">p_proc_object</span><span class="p">);</span>
		<span class="cm">/* Free the Processor Object */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">);</span>
		<span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">processor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_enum_nodes ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Enumerate and get configuration information about nodes allocated</span>
<span class="cm"> *      on a DSP processor.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_enum_nodes</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">node_tab</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">node_tab_size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pu_num_nodes</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="o">*</span><span class="n">pu_allocated</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev_get_node_manager</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">node_enum_nodes</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="p">,</span> <span class="n">node_tab</span><span class="p">,</span>
							 <span class="n">node_tab_size</span><span class="p">,</span>
							 <span class="n">pu_num_nodes</span><span class="p">,</span>
							 <span class="n">pu_allocated</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Cache operation against kernel address instead of users */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">build_dma_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
						<span class="kt">ssize_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pg_i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">rest</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">.</span><span class="n">sg</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">get_mapping_page</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">pg_i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: no page for %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: err page for %08lx(%lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
			       <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">rest</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">ssize_t</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">sg_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">page</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">-=</span> <span class="n">rest</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">rest</span><span class="p">;</span>
		<span class="n">pg_i</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">.</span><span class="n">num_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: bad number of sg iterations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">memory_regain_ownership</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">len</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_data_page</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_data_page</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="cm">/* calculating the number of pages this area spans */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pages</span> <span class="o">=</span> <span class="n">last_data_page</span> <span class="o">-</span> <span class="n">first_data_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dma_map_info</span> <span class="o">*</span><span class="n">dma_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_info</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_info</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">!=</span> <span class="n">dir</span> <span class="o">||</span> <span class="n">dma_info</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">!=</span> <span class="n">num_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: dma info doesn&#39;t match given params</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">dma_info</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">,</span> <span class="n">dma_info</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: dma_map_sg unmapped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dma_info</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">);</span>

	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">.</span><span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Cache operation against kernel address instead of users */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">memory_give_ownership</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">len</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pg_i</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">sg_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_data_page</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_data_page</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="cm">/* calculating the number of pages this area spans */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pages</span> <span class="o">=</span> <span class="n">last_data_page</span> <span class="o">-</span> <span class="n">first_data_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pg_i</span> <span class="o">=</span> <span class="n">find_first_page_in_cache</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pg_i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: failed to find first page in cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sg</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num_pages</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: kcalloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">);</span>

	<span class="cm">/* cleanup a previous sg allocation */</span>
	<span class="cm">/* this may happen if application doesn&#39;t signal for e/o DMA */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">.</span><span class="n">sg</span><span class="p">);</span>

	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">.</span><span class="n">sg</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dir</span><span class="p">;</span>
	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">.</span><span class="n">num_pages</span> <span class="o">=</span> <span class="n">num_pages</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">build_dma_sg</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pg_i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">kfree_sg</span><span class="p">;</span>

	<span class="n">sg_num</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_num</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: dma_map_sg failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">sg_num</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">kfree_sg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: dma_map_sg mapped %d elements</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">sg_num</span><span class="p">);</span>
	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">.</span><span class="n">sg_num</span> <span class="o">=</span> <span class="n">sg_num</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">kfree_sg:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">dma_info</span><span class="p">.</span><span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">proc_begin_dma</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_size</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Keep STATUS here for future additions to this function */</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="p">)</span> <span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr_ctxt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: addr 0x%x, size 0x%x, type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
							<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">pmpu_addr</span><span class="p">,</span>
							<span class="n">ul_size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_lock</span><span class="p">);</span>

	<span class="cm">/* find requested memory are in cached mapping information */</span>
	<span class="n">map_obj</span> <span class="o">=</span> <span class="n">find_containing_mapping</span><span class="p">(</span><span class="n">pr_ctxt</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">ul_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: find_containing_mapping failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">no_map</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memory_give_ownership</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">ul_size</span><span class="p">,</span> <span class="n">dir</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: InValid address parameters %p %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">ul_size</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">no_map:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_lock</span><span class="p">);</span>
<span class="nl">err_out:</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">proc_end_dma</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_size</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Keep STATUS here for future additions to this function */</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="p">)</span> <span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr_ctxt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: addr 0x%x, size 0x%x, type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
							<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">pmpu_addr</span><span class="p">,</span>
							<span class="n">ul_size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_lock</span><span class="p">);</span>

	<span class="cm">/* find requested memory are in cached mapping information */</span>
	<span class="n">map_obj</span> <span class="o">=</span> <span class="n">find_containing_mapping</span><span class="p">(</span><span class="n">pr_ctxt</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">ul_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: find_containing_mapping failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">no_map</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memory_regain_ownership</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">ul_size</span><span class="p">,</span> <span class="n">dir</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: InValid address parameters %p %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">ul_size</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">no_map:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_lock</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_flush_memory ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *     Flush cache</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_flush_memory</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pmpu_addr</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">ul_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">proc_begin_dma</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">ul_size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_invalidate_memory ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *     Invalidates the memory specified</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_invalidate_memory</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">proc_begin_dma</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_get_resource_info ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Enumerate the resources currently available on a processor.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_get_resource_info</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="n">u32</span> <span class="n">resource_type</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dsp_resourceinfo</span> <span class="o">*</span><span class="n">resource_info</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">resource_info_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmm_target_obj</span> <span class="o">*</span><span class="n">rmm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* IO manager handle */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">resource_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DSP_RESOURCE_DYNDARAM</span>:
	<span class="k">case</span> <span class="n">DSP_RESOURCE_DYNSARAM</span>:
	<span class="k">case</span> <span class="n">DSP_RESOURCE_DYNEXTERNAL</span>:
	<span class="k">case</span> <span class="n">DSP_RESOURCE_DYNSRAM</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_node_manager</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">node_get_nldr_obj</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nldr_obj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">nldr_get_rmm_manager</span><span class="p">(</span><span class="n">nldr_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmm</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmm_stat</span><span class="p">(</span><span class="n">rmm</span><span class="p">,</span>
					      <span class="p">(</span><span class="k">enum</span> <span class="n">dsp_memtype</span><span class="p">)</span><span class="n">resource_type</span><span class="p">,</span>
					      <span class="p">(</span><span class="k">struct</span> <span class="n">dsp_memstat</span> <span class="o">*</span><span class="p">)</span>
					      <span class="o">&amp;</span><span class="p">(</span><span class="n">resource_info</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">.</span>
						<span class="n">mem_stat</span><span class="p">)))</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DSP_RESOURCE_PROCLOAD</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_io_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hio_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hio_mgr</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span>
			    <span class="n">io_get_proc_load</span><span class="p">(</span><span class="n">hio_mgr</span><span class="p">,</span>
						 <span class="p">(</span><span class="k">struct</span> <span class="n">dsp_procloadstat</span> <span class="o">*</span><span class="p">)</span>
						 <span class="o">&amp;</span><span class="p">(</span><span class="n">resource_info</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">.</span>
						   <span class="n">proc_load_stat</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_get_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Return the Dev Object handle for a given Processor.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_get_dev_object</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">**</span><span class="n">device_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">device_obj</span> <span class="o">=</span> <span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">device_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_get_state ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Report the state of the specified DSP processor.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_get_state</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dsp_processorstate</span> <span class="o">*</span><span class="n">proc_state_obj</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">state_info_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">brd_status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* First, retrieve BRD state information */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_status</span><span class="p">)</span>
		    <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">brd_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">brd_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">BRD_STOPPED</span>:
				<span class="n">proc_state_obj</span><span class="o">-&gt;</span><span class="n">proc_state</span> <span class="o">=</span> <span class="n">PROC_STOPPED</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BRD_SLEEP_TRANSITION</span>:
			<span class="k">case</span> <span class="n">BRD_DSP_HIBERNATION</span>:
				<span class="cm">/* Fall through */</span>
			<span class="k">case</span> <span class="n">BRD_RUNNING</span>:
				<span class="n">proc_state_obj</span><span class="o">-&gt;</span><span class="n">proc_state</span> <span class="o">=</span> <span class="n">PROC_RUNNING</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BRD_LOADED</span>:
				<span class="n">proc_state_obj</span><span class="o">-&gt;</span><span class="n">proc_state</span> <span class="o">=</span> <span class="n">PROC_LOADED</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BRD_ERROR</span>:
				<span class="n">proc_state_obj</span><span class="o">-&gt;</span><span class="n">proc_state</span> <span class="o">=</span> <span class="n">PROC_ERROR</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">proc_state_obj</span><span class="o">-&gt;</span><span class="n">proc_state</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s, results: status: 0x%x proc_state_obj: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">proc_state_obj</span><span class="o">-&gt;</span><span class="n">proc_state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_get_trace ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the current contents of the trace buffer, located on the</span>
<span class="cm"> *      Processor.  Predefined symbols for the trace buffer must have been</span>
<span class="cm"> *      configured into the DSP executable.</span>
<span class="cm"> *  Details:</span>
<span class="cm"> *      We support using the symbols SYS_PUTCBEG and SYS_PUTCEND to define a</span>
<span class="cm"> *      trace buffer, only.  Treat it as an undocumented feature.</span>
<span class="cm"> *      This call is destructive, meaning the processor is placed in the monitor</span>
<span class="cm"> *      state as a result of this function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_get_trace</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">pbuf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">max_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_load ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Reset a processor and load a new base program image.</span>
<span class="cm"> *      This will be an OEM-only function, and not part of the DSP/BIOS Bridge</span>
<span class="cm"> *      application developer&#39;s API.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_load</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="k">const</span> <span class="n">s32</span> <span class="n">argc_index</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">user_args</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">user_envp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">;</span>	<span class="cm">/* IO manager handle */</span>
	<span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmsg_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">cod_mgr</span><span class="p">;</span>	<span class="cm">/* Code manager handle */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pargv0</span><span class="p">;</span>		<span class="cm">/* temp argv[0] ptr */</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">new_envp</span><span class="p">;</span>	<span class="cm">/* Updated envp[] array. */</span>
	<span class="kt">char</span> <span class="n">sz_proc_id</span><span class="p">[</span><span class="n">MAXPROCIDLEN</span><span class="p">];</span>	<span class="cm">/* Size of &quot;PROC_ID=&lt;n&gt;&quot; */</span>
	<span class="n">s32</span> <span class="n">envp_elems</span><span class="p">;</span>		<span class="cm">/* Num elements in envp[]. */</span>
	<span class="n">s32</span> <span class="n">cnew_envp</span><span class="p">;</span>		<span class="cm">/* &quot;  &quot; in new_envp[] */</span>
	<span class="n">s32</span> <span class="n">nproc_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Anticipate MP version. */</span>
	<span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dw_ext_end</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">proc_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">brd_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

<span class="cp">#ifdef OPT_LOAD_TIME_INSTRUMENTATION</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv2</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_DVFS) &amp;&amp; !defined(CONFIG_CPU_FREQ)</span>
	<span class="k">struct</span> <span class="n">dspbridge_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span>
	    <span class="n">omap_dspbridge_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef OPT_LOAD_TIME_INSTRUMENTATION</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv1</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_get_cod_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cod_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cod_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_stop</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* Place the board in the monitor state. */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_monitor</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* Save ptr to  original argv[0]. */</span>
	<span class="n">pargv0</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">user_args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/*Prepend &quot;PROC_ID=&lt;nproc_id&gt;&quot;to envp array for target. */</span>
	<span class="n">envp_elems</span> <span class="o">=</span> <span class="n">get_envp_count</span><span class="p">((</span><span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="n">user_envp</span><span class="p">);</span>
	<span class="n">cnew_envp</span> <span class="o">=</span> <span class="p">(</span><span class="n">envp_elems</span> <span class="o">?</span> <span class="p">(</span><span class="n">envp_elems</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">envp_elems</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">new_envp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">cnew_envp</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_envp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">sz_proc_id</span><span class="p">,</span> <span class="n">MAXPROCIDLEN</span><span class="p">,</span> <span class="n">PROC_ENVPROCID</span><span class="p">,</span>
				  <span class="n">nproc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Proc ID string overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">new_envp</span> <span class="o">=</span>
			    <span class="n">prepend_envp</span><span class="p">(</span><span class="n">new_envp</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="n">user_envp</span><span class="p">,</span>
					 <span class="n">envp_elems</span><span class="p">,</span> <span class="n">cnew_envp</span><span class="p">,</span> <span class="n">sz_proc_id</span><span class="p">);</span>
			<span class="cm">/* Get the DCD Handle */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">mgr_get_dcd_handle</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">mgr_obj</span><span class="p">,</span>
						    <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">hdcd_handle</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*  Before proceeding with new load,</span>
<span class="cm">				 *  check if a previously registered COFF</span>
<span class="cm">				 *  exists.</span>
<span class="cm">				 *  If yes, unregister nodes in previously</span>
<span class="cm">				 *  registered COFF.  If any error occurred,</span>
<span class="cm">				 *  set previously registered COFF to NULL. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">last_coff</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span>
					    <span class="n">dcd_auto_unregister</span><span class="p">(</span><span class="n">hdcd_handle</span><span class="p">,</span>
								<span class="n">p_proc_object</span><span class="o">-&gt;</span>
								<span class="n">last_coff</span><span class="p">);</span>
					<span class="cm">/* Regardless of auto unregister status,</span>
<span class="cm">					 *  free previously allocated</span>
<span class="cm">					 *  memory. */</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">last_coff</span><span class="p">);</span>
					<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">last_coff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/* On success, do cod_open_base() */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">cod_open_base</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">user_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					       <span class="n">COD_SYMB</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Auto-register data base */</span>
		<span class="cm">/* Get the DCD Handle */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">mgr_get_dcd_handle</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">mgr_obj</span><span class="p">,</span>
					    <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">hdcd_handle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  Auto register nodes in specified COFF</span>
<span class="cm">			 *  file.  If registration did not fail,</span>
<span class="cm">			 *  (status = 0 or -EACCES)</span>
<span class="cm">			 *  save the name of the COFF file for</span>
<span class="cm">			 *  de-registration in the future. */</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">dcd_auto_register</span><span class="p">(</span><span class="n">hdcd_handle</span><span class="p">,</span>
					      <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">user_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Allocate memory for pszLastCoff */</span>
				<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">last_coff</span> <span class="o">=</span>
						<span class="n">kzalloc</span><span class="p">((</span><span class="n">strlen</span><span class="p">(</span><span class="n">user_args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
						<span class="mi">1</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
				<span class="cm">/* If memory allocated, save COFF file name */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">last_coff</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">strncpy</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">last_coff</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">user_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						<span class="p">(</span><span class="n">strlen</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">user_args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
						 <span class="mi">1</span><span class="p">));</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Update shared memory address and size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  Create the message manager. This must be done</span>
<span class="cm">		 *  before calling the IOOnLoaded function. */</span>
		<span class="n">dev_get_msg_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hmsg_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hmsg_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">msg_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmsg_mgr</span><span class="p">,</span> <span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
					    <span class="p">(</span><span class="n">msg_onexit</span><span class="p">)</span> <span class="n">node_on_exit</span><span class="p">);</span>
			<span class="n">dev_set_msg_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="n">hmsg_mgr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the Device object&#39;s message manager */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_io_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hio_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hio_mgr</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">io_on_loaded</span><span class="p">)</span>
								<span class="p">(</span><span class="n">hio_mgr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Now, attempt to load an exec: */</span>

		<span class="cm">/* Boost the OPP level to Maximum level supported by baseport */</span>
<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_DVFS) &amp;&amp; !defined(CONFIG_CPU_FREQ)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">cpu_set_freq</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">cpu_set_freq</span><span class="p">)</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mpu_speed</span><span class="p">[</span><span class="n">VDD1_OPP5</span><span class="p">]);</span>
<span class="cp">#endif</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cod_load_base</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="n">argc_index</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="n">user_args</span><span class="p">,</span>
				       <span class="n">dev_brd_write_fxn</span><span class="p">,</span>
				       <span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Failure to Load the EXE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Couldn&#39;t parse the file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Requesting the lowest opp supported */</span>
<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_DVFS) &amp;&amp; !defined(CONFIG_CPU_FREQ)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">cpu_set_freq</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">cpu_set_freq</span><span class="p">)</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mpu_speed</span><span class="p">[</span><span class="n">VDD1_OPP1</span><span class="p">]);</span>
<span class="cp">#endif</span>

	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Update the Processor status to loaded */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_set_state</span><span class="p">)</span>
		    <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">BRD_LOADED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">proc_state</span> <span class="o">=</span> <span class="n">PROC_LOADED</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span>
				<span class="n">proc_notify_clients</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">,</span>
						    <span class="n">DSP_PROCESSORSTATECHANGE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_processor_id</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">==</span> <span class="n">DSP_UNIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Use all available DSP address space after EXTMEM</span>
<span class="cm">			 * for DMM */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="n">EXTEND</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">dw_ext_end</span><span class="p">);</span>

			<span class="cm">/* Reset DMM structs and add an initial free chunk */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">dev_get_dmm_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">dmm_mgr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dmm_mgr</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Set dw_ext_end to DMM START u8</span>
<span class="cm">					 * address */</span>
					<span class="n">dw_ext_end</span> <span class="o">=</span>
					    <span class="p">(</span><span class="n">dw_ext_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">DSPWORDSIZE</span><span class="p">;</span>
					<span class="cm">/* DMM memory is from EXT_END */</span>
					<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_create_tables</span><span class="p">(</span><span class="n">dmm_mgr</span><span class="p">,</span>
								   <span class="n">dw_ext_end</span><span class="p">,</span>
								   <span class="n">DMMPOOLSIZE</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Restore the original argv[0] */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new_envp</span><span class="p">);</span>
	<span class="n">user_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pargv0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_status</span><span class="p">)</span>
				<span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">brd_state</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: Processor Loaded %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">pargv0</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">base_img</span><span class="p">);</span>
			<span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">base_img</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">pargv0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">base_img</span><span class="p">)</span>
				<span class="n">strncpy</span><span class="p">(</span><span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">base_img</span><span class="p">,</span> <span class="n">pargv0</span><span class="p">,</span>
							<span class="n">strlen</span><span class="p">(</span><span class="n">pargv0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">func_end:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Processor failed to load</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">proc_stop</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef OPT_LOAD_TIME_INSTRUMENTATION</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tv2</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">&lt;</span> <span class="n">tv1</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tv2</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">+=</span> <span class="mi">1000000</span><span class="p">;</span>
		<span class="n">tv2</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: time to load %d sec and %d usec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">tv2</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">tv1</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">tv2</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">tv1</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_map ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Maps a MPU buffer to DSP address space.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_map</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_size</span><span class="p">,</span>
		    <span class="kt">void</span> <span class="o">*</span><span class="n">req_addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">pp_map_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_map_attr</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">va_align</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa_align</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size_align</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="o">*</span><span class="n">map_obj</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TIDSPBRIDGE_CACHE_LINE_CHECK</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ul_map_attr</span> <span class="o">&amp;</span> <span class="n">BUFMODE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RBUF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">DSP_CACHE_LINE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">ul_size</span><span class="p">,</span> <span class="n">DSP_CACHE_LINE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: not aligned: 0x%x (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
						<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">ul_size</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Calculate the page-aligned PA, VA and size */</span>
	<span class="n">va_align</span> <span class="o">=</span> <span class="n">PG_ALIGN_LOW</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">req_addr</span><span class="p">,</span> <span class="n">PG_SIZE4K</span><span class="p">);</span>
	<span class="n">pa_align</span> <span class="o">=</span> <span class="n">PG_ALIGN_LOW</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">PG_SIZE4K</span><span class="p">);</span>
	<span class="n">size_align</span> <span class="o">=</span> <span class="n">PG_ALIGN_HIGH</span><span class="p">(</span><span class="n">ul_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pmpu_addr</span> <span class="o">-</span> <span class="n">pa_align</span><span class="p">,</span>
				   <span class="n">PG_SIZE4K</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Critical section */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_lock</span><span class="p">);</span>
	<span class="n">dmm_get_handle</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmm_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmm_mgr</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_map_memory</span><span class="p">(</span><span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">va_align</span><span class="p">,</span> <span class="n">size_align</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Add mapping to the page tables. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Mapped address = MSB of VA | LSB of PA */</span>
		<span class="n">tmp_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">va_align</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">pmpu_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PG_SIZE4K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
		<span class="cm">/* mapped memory resource tracking */</span>
		<span class="n">map_obj</span> <span class="o">=</span> <span class="n">add_mapping_info</span><span class="p">(</span><span class="n">pr_ctxt</span><span class="p">,</span> <span class="n">pa_align</span><span class="p">,</span> <span class="n">tmp_addr</span><span class="p">,</span>
						<span class="n">size_align</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map_obj</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_mem_map</span><span class="p">)</span>
			    <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">pa_align</span><span class="p">,</span> <span class="n">va_align</span><span class="p">,</span>
			     <span class="n">size_align</span><span class="p">,</span> <span class="n">ul_map_attr</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Mapped address = MSB of VA | LSB of PA */</span>
		<span class="o">*</span><span class="n">pp_map_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp_addr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">remove_mapping_information</span><span class="p">(</span><span class="n">pr_ctxt</span><span class="p">,</span> <span class="n">tmp_addr</span><span class="p">,</span> <span class="n">size_align</span><span class="p">);</span>
		<span class="n">dmm_un_map_memory</span><span class="p">(</span><span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">va_align</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size_align</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

<span class="nl">func_end:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hprocessor %p, pmpu_addr %p, ul_size %x, &quot;</span>
		<span class="s">&quot;req_addr %p, ul_map_attr %x, pp_map_addr %p, va_align %x, &quot;</span>
		<span class="s">&quot;pa_align %x, size_align %x status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">hprocessor</span><span class="p">,</span> <span class="n">pmpu_addr</span><span class="p">,</span> <span class="n">ul_size</span><span class="p">,</span> <span class="n">req_addr</span><span class="p">,</span> <span class="n">ul_map_attr</span><span class="p">,</span>
		<span class="n">pp_map_addr</span><span class="p">,</span> <span class="n">va_align</span><span class="p">,</span> <span class="n">pa_align</span><span class="p">,</span> <span class="n">size_align</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_register_notify ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Register to be notified of specific processor events.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_register_notify</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_mask</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">notify_type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dsp_notification</span>
				<span class="o">*</span> <span class="n">hnotification</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">deh_mgr</span> <span class="o">*</span><span class="n">hdeh_mgr</span><span class="p">;</span>

	<span class="cm">/* Check processor handle */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check if event mask is a valid processor related event */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">DSP_PROCESSORSTATECHANGE</span> <span class="o">|</span> <span class="n">DSP_PROCESSORATTACH</span> <span class="o">|</span>
			<span class="n">DSP_PROCESSORDETACH</span> <span class="o">|</span> <span class="n">DSP_PROCESSORRESTART</span> <span class="o">|</span>
			<span class="n">DSP_MMUFAULT</span> <span class="o">|</span> <span class="n">DSP_SYSERROR</span> <span class="o">|</span> <span class="n">DSP_PWRERROR</span> <span class="o">|</span>
			<span class="n">DSP_WDTOVERFLOW</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Check if notify type is valid */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">notify_type</span> <span class="o">!=</span> <span class="n">DSP_SIGNALEVENT</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If event mask is not DSP_SYSERROR, DSP_MMUFAULT,</span>
<span class="cm">		 * or DSP_PWRERROR then register event immediately. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_mask</span> <span class="o">&amp;</span>
		    <span class="o">~</span><span class="p">(</span><span class="n">DSP_SYSERROR</span> <span class="o">|</span> <span class="n">DSP_MMUFAULT</span> <span class="o">|</span> <span class="n">DSP_PWRERROR</span> <span class="o">|</span>
				<span class="n">DSP_WDTOVERFLOW</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ntfy_register</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span>
					       <span class="n">hnotification</span><span class="p">,</span> <span class="n">event_mask</span><span class="p">,</span>
					       <span class="n">notify_type</span><span class="p">);</span>
			<span class="cm">/* Special case alert, special case alert!</span>
<span class="cm">			 * If we&#39;re trying to *deregister* (i.e. event_mask</span>
<span class="cm">			 * is 0), a DSP_SYSERROR or DSP_MMUFAULT notification,</span>
<span class="cm">			 * we have to deregister with the DEH manager.</span>
<span class="cm">			 * There&#39;s no way to know, based on event_mask which</span>
<span class="cm">			 * manager the notification event was registered with,</span>
<span class="cm">			 * so if we&#39;re trying to deregister and ntfy_register</span>
<span class="cm">			 * failed, we&#39;ll give the deh manager a shot.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">event_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">dev_get_deh_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">hdeh_mgr</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span>
					<span class="n">bridge_deh_register_notify</span><span class="p">(</span><span class="n">hdeh_mgr</span><span class="p">,</span>
							<span class="n">event_mask</span><span class="p">,</span>
							<span class="n">notify_type</span><span class="p">,</span>
							<span class="n">hnotification</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_deh_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">hdeh_mgr</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">bridge_deh_register_notify</span><span class="p">(</span><span class="n">hdeh_mgr</span><span class="p">,</span>
					    <span class="n">event_mask</span><span class="p">,</span>
					    <span class="n">notify_type</span><span class="p">,</span>
					    <span class="n">hnotification</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_reserve_memory ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Reserve a virtually contiguous region of DSP address space.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_reserve_memory</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_size</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">**</span><span class="n">pp_rsv_addr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_rsv_object</span> <span class="o">*</span><span class="n">rsv_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_get_handle</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmm_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmm_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_reserve_memory</span><span class="p">(</span><span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">ul_size</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pp_rsv_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A successful reserve should be followed by insertion of rsv_obj</span>
<span class="cm">	 * into dmm_rsv_list, so that reserved memory resource tracking</span>
<span class="cm">	 * remains uptodate</span>
<span class="cm">	 */</span>
	<span class="n">rsv_obj</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_rsv_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsv_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rsv_obj</span><span class="o">-&gt;</span><span class="n">dsp_reserved_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span><span class="n">pp_rsv_addr</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_rsv_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_rsv_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_rsv_lock</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">func_end:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hprocessor: 0x%p ul_size: 0x%x pp_rsv_addr: 0x%p &quot;</span>
		<span class="s">&quot;status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hprocessor</span><span class="p">,</span>
		<span class="n">ul_size</span><span class="p">,</span> <span class="n">pp_rsv_addr</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_start ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Start a processor running.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_start</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">cod_mgr</span><span class="p">;</span>	<span class="cm">/* Code manager handle */</span>
	<span class="n">u32</span> <span class="n">dw_dsp_addr</span><span class="p">;</span>	<span class="cm">/* Loaded code&#39;s entry point. */</span>
	<span class="kt">int</span> <span class="n">brd_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Call the bridge_brd_start */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">proc_state</span> <span class="o">!=</span> <span class="n">PROC_LOADED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_cod_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cod_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cod_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_entry</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dw_dsp_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_start</span><span class="p">)</span>
	    <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">dw_dsp_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

	<span class="cm">/* Call dev_create2 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_create2</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">proc_state</span> <span class="o">=</span> <span class="n">PROC_RUNNING</span><span class="p">;</span>
		<span class="cm">/* Deep sleep switces off the peripheral clocks.</span>
<span class="cm">		 * we just put the DSP CPU in idle in the idle loop.</span>
<span class="cm">		 * so there is no need to send a command to DSP */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">proc_notify_clients</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">,</span>
					    <span class="n">DSP_PROCESSORSTATECHANGE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Failed to Create Node Manager and DISP Object</span>
<span class="cm">		 * Stop the Processor from running. Put it in STOPPED State */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span>
		       <span class="n">brd_stop</span><span class="p">)</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">);</span>
		<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">proc_state</span> <span class="o">=</span> <span class="n">PROC_STOPPED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">func_cont:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_status</span><span class="p">)</span>
				<span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">brd_state</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: dsp in running state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to start the dsp</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">proc_stop</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_stop ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Stop a processor running.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmsg_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">hnode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_tab_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nodes_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* check if there are any running nodes */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_node_manager</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">hnode_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">node_enum_nodes</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hnode</span><span class="p">,</span> <span class="n">node_tab_size</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">num_nodes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nodes_allocated</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">nodes_allocated</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Can&#39;t stop device, active nodes = %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">nodes_allocated</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Call the bridge_brd_stop */</span>
	<span class="cm">/* It is OK to stop a device that does n&#39;t have nodes OR not started */</span>
	<span class="n">status</span> <span class="o">=</span>
	    <span class="p">(</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span>
	     <span class="n">brd_stop</span><span class="p">)</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: processor in standby mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">proc_state</span> <span class="o">=</span> <span class="n">PROC_STOPPED</span><span class="p">;</span>
		<span class="cm">/* Destroy the Node Manager, msg_ctrl Manager */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev_destroy2</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Destroy the msg_ctrl by calling msg_delete */</span>
			<span class="n">dev_get_msg_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hmsg_mgr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hmsg_mgr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">msg_delete</span><span class="p">(</span><span class="n">hmsg_mgr</span><span class="p">);</span>
				<span class="n">dev_set_msg_mgr</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to stop the processor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_un_map ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Removes a MPU buffer mapping from the DSP address space.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_un_map</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">map_addr</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">va_align</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size_align</span><span class="p">;</span>

	<span class="n">va_align</span> <span class="o">=</span> <span class="n">PG_ALIGN_LOW</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">map_addr</span><span class="p">,</span> <span class="n">PG_SIZE4K</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_get_handle</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmm_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmm_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Critical section */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update DMM structures. Get the size to unmap.</span>
<span class="cm">	 * This function returns error if the VA is not mapped</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_un_map_memory</span><span class="p">(</span><span class="n">dmm_mgr</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">va_align</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size_align</span><span class="p">);</span>
	<span class="cm">/* Remove mapping from the page tables. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_mem_un_map</span><span class="p">)</span>
		    <span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">va_align</span><span class="p">,</span> <span class="n">size_align</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unmap_failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A successful unmap should be followed by removal of map_obj</span>
<span class="cm">	 * from dmm_map_list, so that mapped memory resource tracking</span>
<span class="cm">	 * remains uptodate</span>
<span class="cm">	 */</span>
	<span class="n">remove_mapping_information</span><span class="p">(</span><span class="n">pr_ctxt</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">map_addr</span><span class="p">,</span> <span class="n">size_align</span><span class="p">);</span>

<span class="nl">unmap_failed:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_lock</span><span class="p">);</span>

<span class="nl">func_end:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hprocessor: 0x%p map_addr: 0x%p status: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">hprocessor</span><span class="p">,</span> <span class="n">map_addr</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_un_reserve_memory ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Frees a previously reserved region of DSP address space.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_un_reserve_memory</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">prsv_addr</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_rsv_object</span> <span class="o">*</span><span class="n">rsv_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_get_handle</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmm_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmm_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_un_reserve_memory</span><span class="p">(</span><span class="n">dmm_mgr</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">prsv_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A successful unreserve should be followed by removal of rsv_obj</span>
<span class="cm">	 * from dmm_rsv_list, so that reserved memory resource tracking</span>
<span class="cm">	 * remains uptodate</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_rsv_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rsv_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_rsv_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsv_obj</span><span class="o">-&gt;</span><span class="n">dsp_reserved_addr</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">prsv_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rsv_obj</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">dmm_rsv_lock</span><span class="p">);</span>

<span class="nl">func_end:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hprocessor: 0x%p prsv_addr: 0x%p status: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">hprocessor</span><span class="p">,</span> <span class="n">prsv_addr</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== = proc_monitor ======== ==</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Place the Processor in Monitor State. This is an internal</span>
<span class="cm"> *      function and a requirement before Processor is loaded.</span>
<span class="cm"> *      This does a bridge_brd_stop, dev_destroy2 and bridge_brd_monitor.</span>
<span class="cm"> *      In dev_destroy2 we delete the node manager.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      p_proc_object:    Pointer to Processor Object</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:	Processor placed in monitor mode.</span>
<span class="cm"> *      !0:       Failed to place processor in monitor mode.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid Processor Handle</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      Success:	ProcObject state is PROC_IDLE</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">proc_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmsg_mgr</span><span class="p">;</span>

	<span class="cm">/* This is needed only when Device is loaded when it is</span>
<span class="cm">	 * already &#39;ACTIVE&#39; */</span>
	<span class="cm">/* Destroy the Node Manager, msg_ctrl Manager */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_destroy2</span><span class="p">(</span><span class="n">proc_obj</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Destroy the msg_ctrl by calling msg_delete */</span>
		<span class="n">dev_get_msg_mgr</span><span class="p">(</span><span class="n">proc_obj</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hmsg_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hmsg_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg_delete</span><span class="p">(</span><span class="n">hmsg_mgr</span><span class="p">);</span>
			<span class="n">dev_set_msg_mgr</span><span class="p">(</span><span class="n">proc_obj</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Place the Board in the Monitor State */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="n">proc_obj</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_monitor</span><span class="p">)</span>
			  <span class="p">(</span><span class="n">proc_obj</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== get_envp_count ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Return the number of elements in the envp array, including the</span>
<span class="cm"> *      terminating NULL element.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">get_envp_count</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">envp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">envp</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ret</span><span class="o">++</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Include the terminating NULL in the count. */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== prepend_envp ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Prepend an environment variable=value pair to the new envp array, and</span>
<span class="cm"> *      copy in the existing var=value pairs in the old envp array.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">**</span><span class="nf">prepend_envp</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">new_envp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">,</span> <span class="n">s32</span> <span class="n">envp_elems</span><span class="p">,</span>
			   <span class="n">s32</span> <span class="n">cnew_envp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sz_var</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">pp_envp</span> <span class="o">=</span> <span class="n">new_envp</span><span class="p">;</span>

	<span class="cm">/* Prepend new environ var=value string */</span>
	<span class="o">*</span><span class="n">new_envp</span><span class="o">++</span> <span class="o">=</span> <span class="n">sz_var</span><span class="p">;</span>

	<span class="cm">/* Copy user&#39;s environment into our own. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">envp_elems</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="n">new_envp</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">envp</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Ensure NULL terminates the new environment strings array. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">envp_elems</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">new_envp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pp_envp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_notify_clients ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Notify the processor the events.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_notify_clients</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">proc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ntfy_notify</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_notify_all_clients ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Notify the processor the events. This includes notifying all clients</span>
<span class="cm"> *      attached to a particulat DSP.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_notify_all_clients</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">proc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_proc_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_notify_clients</span><span class="p">(</span><span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>

<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== proc_get_processor_id ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieves the processor ID.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_get_processor_id</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">proc_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">proc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_proc_object</span><span class="p">)</span>
		<span class="o">*</span><span class="n">proc_id</span> <span class="o">=</span> <span class="n">p_proc_object</span><span class="o">-&gt;</span><span class="n">processor_id</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
