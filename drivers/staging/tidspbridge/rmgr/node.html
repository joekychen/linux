<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › rmgr › node.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>node.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * node.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * DSP/BIOS Bridge Node Manager.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="cm">/*  ----------------------------------- Host OS */</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>

<span class="cm">/*  ----------------------------------- DSP/BIOS Bridge */</span>
<span class="cp">#include &lt;dspbridge/dbdefs.h&gt;</span>

<span class="cm">/*  ----------------------------------- OS Adaptation Layer */</span>
<span class="cp">#include &lt;dspbridge/memdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/proc.h&gt;</span>
<span class="cp">#include &lt;dspbridge/strm.h&gt;</span>
<span class="cp">#include &lt;dspbridge/sync.h&gt;</span>
<span class="cp">#include &lt;dspbridge/ntfy.h&gt;</span>

<span class="cm">/*  ----------------------------------- Platform Manager */</span>
<span class="cp">#include &lt;dspbridge/cmm.h&gt;</span>
<span class="cp">#include &lt;dspbridge/cod.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dev.h&gt;</span>
<span class="cp">#include &lt;dspbridge/msg.h&gt;</span>

<span class="cm">/*  ----------------------------------- Resource Manager */</span>
<span class="cp">#include &lt;dspbridge/dbdcd.h&gt;</span>
<span class="cp">#include &lt;dspbridge/disp.h&gt;</span>
<span class="cp">#include &lt;dspbridge/rms_sh.h&gt;</span>

<span class="cm">/*  ----------------------------------- Link Driver */</span>
<span class="cp">#include &lt;dspbridge/dspdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspioctl.h&gt;</span>

<span class="cm">/*  ----------------------------------- Others */</span>
<span class="cp">#include &lt;dspbridge/uuidutil.h&gt;</span>

<span class="cm">/*  ----------------------------------- This */</span>
<span class="cp">#include &lt;dspbridge/nodepriv.h&gt;</span>
<span class="cp">#include &lt;dspbridge/node.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dmm.h&gt;</span>

<span class="cm">/* Static/Dynamic Loader includes */</span>
<span class="cp">#include &lt;dspbridge/dbll.h&gt;</span>
<span class="cp">#include &lt;dspbridge/nldr.h&gt;</span>

<span class="cp">#include &lt;dspbridge/drv.h&gt;</span>
<span class="cp">#include &lt;dspbridge/resourcecleanup.h&gt;</span>
<span class="cp">#include &lt;_tiomap.h&gt;</span>

<span class="cp">#include &lt;dspbridge/dspdeh.h&gt;</span>

<span class="cp">#define HOSTPREFIX	  &quot;/host&quot;</span>
<span class="cp">#define PIPEPREFIX	  &quot;/dbpipe&quot;</span>

<span class="cp">#define MAX_INPUTS(h)  \</span>
<span class="cp">		((h)-&gt;dcd_props.obj_data.node_obj.ndb_props.num_input_streams)</span>
<span class="cp">#define MAX_OUTPUTS(h) \</span>
<span class="cp">		((h)-&gt;dcd_props.obj_data.node_obj.ndb_props.num_output_streams)</span>

<span class="cp">#define NODE_GET_PRIORITY(h) ((h)-&gt;prio)</span>
<span class="cp">#define NODE_SET_PRIORITY(hnode, prio) ((hnode)-&gt;prio = prio)</span>
<span class="cp">#define NODE_SET_STATE(hnode, state) ((hnode)-&gt;node_state = state)</span>

<span class="cp">#define MAXPIPES	100	</span><span class="cm">/* Max # of /pipe connections (CSL limit) */</span><span class="cp"></span>
<span class="cp">#define MAXDEVSUFFIXLEN 2	</span><span class="cm">/* Max(Log base 10 of MAXPIPES, MAXSTREAMS) */</span><span class="cp"></span>

<span class="cp">#define PIPENAMELEN     (sizeof(PIPEPREFIX) + MAXDEVSUFFIXLEN)</span>
<span class="cp">#define HOSTNAMELEN     (sizeof(HOSTPREFIX) + MAXDEVSUFFIXLEN)</span>

<span class="cp">#define MAXDEVNAMELEN	32	</span><span class="cm">/* dsp_ndbprops.ac_name size */</span><span class="cp"></span>
<span class="cp">#define CREATEPHASE	1</span>
<span class="cp">#define EXECUTEPHASE	2</span>
<span class="cp">#define DELETEPHASE	3</span>

<span class="cm">/* Define default STRM parameters */</span>
<span class="cm">/*</span>
<span class="cm"> *  TBD: Put in header file, make global DSP_STRMATTRS with defaults,</span>
<span class="cm"> *  or make defaults configurable.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULTBUFSIZE		32</span>
<span class="cp">#define DEFAULTNBUFS		2</span>
<span class="cp">#define DEFAULTSEGID		0</span>
<span class="cp">#define DEFAULTALIGNMENT	0</span>
<span class="cp">#define DEFAULTTIMEOUT		10000</span>

<span class="cp">#define RMSQUERYSERVER		0</span>
<span class="cp">#define RMSCONFIGURESERVER	1</span>
<span class="cp">#define RMSCREATENODE		2</span>
<span class="cp">#define RMSEXECUTENODE		3</span>
<span class="cp">#define RMSDELETENODE		4</span>
<span class="cp">#define RMSCHANGENODEPRIORITY	5</span>
<span class="cp">#define RMSREADMEMORY		6</span>
<span class="cp">#define RMSWRITEMEMORY		7</span>
<span class="cp">#define RMSCOPY			8</span>
<span class="cp">#define MAXTIMEOUT		2000</span>

<span class="cp">#define NUMRMSFXNS		9</span>

<span class="cp">#define PWR_TIMEOUT		500	</span><span class="cm">/* default PWR timeout in msec */</span><span class="cp"></span>

<span class="cp">#define STACKSEGLABEL &quot;L1DSRAM_HEAP&quot;	</span><span class="cm">/* Label for DSP Stack Segment Addr */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_mgr ========</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">node_mgr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">;</span>	<span class="cm">/* Device object */</span>
	<span class="cm">/* Function interface to Bridge driver */</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">dcd_mgr</span><span class="p">;</span>	<span class="cm">/* Proc/Node data manager */</span>
	<span class="k">struct</span> <span class="n">disp_object</span> <span class="o">*</span><span class="n">disp_obj</span><span class="p">;</span>	<span class="cm">/* Node dispatcher */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node_list</span><span class="p">;</span>	<span class="cm">/* List of all allocated nodes */</span>
	<span class="n">u32</span> <span class="n">num_nodes</span><span class="p">;</span>		<span class="cm">/* Number of nodes in node_list */</span>
	<span class="n">u32</span> <span class="n">num_created</span><span class="p">;</span>	<span class="cm">/* Number of nodes *created* on DSP */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">pipe_map</span><span class="p">,</span> <span class="n">MAXPIPES</span><span class="p">);</span> <span class="cm">/* Pipe connection bitmap */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">pipe_done_map</span><span class="p">,</span> <span class="n">MAXPIPES</span><span class="p">);</span> <span class="cm">/* Pipes that are half free */</span>
	<span class="cm">/* Channel allocation bitmap */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">chnl_map</span><span class="p">,</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">);</span>
	<span class="cm">/* DMA Channel allocation bitmap */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">dma_chnl_map</span><span class="p">,</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">);</span>
	<span class="cm">/* Zero-Copy Channel alloc bitmap */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">zc_chnl_map</span><span class="p">,</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ntfy_object</span> <span class="o">*</span><span class="n">ntfy_obj</span><span class="p">;</span>	<span class="cm">/* Manages registered notifications */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">node_mgr_lock</span><span class="p">;</span>	<span class="cm">/* For critical sections */</span>
	<span class="n">u32</span> <span class="n">fxn_addrs</span><span class="p">[</span><span class="n">NUMRMSFXNS</span><span class="p">];</span>	<span class="cm">/* RMS function addresses */</span>
	<span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">msg_mgr_obj</span><span class="p">;</span>

	<span class="cm">/* Processor properties needed by Node Dispatcher */</span>
	<span class="n">u32</span> <span class="n">num_chnls</span><span class="p">;</span>		<span class="cm">/* Total number of channels */</span>
	<span class="n">u32</span> <span class="n">chnl_offset</span><span class="p">;</span>	<span class="cm">/* Offset of chnl ids rsvd for RMS */</span>
	<span class="n">u32</span> <span class="n">chnl_buf_size</span><span class="p">;</span>	<span class="cm">/* Buffer size for data to RMS */</span>
	<span class="kt">int</span> <span class="n">proc_family</span><span class="p">;</span>	<span class="cm">/* eg, 5000 */</span>
	<span class="kt">int</span> <span class="n">proc_type</span><span class="p">;</span>		<span class="cm">/* eg, 5510 */</span>
	<span class="n">u32</span> <span class="n">dsp_word_size</span><span class="p">;</span>	<span class="cm">/* Size of DSP word on host bytes */</span>
	<span class="n">u32</span> <span class="n">dsp_data_mau_size</span><span class="p">;</span>	<span class="cm">/* Size of DSP data MAU */</span>
	<span class="n">u32</span> <span class="n">dsp_mau_size</span><span class="p">;</span>	<span class="cm">/* Size of MAU */</span>
	<span class="n">s32</span> <span class="n">min_pri</span><span class="p">;</span>		<span class="cm">/* Minimum runtime priority for node */</span>
	<span class="n">s32</span> <span class="n">max_pri</span><span class="p">;</span>		<span class="cm">/* Maximum runtime priority for node */</span>

	<span class="k">struct</span> <span class="n">strm_mgr</span> <span class="o">*</span><span class="n">strm_mgr_obj</span><span class="p">;</span>	<span class="cm">/* STRM manager */</span>

	<span class="cm">/* Loader properties */</span>
	<span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">*</span><span class="n">nldr_obj</span><span class="p">;</span>	<span class="cm">/* Handle to loader */</span>
	<span class="k">struct</span> <span class="n">node_ldr_fxns</span> <span class="n">nldr_fxns</span><span class="p">;</span>	<span class="cm">/* Handle to loader functions */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== connecttype ========</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">connecttype</span> <span class="p">{</span>
	<span class="n">NOTCONNECTED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">NODECONNECT</span><span class="p">,</span>
	<span class="n">HOSTCONNECT</span><span class="p">,</span>
	<span class="n">DEVICECONNECT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== stream_chnl ========</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">stream_chnl</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">connecttype</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* Type of stream connection */</span>
	<span class="n">u32</span> <span class="n">dev_id</span><span class="p">;</span>		<span class="cm">/* pipe or channel id */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_object ========</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">node_object</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_elem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">node_mgr</span><span class="p">;</span>	<span class="cm">/* The manager of this node */</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">processor</span><span class="p">;</span>	<span class="cm">/* Back pointer to processor */</span>
	<span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="n">node_uuid</span><span class="p">;</span>	<span class="cm">/* Node&#39;s ID */</span>
	<span class="n">s32</span> <span class="n">prio</span><span class="p">;</span>		<span class="cm">/* Node&#39;s current priority */</span>
	<span class="n">u32</span> <span class="n">timeout</span><span class="p">;</span>		<span class="cm">/* Timeout for blocking NODE calls */</span>
	<span class="n">u32</span> <span class="n">heap_size</span><span class="p">;</span>		<span class="cm">/* Heap Size */</span>
	<span class="n">u32</span> <span class="n">dsp_heap_virt_addr</span><span class="p">;</span>	<span class="cm">/* Heap Size */</span>
	<span class="n">u32</span> <span class="n">gpp_heap_virt_addr</span><span class="p">;</span>	<span class="cm">/* Heap Size */</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">ntype</span><span class="p">;</span>	<span class="cm">/* Type of node: message, task, etc */</span>
	<span class="k">enum</span> <span class="n">node_state</span> <span class="n">node_state</span><span class="p">;</span>	<span class="cm">/* NODE_ALLOCATED, NODE_CREATED, ... */</span>
	<span class="n">u32</span> <span class="n">num_inputs</span><span class="p">;</span>		<span class="cm">/* Current number of inputs */</span>
	<span class="n">u32</span> <span class="n">num_outputs</span><span class="p">;</span>	<span class="cm">/* Current number of outputs */</span>
	<span class="n">u32</span> <span class="n">max_input_index</span><span class="p">;</span>	<span class="cm">/* Current max input stream index */</span>
	<span class="n">u32</span> <span class="n">max_output_index</span><span class="p">;</span>	<span class="cm">/* Current max output stream index */</span>
	<span class="k">struct</span> <span class="n">stream_chnl</span> <span class="o">*</span><span class="n">inputs</span><span class="p">;</span>	<span class="cm">/* Node&#39;s input streams */</span>
	<span class="k">struct</span> <span class="n">stream_chnl</span> <span class="o">*</span><span class="n">outputs</span><span class="p">;</span>	<span class="cm">/* Node&#39;s output streams */</span>
	<span class="k">struct</span> <span class="n">node_createargs</span> <span class="n">create_args</span><span class="p">;</span>	<span class="cm">/* Args for node create func */</span>
	<span class="n">nodeenv</span> <span class="n">node_env</span><span class="p">;</span>	<span class="cm">/* Environment returned by RMS */</span>
	<span class="k">struct</span> <span class="n">dcd_genericobj</span> <span class="n">dcd_props</span><span class="p">;</span>	<span class="cm">/* Node properties from DCD */</span>
	<span class="k">struct</span> <span class="n">dsp_cbdata</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>	<span class="cm">/* Optional args to pass to node */</span>
	<span class="k">struct</span> <span class="n">ntfy_object</span> <span class="o">*</span><span class="n">ntfy_obj</span><span class="p">;</span>	<span class="cm">/* Manages registered notifications */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str_dev_name</span><span class="p">;</span>	<span class="cm">/* device name, if device node */</span>
	<span class="k">struct</span> <span class="n">sync_object</span> <span class="o">*</span><span class="n">sync_done</span><span class="p">;</span>	<span class="cm">/* Synchronize node_terminate */</span>
	<span class="n">s32</span> <span class="n">exit_status</span><span class="p">;</span>	<span class="cm">/* execute function return status */</span>

	<span class="cm">/* Information needed for node_get_attr() */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">device_owner</span><span class="p">;</span>	<span class="cm">/* If dev node, task that owns it */</span>
	<span class="n">u32</span> <span class="n">num_gpp_inputs</span><span class="p">;</span>	<span class="cm">/* Current # of from GPP streams */</span>
	<span class="n">u32</span> <span class="n">num_gpp_outputs</span><span class="p">;</span>	<span class="cm">/* Current # of to GPP streams */</span>
	<span class="cm">/* Current stream connections */</span>
	<span class="k">struct</span> <span class="n">dsp_streamconnect</span> <span class="o">*</span><span class="n">stream_connect</span><span class="p">;</span>

	<span class="cm">/* Message queue */</span>
	<span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msg_queue_obj</span><span class="p">;</span>

	<span class="cm">/* These fields used for SM messaging */</span>
	<span class="k">struct</span> <span class="n">cmm_xlatorobject</span> <span class="o">*</span><span class="n">xlator</span><span class="p">;</span>	<span class="cm">/* Node&#39;s SM addr translator */</span>

	<span class="cm">/* Handle to pass to dynamic loader */</span>
	<span class="k">struct</span> <span class="n">nldr_nodeobject</span> <span class="o">*</span><span class="n">nldr_node_obj</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">loaded</span><span class="p">;</span>		<span class="cm">/* Code is (dynamically) loaded */</span>
	<span class="n">bool</span> <span class="n">phase_split</span><span class="p">;</span>	<span class="cm">/* Phases split in many libs or ovly */</span>

<span class="p">};</span>

<span class="cm">/* Default buffer attributes */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dsp_bufferattr</span> <span class="n">node_dfltbufattrs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cb_struct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">segment_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_alignment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">delete_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">delete_node_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fill_stream_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">node1</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">node2</span><span class="p">,</span> <span class="n">u32</span> <span class="n">stream1</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">stream2</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fill_stream_def</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">node_strmdef</span> <span class="o">*</span><span class="n">pstrm_def</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dsp_strmattr</span> <span class="o">*</span><span class="n">pattrs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">free_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stream_chnl</span> <span class="n">stream</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">get_fxn_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">fxn_addr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">phase</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">get_node_props</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_mgr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">node_uuid</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dcd_genericobj</span> <span class="o">*</span><span class="n">dcd_prop</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">get_proc_props</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">get_rms_fxns</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">ovly</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv_ref</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_run_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_load_addr</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_space</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">mem_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv_ref</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_add</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pbuf</span><span class="p">,</span>
		     <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_space</span><span class="p">);</span>

<span class="cm">/* Dynamic loader functions. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">node_ldr_fxns</span> <span class="n">nldr_fxns</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">nldr_allocate</span><span class="p">,</span>
	<span class="n">nldr_create</span><span class="p">,</span>
	<span class="n">nldr_delete</span><span class="p">,</span>
	<span class="n">nldr_get_fxn_addr</span><span class="p">,</span>
	<span class="n">nldr_load</span><span class="p">,</span>
	<span class="n">nldr_unload</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">node_state</span> <span class="nf">node_get_state</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hnode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">node_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_allocate ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Allocate GPP resources to manage a node on the DSP.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">node_uuid</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_cbdata</span> <span class="o">*</span><span class="n">pargs</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_nodeattrin</span> <span class="o">*</span><span class="n">attr_in</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">**</span><span class="n">noderes</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span> <span class="o">=</span> <span class="n">NODE_TASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_msgargs</span> <span class="o">*</span><span class="n">pmsg_args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_taskargs</span> <span class="o">*</span><span class="n">ptask_args</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_streams</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">*</span><span class="n">hcmm_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* Shared memory manager hndl */</span>
	<span class="n">u32</span> <span class="n">proc_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pul_value</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dynext_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">off_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_stack_seg_addr</span><span class="p">,</span> <span class="n">ul_stack_seg_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_gpp_mem_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">host_res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">pbridge_context</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mapped_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">map_attrs</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_processorstate</span> <span class="n">proc_state</span><span class="p">;</span>
<span class="cp">#ifdef DSP_DMM_DEBUG</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hprocessor</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">node_res</span><span class="p">;</span>

	<span class="o">*</span><span class="n">noderes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_processor_id</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">!=</span> <span class="n">DSP_UNIT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_dev_object</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdev_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_node_manager</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbridge_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pbridge_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_state</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_state</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_processorstate</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="cm">/* If processor is in error state then don&#39;t attempt</span>
<span class="cm">	   to send the message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_state</span><span class="p">.</span><span class="n">proc_state</span> <span class="o">==</span> <span class="n">PROC_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Assuming that 0 is not a valid function address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">fxn_addrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No RMS on target - we currently can&#39;t handle this */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed, no RMS in base image</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Validate attr_in fields, if non-NULL */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr_in</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Check if attr_in-&gt;prio is within range */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">min_pri</span> <span class="o">||</span>
			    <span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&gt;</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">max_pri</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Allocate node object and fill in */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">pnode</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="cm">/* This critical section protects get_node_props */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

	<span class="cm">/* Get dsp_ndbprops from node database */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">get_node_props</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">,</span> <span class="n">pnode</span><span class="p">,</span> <span class="n">node_uuid</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">node_uuid</span> <span class="o">=</span> <span class="o">*</span><span class="n">node_uuid</span><span class="p">;</span>
	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span> <span class="o">=</span> <span class="n">hprocessor</span><span class="p">;</span>
	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">ntype</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">ndb_props</span><span class="p">.</span><span class="n">ntype</span><span class="p">;</span>
	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">ndb_props</span><span class="p">.</span><span class="n">timeout</span><span class="p">;</span>
	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">ndb_props</span><span class="p">.</span><span class="n">prio</span><span class="p">;</span>

	<span class="cm">/* Currently only C64 DSP builds support Node Dynamic * heaps */</span>
	<span class="cm">/* Allocate memory for node heap */</span>
	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">heap_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">dsp_heap_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">dsp_heap_res_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">gpp_heap_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr_in</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

	<span class="cm">/* Check if we have a user allocated node heap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">pgpp_virt_addr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

	<span class="cm">/* check for page aligned Heap size */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">heap_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PG_SIZE4K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: node heap size not aligned to 4K, size = 0x%x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">heap_size</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">heap_size</span> <span class="o">=</span>
		    <span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">heap_size</span><span class="p">;</span>
		<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">gpp_heap_addr</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">pgpp_virt_addr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_reserve_memory</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span>
				     <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span>
				     <span class="n">heap_size</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span>
					<span class="n">task_arg_obj</span><span class="p">.</span><span class="n">dsp_heap_res_addr</span><span class="p">),</span>
				     <span class="n">pr_ctxt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to reserve memory for heap: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef DSP_DMM_DEBUG</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_get_handle</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmm_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmm_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">DSP_EHANDLE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dmm_mem_map_dump</span><span class="p">(</span><span class="n">dmm_mgr</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">map_attrs</span> <span class="o">|=</span> <span class="n">DSP_MAPLITTLEENDIAN</span><span class="p">;</span>
	<span class="n">map_attrs</span> <span class="o">|=</span> <span class="n">DSP_MAPELEMSIZE32</span><span class="p">;</span>
	<span class="n">map_attrs</span> <span class="o">|=</span> <span class="n">DSP_MAPVIRTUALADDR</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_map</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">pgpp_virt_addr</span><span class="p">,</span>
			  <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">heap_size</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span>
			  <span class="n">dsp_heap_res_addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mapped_addr</span><span class="p">,</span> <span class="n">map_attrs</span><span class="p">,</span>
			  <span class="n">pr_ctxt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to map memory for Heap: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">dsp_heap_addr</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">mapped_addr</span><span class="p">;</span>

<span class="nl">func_cont:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_in</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Overrides of NBD properties */</span>
		<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
		<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">attr_in</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Create object to manage notifications */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ntfy_object</span><span class="p">),</span>
							<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span>
			<span class="n">ntfy_init</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
		<span class="cm">/*  Allocate dsp_streamconnect array for device, task, and</span>
<span class="cm">		 *  dais socket nodes. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_MESSAGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num_streams</span> <span class="o">=</span> <span class="n">MAX_INPUTS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">+</span> <span class="n">MAX_OUTPUTS</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
			<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">stream_connect</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">num_streams</span> <span class="o">*</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_streamconnect</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_streams</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">stream_connect</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">==</span> <span class="n">NODE_TASK</span> <span class="o">||</span>
					      <span class="n">node_type</span> <span class="o">==</span> <span class="n">NODE_DAISSOCKET</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Allocate arrays for maintainig stream connections */</span>
			<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">MAX_INPUTS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">*</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stream_chnl</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">MAX_OUTPUTS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">*</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stream_chnl</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="n">ptask_args</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">);</span>
			<span class="n">ptask_args</span><span class="o">-&gt;</span><span class="n">strm_in_def</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">MAX_INPUTS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">*</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_strmdef</span><span class="p">),</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="n">ptask_args</span><span class="o">-&gt;</span><span class="n">strm_out_def</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">MAX_OUTPUTS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">*</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_strmdef</span><span class="p">),</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">MAX_INPUTS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">inputs</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
						       <span class="n">ptask_args</span><span class="o">-&gt;</span><span class="n">strm_in_def</span>
						       <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">MAX_OUTPUTS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">outputs</span> <span class="o">==</span> <span class="nb">NULL</span>
				    <span class="o">||</span> <span class="n">ptask_args</span><span class="o">-&gt;</span><span class="n">strm_out_def</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)))</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Create an event that will be posted when RMS_EXIT is</span>
<span class="cm">		 * received. */</span>
		<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">sync_done</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sync_object</span><span class="p">),</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">sync_done</span><span class="p">)</span>
			<span class="n">sync_init_event</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">sync_done</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*Get the shared mem mgr for this nodes dev object */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">cmm_get_handle</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcmm_mgr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Allocate a SM addr translator for this node</span>
<span class="cm">				 * w/ deflt attr */</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">cmm_xlator_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">xlator</span><span class="p">,</span>
							   <span class="n">hcmm_mgr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Fill in message args */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">pargs</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pargs</span><span class="o">-&gt;</span><span class="n">cb_data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pmsg_args</span> <span class="o">=</span>
				    <span class="o">&amp;</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">node_msg_args</span><span class="p">);</span>
				<span class="n">pmsg_args</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">pargs</span><span class="o">-&gt;</span><span class="n">cb_data</span><span class="p">,</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pmsg_args</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">pmsg_args</span><span class="o">-&gt;</span><span class="n">arg_length</span> <span class="o">=</span> <span class="n">pargs</span><span class="o">-&gt;</span><span class="n">cb_data</span><span class="p">;</span>
					<span class="n">memcpy</span><span class="p">(</span><span class="n">pmsg_args</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">,</span>
					       <span class="n">pargs</span><span class="o">-&gt;</span><span class="n">node_data</span><span class="p">,</span>
					       <span class="n">pargs</span><span class="o">-&gt;</span><span class="n">cb_data</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Create a message queue for this node */</span>
		<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">msg_create_queue</span><span class="p">)</span> <span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">msg_mgr_obj</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">msg_queue_obj</span><span class="p">,</span>
							<span class="mi">0</span><span class="p">,</span>
							<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span>
							<span class="n">node_msg_args</span><span class="p">.</span><span class="n">max_msgs</span><span class="p">,</span>
							<span class="n">pnode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Create object for dynamic loading */</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">,</span>
							   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pnode</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span>
							   <span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span>
							   <span class="n">nldr_node_obj</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Compare value read from Node Properties and check if it is same as</span>
<span class="cm">	 * STACKSEGLABEL, if yes read the Address of STACKSEGLABEL, calculate</span>
<span class="cm">	 * GPP Address, Read the value in that address and override the</span>
<span class="cm">	 * stack_seg value in task args */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">ndb_props</span><span class="p">.</span>
	    <span class="n">stack_seg_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span>
			   <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">ndb_props</span><span class="p">.</span>
			   <span class="n">stack_seg_name</span><span class="p">,</span> <span class="n">STACKSEGLABEL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span>
			    <span class="n">get_fxn_addr</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="s">&quot;DYNEXT_BEG&quot;</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">dynext_base</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to get addr for DYNEXT_BEG&quot;</span>
				       <span class="s">&quot; status = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span>
			    <span class="n">get_fxn_addr</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span>
					     <span class="s">&quot;L1DSRAM_HEAP&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pul_value</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to get addr for L1DSRAM_HEAP&quot;</span>
				       <span class="s">&quot; status = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

			<span class="n">host_res</span> <span class="o">=</span> <span class="n">pbridge_context</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_res</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to get host resource, status&quot;</span>
				       <span class="s">&quot; = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ul_gpp_mem_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">off_set</span> <span class="o">=</span> <span class="n">pul_value</span> <span class="o">-</span> <span class="n">dynext_base</span><span class="p">;</span>
			<span class="n">ul_stack_seg_addr</span> <span class="o">=</span> <span class="n">ul_gpp_mem_base</span> <span class="o">+</span> <span class="n">off_set</span><span class="p">;</span>
			<span class="n">ul_stack_seg_val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ul_stack_seg_addr</span><span class="p">);</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: StackSegVal = 0x%x, StackSegAddr =&quot;</span>
				<span class="s">&quot; 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ul_stack_seg_val</span><span class="p">,</span>
				<span class="n">ul_stack_seg_addr</span><span class="p">);</span>

			<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">stack_seg</span> <span class="o">=</span>
			    <span class="n">ul_stack_seg_val</span><span class="p">;</span>

		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Add the node to the node manager&#39;s list of allocated</span>
<span class="cm">		 * nodes. */</span>
		<span class="n">NODE_SET_STATE</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">NODE_ALLOCATED</span><span class="p">);</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">list_elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">);</span>
		<span class="o">++</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_nodes</span><span class="p">);</span>

		<span class="cm">/* Exit critical section */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

		<span class="cm">/* Preset this to assume phases are split</span>
<span class="cm">		 * (for overlay and dll) */</span>
		<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">phase_split</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="cm">/* Notify all clients registered for DSP_NODESTATECHANGE. */</span>
		<span class="n">proc_notify_all_clients</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Cleanup */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span><span class="p">)</span>
			<span class="n">delete_node</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">pr_ctxt</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">drv_insert_node_res_element</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_res</span><span class="p">,</span> <span class="n">pr_ctxt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">delete_node</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">pr_ctxt</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">noderes</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">*</span><span class="p">)</span><span class="n">node_res</span><span class="p">;</span>
		<span class="n">drv_proc_node_update_heap_status</span><span class="p">(</span><span class="n">node_res</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">drv_proc_node_update_status</span><span class="p">(</span><span class="n">node_res</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hprocessor: %p pNodeId: %p pargs: %p attr_in: %p &quot;</span>
		<span class="s">&quot;node_res: %p status: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hprocessor</span><span class="p">,</span>
		<span class="n">node_uuid</span><span class="p">,</span> <span class="n">pargs</span><span class="p">,</span> <span class="n">attr_in</span><span class="p">,</span> <span class="n">noderes</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_alloc_msg_buf ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Allocates buffer for zero copy messaging.</span>
<span class="cm"> */</span>
<span class="n">DBAPI</span> <span class="nf">node_alloc_msg_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">u32</span> <span class="n">usize</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dsp_bufferattr</span> <span class="o">*</span><span class="n">pattr</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="o">**</span><span class="n">pbuffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">va_flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">set_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">proc_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnode</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node_get_type</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">==</span> <span class="n">NODE_DEVICE</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pattr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">pattr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_dfltbufattrs</span><span class="p">;</span>	<span class="cm">/* set defaults */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_processor_id</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">!=</span> <span class="n">DSP_UNIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*  If segment ID includes MEM_SETVIRTUALSEGID then pbuffer is a</span>
<span class="cm">	 *  virt  address, so set this info in this node&#39;s translator</span>
<span class="cm">	 *  object for  future ref. If MEM_GETVIRTUALSEGID then retrieve</span>
<span class="cm">	 *  virtual address  from node&#39;s translator. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pattr</span><span class="o">-&gt;</span><span class="n">segment_id</span> <span class="o">&amp;</span> <span class="n">MEM_SETVIRTUALSEGID</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">pattr</span><span class="o">-&gt;</span><span class="n">segment_id</span> <span class="o">&amp;</span> <span class="n">MEM_GETVIRTUALSEGID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">va_flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">set_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">pattr</span><span class="o">-&gt;</span><span class="n">segment_id</span> <span class="o">&amp;</span> <span class="n">MEM_SETVIRTUALSEGID</span><span class="p">)</span> <span class="o">?</span>
		    <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
		<span class="cm">/* Clear mask bits */</span>
		<span class="n">pattr</span><span class="o">-&gt;</span><span class="n">segment_id</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MEM_MASKVIRTUALSEGID</span><span class="p">;</span>
		<span class="cm">/* Set/get this node&#39;s translators virtual address base/size */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cmm_xlator_info</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">xlator</span><span class="p">,</span> <span class="n">pbuffer</span><span class="p">,</span> <span class="n">usize</span><span class="p">,</span>
					 <span class="n">pattr</span><span class="o">-&gt;</span><span class="n">segment_id</span><span class="p">,</span> <span class="n">set_info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">va_flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pattr</span><span class="o">-&gt;</span><span class="n">segment_id</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Node supports single SM segment only. */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*  Arbitrary SM buffer alignment not supported for host side</span>
<span class="cm">		 *  allocs, but guaranteed for the following alignment</span>
<span class="cm">		 *  values. */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">pattr</span><span class="o">-&gt;</span><span class="n">buf_alignment</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* alignment value not suportted */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* allocate physical buffer from seg_id in node&#39;s</span>
<span class="cm">			 * translator */</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">cmm_xlator_alloc_buf</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">xlator</span><span class="p">,</span> <span class="n">pbuffer</span><span class="p">,</span>
						   <span class="n">usize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pbuffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: error - Out of shared memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_change_priority ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Change the priority of a node in the allocated state, or that is</span>
<span class="cm"> *      currently running or paused on the target.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_change_priority</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">s32</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">proc_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span> <span class="o">||</span> <span class="o">!</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
		<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_TASK</span> <span class="o">&amp;&amp;</span> <span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">min_pri</span> <span class="o">||</span> <span class="n">prio</span> <span class="o">&gt;</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">max_pri</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* Enter critical section */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">node_get_state</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">NODE_ALLOCATED</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">NODE_PAUSED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NODE_SET_PRIORITY</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">NODE_RUNNING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_processor_id</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">==</span> <span class="n">DSP_UNIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">disp_node_change_priority</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">disp_obj</span><span class="p">,</span>
						      <span class="n">hnode</span><span class="p">,</span>
						      <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">fxn_addrs</span>
						      <span class="p">[</span><span class="n">RMSCHANGENODEPRIORITY</span><span class="p">],</span>
						      <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">NODE_SET_PRIORITY</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>

	<span class="p">}</span>
<span class="nl">func_cont:</span>
	<span class="cm">/* Leave critical section */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_connect ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Connect two nodes on the DSP, or a node on the DSP to the GPP.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">node1</span><span class="p">,</span> <span class="n">u32</span> <span class="n">stream1</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">node2</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">stream2</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dsp_strmattr</span> <span class="o">*</span><span class="n">pattrs</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dsp_cbdata</span> <span class="o">*</span><span class="n">conn_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pstr_dev_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node1_type</span> <span class="o">=</span> <span class="n">NODE_TASK</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node2_type</span> <span class="o">=</span> <span class="n">NODE_TASK</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dsp_strmmode</span> <span class="n">strm_mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_strmdef</span> <span class="o">*</span><span class="n">pstrm_def</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_strmdef</span> <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_strmdef</span> <span class="o">*</span><span class="n">output</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stream_chnl</span> <span class="o">*</span><span class="n">pstream</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pipe_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chnl_id</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">chnl_mode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dw_length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node1</span> <span class="o">||</span> <span class="o">!</span><span class="n">node2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* The two nodes must be on the same processor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node1</span> <span class="o">!=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">DSP_HGPPNODE</span> <span class="o">&amp;&amp;</span>
			<span class="n">node2</span> <span class="o">!=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">DSP_HGPPNODE</span> <span class="o">&amp;&amp;</span>
			<span class="n">node1</span><span class="o">-&gt;</span><span class="n">node_mgr</span> <span class="o">!=</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* Cannot connect a node to itself */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node1</span> <span class="o">==</span> <span class="n">node2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* node_get_type() will return NODE_GPP if hnode =  DSP_HGPPNODE. */</span>
	<span class="n">node1_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">node1</span><span class="p">);</span>
	<span class="n">node2_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">node2</span><span class="p">);</span>
	<span class="cm">/* Check stream indices ranges */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_GPP</span> <span class="o">&amp;&amp;</span> <span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span> <span class="o">&amp;&amp;</span>
				<span class="n">stream1</span> <span class="o">&gt;=</span> <span class="n">MAX_OUTPUTS</span><span class="p">(</span><span class="n">node1</span><span class="p">))</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">node2_type</span> <span class="o">!=</span> <span class="n">NODE_GPP</span> <span class="o">&amp;&amp;</span> <span class="n">node2_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span> <span class="o">&amp;&amp;</span>
			 <span class="n">stream2</span> <span class="o">&gt;=</span> <span class="n">MAX_INPUTS</span><span class="p">(</span><span class="n">node2</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Only the following types of connections are allowed:</span>
<span class="cm">	 *      task/dais socket &lt; == &gt; task/dais socket</span>
<span class="cm">	 *      task/dais socket &lt; == &gt; device</span>
<span class="cm">	 *      task/dais socket &lt; == &gt; GPP</span>
<span class="cm">	 *</span>
<span class="cm">	 *  ie, no message nodes, and at least one task or dais</span>
<span class="cm">	 *  socket node.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">==</span> <span class="n">NODE_MESSAGE</span> <span class="o">||</span> <span class="n">node2_type</span> <span class="o">==</span> <span class="n">NODE_MESSAGE</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_TASK</span> <span class="o">&amp;&amp;</span>
			 <span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_DAISSOCKET</span> <span class="o">&amp;&amp;</span>
			 <span class="n">node2_type</span> <span class="o">!=</span> <span class="n">NODE_TASK</span> <span class="o">&amp;&amp;</span>
			 <span class="n">node2_type</span> <span class="o">!=</span> <span class="n">NODE_DAISSOCKET</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check stream mode. Default is STRMMODE_PROCCOPY.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pattrs</span> <span class="o">&amp;&amp;</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">strm_mode</span> <span class="o">!=</span> <span class="n">STRMMODE_PROCCOPY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>	<span class="cm">/* illegal stream mode */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_GPP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">node1</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enter critical section */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

	<span class="cm">/* Nodes must be in the allocated state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_GPP</span> <span class="o">&amp;&amp;</span>
			<span class="n">node_get_state</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NODE_ALLOCATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node2_type</span> <span class="o">!=</span> <span class="n">NODE_GPP</span> <span class="o">&amp;&amp;</span>
			<span class="n">node_get_state</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NODE_ALLOCATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check that stream indices for task and dais socket nodes</span>
<span class="cm">	 *  are not already be used. (Device nodes checked later)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">==</span> <span class="n">NODE_TASK</span> <span class="o">||</span> <span class="n">node1_type</span> <span class="o">==</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">output</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span>
				<span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_out_def</span><span class="p">[</span><span class="n">stream1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node2_type</span> <span class="o">==</span> <span class="n">NODE_TASK</span> <span class="o">||</span> <span class="n">node2_type</span> <span class="o">==</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">input</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span>
				<span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_in_def</span><span class="p">[</span><span class="n">stream2</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="cm">/* Connecting two task nodes? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">node1_type</span> <span class="o">==</span> <span class="n">NODE_TASK</span> <span class="o">||</span> <span class="n">node1_type</span> <span class="o">==</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">node2_type</span> <span class="o">==</span> <span class="n">NODE_TASK</span> <span class="o">||</span>
				 <span class="n">node2_type</span> <span class="o">==</span> <span class="n">NODE_DAISSOCKET</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Find available pipe */</span>
		<span class="n">pipe_id</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">pipe_map</span><span class="p">,</span> <span class="n">MAXPIPES</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pipe_id</span> <span class="o">==</span> <span class="n">MAXPIPES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">pipe_id</span><span class="p">,</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">pipe_map</span><span class="p">);</span>
		<span class="n">node1</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">[</span><span class="n">stream1</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">NODECONNECT</span><span class="p">;</span>
		<span class="n">node2</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">[</span><span class="n">stream2</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">NODECONNECT</span><span class="p">;</span>
		<span class="n">node1</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">[</span><span class="n">stream1</span><span class="p">].</span><span class="n">dev_id</span> <span class="o">=</span> <span class="n">pipe_id</span><span class="p">;</span>
		<span class="n">node2</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">[</span><span class="n">stream2</span><span class="p">].</span><span class="n">dev_id</span> <span class="o">=</span> <span class="n">pipe_id</span><span class="p">;</span>
		<span class="n">output</span><span class="o">-&gt;</span><span class="n">sz_device</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">PIPENAMELEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">input</span><span class="o">-&gt;</span><span class="n">sz_device</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">PIPENAMELEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">sz_device</span> <span class="o">||</span> <span class="o">!</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Undo the connection */</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">pipe_id</span><span class="p">,</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">pipe_map</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Copy &quot;/dbpipe&lt;pipId&gt;&quot; name to device names */</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">,</span> <span class="s">&quot;%s%d&quot;</span><span class="p">,</span> <span class="n">PIPEPREFIX</span><span class="p">,</span> <span class="n">pipe_id</span><span class="p">);</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">,</span> <span class="n">output</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Connecting task node to host? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">==</span> <span class="n">NODE_GPP</span> <span class="o">||</span> <span class="n">node2_type</span> <span class="o">==</span> <span class="n">NODE_GPP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pstr_dev_name</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">HOSTNAMELEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pstr_dev_name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">chnl_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">==</span> <span class="n">NODE_GPP</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">CHNL_MODETODSP</span> <span class="o">:</span> <span class="n">CHNL_MODEFROMDSP</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Reserve a channel id. We need to put the name &quot;/host&lt;id&gt;&quot;</span>
<span class="cm">		 *  in the node&#39;s create_args, but the host</span>
<span class="cm">		 *  side channel will not be opened until DSPStream_Open is</span>
<span class="cm">		 *  called for this node.</span>
<span class="cm">		 */</span>
		<span class="n">strm_mode</span> <span class="o">=</span> <span class="n">pattrs</span> <span class="o">?</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">strm_mode</span> <span class="o">:</span> <span class="n">STRMMODE_PROCCOPY</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">strm_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">STRMMODE_RDMA</span>:
			<span class="n">chnl_id</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dma_chnl_map</span><span class="p">,</span>
					<span class="n">CHNL_MAXCHANNELS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chnl_id</span> <span class="o">&lt;</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">chnl_id</span><span class="p">,</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dma_chnl_map</span><span class="p">);</span>
				<span class="cm">/* dma chans are 2nd transport chnl set</span>
<span class="cm">				 * ids(e.g. 16-31) */</span>
				<span class="n">chnl_id</span> <span class="o">=</span> <span class="n">chnl_id</span> <span class="o">+</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_chnls</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">STRMMODE_ZEROCOPY</span>:
			<span class="n">chnl_id</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">zc_chnl_map</span><span class="p">,</span>
					<span class="n">CHNL_MAXCHANNELS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chnl_id</span> <span class="o">&lt;</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">chnl_id</span><span class="p">,</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">zc_chnl_map</span><span class="p">);</span>
				<span class="cm">/* zero-copy chans are 3nd transport set</span>
<span class="cm">				 * (e.g. 32-47) */</span>
				<span class="n">chnl_id</span> <span class="o">=</span> <span class="n">chnl_id</span> <span class="o">+</span>
					<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_chnls</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">STRMMODE_PROCCOPY</span>:
			<span class="n">chnl_id</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">chnl_map</span><span class="p">,</span>
					<span class="n">CHNL_MAXCHANNELS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chnl_id</span> <span class="o">&lt;</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">)</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">chnl_id</span><span class="p">,</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">chnl_map</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chnl_id</span> <span class="o">==</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node1</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">DSP_HGPPNODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node2</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">[</span><span class="n">stream2</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">HOSTCONNECT</span><span class="p">;</span>
			<span class="n">node2</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">[</span><span class="n">stream2</span><span class="p">].</span><span class="n">dev_id</span> <span class="o">=</span> <span class="n">chnl_id</span><span class="p">;</span>
			<span class="n">input</span><span class="o">-&gt;</span><span class="n">sz_device</span> <span class="o">=</span> <span class="n">pstr_dev_name</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">node1</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">[</span><span class="n">stream1</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">HOSTCONNECT</span><span class="p">;</span>
			<span class="n">node1</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">[</span><span class="n">stream1</span><span class="p">].</span><span class="n">dev_id</span> <span class="o">=</span> <span class="n">chnl_id</span><span class="p">;</span>
			<span class="n">output</span><span class="o">-&gt;</span><span class="n">sz_device</span> <span class="o">=</span> <span class="n">pstr_dev_name</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">pstr_dev_name</span><span class="p">,</span> <span class="s">&quot;%s%d&quot;</span><span class="p">,</span> <span class="n">HOSTPREFIX</span><span class="p">,</span> <span class="n">chnl_id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Connecting task node to device node? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">node1_type</span> <span class="o">==</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">node2_type</span> <span class="o">==</span> <span class="n">NODE_DEVICE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node2_type</span> <span class="o">==</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* node1 == &gt; device */</span>
			<span class="n">dev_node_obj</span> <span class="o">=</span> <span class="n">node2</span><span class="p">;</span>
			<span class="n">hnode</span> <span class="o">=</span> <span class="n">node1</span><span class="p">;</span>
			<span class="n">pstream</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">[</span><span class="n">stream1</span><span class="p">]);</span>
			<span class="n">pstrm_def</span> <span class="o">=</span> <span class="n">output</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* device == &gt; node2 */</span>
			<span class="n">dev_node_obj</span> <span class="o">=</span> <span class="n">node1</span><span class="p">;</span>
			<span class="n">hnode</span> <span class="o">=</span> <span class="n">node2</span><span class="p">;</span>
			<span class="n">pstream</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">[</span><span class="n">stream2</span><span class="p">]);</span>
			<span class="n">pstrm_def</span> <span class="o">=</span> <span class="n">input</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Set up create args */</span>
		<span class="n">pstream</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">DEVICECONNECT</span><span class="p">;</span>
		<span class="n">dw_length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">dev_node_obj</span><span class="o">-&gt;</span><span class="n">str_dev_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn_param</span><span class="p">)</span>
			<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">sz_device</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">dw_length</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
					<span class="n">conn_param</span><span class="o">-&gt;</span><span class="n">cb_data</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">sz_device</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">dw_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Copy device name */</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">,</span>
				<span class="n">dev_node_obj</span><span class="o">-&gt;</span><span class="n">str_dev_name</span><span class="p">,</span> <span class="n">dw_length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn_param</span><span class="p">)</span>
			<span class="n">strncat</span><span class="p">(</span><span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">sz_device</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">conn_param</span><span class="o">-&gt;</span><span class="n">node_data</span><span class="p">,</span>
					<span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">conn_param</span><span class="o">-&gt;</span><span class="n">cb_data</span><span class="p">);</span>
		<span class="n">dev_node_obj</span><span class="o">-&gt;</span><span class="n">device_owner</span> <span class="o">=</span> <span class="n">hnode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Fill in create args */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">==</span> <span class="n">NODE_TASK</span> <span class="o">||</span> <span class="n">node1_type</span> <span class="o">==</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node1</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">num_outputs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">fill_stream_def</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pattrs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node2_type</span> <span class="o">==</span> <span class="n">NODE_TASK</span> <span class="o">||</span> <span class="n">node2_type</span> <span class="o">==</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node2</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">num_inputs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">fill_stream_def</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">pattrs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Update node1 and node2 stream_connect */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_GPP</span> <span class="o">&amp;&amp;</span> <span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node1</span><span class="o">-&gt;</span><span class="n">num_outputs</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream1</span> <span class="o">&gt;</span> <span class="n">node1</span><span class="o">-&gt;</span><span class="n">max_output_index</span><span class="p">)</span>
			<span class="n">node1</span><span class="o">-&gt;</span><span class="n">max_output_index</span> <span class="o">=</span> <span class="n">stream1</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node2_type</span> <span class="o">!=</span> <span class="n">NODE_GPP</span> <span class="o">&amp;&amp;</span> <span class="n">node2_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node2</span><span class="o">-&gt;</span><span class="n">num_inputs</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream2</span> <span class="o">&gt;</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">max_input_index</span><span class="p">)</span>
			<span class="n">node2</span><span class="o">-&gt;</span><span class="n">max_input_index</span> <span class="o">=</span> <span class="n">stream2</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">fill_stream_connect</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">stream1</span><span class="p">,</span> <span class="n">stream2</span><span class="p">);</span>
	<span class="cm">/* end of sync_enter_cs */</span>
	<span class="cm">/* Exit critical section */</span>
<span class="nl">out_unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">pstr_dev_name</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pstr_dev_name</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: node1: %p stream1: %d node2: %p stream2: %d&quot;</span>
			<span class="s">&quot;pattrs: %p status: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span>
			<span class="n">stream1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">stream2</span><span class="p">,</span> <span class="n">pattrs</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create a node on the DSP by remotely calling the node&#39;s create function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_create_fxn</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_cbdata</span> <span class="n">cb_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">proc_id</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_processorstate</span> <span class="n">proc_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_DVFS) &amp;&amp; !defined(CONFIG_CPU_FREQ)</span>
	<span class="k">struct</span> <span class="n">dspbridge_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span>
	    <span class="n">omap_dspbridge_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hprocessor</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_state</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_state</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_processorstate</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="cm">/* If processor is in error state then don&#39;t attempt to create</span>
<span class="cm">	   new node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_state</span><span class="p">.</span><span class="n">proc_state</span> <span class="o">==</span> <span class="n">PROC_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* create struct dsp_cbdata struct for PWR calls */</span>
	<span class="n">cb_data</span><span class="p">.</span><span class="n">cb_data</span> <span class="o">=</span> <span class="n">PWR_TIMEOUT</span><span class="p">;</span>
	<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
	<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="cm">/* Get access to node dispatcher */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

	<span class="cm">/* Check node state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_get_state</span><span class="p">(</span><span class="n">hnode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NODE_ALLOCATED</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_processor_id</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_cont2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">!=</span> <span class="n">DSP_UNIT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_cont2</span><span class="p">;</span>

	<span class="cm">/* Make sure streams are properly connected */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">num_inputs</span> <span class="o">&amp;&amp;</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">max_input_index</span> <span class="o">&gt;</span>
	     <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">num_inputs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">num_outputs</span> <span class="o">&amp;&amp;</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">max_output_index</span> <span class="o">&gt;</span>
	     <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">num_outputs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If node&#39;s create function is not loaded, load it */</span>
		<span class="cm">/* Boost the OPP level to max level that DSP can be requested */</span>
<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_DVFS) &amp;&amp; !defined(CONFIG_CPU_FREQ)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">cpu_set_freq</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">cpu_set_freq</span><span class="p">)</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mpu_speed</span><span class="p">[</span><span class="n">VDD1_OPP3</span><span class="p">]);</span>
<span class="cp">#endif</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span>
						       <span class="n">NLDR_CREATE</span><span class="p">);</span>
		<span class="cm">/* Get address of node&#39;s create function */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">get_fxn_address</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_create_fxn</span><span class="p">,</span>
							 <span class="n">CREATEPHASE</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: failed to load create code: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Request the lowest OPP level */</span>
<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_DVFS) &amp;&amp; !defined(CONFIG_CPU_FREQ)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">cpu_set_freq</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">cpu_set_freq</span><span class="p">)</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mpu_speed</span><span class="p">[</span><span class="n">VDD1_OPP1</span><span class="p">]);</span>
<span class="cp">#endif</span>
		<span class="cm">/* Get address of iAlg functions, if socket node */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">==</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span><span class="n">get_fxn_addr</span>
				    <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span>
				     <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span>
				     <span class="n">str_i_alg_name</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span>
				     <span class="n">task_arg_obj</span><span class="p">.</span><span class="n">dais_arg</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">disp_node_create</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">disp_obj</span><span class="p">,</span> <span class="n">hnode</span><span class="p">,</span>
						  <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">fxn_addrs</span>
						  <span class="p">[</span><span class="n">RMSCREATENODE</span><span class="p">],</span>
						  <span class="n">ul_create_fxn</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">),</span>
						  <span class="o">&amp;</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Set the message queue id to the node env</span>
<span class="cm">				 * pointer */</span>
				<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
				<span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">msg_set_queue_id</span><span class="p">)</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span>
							<span class="n">msg_queue_obj</span><span class="p">,</span>
							<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*  Phase II/Overlays: Create, execute, delete phases  possibly in</span>
<span class="cm">	 *  different files/sections. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">&amp;&amp;</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If create code was dynamically loaded, we can now unload</span>
<span class="cm">		 * it. */</span>
		<span class="n">status1</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span><span class="n">unload</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span>
							  <span class="n">NLDR_CREATE</span><span class="p">);</span>
		<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status1</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to unload create code: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">status1</span><span class="p">);</span>
<span class="nl">func_cont2:</span>
	<span class="cm">/* Update node state and node manager state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NODE_SET_STATE</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="n">NODE_CREATED</span><span class="p">);</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_created</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Put back in NODE_ALLOCATED state if error occurred */</span>
		<span class="n">NODE_SET_STATE</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="n">NODE_ALLOCATED</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_cont:</span>
	<span class="cm">/* Free access to node dispatcher */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
<span class="nl">func_end:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proc_notify_clients</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">);</span>
		<span class="n">ntfy_notify</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hnode: %p status: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">hnode</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_create_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create a NODE Manager object.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_create_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">**</span><span class="n">node_man</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">node_mgr_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disp_attr</span> <span class="n">disp_attr_obj</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sz_zl_file</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nldr_attrs</span> <span class="n">nldr_attrs_obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dev_type</span><span class="p">;</span>

	<span class="o">*</span><span class="n">node_man</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Allocate Node manager object */</span>
	<span class="n">node_mgr_obj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_mgr_obj</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ntfy_object</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ntfy_init</span><span class="p">(</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">);</span>

	<span class="n">dev_get_dev_type</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_type</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dcd_create_manager</span><span class="p">(</span><span class="n">sz_zl_file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">get_proc_props</span><span class="p">(</span><span class="n">node_mgr_obj</span><span class="p">,</span> <span class="n">hdev_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="cm">/* Create NODE Dispatcher */</span>
	<span class="n">disp_attr_obj</span><span class="p">.</span><span class="n">chnl_offset</span> <span class="o">=</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_offset</span><span class="p">;</span>
	<span class="n">disp_attr_obj</span><span class="p">.</span><span class="n">chnl_buf_size</span> <span class="o">=</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_buf_size</span><span class="p">;</span>
	<span class="n">disp_attr_obj</span><span class="p">.</span><span class="n">proc_family</span> <span class="o">=</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">proc_family</span><span class="p">;</span>
	<span class="n">disp_attr_obj</span><span class="p">.</span><span class="n">proc_type</span> <span class="o">=</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">proc_type</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">disp_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">disp_obj</span><span class="p">,</span> <span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disp_attr_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="cm">/* Create a STRM Manager */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">strm_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">strm_mgr_obj</span><span class="p">,</span> <span class="n">hdev_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">dev_get_intf_fxns</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">);</span>
	<span class="cm">/* Get msg_ctrl queue manager */</span>
	<span class="n">dev_get_msg_mgr</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">msg_mgr_obj</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

	<span class="cm">/* Block out reserved channels */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_offset</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_map</span><span class="p">);</span>

	<span class="cm">/* Block out channels reserved for RMS */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_offset</span><span class="p">,</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_map</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_map</span><span class="p">);</span>

	<span class="cm">/* NO RM Server on the IVA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_type</span> <span class="o">!=</span> <span class="n">IVA_UNIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get addresses of any RMS functions loaded */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">get_rms_fxns</span><span class="p">(</span><span class="n">node_mgr_obj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get loader functions and create loader */</span>
	<span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span> <span class="o">=</span> <span class="n">nldr_fxns</span><span class="p">;</span>	<span class="cm">/* Dyn loader funcs */</span>

	<span class="n">nldr_attrs_obj</span><span class="p">.</span><span class="n">ovly</span> <span class="o">=</span> <span class="n">ovly</span><span class="p">;</span>
	<span class="n">nldr_attrs_obj</span><span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">mem_write</span><span class="p">;</span>
	<span class="n">nldr_attrs_obj</span><span class="p">.</span><span class="n">dsp_word_size</span> <span class="o">=</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span><span class="p">;</span>
	<span class="n">nldr_attrs_obj</span><span class="p">.</span><span class="n">dsp_mau_size</span> <span class="o">=</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">dsp_mau_size</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">,</span>
			<span class="n">hdev_obj</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">nldr_attrs_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">node_man</span> <span class="o">=</span> <span class="n">node_mgr_obj</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">delete_node_mgr</span><span class="p">(</span><span class="n">node_mgr_obj</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_delete ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Delete a node on the DSP by remotely calling the node&#39;s delete function.</span>
<span class="cm"> *      Loads the node&#39;s delete function if necessary. Free GPP side resources</span>
<span class="cm"> *      after node&#39;s delete function returns.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">*</span><span class="n">noderes</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="n">noderes</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disp_object</span> <span class="o">*</span><span class="n">disp_obj</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_delete_fxn</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_cbdata</span> <span class="n">cb_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">proc_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">node_res</span> <span class="o">=</span> <span class="n">noderes</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dsp_processorstate</span> <span class="n">proc_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* create struct dsp_cbdata struct for PWR call */</span>
	<span class="n">cb_data</span><span class="p">.</span><span class="n">cb_data</span> <span class="o">=</span> <span class="n">PWR_TIMEOUT</span><span class="p">;</span>
	<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="n">hprocessor</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">;</span>
	<span class="n">disp_obj</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">disp_obj</span><span class="p">;</span>
	<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
	<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="cm">/* Enter critical section */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">node_get_state</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
	<span class="cm">/*  Execute delete phase code for non-device node in all cases</span>
<span class="cm">	 *  except when the node was only allocated. Delete phase must be</span>
<span class="cm">	 *  executed even if create phase was executed, but failed.</span>
<span class="cm">	 *  If the node environment pointer is non-NULL, the delete phase</span>
<span class="cm">	 *  code must be  executed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">NODE_ALLOCATED</span> <span class="o">&amp;&amp;</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">node_env</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_processor_id</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_cont1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">==</span> <span class="n">DSP_UNIT</span> <span class="o">||</span> <span class="n">proc_id</span> <span class="o">==</span> <span class="n">IVA_UNIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  If node has terminated, execute phase code will</span>
<span class="cm">			 *  have already been unloaded in node_on_exit(). If the</span>
<span class="cm">			 *  node is PAUSED, the execute phase is loaded, and it</span>
<span class="cm">			 *  is now ok to unload it. If the node is running, we</span>
<span class="cm">			 *  will unload the execute phase only after deleting</span>
<span class="cm">			 *  the node. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">NODE_PAUSED</span> <span class="o">&amp;&amp;</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">&amp;&amp;</span>
			    <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Ok to unload execute code as long as node</span>
<span class="cm">				 * is not * running */</span>
				<span class="n">status1</span> <span class="o">=</span>
				    <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span>
				    <span class="n">unload</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span>
					       <span class="n">NLDR_EXECUTE</span><span class="p">);</span>
				<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">NODE_SET_STATE</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">NODE_DONE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Load delete phase code if not loaded or if haven&#39;t</span>
<span class="cm">			 * * unloaded EXECUTE phase */</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">loaded</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">NODE_RUNNING</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			    <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span>
				    <span class="n">load</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="n">NLDR_DELETE</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
					<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: fail - load delete code:&quot;</span>
					       <span class="s">&quot; 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="nl">func_cont1:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Unblock a thread trying to terminate the node */</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sync_set_event</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">sync_done</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">==</span> <span class="n">DSP_UNIT</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* ul_delete_fxn = address of node&#39;s delete</span>
<span class="cm">				 * function */</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">get_fxn_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_delete_fxn</span><span class="p">,</span>
							 <span class="n">DELETEPHASE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">==</span> <span class="n">IVA_UNIT</span><span class="p">)</span>
				<span class="n">ul_delete_fxn</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_state</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">proc_state</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span>
						       <span class="n">dsp_processorstate</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">proc_state</span><span class="p">.</span><span class="n">proc_state</span> <span class="o">!=</span> <span class="n">PROC_ERROR</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span>
					    <span class="n">disp_node_delete</span><span class="p">(</span><span class="n">disp_obj</span><span class="p">,</span> <span class="n">pnode</span><span class="p">,</span>
							     <span class="n">hnode_mgr</span><span class="o">-&gt;</span>
							     <span class="n">fxn_addrs</span>
							     <span class="p">[</span><span class="n">RMSDELETENODE</span><span class="p">],</span>
							     <span class="n">ul_delete_fxn</span><span class="p">,</span>
							     <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">NODE_SET_STATE</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">NODE_DONE</span><span class="p">);</span>

				<span class="cm">/* Unload execute, if not unloaded, and delete</span>
<span class="cm">				 * function */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">NODE_RUNNING</span> <span class="o">&amp;&amp;</span>
				    <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">status1</span> <span class="o">=</span>
					    <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span>
					    <span class="n">unload</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span>
						       <span class="n">NLDR_EXECUTE</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status1</span><span class="p">)</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: fail - unload execute code:&quot;</span>
					       <span class="s">&quot; 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status1</span><span class="p">);</span>

				<span class="n">status1</span> <span class="o">=</span>
				    <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span><span class="n">unload</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span>
							    <span class="n">nldr_node_obj</span><span class="p">,</span>
							    <span class="n">NLDR_DELETE</span><span class="p">);</span>
				<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status1</span><span class="p">)</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: fail - unload delete code: &quot;</span>
					       <span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status1</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Free host side resources even if a failure occurred */</span>
	<span class="cm">/* Remove node from hnode_mgr-&gt;node_list */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">list_elem</span><span class="p">);</span>
	<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_nodes</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/* Decrement count of nodes created on DSP */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">state</span> <span class="o">!=</span> <span class="n">NODE_ALLOCATED</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">state</span> <span class="o">==</span> <span class="n">NODE_ALLOCATED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					  <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">node_env</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">)))</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_created</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/*  Free host-side resources allocated by node_create()</span>
<span class="cm">	 *  delete_node() fails if SM buffers not freed by client! */</span>
	<span class="n">drv_proc_node_update_status</span><span class="p">(</span><span class="n">node_res</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">delete_node</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">pr_ctxt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release all Node resources and its context</span>
<span class="cm">	 */</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="n">pr_ctxt</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span> <span class="p">((</span><span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">*</span><span class="p">)</span><span class="n">node_res</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node_res</span><span class="p">);</span>

	<span class="cm">/* Exit critical section */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
	<span class="n">proc_notify_clients</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">);</span>
<span class="nl">func_end:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: pnode: %p status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">pnode</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_delete_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Delete the NODE Manager.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_delete_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode_mgr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">delete_node_mgr</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_enum_nodes ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Enumerate currently allocated nodes.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_enum_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">node_tab</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">node_tab_size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pu_num_nodes</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="o">*</span><span class="n">pu_allocated</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Enter critical section */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_nodes</span> <span class="o">&gt;</span> <span class="n">node_tab_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">pu_allocated</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_nodes</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pu_num_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">,</span> <span class="n">list_elem</span><span class="p">)</span>
			<span class="n">node_tab</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">hnode</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pu_allocated</span> <span class="o">=</span> <span class="o">*</span><span class="n">pu_num_nodes</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_nodes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* end of sync_enter_cs */</span>
	<span class="cm">/* Exit critical section */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_free_msg_buf ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Frees the message buffer.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_free_msg_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">pbuffer</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dsp_bufferattr</span> <span class="o">*</span><span class="n">pattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">proc_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_processor_id</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">==</span> <span class="n">DSP_UNIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pattr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* set defaults */</span>
				<span class="n">pattr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_dfltbufattrs</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Node supports single SM segment only */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pattr</span><span class="o">-&gt;</span><span class="n">segment_id</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>

			<span class="cm">/* pbuffer is clients Va. */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">cmm_xlator_free_buf</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">xlator</span><span class="p">,</span> <span class="n">pbuffer</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_attr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Copy the current attributes of the specified node into a dsp_nodeattr</span>
<span class="cm"> *      structure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_get_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dsp_nodeattr</span> <span class="o">*</span><span class="n">pattr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">attr_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="cm">/* Enter hnode_mgr critical section (since we&#39;re accessing</span>
<span class="cm">	 * data that could be changed by node_change_priority() and</span>
<span class="cm">	 * node_connect(). */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
	<span class="n">pattr</span><span class="o">-&gt;</span><span class="n">cb_struct</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_nodeattr</span><span class="p">);</span>
	<span class="cm">/* dsp_nodeattrin */</span>
	<span class="n">pattr</span><span class="o">-&gt;</span><span class="n">in_node_attr_in</span><span class="p">.</span><span class="n">cb_struct</span> <span class="o">=</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_nodeattrin</span><span class="p">);</span>
	<span class="n">pattr</span><span class="o">-&gt;</span><span class="n">in_node_attr_in</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="n">pattr</span><span class="o">-&gt;</span><span class="n">in_node_attr_in</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="n">pattr</span><span class="o">-&gt;</span><span class="n">in_node_attr_in</span><span class="p">.</span><span class="n">heap_size</span> <span class="o">=</span>
		<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">heap_size</span><span class="p">;</span>
	<span class="n">pattr</span><span class="o">-&gt;</span><span class="n">in_node_attr_in</span><span class="p">.</span><span class="n">pgpp_virt_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">gpp_heap_addr</span><span class="p">;</span>
	<span class="n">pattr</span><span class="o">-&gt;</span><span class="n">node_attr_inputs</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">num_gpp_inputs</span><span class="p">;</span>
	<span class="n">pattr</span><span class="o">-&gt;</span><span class="n">node_attr_outputs</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">num_gpp_outputs</span><span class="p">;</span>
	<span class="cm">/* dsp_nodeinfo */</span>
	<span class="n">get_node_info</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pattr</span><span class="o">-&gt;</span><span class="n">node_info</span><span class="p">));</span>
	<span class="cm">/* end of sync_enter_cs */</span>
	<span class="cm">/* Exit critical section */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_channel_id ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Get the channel index reserved for a stream connection between the</span>
<span class="cm"> *      host and a node.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_get_channel_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dir</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="o">*</span><span class="n">chan_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_TASK</span> <span class="o">&amp;&amp;</span> <span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DSP_TONODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAX_INPUTS</span><span class="p">(</span><span class="n">hnode</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">HOSTCONNECT</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">chan_id</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">dev_id</span><span class="p">;</span>
				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAX_OUTPUTS</span><span class="p">(</span><span class="n">hnode</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">HOSTCONNECT</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">chan_id</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">dev_id</span><span class="p">;</span>
				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_message ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve a message from a node on the DSP.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_get_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dsp_msg</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="n">u32</span> <span class="n">utimeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tmp_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_processorstate</span> <span class="n">proc_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hprocessor</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_state</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_state</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_processorstate</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="cm">/* If processor is in error state then don&#39;t attempt to get the</span>
<span class="cm">	   message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_state</span><span class="p">.</span><span class="n">proc_state</span> <span class="o">==</span> <span class="n">PROC_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_MESSAGE</span> <span class="o">&amp;&amp;</span> <span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_TASK</span> <span class="o">&amp;&amp;</span>
	    <span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*  This function will block unless a message is available. Since</span>
<span class="cm">	 *  DSPNode_RegisterNotify() allows notification when a message</span>
<span class="cm">	 *  is available, the system can be designed so that</span>
<span class="cm">	 *  DSPNode_GetMessage() is only called when a message is</span>
<span class="cm">	 *  available. */</span>
	<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span>
	    <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">msg_get</span><span class="p">)</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">msg_queue_obj</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">utimeout</span><span class="p">);</span>
	<span class="cm">/* Check if message contains SM descriptor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">DSP_RMSBUFDESC</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* Translate DSP byte addr to GPP Va. */</span>
	<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">cmm_xlator_translate</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">xlator</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">arg1</span> <span class="o">*</span>
						<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="o">-&gt;</span>
						<span class="n">dsp_word_size</span><span class="p">),</span> <span class="n">CMM_DSPPA2PA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* now convert this GPP Pa to Va */</span>
		<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">cmm_xlator_translate</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">xlator</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span>
					       <span class="n">CMM_PA2VA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Adjust SM size in msg */</span>
			<span class="n">message</span><span class="o">-&gt;</span><span class="n">arg1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">tmp_buf</span><span class="p">;</span>
			<span class="n">message</span><span class="o">-&gt;</span><span class="n">arg2</span> <span class="o">*=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hnode: %p message: %p utimeout: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">hnode</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">utimeout</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *   ======== node_get_nldr_obj ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_get_nldr_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">**</span><span class="n">nldr_ovlyobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">node_mgr_obj</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode_mgr</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">nldr_ovlyobj</span> <span class="o">=</span> <span class="n">node_mgr_obj</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_strm_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Returns the Stream manager.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_get_strm_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">strm_mgr</span> <span class="o">**</span><span class="n">strm_man</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">strm_man</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="o">-&gt;</span><span class="n">strm_mgr_obj</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_load_type ========</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">nldr_loadtype</span> <span class="nf">node_get_load_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Failed. hnode: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hnode</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">load_type</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_timeout ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Returns the timeout value for this node.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">node_get_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: failed. hnode: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hnode</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_type ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Returns the node type.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">node_type</span> <span class="nf">node_get_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">DSP_HGPPNODE</span><span class="p">)</span>
		<span class="n">node_type</span> <span class="o">=</span> <span class="n">NODE_GPP</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span>
			<span class="n">node_type</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">node_type</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntype</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">node_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_on_exit ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Gets called when RMS_EXIT is received for a node.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">node_on_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">s32</span> <span class="n">node_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Set node state to done */</span>
	<span class="n">NODE_SET_STATE</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="n">NODE_DONE</span><span class="p">);</span>
	<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">exit_status</span> <span class="o">=</span> <span class="n">node_status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">&amp;&amp;</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span><span class="n">unload</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span>
							     <span class="n">nldr_node_obj</span><span class="p">,</span>
							     <span class="n">NLDR_EXECUTE</span><span class="p">);</span>
		<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Unblock call to node_terminate */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sync_set_event</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">sync_done</span><span class="p">);</span>
	<span class="cm">/* Notify clients */</span>
	<span class="n">proc_notify_clients</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">);</span>
	<span class="n">ntfy_notify</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_pause ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Suspend execution of a node currently running on the DSP.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hnode</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">proc_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_processorstate</span> <span class="n">proc_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_TASK</span> <span class="o">&amp;&amp;</span> <span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_processor_id</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">==</span> <span class="n">IVA_UNIT</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>

		<span class="cm">/* Enter critical section */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">node_get_state</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
		<span class="cm">/* Check node state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">NODE_RUNNING</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
		<span class="n">hprocessor</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_state</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_state</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_processorstate</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
		<span class="cm">/* If processor is in error state then don&#39;t attempt</span>
<span class="cm">		   to send the message */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proc_state</span><span class="p">.</span><span class="n">proc_state</span> <span class="o">==</span> <span class="n">PROC_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">disp_node_change_priority</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">disp_obj</span><span class="p">,</span> <span class="n">hnode</span><span class="p">,</span>
			<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">fxn_addrs</span><span class="p">[</span><span class="n">RMSCHANGENODEPRIORITY</span><span class="p">],</span>
			<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">,</span> <span class="n">NODE_SUSPENDEDPRI</span><span class="p">);</span>

		<span class="cm">/* Update state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">NODE_SET_STATE</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="n">NODE_PAUSED</span><span class="p">);</span>

<span class="nl">func_cont:</span>
		<span class="cm">/* End of sync_enter_cs */</span>
		<span class="cm">/* Leave critical section */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">proc_notify_clients</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span>
					    <span class="n">DSP_NODESTATECHANGE</span><span class="p">);</span>
			<span class="n">ntfy_notify</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hnode: %p status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hnode</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_put_message ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Send a message to a message node, task node, or XDAIS socket node. This</span>
<span class="cm"> *      function will block until the message stream can accommodate the</span>
<span class="cm"> *      message, or a timeout occurs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_put_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_msg</span> <span class="o">*</span><span class="n">pmsg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">utimeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tmp_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_msg</span> <span class="n">new_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_processorstate</span> <span class="n">proc_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hprocessor</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_state</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_state</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_processorstate</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="cm">/* If processor is in bad state then don&#39;t attempt sending the</span>
<span class="cm">	   message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_state</span><span class="p">.</span><span class="n">proc_state</span> <span class="o">==</span> <span class="n">PROC_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_MESSAGE</span> <span class="o">&amp;&amp;</span> <span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_TASK</span> <span class="o">&amp;&amp;</span>
	    <span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  Check node state. Can&#39;t send messages to a node after</span>
<span class="cm">		 *  we&#39;ve sent the RMS_EXIT command. There is still the</span>
<span class="cm">		 *  possibility that node_terminate can be called after we&#39;ve</span>
<span class="cm">		 *  checked the state. Could add another SYNC object to</span>
<span class="cm">		 *  prevent this (can&#39;t use node_mgr_lock, since we don&#39;t</span>
<span class="cm">		 *  want to block other NODE functions). However, the node may</span>
<span class="cm">		 *  still exit on its own, before this message is sent. */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">node_get_state</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">NODE_TERMINATING</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">NODE_DONE</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>

		<span class="cm">/* end of sync_enter_cs */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* assign pmsg values to new msg */</span>
	<span class="n">new_msg</span> <span class="o">=</span> <span class="o">*</span><span class="n">pmsg</span><span class="p">;</span>
	<span class="cm">/* Now, check if message contains a SM buffer descriptor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">DSP_RMSBUFDESC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Translate GPP Va to DSP physical buf Ptr. */</span>
		<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">cmm_xlator_translate</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">xlator</span><span class="p">,</span>
					       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">new_msg</span><span class="p">.</span><span class="n">arg1</span><span class="p">,</span>
					       <span class="n">CMM_VA2DSPPA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* got translation, convert to MAUs in msg */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_msg</span><span class="p">.</span><span class="n">arg1</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">tmp_buf</span> <span class="o">/</span>
				    <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span><span class="p">;</span>
				<span class="cm">/* MAUs */</span>
				<span class="n">new_msg</span><span class="p">.</span><span class="n">arg2</span> <span class="o">/=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="o">-&gt;</span>
				    <span class="n">dsp_word_size</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: dsp_word_size is zero!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>	<span class="cm">/* bad DSPWordSize */</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* failed to translate buffer address */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">msg_put</span><span class="p">)</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">msg_queue_obj</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">new_msg</span><span class="p">,</span> <span class="n">utimeout</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hnode: %p pmsg: %p utimeout: 0x%x, &quot;</span>
		<span class="s">&quot;status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hnode</span><span class="p">,</span> <span class="n">pmsg</span><span class="p">,</span> <span class="n">utimeout</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_register_notify ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Register to be notified on specific events for this node.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_register_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_mask</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">notify_type</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dsp_notification</span> <span class="o">*</span><span class="n">hnotification</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Check if event mask is a valid node related event */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">DSP_NODESTATECHANGE</span> <span class="o">|</span> <span class="n">DSP_NODEMESSAGEREADY</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* Check if notify type is valid */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">notify_type</span> <span class="o">!=</span> <span class="n">DSP_SIGNALEVENT</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* Only one Notification can be registered at a</span>
<span class="cm">		 * time - Limitation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_mask</span> <span class="o">==</span> <span class="p">(</span><span class="n">DSP_NODESTATECHANGE</span> <span class="o">|</span> <span class="n">DSP_NODEMESSAGEREADY</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_mask</span> <span class="o">==</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ntfy_register</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">hnotification</span><span class="p">,</span>
					       <span class="n">event_mask</span> <span class="o">&amp;</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">,</span>
					       <span class="n">notify_type</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Send Message part of event mask to msg_ctrl */</span>
			<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">msg_register_notify</span><span class="p">)</span>
			    <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">msg_queue_obj</span><span class="p">,</span>
			     <span class="n">event_mask</span> <span class="o">&amp;</span> <span class="n">DSP_NODEMESSAGEREADY</span><span class="p">,</span> <span class="n">notify_type</span><span class="p">,</span>
			     <span class="n">hnotification</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hnode: %p event_mask: 0x%x notify_type: 0x%x &quot;</span>
		<span class="s">&quot;hnotification: %p status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hnode</span><span class="p">,</span>
		<span class="n">event_mask</span><span class="p">,</span> <span class="n">notify_type</span><span class="p">,</span> <span class="n">hnotification</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_run ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Start execution of a node&#39;s execute phase, or resume execution of a node</span>
<span class="cm"> *      that has been suspended (via NODE_NodePause()) on the DSP. Load the</span>
<span class="cm"> *      node&#39;s execute function if necessary.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_execute_fxn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_fxn_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">proc_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_processorstate</span> <span class="n">proc_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hprocessor</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_state</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_state</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_processorstate</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="cm">/* If processor is in error state then don&#39;t attempt to run the node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_state</span><span class="p">.</span><span class="n">proc_state</span> <span class="o">==</span> <span class="n">PROC_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">==</span> <span class="n">NODE_DEVICE</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="cm">/* Enter critical section */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">node_get_state</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">NODE_CREATED</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">!=</span> <span class="n">NODE_PAUSED</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_processor_id</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_cont1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">proc_id</span> <span class="o">!=</span> <span class="n">DSP_UNIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">!=</span> <span class="n">IVA_UNIT</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">func_cont1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">NODE_CREATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If node&#39;s execute function is not loaded, load it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">loaded</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">phase_split</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span>
							  <span class="n">NLDR_EXECUTE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: fail - load execute code: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Get address of node&#39;s execute function */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">proc_id</span> <span class="o">==</span> <span class="n">IVA_UNIT</span><span class="p">)</span>
				<span class="n">ul_execute_fxn</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">get_fxn_address</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_execute_fxn</span><span class="p">,</span>
							 <span class="n">EXECUTEPHASE</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ul_fxn_addr</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">fxn_addrs</span><span class="p">[</span><span class="n">RMSEXECUTENODE</span><span class="p">];</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">disp_node_run</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">disp_obj</span><span class="p">,</span> <span class="n">hnode</span><span class="p">,</span>
					  <span class="n">ul_fxn_addr</span><span class="p">,</span> <span class="n">ul_execute_fxn</span><span class="p">,</span>
					  <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">NODE_PAUSED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ul_fxn_addr</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">fxn_addrs</span><span class="p">[</span><span class="n">RMSCHANGENODEPRIORITY</span><span class="p">];</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">disp_node_change_priority</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">disp_obj</span><span class="p">,</span> <span class="n">hnode</span><span class="p">,</span>
						   <span class="n">ul_fxn_addr</span><span class="p">,</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">,</span>
						   <span class="n">NODE_GET_PRIORITY</span><span class="p">(</span><span class="n">hnode</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We should never get here */</span>
	<span class="p">}</span>
<span class="nl">func_cont1:</span>
	<span class="cm">/* Update node state. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">NODE_SET_STATE</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="n">NODE_RUNNING</span><span class="p">);</span>
	<span class="k">else</span>			<span class="cm">/* Set state back to previous value */</span>
		<span class="n">NODE_SET_STATE</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="cm">/*End of sync_enter_cs */</span>
	<span class="cm">/* Exit critical section */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proc_notify_clients</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">);</span>
		<span class="n">ntfy_notify</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">DSP_NODESTATECHANGE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hnode: %p status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hnode</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_terminate ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Signal a node running on the DSP that it should exit its execute phase</span>
<span class="cm"> *      function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_terminate</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pstatus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_msg</span> <span class="n">msg</span><span class="p">,</span> <span class="n">killmsg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">proc_id</span><span class="p">,</span> <span class="n">kill_time_out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">deh_mgr</span> <span class="o">*</span><span class="n">hdeh_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_processorstate</span> <span class="n">proc_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span> <span class="o">||</span> <span class="o">!</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_processor_id</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
		<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_TASK</span> <span class="o">&amp;&amp;</span> <span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check node state */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">node_get_state</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">NODE_RUNNING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
			<span class="cm">/* Set the exit status if node terminated on</span>
<span class="cm">			 * its own. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">NODE_DONE</span><span class="p">)</span>
				<span class="o">*</span><span class="n">pstatus</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">exit_status</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">NODE_SET_STATE</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="n">NODE_TERMINATING</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* end of sync_enter_cs */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Send exit message. Do not change state to NODE_DONE</span>
<span class="cm">		 *  here. That will be done in callback.</span>
<span class="cm">		 */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_state</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_state</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_processorstate</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
		<span class="cm">/* If processor is in error state then don&#39;t attempt to send</span>
<span class="cm">		 * A kill task command */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proc_state</span><span class="p">.</span><span class="n">proc_state</span> <span class="o">==</span> <span class="n">PROC_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">msg</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">RMS_EXIT</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">arg1</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">;</span>
		<span class="n">killmsg</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">RMS_KILLTASK</span><span class="p">;</span>
		<span class="n">killmsg</span><span class="p">.</span><span class="n">arg1</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">;</span>
		<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">MAXTIMEOUT</span><span class="p">)</span>
			<span class="n">kill_time_out</span> <span class="o">=</span> <span class="n">MAXTIMEOUT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">kill_time_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">msg_put</span><span class="p">)</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">msg_queue_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span>
						    <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait on synchronization object that will be</span>
<span class="cm">		 * posted in the callback on receiving RMS_EXIT</span>
<span class="cm">		 * message, or by node_delete. Check for valid hnode,</span>
<span class="cm">		 * in case posted by node_delete().</span>
<span class="cm">		 */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sync_wait_on_event</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">sync_done</span><span class="p">,</span>
					    <span class="n">kill_time_out</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">ETIME</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">msg_put</span><span class="p">)(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">msg_queue_obj</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">killmsg</span><span class="p">,</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sync_wait_on_event</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">sync_done</span><span class="p">,</span>
					     <span class="n">kill_time_out</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Here it goes the part of the simulation of</span>
<span class="cm">			 * the DSP exception.</span>
<span class="cm">			 */</span>
			<span class="n">dev_get_deh_mgr</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdeh_mgr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdeh_mgr</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

			<span class="n">bridge_deh_notify</span><span class="p">(</span><span class="n">hdeh_mgr</span><span class="p">,</span> <span class="n">DSP_SYSERROR</span><span class="p">,</span> <span class="n">DSP_EXCEPTIONABORT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">func_cont:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enter CS before getting exit status, in case node was</span>
<span class="cm">		 * deleted. */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
		<span class="cm">/* Make sure node wasn&#39;t deleted while we blocked */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">pstatus</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">exit_status</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: hnode: %p env 0x%x status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">hnode</span><span class="p">,</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
	<span class="p">}</span>			<span class="cm">/*End of sync_enter_cs */</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== delete_node ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Free GPP resources allocated in node_allocate() or node_connect().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stream_chnl</span> <span class="n">stream</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_msgargs</span> <span class="n">node_msg_args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_taskargs</span> <span class="n">task_arg_obj</span><span class="p">;</span>
<span class="cp">#ifdef DSP_DMM_DEBUG</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">p_proc_object</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnode_mgr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">node_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_msg_args</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">node_msg_args</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">node_msg_args</span><span class="p">.</span><span class="n">pdata</span><span class="p">);</span>

		<span class="cm">/* Free msg_ctrl queue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">msg_queue_obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
			<span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">msg_delete_queue</span><span class="p">)</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span>
							    <span class="n">msg_queue_obj</span><span class="p">);</span>
			<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">msg_queue_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">sync_done</span><span class="p">);</span>

		<span class="cm">/* Free all stream info */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_INPUTS</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">stream</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">free_stream</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">inputs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_OUTPUTS</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">stream</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">free_stream</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">);</span>
			<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">outputs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">task_arg_obj</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_in_def</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_INPUTS</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_in_def</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sz_device</span><span class="p">);</span>
				<span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_in_def</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sz_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_in_def</span><span class="p">);</span>
			<span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_in_def</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_out_def</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_OUTPUTS</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_out_def</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sz_device</span><span class="p">);</span>
				<span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_out_def</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sz_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_out_def</span><span class="p">);</span>
			<span class="n">task_arg_obj</span><span class="p">.</span><span class="n">strm_out_def</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_arg_obj</span><span class="p">.</span><span class="n">dsp_heap_res_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">proc_un_map</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
					     <span class="n">task_arg_obj</span><span class="p">.</span><span class="n">dsp_heap_addr</span><span class="p">,</span>
					     <span class="n">pr_ctxt</span><span class="p">);</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">proc_un_reserve_memory</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">processor</span><span class="p">,</span>
							<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
							<span class="n">task_arg_obj</span><span class="p">.</span>
							<span class="n">dsp_heap_res_addr</span><span class="p">,</span>
							<span class="n">pr_ctxt</span><span class="p">);</span>
<span class="cp">#ifdef DSP_DMM_DEBUG</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_get_handle</span><span class="p">(</span><span class="n">p_proc_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmm_mgr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dmm_mgr</span><span class="p">)</span>
				<span class="n">dmm_mem_map_dump</span><span class="p">(</span><span class="n">dmm_mgr</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">DSP_EHANDLE</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_MESSAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">stream_connect</span><span class="p">);</span>
		<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">stream_connect</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">str_dev_name</span><span class="p">);</span>
	<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">str_dev_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfy_delete</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
		<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* These were allocated in dcd_get_object_def (via node_allocate) */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_create_phase_fxn</span><span class="p">);</span>
	<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_create_phase_fxn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_execute_phase_fxn</span><span class="p">);</span>
	<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_execute_phase_fxn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_delete_phase_fxn</span><span class="p">);</span>
	<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_delete_phase_fxn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_i_alg_name</span><span class="p">);</span>
	<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_i_alg_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Free all SM address translator resources */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">xlator</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">);</span>
	<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>
	<span class="n">hnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">func_end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== delete_node_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Frees the node manager.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_node_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Free resources */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">)</span>
			<span class="n">dcd_destroy_manager</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">);</span>

		<span class="cm">/* Remove any elements remaining in lists */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">,</span>
				<span class="n">list_elem</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">list_elem</span><span class="p">);</span>
			<span class="n">delete_node</span><span class="p">(</span><span class="n">hnode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfy_delete</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">disp_obj</span><span class="p">)</span>
			<span class="n">disp_delete</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">disp_obj</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">strm_mgr_obj</span><span class="p">)</span>
			<span class="n">strm_delete</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">strm_mgr_obj</span><span class="p">);</span>

		<span class="cm">/* Delete the loader */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">)</span>
			<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_obj</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== fill_stream_connect ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Fills stream information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_stream_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">node1</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">node2</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">stream1</span><span class="p">,</span> <span class="n">u32</span> <span class="n">stream2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">strm_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_streamconnect</span> <span class="o">*</span><span class="n">strm1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_streamconnect</span> <span class="o">*</span><span class="n">strm2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node1_type</span> <span class="o">=</span> <span class="n">NODE_TASK</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node2_type</span> <span class="o">=</span> <span class="n">NODE_TASK</span><span class="p">;</span>

	<span class="n">node1_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">node1</span><span class="p">);</span>
	<span class="n">node2_type</span> <span class="o">=</span> <span class="n">node_get_type</span><span class="p">(</span><span class="n">node2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node1</span> <span class="o">!=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">DSP_HGPPNODE</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">strm_index</span> <span class="o">=</span> <span class="n">node1</span><span class="o">-&gt;</span><span class="n">num_inputs</span> <span class="o">+</span>
			    <span class="n">node1</span><span class="o">-&gt;</span><span class="n">num_outputs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">strm1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">stream_connect</span><span class="p">[</span><span class="n">strm_index</span><span class="p">]);</span>
			<span class="n">strm1</span><span class="o">-&gt;</span><span class="n">cb_struct</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_streamconnect</span><span class="p">);</span>
			<span class="n">strm1</span><span class="o">-&gt;</span><span class="n">this_node_stream_index</span> <span class="o">=</span> <span class="n">stream1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node2</span> <span class="o">!=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">DSP_HGPPNODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* NODE == &gt; NODE */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">strm1</span><span class="o">-&gt;</span><span class="n">connected_node</span> <span class="o">=</span> <span class="n">node2</span><span class="p">;</span>
				<span class="n">strm1</span><span class="o">-&gt;</span><span class="n">ui_connected_node_id</span> <span class="o">=</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">node_uuid</span><span class="p">;</span>
				<span class="n">strm1</span><span class="o">-&gt;</span><span class="n">connected_node_stream_index</span> <span class="o">=</span> <span class="n">stream2</span><span class="p">;</span>
				<span class="n">strm1</span><span class="o">-&gt;</span><span class="n">connect_type</span> <span class="o">=</span> <span class="n">CONNECTTYPE_NODEOUTPUT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node2_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">strm_index</span> <span class="o">=</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">num_inputs</span> <span class="o">+</span>
				    <span class="n">node2</span><span class="o">-&gt;</span><span class="n">num_outputs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">strm2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">stream_connect</span><span class="p">[</span><span class="n">strm_index</span><span class="p">]);</span>
				<span class="n">strm2</span><span class="o">-&gt;</span><span class="n">cb_struct</span> <span class="o">=</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_streamconnect</span><span class="p">);</span>
				<span class="n">strm2</span><span class="o">-&gt;</span><span class="n">this_node_stream_index</span> <span class="o">=</span> <span class="n">stream2</span><span class="p">;</span>
				<span class="n">strm2</span><span class="o">-&gt;</span><span class="n">connected_node</span> <span class="o">=</span> <span class="n">node1</span><span class="p">;</span>
				<span class="n">strm2</span><span class="o">-&gt;</span><span class="n">ui_connected_node_id</span> <span class="o">=</span> <span class="n">node1</span><span class="o">-&gt;</span><span class="n">node_uuid</span><span class="p">;</span>
				<span class="n">strm2</span><span class="o">-&gt;</span><span class="n">connected_node_stream_index</span> <span class="o">=</span> <span class="n">stream1</span><span class="p">;</span>
				<span class="n">strm2</span><span class="o">-&gt;</span><span class="n">connect_type</span> <span class="o">=</span> <span class="n">CONNECTTYPE_NODEINPUT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node1_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span>
			<span class="n">strm1</span><span class="o">-&gt;</span><span class="n">connect_type</span> <span class="o">=</span> <span class="n">CONNECTTYPE_GPPOUTPUT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* GPP == &gt; NODE */</span>
		<span class="n">strm_index</span> <span class="o">=</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">num_inputs</span> <span class="o">+</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">num_outputs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">strm2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">stream_connect</span><span class="p">[</span><span class="n">strm_index</span><span class="p">]);</span>
		<span class="n">strm2</span><span class="o">-&gt;</span><span class="n">cb_struct</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_streamconnect</span><span class="p">);</span>
		<span class="n">strm2</span><span class="o">-&gt;</span><span class="n">this_node_stream_index</span> <span class="o">=</span> <span class="n">stream2</span><span class="p">;</span>
		<span class="n">strm2</span><span class="o">-&gt;</span><span class="n">connect_type</span> <span class="o">=</span> <span class="n">CONNECTTYPE_GPPINPUT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== fill_stream_def ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Fills Stream attributes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_stream_def</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">node_strmdef</span> <span class="o">*</span><span class="n">pstrm_def</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dsp_strmattr</span> <span class="o">*</span><span class="n">pattrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pattrs</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">num_bufs</span> <span class="o">=</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">num_bufs</span><span class="p">;</span>
		<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">=</span>
		    <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">/</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dsp_data_mau_size</span><span class="p">;</span>
		<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">seg_id</span> <span class="o">=</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">seg_id</span><span class="p">;</span>
		<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">buf_alignment</span> <span class="o">=</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">buf_alignment</span><span class="p">;</span>
		<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">num_bufs</span> <span class="o">=</span> <span class="n">DEFAULTNBUFS</span><span class="p">;</span>
		<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">=</span>
		    <span class="n">DEFAULTBUFSIZE</span> <span class="o">/</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dsp_data_mau_size</span><span class="p">;</span>
		<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">seg_id</span> <span class="o">=</span> <span class="n">DEFAULTSEGID</span><span class="p">;</span>
		<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">buf_alignment</span> <span class="o">=</span> <span class="n">DEFAULTALIGNMENT</span><span class="p">;</span>
		<span class="n">pstrm_def</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">DEFAULTTIMEOUT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== free_stream ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Updates the channel mask and frees the pipe id.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stream_chnl</span> <span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Free up the pipe id unless other node has not yet been deleted. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">NODECONNECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">pipe_done_map</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* The other node has already been deleted */</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">pipe_done_map</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">pipe_map</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* The other node has not been deleted yet */</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">pipe_done_map</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">HOSTCONNECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">dev_id</span> <span class="o">&lt;</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_chnls</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">chnl_map</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">dev_id</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_chnls</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* dsp-dma */</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">dev_id</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_chnls</span><span class="p">),</span>
					<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dma_chnl_map</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">dev_id</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_chnls</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* zero-copy */</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">dev_id</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_chnls</span><span class="p">),</span>
					<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">zc_chnl_map</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== get_fxn_address ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieves the address for create, execute or delete phase for a node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_fxn_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">fxn_addr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">phase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pstr_fxn_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CREATEPHASE</span>:
		<span class="n">pstr_fxn_name</span> <span class="o">=</span>
		    <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_create_phase_fxn</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXECUTEPHASE</span>:
		<span class="n">pstr_fxn_name</span> <span class="o">=</span>
		    <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_execute_phase_fxn</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DELETEPHASE</span>:
		<span class="n">pstr_fxn_name</span> <span class="o">=</span>
		    <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">str_delete_phase_fxn</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Should never get here */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span>
	    <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">nldr_fxns</span><span class="p">.</span><span class="n">get_fxn_addr</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span>
						  <span class="n">pstr_fxn_name</span><span class="p">,</span> <span class="n">fxn_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== get_node_info ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieves the node information.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">get_node_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dsp_nodeinfo</span> <span class="o">*</span><span class="n">node_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">node_info</span><span class="o">-&gt;</span><span class="n">cb_struct</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_nodeinfo</span><span class="p">);</span>
	<span class="n">node_info</span><span class="o">-&gt;</span><span class="n">nb_node_database_props</span> <span class="o">=</span>
	    <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">dcd_props</span><span class="p">.</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">ndb_props</span><span class="p">;</span>
	<span class="n">node_info</span><span class="o">-&gt;</span><span class="n">execution_priority</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="n">node_info</span><span class="o">-&gt;</span><span class="n">device_owner</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">device_owner</span><span class="p">;</span>
	<span class="n">node_info</span><span class="o">-&gt;</span><span class="n">number_streams</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">num_inputs</span> <span class="o">+</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">num_outputs</span><span class="p">;</span>
	<span class="n">node_info</span><span class="o">-&gt;</span><span class="n">node_env</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_env</span><span class="p">;</span>

	<span class="n">node_info</span><span class="o">-&gt;</span><span class="n">ns_execution_state</span> <span class="o">=</span> <span class="n">node_get_state</span><span class="p">(</span><span class="n">hnode</span><span class="p">);</span>

	<span class="cm">/* Copy stream connect data */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">num_inputs</span> <span class="o">+</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">num_outputs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">node_info</span><span class="o">-&gt;</span><span class="n">sc_stream_connection</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">stream_connect</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== get_node_props ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve node properties.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_node_props</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_mgr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">node_uuid</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dcd_genericobj</span> <span class="o">*</span><span class="n">dcd_prop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_msgargs</span> <span class="o">*</span><span class="n">pmsg_args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_taskargs</span> <span class="o">*</span><span class="n">task_arg_obj</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">node_type</span> <span class="n">node_type</span> <span class="o">=</span> <span class="n">NODE_TASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_ndbprops</span> <span class="o">*</span><span class="n">pndb_props</span> <span class="o">=</span>
	    <span class="o">&amp;</span><span class="p">(</span><span class="n">dcd_prop</span><span class="o">-&gt;</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">ndb_props</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">sz_uuid</span><span class="p">[</span><span class="n">MAXUUIDLEN</span><span class="p">];</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dcd_get_object_def</span><span class="p">(</span><span class="n">hdcd_mgr</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="p">)</span><span class="n">node_uuid</span><span class="p">,</span>
				    <span class="n">DSP_DCDNODETYPE</span><span class="p">,</span> <span class="n">dcd_prop</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">ntype</span> <span class="o">=</span> <span class="n">node_type</span> <span class="o">=</span> <span class="n">pndb_props</span><span class="o">-&gt;</span><span class="n">ntype</span><span class="p">;</span>

		<span class="cm">/* Create UUID value to set in registry. */</span>
		<span class="n">uuid_uuid_to_string</span><span class="p">((</span><span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="p">)</span><span class="n">node_uuid</span><span class="p">,</span> <span class="n">sz_uuid</span><span class="p">,</span>
				    <span class="n">MAXUUIDLEN</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;(node) UUID: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sz_uuid</span><span class="p">);</span>

		<span class="cm">/* Fill in message args that come from NDB */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">NODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmsg_args</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">node_msg_args</span><span class="p">);</span>
			<span class="n">pmsg_args</span><span class="o">-&gt;</span><span class="n">seg_id</span> <span class="o">=</span>
			    <span class="n">dcd_prop</span><span class="o">-&gt;</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">msg_segid</span><span class="p">;</span>
			<span class="n">pmsg_args</span><span class="o">-&gt;</span><span class="n">notify_type</span> <span class="o">=</span>
			    <span class="n">dcd_prop</span><span class="o">-&gt;</span><span class="n">obj_data</span><span class="p">.</span><span class="n">node_obj</span><span class="p">.</span><span class="n">msg_notify_type</span><span class="p">;</span>
			<span class="n">pmsg_args</span><span class="o">-&gt;</span><span class="n">max_msgs</span> <span class="o">=</span> <span class="n">pndb_props</span><span class="o">-&gt;</span><span class="n">message_depth</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;(node) Max Number of Messages: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pmsg_args</span><span class="o">-&gt;</span><span class="n">max_msgs</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Copy device name */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">pndb_props</span><span class="o">-&gt;</span><span class="n">ac_name</span><span class="p">);</span>
			<span class="n">hnode</span><span class="o">-&gt;</span><span class="n">str_dev_name</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">str_dev_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">strncpy</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">str_dev_name</span><span class="p">,</span>
					<span class="n">pndb_props</span><span class="o">-&gt;</span><span class="n">ac_name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Fill in create args that come from NDB */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">==</span> <span class="n">NODE_TASK</span> <span class="o">||</span> <span class="n">node_type</span> <span class="o">==</span> <span class="n">NODE_DAISSOCKET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">task_arg_obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">hnode</span><span class="o">-&gt;</span><span class="n">create_args</span><span class="p">.</span><span class="n">asa</span><span class="p">.</span><span class="n">task_arg_obj</span><span class="p">);</span>
			<span class="n">task_arg_obj</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">pndb_props</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
			<span class="n">task_arg_obj</span><span class="o">-&gt;</span><span class="n">stack_size</span> <span class="o">=</span> <span class="n">pndb_props</span><span class="o">-&gt;</span><span class="n">stack_size</span><span class="p">;</span>
			<span class="n">task_arg_obj</span><span class="o">-&gt;</span><span class="n">sys_stack_size</span> <span class="o">=</span>
			    <span class="n">pndb_props</span><span class="o">-&gt;</span><span class="n">sys_stack_size</span><span class="p">;</span>
			<span class="n">task_arg_obj</span><span class="o">-&gt;</span><span class="n">stack_seg</span> <span class="o">=</span> <span class="n">pndb_props</span><span class="o">-&gt;</span><span class="n">stack_seg</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;(node) Priority: 0x%x Stack Size: &quot;</span>
				<span class="s">&quot;0x%x words System Stack Size: 0x%x words &quot;</span>
				<span class="s">&quot;Stack Segment: 0x%x profile count : 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task_arg_obj</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">,</span> <span class="n">task_arg_obj</span><span class="o">-&gt;</span><span class="n">stack_size</span><span class="p">,</span>
				<span class="n">task_arg_obj</span><span class="o">-&gt;</span><span class="n">sys_stack_size</span><span class="p">,</span>
				<span class="n">task_arg_obj</span><span class="o">-&gt;</span><span class="n">stack_seg</span><span class="p">,</span>
				<span class="n">pndb_props</span><span class="o">-&gt;</span><span class="n">count_profiles</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== get_proc_props ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the processor properties.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_proc_props</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">host_res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">pbridge_context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbridge_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pbridge_context</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">host_res</span> <span class="o">=</span> <span class="n">pbridge_context</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_res</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">chnl_offset</span> <span class="o">=</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">chnl_offset</span><span class="p">;</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">chnl_buf_size</span> <span class="o">=</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">chnl_buf_size</span><span class="p">;</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">num_chnls</span> <span class="o">=</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">num_chnls</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  PROC will add an API to get dsp_processorinfo.</span>
<span class="cm">		 *  Fill in default values for now.</span>
<span class="cm">		 */</span>
		<span class="cm">/* TODO -- Instead of hard coding, take from registry */</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">proc_family</span> <span class="o">=</span> <span class="mi">6000</span><span class="p">;</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">proc_type</span> <span class="o">=</span> <span class="mi">6410</span><span class="p">;</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">min_pri</span> <span class="o">=</span> <span class="n">DSP_NODE_MIN_PRIORITY</span><span class="p">;</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">max_pri</span> <span class="o">=</span> <span class="n">DSP_NODE_MAX_PRIORITY</span><span class="p">;</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span> <span class="o">=</span> <span class="n">DSPWORDSIZE</span><span class="p">;</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dsp_data_mau_size</span> <span class="o">=</span> <span class="n">DSPWORDSIZE</span><span class="p">;</span>
		<span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dsp_mau_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_uuid_props ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Fetch Node UUID properties from DCD/DOF file.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_get_uuid_props</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">node_uuid</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dsp_ndbprops</span> <span class="o">*</span><span class="n">node_props</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dcd_nodeprops</span> <span class="n">dcd_node_props</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dsp_processorstate</span> <span class="n">proc_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hprocessor</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">node_uuid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_state</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_state</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_processorstate</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="cm">/* If processor is in error state then don&#39;t attempt</span>
<span class="cm">	   to send the message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_state</span><span class="p">.</span><span class="n">proc_state</span> <span class="o">==</span> <span class="n">PROC_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_dev_object</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdev_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_node_manager</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hnode_mgr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enter the critical section. This is needed because</span>
<span class="cm">	 * dcd_get_object_def will ultimately end up calling dbll_open/close,</span>
<span class="cm">	 * which needs to be protected in order to not corrupt the zlib manager</span>
<span class="cm">	 * (COD).</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>

	<span class="n">dcd_node_props</span><span class="p">.</span><span class="n">str_create_phase_fxn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dcd_node_props</span><span class="p">.</span><span class="n">str_execute_phase_fxn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dcd_node_props</span><span class="p">.</span><span class="n">str_delete_phase_fxn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dcd_node_props</span><span class="p">.</span><span class="n">str_i_alg_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dcd_get_object_def</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dcd_mgr</span><span class="p">,</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="p">)</span><span class="n">node_uuid</span><span class="p">,</span> <span class="n">DSP_DCDNODETYPE</span><span class="p">,</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">dcd_genericobj</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dcd_node_props</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">node_props</span> <span class="o">=</span> <span class="n">dcd_node_props</span><span class="p">.</span><span class="n">ndb_props</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dcd_node_props</span><span class="p">.</span><span class="n">str_create_phase_fxn</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">dcd_node_props</span><span class="p">.</span><span class="n">str_execute_phase_fxn</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">dcd_node_props</span><span class="p">.</span><span class="n">str_delete_phase_fxn</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">dcd_node_props</span><span class="p">.</span><span class="n">str_i_alg_name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*  Leave the critical section, we&#39;re done. */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">node_mgr_lock</span><span class="p">);</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== get_rms_fxns ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the RMS functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_rms_fxns</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">psz_fxns</span><span class="p">[</span><span class="n">NUMRMSFXNS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;RMS_queryServer&quot;</span><span class="p">,</span>	<span class="cm">/* RMSQUERYSERVER */</span>
		<span class="s">&quot;RMS_configureServer&quot;</span><span class="p">,</span>	<span class="cm">/* RMSCONFIGURESERVER */</span>
		<span class="s">&quot;RMS_createNode&quot;</span><span class="p">,</span>	<span class="cm">/* RMSCREATENODE */</span>
		<span class="s">&quot;RMS_executeNode&quot;</span><span class="p">,</span>	<span class="cm">/* RMSEXECUTENODE */</span>
		<span class="s">&quot;RMS_deleteNode&quot;</span><span class="p">,</span>	<span class="cm">/* RMSDELETENODE */</span>
		<span class="s">&quot;RMS_changeNodePriority&quot;</span><span class="p">,</span>	<span class="cm">/* RMSCHANGENODEPRIORITY */</span>
		<span class="s">&quot;RMS_readMemory&quot;</span><span class="p">,</span>	<span class="cm">/* RMSREADMEMORY */</span>
		<span class="s">&quot;RMS_writeMemory&quot;</span><span class="p">,</span>	<span class="cm">/* RMSWRITEMEMORY */</span>
		<span class="s">&quot;RMS_copy&quot;</span><span class="p">,</span>	<span class="cm">/* RMSCOPY */</span>
	<span class="p">};</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUMRMSFXNS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_symbol</span><span class="p">(</span><span class="n">dev_obj</span><span class="p">,</span> <span class="n">psz_fxns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="o">&amp;</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">fxn_addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 *  May be loaded dynamically (in the future),</span>
<span class="cm">				 *  but return an error for now.</span>
<span class="cm">				 */</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: RMS function: %s currently&quot;</span>
					<span class="s">&quot; not loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">psz_fxns</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Symbol not found: %s &quot;</span>
					<span class="s">&quot;status = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
					<span class="n">psz_fxns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">status</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== ovly ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Called during overlay.Sends command to RMS to copy a block of data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">ovly</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv_ref</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_run_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_load_addr</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">priv_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">hbridge_context</span><span class="p">;</span>
	<span class="cm">/* Function interface to Bridge driver*/</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>

	<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>

	<span class="n">ul_size</span> <span class="o">=</span> <span class="n">ul_num_bytes</span> <span class="o">/</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dsp_word_size</span><span class="p">;</span>
	<span class="n">ul_timeout</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/* Call new MemCopy function */</span>
	<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hbridge_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_mem_copy</span><span class="p">)</span> <span class="p">(</span><span class="n">hbridge_context</span><span class="p">,</span>
						<span class="n">dsp_run_addr</span><span class="p">,</span> <span class="n">dsp_load_addr</span><span class="p">,</span>
						<span class="n">ul_num_bytes</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">mem_space</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
			<span class="n">ul_bytes</span> <span class="o">=</span> <span class="n">ul_num_bytes</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: failed to copy brd memory, status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: failed to get Bridge context, status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ul_bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== mem_write ========</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">mem_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv_ref</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_add</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pbuf</span><span class="p">,</span>
		     <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="p">)</span><span class="n">priv_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mem_sect_type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">hbridge_context</span><span class="p">;</span>
	<span class="cm">/* Function interface to Bridge driver */</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>

	<span class="n">hnode_mgr</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>

	<span class="n">ul_timeout</span> <span class="o">=</span> <span class="n">hnode</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="n">mem_sect_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">mem_space</span> <span class="o">&amp;</span> <span class="n">DBLL_CODE</span><span class="p">)</span> <span class="o">?</span> <span class="n">RMS_CODE</span> <span class="o">:</span> <span class="n">RMS_DATA</span><span class="p">;</span>

	<span class="cm">/* Call new MemWrite function */</span>
	<span class="n">intf_fxns</span> <span class="o">=</span> <span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="n">hnode_mgr</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hbridge_context</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_mem_write</span><span class="p">)</span> <span class="p">(</span><span class="n">hbridge_context</span><span class="p">,</span> <span class="n">pbuf</span><span class="p">,</span>
					<span class="n">dsp_add</span><span class="p">,</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">mem_sect_type</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ul_num_bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE</span>
<span class="cm">/*</span>
<span class="cm"> *  ======== node_find_addr ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">node_find_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">node_mgr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sym_addr</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">offset_range</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sym_addr_output</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sym_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">node_obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%x, 0x%x, 0x%x, 0x%x,  %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">node_mgr</span><span class="p">,</span>
			<span class="n">sym_addr</span><span class="p">,</span> <span class="n">offset_range</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">sym_addr_output</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">node_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_mgr</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">,</span> <span class="n">list_elem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">nldr_find_addr</span><span class="p">(</span><span class="n">node_obj</span><span class="o">-&gt;</span><span class="n">nldr_node_obj</span><span class="p">,</span> <span class="n">sym_addr</span><span class="p">,</span>
			<span class="n">offset_range</span><span class="p">,</span> <span class="n">sym_addr_output</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
