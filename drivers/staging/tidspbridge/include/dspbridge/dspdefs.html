<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › include › dspbridge › dspdefs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>dspdefs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * dspdefs.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Bridge driver entry point and interface function declarations.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *   The DSP API obtains it&#39;s function interface to</span>
<span class="cm"> *   the Bridge driver via a call to bridge_drv_entry().</span>
<span class="cm"> *</span>
<span class="cm"> *   Bridge services exported to Bridge drivers are initialized by the</span>
<span class="cm"> *   DSP API on behalf of the Bridge driver.</span>
<span class="cm"> *</span>
<span class="cm"> *   Bridge function DBC Requires and Ensures are also made by the DSP API on</span>
<span class="cm"> *   behalf of the Bridge driver, to simplify the Bridge driver code.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef DSPDEFS_</span>
<span class="cp">#define DSPDEFS_</span>

<span class="cp">#include &lt;dspbridge/brddefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/cfgdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/chnlpriv.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspdeh.h&gt;</span>
<span class="cp">#include &lt;dspbridge/devdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/io.h&gt;</span>
<span class="cp">#include &lt;dspbridge/msgdefs.h&gt;</span>

<span class="cm">/* Handle to Bridge driver&#39;s private device context. */</span>
<span class="k">struct</span> <span class="n">bridge_dev_context</span><span class="p">;</span>

<span class="cm">/*--------------------------------------------------------------------------- */</span>
<span class="cm">/* BRIDGE DRIVER FUNCTION TYPES */</span>
<span class="cm">/*--------------------------------------------------------------------------- */</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_monitor ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Bring the board to the BRD_IDLE (monitor) state.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device context.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.</span>
<span class="cm"> *      -EPERM:      Other, unspecified error.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_ctxt != NULL</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        Board is in BRD_IDLE state;</span>
<span class="cm"> *      else:           Board state is indeterminate.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_monitor</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== fxn_brd_setstate ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Sets the Bridge driver state</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device info.</span>
<span class="cm"> *      brd_state:      Board state</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EPERM:      Other, unspecified error.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_ctxt != NULL;</span>
<span class="cm"> *      brd_state  &lt;= BRD_LASTSTATE.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      brd_state  &lt;= BRD_LASTSTATE.</span>
<span class="cm"> *  Update the Board state to the specified state.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_setstate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span>
				       <span class="o">*</span> <span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">brd_state</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_start ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Bring board to the BRD_RUNNING (start) state.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device context.</span>
<span class="cm"> *      dsp_addr:       DSP address at which to start execution.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.</span>
<span class="cm"> *      -EPERM:      Other, unspecified error.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_ctxt != NULL</span>
<span class="cm"> *      Board is in monitor (BRD_IDLE) state.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        Board is in BRD_RUNNING state.</span>
<span class="cm"> *                      Interrupts to the PC are enabled.</span>
<span class="cm"> *      else:           Board state is indeterminate.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_start</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span>
				    <span class="o">*</span> <span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_mem_copy ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *  Copy memory from one DSP address to another</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_context:    Pointer to context handle</span>
<span class="cm"> *  dsp_dest_addr:  DSP address to copy to</span>
<span class="cm"> *  dsp_src_addr:   DSP address to copy from</span>
<span class="cm"> *  ul_num_bytes: Number of bytes to copy</span>
<span class="cm"> *  mem_type:   What section of memory to copy to</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EPERM:      Other, unspecified error.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_context != NULL</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        Board is in BRD_RUNNING state.</span>
<span class="cm"> *                      Interrupts to the PC are enabled.</span>
<span class="cm"> *      else:           Board state is indeterminate.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_memcopy</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span>
				      <span class="o">*</span> <span class="n">dev_ctxt</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">dsp_dest_addr</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">dsp_src_addr</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_type</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_mem_write ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Write a block of host memory into a DSP address, into a given memory</span>
<span class="cm"> *      space.  Unlike bridge_brd_write, this API does reset the DSP</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device info.</span>
<span class="cm"> *      dsp_addr:       Address on DSP board (Destination).</span>
<span class="cm"> *      host_buf:       Pointer to host buffer (Source).</span>
<span class="cm"> *      ul_num_bytes:     Number of bytes to transfer.</span>
<span class="cm"> *      mem_type:       Memory space on DSP to which to transfer.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.</span>
<span class="cm"> *      -EPERM:      Other, unspecified error.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_ctxt != NULL;</span>
<span class="cm"> *      host_buf != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_memwrite</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span>
				       <span class="o">*</span> <span class="n">dev_ctxt</span><span class="p">,</span>
				       <span class="n">u8</span> <span class="o">*</span><span class="n">host_buf</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">mem_type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_mem_map ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Map a MPU memory region to a DSP/IVA memory space</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device info.</span>
<span class="cm"> *      ul_mpu_addr:      MPU memory region start address.</span>
<span class="cm"> *      virt_addr:      DSP/IVA memory region u8 address.</span>
<span class="cm"> *      ul_num_bytes:     Number of bytes to map.</span>
<span class="cm"> *      map_attrs:       Mapping attributes (e.g. endianness).</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EPERM:      Other, unspecified error.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_ctxt != NULL;</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_memmap</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span>
				     <span class="o">*</span> <span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_mpu_addr</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">virt_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">map_attr</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">mapped_pages</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_mem_un_map ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      UnMap an MPU memory region from DSP/IVA memory space</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device info.</span>
<span class="cm"> *      virt_addr:      DSP/IVA memory region u8 address.</span>
<span class="cm"> *      ul_num_bytes:     Number of bytes to unmap.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EPERM:      Other, unspecified error.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_ctxt != NULL;</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_memunmap</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span>
				       <span class="o">*</span> <span class="n">dev_ctxt</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">virt_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_stop ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Bring board to the BRD_STOPPED state.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device context.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.</span>
<span class="cm"> *      -EPERM:      Other, unspecified error.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_ctxt != NULL</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        Board is in BRD_STOPPED (stop) state;</span>
<span class="cm"> *                      Interrupts to the PC are disabled.</span>
<span class="cm"> *      else:           Board state is indeterminate.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_stop</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_status ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Report the current state of the board.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device context.</span>
<span class="cm"> *      board_state:    Ptr to BRD status variable.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      board_state != NULL;</span>
<span class="cm"> *      dev_ctxt != NULL</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      *board_state is one of</span>
<span class="cm"> *       {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_status</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">board_state</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_read ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Read a block of DSP memory, from a given memory space, into a host</span>
<span class="cm"> *      buffer.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device info.</span>
<span class="cm"> *      host_buf:       Pointer to host buffer (Destination).</span>
<span class="cm"> *      dsp_addr:       Address on DSP board (Source).</span>
<span class="cm"> *      ul_num_bytes:     Number of bytes to transfer.</span>
<span class="cm"> *      mem_type:       Memory space on DSP from which to transfer.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.</span>
<span class="cm"> *      -EPERM:      Other, unspecified error.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_ctxt != NULL;</span>
<span class="cm"> *      host_buf != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *  Will not write more than ul_num_bytes bytes into host_buf.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="o">*</span><span class="n">host_buf</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_write ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Write a block of host memory into a DSP address, into a given memory</span>
<span class="cm"> *      space.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device info.</span>
<span class="cm"> *      dsp_addr:       Address on DSP board (Destination).</span>
<span class="cm"> *      host_buf:       Pointer to host buffer (Source).</span>
<span class="cm"> *      ul_num_bytes:     Number of bytes to transfer.</span>
<span class="cm"> *      mem_type:       Memory space on DSP to which to transfer.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.</span>
<span class="cm"> *      -EPERM:      Other, unspecified error.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_ctxt != NULL;</span>
<span class="cm"> *      host_buf != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_brd_write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="o">*</span><span class="n">host_buf</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create a channel manager object, responsible for opening new channels</span>
<span class="cm"> *      and closing old ones for a given &#39;Bridge board.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      channel_mgr:    Location to store a channel manager object on output.</span>
<span class="cm"> *      hdev_obj:     Handle to a device object.</span>
<span class="cm"> *      mgr_attrts:      Channel manager attributes.</span>
<span class="cm"> *      mgr_attrts-&gt;max_channels: Max channels</span>
<span class="cm"> *      mgr_attrts-&gt;birq:      Channel&#39;s I/O IRQ number.</span>
<span class="cm"> *      mgr_attrts-&gt;irq_shared:   TRUE if the IRQ is shareable.</span>
<span class="cm"> *      mgr_attrts-&gt;word_size: DSP Word size in equivalent PC bytes..</span>
<span class="cm"> *      mgr_attrts-&gt;shm_base:  Base physical address of shared memory, if any.</span>
<span class="cm"> *      mgr_attrts-&gt;sm_length: Bytes of shared memory block.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success;</span>
<span class="cm"> *      -ENOMEM:        Insufficient memory for requested resources.</span>
<span class="cm"> *      -EIO:         Unable to plug ISR for given IRQ.</span>
<span class="cm"> *      -EFAULT:    Couldn&#39;t map physical address to a virtual one.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      channel_mgr != NULL.</span>
<span class="cm"> *      mgr_attrts != NULL</span>
<span class="cm"> *      mgr_attrts field are all valid:</span>
<span class="cm"> *          0 &lt; max_channels &lt;= CHNL_MAXCHANNELS.</span>
<span class="cm"> *          birq &lt;= 15.</span>
<span class="cm"> *          word_size &gt; 0.</span>
<span class="cm"> *      hdev_obj != NULL</span>
<span class="cm"> *      No channel manager exists for this board.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_create</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span>
				      <span class="o">**</span><span class="n">channel_mgr</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dev_object</span>
				      <span class="o">*</span> <span class="n">hdev_obj</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span>
				      <span class="n">chnl_mgrattrs</span> <span class="o">*</span> <span class="n">mgr_attrts</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_destroy ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Close all open channels, and destroy the channel manager.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hchnl_mgr:       Channel manager object.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    hchnl_mgr was invalid.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0: Cancels I/O on each open channel. Closes each open channel.</span>
<span class="cm"> *          chnl_create may subsequently be called for the same device.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_destroy</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">hchnl_mgr</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_deh_notify ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      When notified of DSP error, take appropriate action.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdeh_mgr:        Handle to DEH manager object.</span>
<span class="cm"> *      evnt_mask:    Indicate the type of exception</span>
<span class="cm"> *      error_info:    Error information</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      hdeh_mgr != NULL;</span>
<span class="cm"> *     evnt_mask with a valid exception</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fxn_deh_notify</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">deh_mgr</span> <span class="o">*</span><span class="n">hdeh_mgr</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">evnt_mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_info</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_open ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Open a new half-duplex channel to the DSP board.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      chnl:           Location to store a channel object handle.</span>
<span class="cm"> *      hchnl_mgr:	Handle to channel manager, as returned by</span>
<span class="cm"> *      		CHNL_GetMgr().</span>
<span class="cm"> *      chnl_mode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies</span>
<span class="cm"> *                      direction of data transfer.</span>
<span class="cm"> *      ch_id:        If CHNL_PICKFREE is specified, the channel manager will</span>
<span class="cm"> *                      select a free channel id (default);</span>
<span class="cm"> *                      otherwise this field specifies the id of the channel.</span>
<span class="cm"> *      pattrs:         Channel attributes.  Attribute fields are as follows:</span>
<span class="cm"> *      pattrs-&gt;uio_reqs: Specifies the maximum number of I/O requests which can</span>
<span class="cm"> *                      be pending at any given time. All request packets are</span>
<span class="cm"> *                      preallocated when the channel is opened.</span>
<span class="cm"> *      pattrs-&gt;event_obj: This field allows the user to supply an auto reset</span>
<span class="cm"> *                      event object for channel I/O completion notifications.</span>
<span class="cm"> *                      It is the responsibility of the user to destroy this</span>
<span class="cm"> *                      object AFTER closing the channel.</span>
<span class="cm"> *                      This channel event object can be retrieved using</span>
<span class="cm"> *                      CHNL_GetEventHandle().</span>
<span class="cm"> *      pattrs-&gt;hReserved: The kernel mode handle of this event object.</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:                Success.</span>
<span class="cm"> *      -EFAULT:            hchnl_mgr is invalid.</span>
<span class="cm"> *      -ENOMEM:            Insufficient memory for requested resources.</span>
<span class="cm"> *      -EINVAL:        Invalid number of IOReqs.</span>
<span class="cm"> *      -ENOSR:    No free channels available.</span>
<span class="cm"> *      -ECHRNG:       Channel ID is out of range.</span>
<span class="cm"> *      -EALREADY:        Channel is in use.</span>
<span class="cm"> *      -EIO:         No free IO request packets available for</span>
<span class="cm"> *                              queuing.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      chnl != NULL.</span>
<span class="cm"> *      pattrs != NULL.</span>
<span class="cm"> *      pattrs-&gt;event_obj is a valid event handle.</span>
<span class="cm"> *      pattrs-&gt;hReserved is the kernel mode handle for pattrs-&gt;event_obj.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:                *chnl is a valid channel.</span>
<span class="cm"> *      else:                   *chnl is set to NULL if (chnl != NULL);</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span>
				    <span class="o">**</span><span class="n">chnl</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">hchnl_mgr</span><span class="p">,</span>
				    <span class="n">s8</span> <span class="n">chnl_mode</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">ch_id</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span>
				    <span class="n">chnl_attr</span> <span class="o">*</span> <span class="n">pattrs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_close ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Ensures all pending I/O on this channel is cancelled, discards all</span>
<span class="cm"> *      queued I/O completion notifications, then frees the resources allocated</span>
<span class="cm"> *      for this channel, and makes the corresponding logical channel id</span>
<span class="cm"> *      available for subsequent use.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      chnl_obj:          Handle to a channel object.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success;</span>
<span class="cm"> *      -EFAULT:    Invalid chnl_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      No thread must be blocked on this channel&#39;s I/O completion event.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        chnl_obj is no longer valid.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_close</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_add_io_req ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Enqueue an I/O request for data transfer on a channel to the DSP.</span>
<span class="cm"> *      The direction (mode) is specified in the channel object. Note the DSP</span>
<span class="cm"> *      address is specified for channels opened in direct I/O mode.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      chnl_obj:          Channel object handle.</span>
<span class="cm"> *      host_buf:       Host buffer address source.</span>
<span class="cm"> *      byte_size:	Number of PC bytes to transfer. A zero value indicates</span>
<span class="cm"> *                      that this buffer is the last in the output channel.</span>
<span class="cm"> *                      A zero value is invalid for an input channel.</span>
<span class="cm"> *!     buf_size:       Actual buffer size in host bytes.</span>
<span class="cm"> *      dw_dsp_addr:      DSP address for transfer.  (Currently ignored).</span>
<span class="cm"> *      dw_arg:          A user argument that travels with the buffer.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success;</span>
<span class="cm"> *      -EFAULT: Invalid chnl_obj or host_buf.</span>
<span class="cm"> *      -EPERM:   User cannot mark EOS on an input channel.</span>
<span class="cm"> *      -ECANCELED: I/O has been cancelled on this channel.  No further</span>
<span class="cm"> *                      I/O is allowed.</span>
<span class="cm"> *      -EPIPE:     End of stream was already marked on a previous</span>
<span class="cm"> *                      IORequest on this channel.  No further I/O is expected.</span>
<span class="cm"> *      -EINVAL: Buffer submitted to this output channel is larger than</span>
<span class="cm"> *                      the size of the physical shared memory output window.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0: The buffer will be transferred if the channel is ready;</span>
<span class="cm"> *          otherwise, will be queued for transfer when the channel becomes</span>
<span class="cm"> *          ready.  In any case, notifications of I/O completion are</span>
<span class="cm"> *          asynchronous.</span>
<span class="cm"> *          If byte_size is 0 for an output channel, subsequent CHNL_AddIOReq&#39;s</span>
<span class="cm"> *          on this channel will fail with error code -EPIPE.  The</span>
<span class="cm"> *          corresponding IOC for this I/O request will have its status flag</span>
<span class="cm"> *          set to CHNL_IOCSTATEOS.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_addioreq</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span>
					<span class="o">*</span> <span class="n">chnl_obj</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">host_buf</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">byte_size</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">buf_size</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">dw_dsp_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dw_arg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_get_ioc ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Dequeue an I/O completion record, which contains information about the</span>
<span class="cm"> *      completed I/O request.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      chnl_obj:          Channel object handle.</span>
<span class="cm"> *      timeout:        A value of CHNL_IOCNOWAIT will simply dequeue the</span>
<span class="cm"> *                      first available IOC.</span>
<span class="cm"> *      chan_ioc:       On output, contains host buffer address, bytes</span>
<span class="cm"> *                      transferred, and status of I/O completion.</span>
<span class="cm"> *      chan_ioc-&gt;status:   See chnldefs.h.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT: Invalid chnl_obj or chan_ioc.</span>
<span class="cm"> *      -EREMOTEIO:   CHNL_IOCNOWAIT was specified as the timeout parameter</span>
<span class="cm"> *                      yet no I/O completions were queued.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      timeout == CHNL_IOCNOWAIT.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0: if there are any remaining IOC&#39;s queued before this call</span>
<span class="cm"> *          returns, the channel event object will be left in a signalled</span>
<span class="cm"> *          state.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_getioc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">chnl_ioc</span> <span class="o">*</span><span class="n">chan_ioc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_cancel_io ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Return all I/O requests to the client which have not yet been</span>
<span class="cm"> *      transferred.  The channel&#39;s I/O completion object is</span>
<span class="cm"> *      signalled, and all the I/O requests are queued as IOC&#39;s, with the</span>
<span class="cm"> *      status field set to CHNL_IOCSTATCANCEL.</span>
<span class="cm"> *      This call is typically used in abort situations, and is a prelude to</span>
<span class="cm"> *      chnl_close();</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      chnl_obj:          Channel object handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success;</span>
<span class="cm"> *      -EFAULT:    Invalid chnl_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      Subsequent I/O requests to this channel will not be accepted.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_cancelio</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_flush_io ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      For an output stream (to the DSP), indicates if any IO requests are in</span>
<span class="cm"> *      the output request queue.  For input streams (from the DSP), will</span>
<span class="cm"> *      cancel all pending IO requests.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      chnl_obj:              Channel object handle.</span>
<span class="cm"> *      timeout:            Timeout value for flush operation.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success;</span>
<span class="cm"> *      S_CHNLIOREQUEST:    Returned if any IORequests are in the output queue.</span>
<span class="cm"> *      -EFAULT:        Invalid chnl_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:            No I/O requests will be pending on this channel.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_flushio</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">timeout</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_get_info ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve information related to a channel.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      chnl_obj:          Handle to a valid channel object, or NULL.</span>
<span class="cm"> *      channel_info:   Location to store channel info.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success;</span>
<span class="cm"> *      -EFAULT: Invalid chnl_obj or channel_info.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        channel_info points to a filled in chnl_info struct,</span>
<span class="cm"> *                      if (channel_info != NULL).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_getinfo</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">chnl_info</span> <span class="o">*</span><span class="n">channel_info</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_get_mgr_info ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve information related to the channel manager.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hchnl_mgr:           Handle to a valid channel manager, or NULL.</span>
<span class="cm"> *      ch_id:            Channel ID.</span>
<span class="cm"> *      mgr_info:           Location to store channel manager info.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success;</span>
<span class="cm"> *      -EFAULT: Invalid hchnl_mgr or mgr_info.</span>
<span class="cm"> *      -ECHRNG:   Invalid channel ID.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:            mgr_info points to a filled in chnl_mgrinfo</span>
<span class="cm"> *                          struct, if (mgr_info != NULL).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_getmgrinfo</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span>
					  <span class="o">*</span> <span class="n">hchnl_mgr</span><span class="p">,</span>
					  <span class="n">u32</span> <span class="n">ch_id</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">chnl_mgrinfo</span> <span class="o">*</span><span class="n">mgr_info</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_idle ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Idle a channel. If this is an input channel, or if this is an output</span>
<span class="cm"> *      channel and flush_data is TRUE, all currently enqueued buffers will be</span>
<span class="cm"> *      dequeued (data discarded for output channel).</span>
<span class="cm"> *      If this is an output channel and flush_data is FALSE, this function</span>
<span class="cm"> *      will block until all currently buffered data is output, or the timeout</span>
<span class="cm"> *      specified has been reached.</span>
<span class="cm"> *</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      chnl_obj:          Channel object handle.</span>
<span class="cm"> *      timeout:        If output channel and flush_data is FALSE, timeout value</span>
<span class="cm"> *                      to wait for buffers to be output. (Not used for</span>
<span class="cm"> *                      input channel).</span>
<span class="cm"> *      flush_data:     If output channel and flush_data is TRUE, discard any</span>
<span class="cm"> *                      currently buffered data. If FALSE, wait for currently</span>
<span class="cm"> *                      buffered data to be output, or timeout, whichever</span>
<span class="cm"> *                      occurs first. flush_data is ignored for input channel.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success;</span>
<span class="cm"> *      -EFAULT:        Invalid chnl_obj.</span>
<span class="cm"> *      -ETIMEDOUT: Timeout occurred before channel could be idled.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_idle</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">bool</span> <span class="n">flush_data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_register_notify ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Register for notification of events on a channel.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      chnl_obj:          Channel object handle.</span>
<span class="cm"> *      event_mask:     Type of events to be notified about: IO completion</span>
<span class="cm"> *                      (DSP_STREAMIOCOMPLETION) or end of stream</span>
<span class="cm"> *                      (DSP_STREAMDONE).</span>
<span class="cm"> *      notify_type:    DSP_SIGNALEVENT.</span>
<span class="cm"> *      hnotification:  Handle of a dsp_notification object.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ENOMEM:    Insufficient memory.</span>
<span class="cm"> *      -EINVAL:     event_mask is 0 and hnotification was not</span>
<span class="cm"> *                      previously registered.</span>
<span class="cm"> *      -EFAULT:    NULL hnotification, hnotification event name</span>
<span class="cm"> *                      too long, or hnotification event name NULL.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid chnl_obj.</span>
<span class="cm"> *      hnotification != NULL.</span>
<span class="cm"> *      (event_mask &amp; ~(DSP_STREAMIOCOMPLETION | DSP_STREAMDONE)) == 0.</span>
<span class="cm"> *      notify_type == DSP_SIGNALEVENT.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_chnl_registernotify</span><span class="p">)</span>
 <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span>
  <span class="n">u32</span> <span class="n">event_mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">notify_type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dsp_notification</span> <span class="o">*</span><span class="n">hnotification</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_dev_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Complete creation of the device object for this board.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      device_ctx:     Ptr to location to store a Bridge device context.</span>
<span class="cm"> *      hdev_obj:     Handle to a Device Object, created and managed by DSP API.</span>
<span class="cm"> *      config_param:        Ptr to configuration parameters provided by the</span>
<span class="cm"> *                      Configuration Manager during device loading.</span>
<span class="cm"> *      pDspConfig:     DSP resources, as specified in the registry key for this</span>
<span class="cm"> *                      device.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -ENOMEM:        Unable to allocate memory for device context.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      device_ctx != NULL;</span>
<span class="cm"> *      hdev_obj != NULL;</span>
<span class="cm"> *      config_param != NULL;</span>
<span class="cm"> *      pDspConfig != NULL;</span>
<span class="cm"> *      Fields in config_param and pDspConfig contain valid values.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        All Bridge driver specific DSP resource and other</span>
<span class="cm"> *                      board context has been allocated.</span>
<span class="cm"> *      -ENOMEM:    Bridge failed to allocate resources.</span>
<span class="cm"> *                      Any acquired resources have been freed.  The DSP API</span>
<span class="cm"> *                      will not call bridge_dev_destroy() if</span>
<span class="cm"> *                      bridge_dev_create() fails.</span>
<span class="cm"> *  Details:</span>
<span class="cm"> *      Called during the CONFIGMG&#39;s Device_Init phase. Based on host and</span>
<span class="cm"> *      DSP configuration information, create a board context, a handle to</span>
<span class="cm"> *      which is passed into other Bridge BRD and CHNL functions.  The</span>
<span class="cm"> *      board context contains state information for the device. Since the</span>
<span class="cm"> *      addresses of all pointer parameters may be invalid when this</span>
<span class="cm"> *      function returns, they must not be stored into the device context</span>
<span class="cm"> *      structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_dev_create</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span>
				     <span class="o">**</span><span class="n">device_ctx</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dev_object</span>
				     <span class="o">*</span> <span class="n">hdev_obj</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">cfg_hostres</span>
				     <span class="o">*</span> <span class="n">config_param</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_dev_ctrl ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Bridge driver specific interface.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device info.</span>
<span class="cm"> *      dw_cmd:          Bridge driver defined command code.</span>
<span class="cm"> *      pargs:          Pointer to an arbitrary argument structure.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0 or -EPERM. Actual command error codes should be passed back in</span>
<span class="cm"> *      the pargs structure, and are defined by the Bridge driver implementor.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      All calls are currently assumed to be synchronous.  There are no</span>
<span class="cm"> *      IOCTL completion routines provided.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_dev_ctrl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">dw_cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pargs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_dev_destroy ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Deallocate Bridge device extension structures and all other resources</span>
<span class="cm"> *      acquired by the Bridge driver.</span>
<span class="cm"> *      No calls to other Bridge driver functions may subsequently</span>
<span class="cm"> *      occur, except for bridge_dev_create().</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device information.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EPERM:      Failed to release a resource previously acquired.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_ctxt != NULL;</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0: Device context is freed.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_dev_destroy</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_io_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create an object that manages I/O between CHNL and msg_ctrl.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      io_man:         Location to store IO manager on output.</span>
<span class="cm"> *      hchnl_mgr:       Handle to channel manager.</span>
<span class="cm"> *      hmsg_mgr:        Handle to message manager.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ENOMEM:    Memory allocation failure.</span>
<span class="cm"> *      -EPERM:      Creation failed.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      hdev_obj != NULL;</span>
<span class="cm"> *      Channel manager already created;</span>
<span class="cm"> *      Message manager already created;</span>
<span class="cm"> *      mgr_attrts != NULL;</span>
<span class="cm"> *      io_man != NULL;</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_io_create</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">**</span><span class="n">io_man</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">io_attrs</span> <span class="o">*</span><span class="n">mgr_attrts</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_io_destroy ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Destroy object created in bridge_io_create.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hio_mgr:         IO Manager.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ENOMEM:    Memory allocation failure.</span>
<span class="cm"> *      -EPERM:      Creation failed.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid hio_mgr;</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_io_destroy</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_io_on_loaded ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Called whenever a program is loaded to update internal data. For</span>
<span class="cm"> *      example, if shared memory is used, this function would update the</span>
<span class="cm"> *      shared memory location and address.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hio_mgr:     IO Manager.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:    Success.</span>
<span class="cm"> *      -EPERM:  Internal failure occurred.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid hio_mgr;</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_io_onloaded</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== fxn_io_getprocload ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Called to get the Processor&#39;s current and predicted load</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hio_mgr:     IO Manager.</span>
<span class="cm"> *      proc_load_stat   Processor Load statistics</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:    Success.</span>
<span class="cm"> *      -EPERM:  Internal failure occurred.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid hio_mgr;</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_io_getprocload</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dsp_procloadstat</span> <span class="o">*</span>
					 <span class="n">proc_load_stat</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_msg_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create an object to manage message queues. Only one of these objects</span>
<span class="cm"> *      can exist per device object.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      msg_man:            Location to store msg_ctrl manager on output.</span>
<span class="cm"> *      hdev_obj:         Handle to a device object.</span>
<span class="cm"> *      msg_callback:        Called whenever an RMS_EXIT message is received.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -ENOMEM:        Insufficient memory.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      msg_man != NULL.</span>
<span class="cm"> *      msg_callback != NULL.</span>
<span class="cm"> *      hdev_obj != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_msg_create</span><span class="p">)</span>
 <span class="p">(</span><span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">**</span><span class="n">msg_man</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="n">msg_onexit</span> <span class="n">msg_callback</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_msg_create_queue ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create a msg_ctrl queue for sending or receiving messages from a Message</span>
<span class="cm"> *      node on the DSP.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hmsg_mgr:            msg_ctrl queue manager handle returned from</span>
<span class="cm"> *                          bridge_msg_create.</span>
<span class="cm"> *      msgq:               Location to store msg_ctrl queue on output.</span>
<span class="cm"> *      msgq_id:	    Identifier for messages (node environment pointer).</span>
<span class="cm"> *      max_msgs:           Max number of simultaneous messages for the node.</span>
<span class="cm"> *      h:                  Handle passed to hmsg_mgr-&gt;msg_callback().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -ENOMEM:        Insufficient memory.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      msgq != NULL.</span>
<span class="cm"> *      h != NULL.</span>
<span class="cm"> *      max_msgs &gt; 0.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      msgq !=NULL &lt;==&gt; 0.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_msg_createqueue</span><span class="p">)</span>
 <span class="p">(</span><span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmsg_mgr</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">**</span><span class="n">msgq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msgq_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">max_msgs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_msg_delete ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Delete a msg_ctrl manager allocated in bridge_msg_create().</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hmsg_mgr:    Handle returned from bridge_msg_create().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid hmsg_mgr.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fxn_msg_delete</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmsg_mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_msg_delete_queue ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Delete a msg_ctrl queue allocated in bridge_msg_create_queue.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      msg_queue_obj:  Handle to msg_ctrl queue returned from</span>
<span class="cm"> *                  bridge_msg_create_queue.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid msg_queue_obj.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fxn_msg_deletequeue</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msg_queue_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_msg_get ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Get a message from a msg_ctrl queue.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      msg_queue_obj:     Handle to msg_ctrl queue returned from</span>
<span class="cm"> *                     bridge_msg_create_queue.</span>
<span class="cm"> *      pmsg:          Location to copy message into.</span>
<span class="cm"> *      utimeout:      Timeout to wait for a message.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:       Success.</span>
<span class="cm"> *      -ETIME:  Timeout occurred.</span>
<span class="cm"> *      -EPERM:     No frames available for message (max_msgs too</span>
<span class="cm"> *                     small).</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid msg_queue_obj.</span>
<span class="cm"> *      pmsg != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_msg_get</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msg_queue_obj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dsp_msg</span> <span class="o">*</span><span class="n">pmsg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">utimeout</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_msg_put ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Put a message onto a msg_ctrl queue.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      msg_queue_obj:      Handle to msg_ctrl queue returned from</span>
<span class="cm"> *                      bridge_msg_create_queue.</span>
<span class="cm"> *      pmsg:           Pointer to message.</span>
<span class="cm"> *      utimeout:       Timeout to wait for a message.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ETIME:   Timeout occurred.</span>
<span class="cm"> *      -EPERM:      No frames available for message (max_msgs too</span>
<span class="cm"> *                      small).</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid msg_queue_obj.</span>
<span class="cm"> *      pmsg != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_msg_put</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msg_queue_obj</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_msg</span> <span class="o">*</span><span class="n">pmsg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">utimeout</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_msg_register_notify ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Register notification for when a message is ready.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      msg_queue_obj:      Handle to msg_ctrl queue returned from</span>
<span class="cm"> *                      bridge_msg_create_queue.</span>
<span class="cm"> *      event_mask:     Type of events to be notified about: Must be</span>
<span class="cm"> *                      DSP_NODEMESSAGEREADY, or 0 to unregister.</span>
<span class="cm"> *      notify_type:    DSP_SIGNALEVENT.</span>
<span class="cm"> *      hnotification:  Handle of notification object.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ENOMEM:    Insufficient memory.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid msg_queue_obj.</span>
<span class="cm"> *      hnotification != NULL.</span>
<span class="cm"> *      notify_type == DSP_SIGNALEVENT.</span>
<span class="cm"> *      event_mask == DSP_NODEMESSAGEREADY || event_mask == 0.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fxn_msg_registernotify</span><span class="p">)</span>
 <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msg_queue_obj</span><span class="p">,</span>
  <span class="n">u32</span> <span class="n">event_mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">notify_type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dsp_notification</span> <span class="o">*</span><span class="n">hnotification</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_msg_set_queue_id ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Set message queue id to node environment. Allows bridge_msg_create_queue</span>
<span class="cm"> *      to be called in node_allocate, before the node environment is known.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      msg_queue_obj:  Handle to msg_ctrl queue returned from</span>
<span class="cm"> *                  bridge_msg_create_queue.</span>
<span class="cm"> *      msgq_id:       Node environment pointer.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid msg_queue_obj.</span>
<span class="cm"> *      msgq_id != 0.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fxn_msg_setqueueid</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msg_queue_obj</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">msgq_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  Bridge Driver interface function table.</span>
<span class="cm"> *</span>
<span class="cm"> *  The information in this table is filled in by the specific Bridge driver,</span>
<span class="cm"> *  and copied into the DSP API&#39;s own space.  If any interface</span>
<span class="cm"> *  function field is set to a value of NULL, then the DSP API will</span>
<span class="cm"> *  consider that function not implemented, and return the error code</span>
<span class="cm"> *  -ENOSYS when a Bridge driver client attempts to call that function.</span>
<span class="cm"> *</span>
<span class="cm"> *  This function table contains DSP API version numbers, which are used by the</span>
<span class="cm"> *  Bridge driver loader to help ensure backwards compatility between older</span>
<span class="cm"> *  Bridge drivers and newer DSP API.  These must be set to</span>
<span class="cm"> *  BRD_API_MAJOR_VERSION and BRD_API_MINOR_VERSION, respectively.</span>
<span class="cm"> *</span>
<span class="cm"> *  A Bridge driver need not export a CHNL interface.  In this case, *all* of</span>
<span class="cm"> *  the bridge_chnl_* entries must be set to NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">brd_api_major_version</span><span class="p">;</span>	<span class="cm">/* Set to BRD_API_MAJOR_VERSION. */</span>
	<span class="n">u32</span> <span class="n">brd_api_minor_version</span><span class="p">;</span>	<span class="cm">/* Set to BRD_API_MINOR_VERSION. */</span>
	<span class="n">fxn_dev_create</span> <span class="n">dev_create</span><span class="p">;</span>	<span class="cm">/* Create device context */</span>
	<span class="n">fxn_dev_destroy</span> <span class="n">dev_destroy</span><span class="p">;</span>	<span class="cm">/* Destroy device context */</span>
	<span class="n">fxn_dev_ctrl</span> <span class="n">dev_cntrl</span><span class="p">;</span>	<span class="cm">/* Optional vendor interface */</span>
	<span class="n">fxn_brd_monitor</span> <span class="n">brd_monitor</span><span class="p">;</span>	<span class="cm">/* Load and/or start monitor */</span>
	<span class="n">fxn_brd_start</span> <span class="n">brd_start</span><span class="p">;</span>	<span class="cm">/* Start DSP program. */</span>
	<span class="n">fxn_brd_stop</span> <span class="n">brd_stop</span><span class="p">;</span>	<span class="cm">/* Stop/reset board. */</span>
	<span class="n">fxn_brd_status</span> <span class="n">brd_status</span><span class="p">;</span>	<span class="cm">/* Get current board status. */</span>
	<span class="n">fxn_brd_read</span> <span class="n">brd_read</span><span class="p">;</span>	<span class="cm">/* Read board memory */</span>
	<span class="n">fxn_brd_write</span> <span class="n">brd_write</span><span class="p">;</span>	<span class="cm">/* Write board memory. */</span>
	<span class="n">fxn_brd_setstate</span> <span class="n">brd_set_state</span><span class="p">;</span>	<span class="cm">/* Sets the Board State */</span>
	<span class="n">fxn_brd_memcopy</span> <span class="n">brd_mem_copy</span><span class="p">;</span>	<span class="cm">/* Copies DSP Memory */</span>
	<span class="n">fxn_brd_memwrite</span> <span class="n">brd_mem_write</span><span class="p">;</span>	<span class="cm">/* Write DSP Memory w/o halt */</span>
	<span class="n">fxn_brd_memmap</span> <span class="n">brd_mem_map</span><span class="p">;</span>	<span class="cm">/* Maps MPU mem to DSP mem */</span>
	<span class="n">fxn_brd_memunmap</span> <span class="n">brd_mem_un_map</span><span class="p">;</span>	<span class="cm">/* Unmaps MPU mem to DSP mem */</span>
	<span class="n">fxn_chnl_create</span> <span class="n">chnl_create</span><span class="p">;</span>	<span class="cm">/* Create channel manager. */</span>
	<span class="n">fxn_chnl_destroy</span> <span class="n">chnl_destroy</span><span class="p">;</span>	<span class="cm">/* Destroy channel manager. */</span>
	<span class="n">fxn_chnl_open</span> <span class="n">chnl_open</span><span class="p">;</span>	<span class="cm">/* Create a new channel. */</span>
	<span class="n">fxn_chnl_close</span> <span class="n">chnl_close</span><span class="p">;</span>	<span class="cm">/* Close a channel. */</span>
	<span class="n">fxn_chnl_addioreq</span> <span class="n">chnl_add_io_req</span><span class="p">;</span>	<span class="cm">/* Req I/O on a channel. */</span>
	<span class="n">fxn_chnl_getioc</span> <span class="n">chnl_get_ioc</span><span class="p">;</span>	<span class="cm">/* Wait for I/O completion. */</span>
	<span class="n">fxn_chnl_cancelio</span> <span class="n">chnl_cancel_io</span><span class="p">;</span>	<span class="cm">/* Cancl I/O on a channel. */</span>
	<span class="n">fxn_chnl_flushio</span> <span class="n">chnl_flush_io</span><span class="p">;</span>	<span class="cm">/* Flush I/O. */</span>
	<span class="n">fxn_chnl_getinfo</span> <span class="n">chnl_get_info</span><span class="p">;</span>	<span class="cm">/* Get channel specific info */</span>
	<span class="cm">/* Get channel manager info. */</span>
	<span class="n">fxn_chnl_getmgrinfo</span> <span class="n">chnl_get_mgr_info</span><span class="p">;</span>
	<span class="n">fxn_chnl_idle</span> <span class="n">chnl_idle</span><span class="p">;</span>	<span class="cm">/* Idle the channel */</span>
	<span class="cm">/* Register for notif. */</span>
	<span class="n">fxn_chnl_registernotify</span> <span class="n">chnl_register_notify</span><span class="p">;</span>
	<span class="n">fxn_io_create</span> <span class="n">io_create</span><span class="p">;</span>	<span class="cm">/* Create IO manager */</span>
	<span class="n">fxn_io_destroy</span> <span class="n">io_destroy</span><span class="p">;</span>	<span class="cm">/* Destroy IO manager */</span>
	<span class="n">fxn_io_onloaded</span> <span class="n">io_on_loaded</span><span class="p">;</span>	<span class="cm">/* Notify of program loaded */</span>
	<span class="cm">/* Get Processor&#39;s current and predicted load */</span>
	<span class="n">fxn_io_getprocload</span> <span class="n">io_get_proc_load</span><span class="p">;</span>
	<span class="n">fxn_msg_create</span> <span class="n">msg_create</span><span class="p">;</span>	<span class="cm">/* Create message manager */</span>
	<span class="cm">/* Create message queue */</span>
	<span class="n">fxn_msg_createqueue</span> <span class="n">msg_create_queue</span><span class="p">;</span>
	<span class="n">fxn_msg_delete</span> <span class="n">msg_delete</span><span class="p">;</span>	<span class="cm">/* Delete message manager */</span>
	<span class="cm">/* Delete message queue */</span>
	<span class="n">fxn_msg_deletequeue</span> <span class="n">msg_delete_queue</span><span class="p">;</span>
	<span class="n">fxn_msg_get</span> <span class="n">msg_get</span><span class="p">;</span>	<span class="cm">/* Get a message */</span>
	<span class="n">fxn_msg_put</span> <span class="n">msg_put</span><span class="p">;</span>	<span class="cm">/* Send a message */</span>
	<span class="cm">/* Register for notif. */</span>
	<span class="n">fxn_msg_registernotify</span> <span class="n">msg_register_notify</span><span class="p">;</span>
	<span class="cm">/* Set message queue id */</span>
	<span class="n">fxn_msg_setqueueid</span> <span class="n">msg_set_queue_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_drv_entry ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Registers Bridge driver functions with the DSP API. Called only once</span>
<span class="cm"> *      by the DSP API.  The caller will first check DSP API version</span>
<span class="cm"> *      compatibility, and then copy the interface functions into its own</span>
<span class="cm"> *      memory space.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      drv_intf  Pointer to a location to receive a pointer to the</span>
<span class="cm"> *                      Bridge driver interface.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      The code segment this function resides in must expect to be discarded</span>
<span class="cm"> *      after completion.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      drv_intf pointer initialized to Bridge driver&#39;s function</span>
<span class="cm"> *      interface. No system resources are acquired by this function.</span>
<span class="cm"> *  Details:</span>
<span class="cm"> *      Called during the Device_Init phase.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">bridge_drv_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">**</span><span class="n">drv_intf</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_file_name</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* DSPDEFS_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
