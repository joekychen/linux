<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › include › dspbridge › dblldefs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>dblldefs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * dblldefs.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef DBLLDEFS_</span>
<span class="cp">#define DBLLDEFS_</span>

<span class="cm">/*</span>
<span class="cm"> *  Bit masks for dbl_flags.</span>
<span class="cm"> */</span>
<span class="cp">#define DBLL_NOLOAD   0x0	</span><span class="cm">/* Don&#39;t load symbols, code, or data */</span><span class="cp"></span>
<span class="cp">#define DBLL_SYMB     0x1	</span><span class="cm">/* load symbols */</span><span class="cp"></span>
<span class="cp">#define DBLL_CODE     0x2	</span><span class="cm">/* load code */</span><span class="cp"></span>
<span class="cp">#define DBLL_DATA     0x4	</span><span class="cm">/* load data */</span><span class="cp"></span>
<span class="cp">#define DBLL_DYNAMIC  0x8	</span><span class="cm">/* dynamic load */</span><span class="cp"></span>
<span class="cp">#define DBLL_BSS      0x20	</span><span class="cm">/* Unitialized section */</span><span class="cp"></span>

<span class="cp">#define DBLL_MAXPATHLENGTH       255</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== DBLL_Target ========</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dbll_tar_obj</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_flags ========</span>
<span class="cm"> *  Specifies whether to load code, data, or symbols</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">s32</span> <span class="n">dbll_flags</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== DBLL_Library ========</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dbll_library_obj</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_sect_info ========</span>
<span class="cm"> *  For collecting info on overlay sections</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dbll_sect_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>	<span class="cm">/* name of section */</span>
	<span class="n">u32</span> <span class="n">sect_run_addr</span><span class="p">;</span>	<span class="cm">/* run address of section */</span>
	<span class="n">u32</span> <span class="n">sect_load_addr</span><span class="p">;</span>	<span class="cm">/* load address of section */</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* size of section (target MAUs) */</span>
	<span class="n">dbll_flags</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* Code, data, or BSS */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_sym_val ========</span>
<span class="cm"> *  (Needed for dynamic load library)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dbll_sym_val</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_alloc_fxn ========</span>
<span class="cm"> *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)</span>
<span class="cm"> *  &quot;size&quot; bytes of memory from segment &quot;space&quot; and return the address in</span>
<span class="cm"> *  *dsp_address (or starting at *dsp_address if reserve == TRUE). Returns 0 on</span>
<span class="cm"> *  success, or an error code on failure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">s32</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_alloc_fxn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span> <span class="n">s32</span> <span class="n">space</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">align</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="o">*</span><span class="n">dsp_address</span><span class="p">,</span> <span class="n">s32</span> <span class="n">seg_id</span><span class="p">,</span> <span class="n">s32</span> <span class="n">req</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">reserved</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_close_fxn ========</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">s32</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_f_close_fxn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_free_fxn ========</span>
<span class="cm"> *  Free memory function.  Free, or unreserve (if reserved == TRUE) &quot;size&quot;</span>
<span class="cm"> *  bytes of memory from segment &quot;space&quot;</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">bool</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_free_fxn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">s32</span> <span class="n">space</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">reserved</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_f_open_fxn ========</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_f_open_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_log_write_fxn ========</span>
<span class="cm"> *  Function to call when writing data from a section, to log the info.</span>
<span class="cm"> *  Can be NULL if no logging is required.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_log_write_fxn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dbll_sect_info</span> <span class="o">*</span><span class="n">sect</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">bytes</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_read_fxn ========</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">s32</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_read_fxn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_seek_fxn ========</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">s32</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_seek_fxn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_sym_lookup ========</span>
<span class="cm"> *  Symbol lookup function - Find the symbol name and return its value.</span>
<span class="cm"> *</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      handle          - Opaque handle</span>
<span class="cm"> *      parg            - Opaque argument.</span>
<span class="cm"> *      name            - Name of symbol to lookup.</span>
<span class="cm"> *      sym             - Location to store address of symbol structure.</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      TRUE:           Success (symbol was found).</span>
<span class="cm"> *      FALSE:          Failed to find symbol.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">bool</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_sym_lookup</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">parg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rmm_handle</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dbll_sym_val</span> <span class="o">**</span> <span class="n">sym</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_tell_fxn ========</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">s32</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_tell_fxn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_write_fxn ========</span>
<span class="cm"> *  Write memory function.  Write &quot;n&quot; HOST bytes of memory to segment &quot;mtype&quot;</span>
<span class="cm"> *  starting at address &quot;dsp_address&quot; from the buffer &quot;buf&quot;.  The buffer is</span>
<span class="cm"> *  formatted as an array of words appropriate for the DSP.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">s32</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_write_fxn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_address</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">n</span><span class="p">,</span> <span class="n">s32</span> <span class="n">mtype</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_attrs ========</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dbll_attrs</span> <span class="p">{</span>
	<span class="n">dbll_alloc_fxn</span> <span class="n">alloc</span><span class="p">;</span>
	<span class="n">dbll_free_fxn</span> <span class="n">free</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rmm_handle</span><span class="p">;</span>	<span class="cm">/* Handle to pass to alloc, free functions */</span>
	<span class="n">dbll_write_fxn</span> <span class="n">write</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">input_params</span><span class="p">;</span>	<span class="cm">/* Handle to pass to write, cinit function */</span>
	<span class="n">bool</span> <span class="n">base_image</span><span class="p">;</span>
	<span class="n">dbll_log_write_fxn</span> <span class="n">log_write</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">log_write_handle</span><span class="p">;</span>

	<span class="cm">/* Symbol matching function and handle to pass to it */</span>
	<span class="n">dbll_sym_lookup</span> <span class="n">sym_lookup</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sym_handle</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sym_arg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  These file manipulation functions should be compatible with the</span>
<span class="cm">	 *  &quot;C&quot; run time library functions of the same name.</span>
<span class="cm">	 */</span>
	 <span class="n">s32</span><span class="p">(</span><span class="o">*</span><span class="n">fread</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	 <span class="n">s32</span><span class="p">(</span><span class="o">*</span><span class="n">fseek</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	 <span class="n">s32</span><span class="p">(</span><span class="o">*</span><span class="n">ftell</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	 <span class="n">s32</span><span class="p">(</span><span class="o">*</span><span class="n">fclose</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">fopen</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_close ========</span>
<span class="cm"> *  Close library opened with dbll_open.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      lib             - Handle returned from dbll_open().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      Valid lib.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dbll_close_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">library</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_create ========</span>
<span class="cm"> *  Create a target object, specifying the alloc, free, and write functions.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      target_obj         - Location to store target handle on output.</span>
<span class="cm"> *      pattrs          - Attributes.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ENOMEM:    Memory allocation failed.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      pattrs != NULL.</span>
<span class="cm"> *      target_obj != NULL;</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      Success:        *target_obj != NULL.</span>
<span class="cm"> *      Failure:        *target_obj == NULL.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_create_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_tar_obj</span> <span class="o">**</span><span class="n">target_obj</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dbll_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_delete ========</span>
<span class="cm"> *  Delete target object and free resources for any loaded libraries.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      target          - Handle returned from DBLL_Create().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      Valid target.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dbll_delete_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_tar_obj</span> <span class="o">*</span><span class="n">target</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_exit ========</span>
<span class="cm"> *  Discontinue use of DBL module.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      refs &gt; 0.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      refs &gt;= 0.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dbll_exit_fxn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_get_addr ========</span>
<span class="cm"> *  Get address of name in the specified library.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      lib             - Handle returned from dbll_open().</span>
<span class="cm"> *      name            - Name of symbol</span>
<span class="cm"> *      sym_val         - Location to store symbol address on output.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      TRUE:           Success.</span>
<span class="cm"> *      FALSE:          Symbol not found.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      Valid library.</span>
<span class="cm"> *      name != NULL.</span>
<span class="cm"> *      sym_val != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">bool</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_get_addr_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">lib</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dbll_sym_val</span> <span class="o">**</span><span class="n">sym_val</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_get_attrs ========</span>
<span class="cm"> *  Retrieve the attributes of the target.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      target          - Handle returned from DBLL_Create().</span>
<span class="cm"> *      pattrs          - Location to store attributes on output.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      Valid target.</span>
<span class="cm"> *      pattrs != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dbll_get_attrs_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_tar_obj</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dbll_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_get_c_addr ========</span>
<span class="cm"> *  Get address of &quot;C&quot; name on the specified library.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      lib             - Handle returned from dbll_open().</span>
<span class="cm"> *      name            - Name of symbol</span>
<span class="cm"> *      sym_val         - Location to store symbol address on output.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      TRUE:           Success.</span>
<span class="cm"> *      FALSE:          Symbol not found.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      Valid target.</span>
<span class="cm"> *      name != NULL.</span>
<span class="cm"> *      sym_val != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">bool</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_get_c_addr_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">lib</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dbll_sym_val</span> <span class="o">**</span><span class="n">sym_val</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_get_sect ========</span>
<span class="cm"> *  Get address and size of a named section.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      lib             - Library handle returned from dbll_open().</span>
<span class="cm"> *      name            - Name of section.</span>
<span class="cm"> *      paddr           - Location to store section address on output.</span>
<span class="cm"> *      psize           - Location to store section size on output.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ENXIO:    Section not found.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      Valid lib.</span>
<span class="cm"> *      name != NULL.</span>
<span class="cm"> *      paddr != NULL;</span>
<span class="cm"> *      psize != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_get_sect_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">lib</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_init ========</span>
<span class="cm"> *  Initialize DBL module.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      TRUE:           Success.</span>
<span class="cm"> *      FALSE:          Failure.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      refs &gt;= 0.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      Success:        refs &gt; 0.</span>
<span class="cm"> *      Failure:        refs &gt;= 0.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">bool</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_init_fxn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_load ========</span>
<span class="cm"> *  Load library onto the target.</span>
<span class="cm"> *</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      lib             - Library handle returned from dbll_open().</span>
<span class="cm"> *      flags           - Load code, data and/or symbols.</span>
<span class="cm"> *      attrs           - May contain alloc, free, and write function.</span>
<span class="cm"> *      entry_pt        - Location to store program entry on output.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EBADF:     File read failed.</span>
<span class="cm"> *      -EILSEQ:   Failure in dynamic loader library.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      Valid lib.</span>
<span class="cm"> *      entry != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_load_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">lib</span><span class="p">,</span>
				    <span class="n">dbll_flags</span> <span class="n">flags</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dbll_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_open ========</span>
<span class="cm"> *  dbll_open() returns a library handle that can be used to load/unload</span>
<span class="cm"> *  the symbols/code/data via dbll_load()/dbll_unload().</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      target          - Handle returned from dbll_create().</span>
<span class="cm"> *      file            - Name of file to open.</span>
<span class="cm"> *      flags           - If flags &amp; DBLL_SYMB, load symbols.</span>
<span class="cm"> *      lib_obj         - Location to store library handle on output.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -ENOMEM:        Memory allocation failure.</span>
<span class="cm"> *      -EBADF:         File open/read failure.</span>
<span class="cm"> *                      Unable to determine target type.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      Valid target.</span>
<span class="cm"> *      file != NULL.</span>
<span class="cm"> *      lib_obj != NULL.</span>
<span class="cm"> *      dbll_attrs fopen function non-NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      Success:        Valid *lib_obj.</span>
<span class="cm"> *      Failure:        *lib_obj == NULL.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_open_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_tar_obj</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				    <span class="n">dbll_flags</span> <span class="n">flags</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">**</span><span class="n">lib_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_read_sect ========</span>
<span class="cm"> *  Read COFF section into a character buffer.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      lib             - Library handle returned from dbll_open().</span>
<span class="cm"> *      name            - Name of section.</span>
<span class="cm"> *      pbuf            - Buffer to write section contents into.</span>
<span class="cm"> *      size            - Buffer size</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ENXIO:    Named section does not exists.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      Valid lib.</span>
<span class="cm"> *      name != NULL.</span>
<span class="cm"> *      pbuf != NULL.</span>
<span class="cm"> *      size != 0.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">dbll_read_sect_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">lib</span><span class="p">,</span>
					 <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">cont_size</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> *  ======== dbll_unload ========</span>
<span class="cm"> *  Unload library loaded with dbll_load().</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      lib             - Handle returned from dbll_open().</span>
<span class="cm"> *      attrs           - Contains free() function and handle to pass to it.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DBL initialized.</span>
<span class="cm"> *      Valid lib.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dbll_unload_fxn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbll_library_obj</span> <span class="o">*</span><span class="n">library</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dbll_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dbll_fxns</span> <span class="p">{</span>
	<span class="n">dbll_close_fxn</span> <span class="n">close_fxn</span><span class="p">;</span>
	<span class="n">dbll_create_fxn</span> <span class="n">create_fxn</span><span class="p">;</span>
	<span class="n">dbll_delete_fxn</span> <span class="n">delete_fxn</span><span class="p">;</span>
	<span class="n">dbll_exit_fxn</span> <span class="n">exit_fxn</span><span class="p">;</span>
	<span class="n">dbll_get_attrs_fxn</span> <span class="n">get_attrs_fxn</span><span class="p">;</span>
	<span class="n">dbll_get_addr_fxn</span> <span class="n">get_addr_fxn</span><span class="p">;</span>
	<span class="n">dbll_get_c_addr_fxn</span> <span class="n">get_c_addr_fxn</span><span class="p">;</span>
	<span class="n">dbll_get_sect_fxn</span> <span class="n">get_sect_fxn</span><span class="p">;</span>
	<span class="n">dbll_init_fxn</span> <span class="n">init_fxn</span><span class="p">;</span>
	<span class="n">dbll_load_fxn</span> <span class="n">load_fxn</span><span class="p">;</span>
	<span class="n">dbll_open_fxn</span> <span class="n">open_fxn</span><span class="p">;</span>
	<span class="n">dbll_read_sect_fxn</span> <span class="n">read_sect_fxn</span><span class="p">;</span>
	<span class="n">dbll_unload_fxn</span> <span class="n">unload_fxn</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* DBLDEFS_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
