<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › include › dspbridge › cmm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>cmm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * cmm.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * The Communication Memory Management(CMM) module provides shared memory</span>
<span class="cm"> * management services for DSP/BIOS Bridge data streaming and messaging.</span>
<span class="cm"> * Multiple shared memory segments can be registered with CMM. Memory is</span>
<span class="cm"> * coelesced back to the appropriate pool when a buffer is freed.</span>
<span class="cm"> *</span>
<span class="cm"> * The CMM_Xlator[xxx] functions are used for node messaging and data</span>
<span class="cm"> * streaming address translation to perform zero-copy inter-processor</span>
<span class="cm"> * data transfer(GPP&lt;-&gt;DSP). A &quot;translator&quot; object is created for a node or</span>
<span class="cm"> * stream object that contains per thread virtual address information. This</span>
<span class="cm"> * translator info is used at runtime to perform SM address translation</span>
<span class="cm"> * to/from the DSP address space.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *   cmm_xlator_alloc_buf - Used by Node and Stream modules for SM address</span>
<span class="cm"> *			  translation.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef CMM_</span>
<span class="cp">#define CMM_</span>

<span class="cp">#include &lt;dspbridge/devdefs.h&gt;</span>

<span class="cp">#include &lt;dspbridge/cmmdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_calloc_buf ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Allocate memory buffers that can be used for data streaming or</span>
<span class="cm"> *      messaging.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hcmm_mgr:   Cmm Mgr handle.</span>
<span class="cm"> *      usize:     Number of bytes to allocate.</span>
<span class="cm"> *      pattr:     Attributes of memory to allocate.</span>
<span class="cm"> *      pp_buf_va:   Address of where to place VA.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      Pointer to a zero&#39;d block of SM memory;</span>
<span class="cm"> *      NULL if memory couldn&#39;t be allocated,</span>
<span class="cm"> *      or if byte_size == 0,</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid hcmm_mgr.</span>
<span class="cm"> *      CMM initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      The returned pointer, if not NULL, points to a valid memory block of</span>
<span class="cm"> *      the size requested.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cmm_calloc_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">*</span><span class="n">hcmm_mgr</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">usize</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cmm_attrs</span> <span class="o">*</span><span class="n">pattrs</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">**</span><span class="n">pp_buf_va</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create a communication memory manager object.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      ph_cmm_mgr:	Location to store a communication manager handle on</span>
<span class="cm"> *      		output.</span>
<span class="cm"> *      hdev_obj: Handle to a device object.</span>
<span class="cm"> *      mgr_attrts: Comm mem manager attributes.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success;</span>
<span class="cm"> *      -ENOMEM:    Insufficient memory for requested resources.</span>
<span class="cm"> *      -EPERM:      Failed to initialize critical sect sync object.</span>
<span class="cm"> *</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      ph_cmm_mgr != NULL.</span>
<span class="cm"> *      mgr_attrts-&gt;min_block_size &gt;= 4 bytes.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cmm_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">**</span><span class="n">ph_cmm_mgr</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">cmm_mgrattrs</span> <span class="o">*</span><span class="n">mgr_attrts</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_destroy ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Destroy the communication memory manager object.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hcmm_mgr:   Cmm Mgr handle.</span>
<span class="cm"> *      force:     Force deallocation of all cmm memory immediately if set TRUE.</span>
<span class="cm"> *                 If FALSE, and outstanding allocations will return -EPERM</span>
<span class="cm"> *                 status.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        CMM object &amp; resources deleted.</span>
<span class="cm"> *      -EPERM:      Unable to free CMM object due to outstanding allocation.</span>
<span class="cm"> *      -EFAULT:    Unable to free CMM due to bad handle.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      CMM is initialized.</span>
<span class="cm"> *      hcmm_mgr != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      Memory resources used by Cmm Mgr are freed.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cmm_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">*</span><span class="n">hcmm_mgr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_free_buf ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Free the given buffer.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hcmm_mgr:    Cmm Mgr handle.</span>
<span class="cm"> *      pbuf:       Pointer to memory allocated by cmm_calloc_buf().</span>
<span class="cm"> *      ul_seg_id:    SM segment Id used in CMM_Calloc() attrs.</span>
<span class="cm"> *                  Set to 0 to use default segment.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0</span>
<span class="cm"> *      -EPERM</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      CMM initialized.</span>
<span class="cm"> *      buf_pa != NULL</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cmm_free_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">*</span><span class="n">hcmm_mgr</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">buf_pa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_seg_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_get_handle ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Return the handle to the cmm mgr for the given device obj.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hprocessor:   Handle to a Processor.</span>
<span class="cm"> *      ph_cmm_mgr:	Location to store the shared memory mgr handle on</span>
<span class="cm"> *      		output.</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Cmm Mgr opaque handle returned.</span>
<span class="cm"> *      -EFAULT:    Invalid handle.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      ph_cmm_mgr != NULL</span>
<span class="cm"> *      hdev_obj != NULL</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cmm_get_handle</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">**</span><span class="n">ph_cmm_mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_get_info ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Return the current SM and VM utilization information.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hcmm_mgr:     Handle to a Cmm Mgr.</span>
<span class="cm"> *      cmm_info_obj:    Location to store the Cmm information on output.</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid handle.</span>
<span class="cm"> *      -EINVAL Invalid input argument.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cmm_get_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">*</span><span class="n">hcmm_mgr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">cmm_info</span> <span class="o">*</span><span class="n">cmm_info_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_register_gppsm_seg ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Register a block of SM with the CMM.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hcmm_mgr:         Handle to a Cmm Mgr.</span>
<span class="cm"> *      lpGPPBasePA:     GPP Base Physical address.</span>
<span class="cm"> *      ul_size:          Size in GPP bytes.</span>
<span class="cm"> *      dsp_addr_offset  GPP PA to DSP PA Offset.</span>
<span class="cm"> *      c_factor:         Add offset if CMM_ADDTODSPPA, sub if CMM_SUBFROMDSPPA.</span>
<span class="cm"> *      dw_dsp_base:       DSP virtual base byte address.</span>
<span class="cm"> *      ul_dsp_size:       Size of DSP segment in bytes.</span>
<span class="cm"> *      sgmt_id:         Address to store segment Id.</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:         Success.</span>
<span class="cm"> *      -EFAULT:     Invalid hcmm_mgr handle.</span>
<span class="cm"> *      -EINVAL: Invalid input argument.</span>
<span class="cm"> *      -EPERM:       Unable to register.</span>
<span class="cm"> *      - On success *sgmt_id is a valid SM segment ID.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      ul_size &gt; 0</span>
<span class="cm"> *      sgmt_id != NULL</span>
<span class="cm"> *      dw_gpp_base_pa != 0</span>
<span class="cm"> *      c_factor = CMM_ADDTODSPPA || c_factor = CMM_SUBFROMDSPPA</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cmm_register_gppsm_seg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">*</span><span class="n">hcmm_mgr</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dw_gpp_base_pa</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">ul_size</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">dsp_addr_offset</span><span class="p">,</span>
					 <span class="n">s8</span> <span class="n">c_factor</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dw_dsp_base</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">ul_dsp_size</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="o">*</span><span class="n">sgmt_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gpp_base_va</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_un_register_gppsm_seg ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Unregister the given memory segment that was previously registered</span>
<span class="cm"> *      by cmm_register_gppsm_seg.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hcmm_mgr:    Handle to a Cmm Mgr.</span>
<span class="cm"> *      ul_seg_id     Segment identifier returned by cmm_register_gppsm_seg.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *       0:         Success.</span>
<span class="cm"> *       -EFAULT:     Invalid handle.</span>
<span class="cm"> *       -EINVAL: Invalid ul_seg_id.</span>
<span class="cm"> *       -EPERM:       Unable to unregister for unknown reason.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cmm_un_register_gppsm_seg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">*</span><span class="n">hcmm_mgr</span><span class="p">,</span>
					    <span class="n">u32</span> <span class="n">ul_seg_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_xlator_alloc_buf ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Allocate the specified SM buffer and create a local memory descriptor.</span>
<span class="cm"> *      Place on the descriptor on the translator&#39;s HaQ (Host Alloc&#39;d Queue).</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      xlator:    Handle to a Xlator object.</span>
<span class="cm"> *      va_buf:     Virtual address ptr(client context)</span>
<span class="cm"> *      pa_size:    Size of SM memory to allocate.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      Ptr to valid physical address(Pa) of pa_size bytes, NULL if failed.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      va_buf != 0.</span>
<span class="cm"> *      pa_size != 0.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cmm_xlator_alloc_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_xlatorobject</span> <span class="o">*</span><span class="n">xlator</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">va_buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pa_size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_xlator_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *     Create a translator(xlator) object used for process specific Va&lt;-&gt;Pa</span>
<span class="cm"> *     address translation. Node messaging and streams use this to perform</span>
<span class="cm"> *     inter-processor(GPP&lt;-&gt;DSP) zero-copy data transfer.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *     xlator:         Address to place handle to a new Xlator handle.</span>
<span class="cm"> *     hcmm_mgr:        Handle to Cmm Mgr associated with this translator.</span>
<span class="cm"> *     xlator_attrs:   Translator attributes used for the client NODE or STREAM.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *     0:            Success.</span>
<span class="cm"> *     -EINVAL:    Bad input Attrs.</span>
<span class="cm"> *     -ENOMEM:   Insufficient memory(local) for requested resources.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *     xlator != NULL</span>
<span class="cm"> *     hcmm_mgr != NULL</span>
<span class="cm"> *     xlator_attrs != NULL</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cmm_xlator_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_xlatorobject</span> <span class="o">**</span><span class="n">xlator</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">*</span><span class="n">hcmm_mgr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">cmm_xlatorattrs</span> <span class="o">*</span><span class="n">xlator_attrs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_xlator_free_buf ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Free SM buffer and descriptor.</span>
<span class="cm"> *      Does not free client process VM.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      xlator:    handle to translator.</span>
<span class="cm"> *      buf_va      Virtual address of PA to free.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Bad translator handle.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cmm_xlator_free_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_xlatorobject</span> <span class="o">*</span><span class="n">xlator</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">buf_va</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_xlator_info ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Set/Get process specific &quot;translator&quot; address info.</span>
<span class="cm"> *      This is used to perform fast virtaul address translation</span>
<span class="cm"> *      for shared memory buffers between the GPP and DSP.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *     xlator:     handle to translator.</span>
<span class="cm"> *     paddr:       Virtual base address of segment.</span>
<span class="cm"> *     ul_size:      Size in bytes.</span>
<span class="cm"> *     segm_id:     Segment identifier of SM segment(s)</span>
<span class="cm"> *     set_info     Set xlator fields if TRUE, else return base addr</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Bad translator handle.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      (paddr != NULL)</span>
<span class="cm"> *      (ul_size &gt; 0)</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cmm_xlator_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_xlatorobject</span> <span class="o">*</span><span class="n">xlator</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="o">**</span><span class="n">paddr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">ul_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segm_id</span><span class="p">,</span> <span class="n">bool</span> <span class="n">set_info</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== cmm_xlator_translate ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Perform address translation VA&lt;-&gt;PA for the specified stream or</span>
<span class="cm"> *      message shared memory buffer.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *     xlator: handle to translator.</span>
<span class="cm"> *     paddr    address of buffer to translate.</span>
<span class="cm"> *     xtype    Type of address xlation. CMM_PA2VA or CMM_VA2PA.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *     Valid address on success, else NULL.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      paddr != NULL</span>
<span class="cm"> *      xtype &gt;= CMM_VA2PA) &amp;&amp; (xtype &lt;= CMM_DSPPA2PA)</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cmm_xlator_translate</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmm_xlatorobject</span> <span class="o">*</span><span class="n">xlator</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">paddr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cmm_xlatetype</span> <span class="n">xtype</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CMM_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
