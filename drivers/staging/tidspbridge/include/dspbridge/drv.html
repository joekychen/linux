<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › include › dspbridge › drv.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>drv.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drv.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * DRV Resource allocation module. Driver Object gets Created</span>
<span class="cm"> * at the time of Loading. It holds the List of Device Objects</span>
<span class="cm"> * in the system.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef DRV_</span>
<span class="cp">#define DRV_</span>

<span class="cp">#include &lt;dspbridge/devdefs.h&gt;</span>

<span class="cp">#include &lt;linux/idr.h&gt;</span>

<span class="cm">/* Bridge Driver Object */</span>
<span class="k">struct</span> <span class="n">drv_object</span><span class="p">;</span>

<span class="cm">/* Provide the DSP Internal memory windows that can be accessed from L3 address</span>
<span class="cm"> * space */</span>

<span class="cp">#define OMAP_GEM_BASE   0x107F8000</span>
<span class="cp">#define OMAP_DSP_SIZE   0x00720000</span>

<span class="cm">/* MEM1 is L2 RAM + L2 Cache space */</span>
<span class="cp">#define OMAP_DSP_MEM1_BASE 0x5C7F8000</span>
<span class="cp">#define OMAP_DSP_MEM1_SIZE 0x18000</span>

<span class="cm">/* MEM2 is L1P RAM/CACHE space */</span>
<span class="cp">#define OMAP_DSP_MEM2_BASE 0x5CE00000</span>
<span class="cp">#define OMAP_DSP_MEM2_SIZE 0x8000</span>

<span class="cm">/* MEM3 is L1D RAM/CACHE space */</span>
<span class="cp">#define OMAP_DSP_MEM3_BASE 0x5CF04000</span>
<span class="cp">#define OMAP_DSP_MEM3_SIZE 0x14000</span>

<span class="cp">#define OMAP_PER_CM_BASE 0x48005000</span>
<span class="cp">#define OMAP_PER_CM_SIZE 0x1000</span>

<span class="cp">#define OMAP_PER_PRM_BASE 0x48307000</span>
<span class="cp">#define OMAP_PER_PRM_SIZE 0x1000</span>

<span class="cp">#define OMAP_CORE_PRM_BASE 0x48306A00</span>
<span class="cp">#define OMAP_CORE_PRM_SIZE 0x1000</span>

<span class="cp">#define OMAP_DMMU_BASE 0x5D000000</span>
<span class="cp">#define OMAP_DMMU_SIZE 0x1000</span>

<span class="cm">/* GPP PROCESS CLEANUP Data structures */</span>

<span class="cm">/* New structure (member of process context) abstracts NODE resource info */</span>
<span class="k">struct</span> <span class="n">node_res_object</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">node_allocated</span><span class="p">;</span>	<span class="cm">/* Node status */</span>
	<span class="n">s32</span> <span class="n">heap_allocated</span><span class="p">;</span>	<span class="cm">/* Heap status */</span>
	<span class="n">s32</span> <span class="n">streams_allocated</span><span class="p">;</span>	<span class="cm">/* Streams status */</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* used to cache dma mapping information */</span>
<span class="k">struct</span> <span class="n">bridge_dma_map_info</span> <span class="p">{</span>
	<span class="cm">/* direction of DMA in action, or DMA_NONE */</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">;</span>
	<span class="cm">/* number of elements requested by us */</span>
	<span class="kt">int</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="cm">/* number of elements returned from dma_map_sg */</span>
	<span class="kt">int</span> <span class="n">sg_num</span><span class="p">;</span>
	<span class="cm">/* list of buffers used in this DMA action */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Used for DMM mapped memory accounting */</span>
<span class="k">struct</span> <span class="n">dmm_map_object</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mpu_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_usr_pgs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dma_map_info</span> <span class="n">dma_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Used for DMM reserved memory accounting */</span>
<span class="k">struct</span> <span class="n">dmm_rsv_object</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dsp_reserved_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* New structure (member of process context) abstracts stream resource info */</span>
<span class="k">struct</span> <span class="n">strm_res_object</span> <span class="p">{</span>
	<span class="n">s32</span> <span class="n">stream_allocated</span><span class="p">;</span>	<span class="cm">/* Stream status */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_bufs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Overall Bridge process resource usage state */</span>
<span class="k">enum</span> <span class="n">gpp_proc_res_state</span> <span class="p">{</span>
	<span class="n">PROC_RES_ALLOCATED</span><span class="p">,</span>
	<span class="n">PROC_RES_FREED</span>
<span class="p">};</span>

<span class="cm">/* Bridge Data */</span>
<span class="k">struct</span> <span class="n">drv_data</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">base_img</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">shm_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tc_wordswapon</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">drv_object</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dev_object</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mgr_object</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Process Context */</span>
<span class="k">struct</span> <span class="n">process_context</span> <span class="p">{</span>
	<span class="cm">/* Process State */</span>
	<span class="k">enum</span> <span class="n">gpp_proc_res_state</span> <span class="n">res_state</span><span class="p">;</span>

	<span class="cm">/* Handle to Processor */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">processor</span><span class="p">;</span>

	<span class="cm">/* DSP Node resources */</span>
	<span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">node_id</span><span class="p">;</span>

	<span class="cm">/* DMM mapped memory resources */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dmm_map_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">dmm_map_lock</span><span class="p">;</span>

	<span class="cm">/* DMM reserved memory resources */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dmm_rsv_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">dmm_rsv_lock</span><span class="p">;</span>

	<span class="cm">/* Stream resources */</span>
	<span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">stream_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Creates the Driver Object. This is done during the driver loading.</span>
<span class="cm"> *      There is only one Driver Object in the DSP/BIOS Bridge.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      drv_obj:        Location to store created DRV Object handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success</span>
<span class="cm"> *      -ENOMEM:    Failed in Memory allocation</span>
<span class="cm"> *      -EPERM:      General Failure</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DRV Initialized (refs &gt; 0 )</span>
<span class="cm"> *      drv_obj != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        - *drv_obj is a valid DRV interface to the device.</span>
<span class="cm"> *                      - List of DevObject Created and Initialized.</span>
<span class="cm"> *                      - List of dev_node String created and initialized.</span>
<span class="cm"> *                      - Registry is updated with the DRV Object.</span>
<span class="cm"> *      !0:       DRV Object not created</span>
<span class="cm"> *  Details:</span>
<span class="cm"> *      There is one Driver Object for the Driver representing</span>
<span class="cm"> *      the driver itself. It contains the list of device</span>
<span class="cm"> *      Objects and the list of Device Extensions in the system.</span>
<span class="cm"> *      Also it can hold other necessary</span>
<span class="cm"> *      information in its storage area.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drv_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">**</span><span class="n">drv_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_destroy ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      destroys the Dev Object list, DrvExt list</span>
<span class="cm"> *      and destroy the DRV object</span>
<span class="cm"> *      Called upon driver unLoading.or unsuccessful loading of the driver.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      driver_obj:     Handle to Driver object .</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EPERM:      Failed to destroy DRV Object</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DRV Initialized (cRegs &gt; 0 )</span>
<span class="cm"> *      hdrv_obj is not NULL and a valid DRV handle .</span>
<span class="cm"> *      List of DevObject is Empty.</span>
<span class="cm"> *      List of DrvExt is Empty</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        - DRV Object destroyed and hdrv_obj is not a valid</span>
<span class="cm"> *                        DRV handle.</span>
<span class="cm"> *                      - Registry is updated with &quot;0&quot; as the DRV Object.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drv_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">driver_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_get_first_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Returns the Ptr to the FirstDev Object in the List</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DRV Initialized</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      dw_dev_object:  Ptr to the First Dev Object as a u32</span>
<span class="cm"> *      0 if it fails to retrieve the First Dev Object</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">drv_get_first_dev_object</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_get_first_dev_extension ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Returns the Ptr to the First Device Extension in the List</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DRV Initialized</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      dw_dev_extension:     Ptr to the First Device Extension as a u32</span>
<span class="cm"> *      0:                  Failed to Get the Device Extension</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">drv_get_first_dev_extension</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_get_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Given a index, returns a handle to DevObject from the list</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdrv_obj:     Handle to the Manager</span>
<span class="cm"> *      device_obj:     Location to store the Dev Handle</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DRV Initialized</span>
<span class="cm"> *      index &gt;= 0</span>
<span class="cm"> *      hdrv_obj is not NULL and Valid DRV Object</span>
<span class="cm"> *      device_obj is not NULL</span>
<span class="cm"> *      Device Object List not Empty</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success</span>
<span class="cm"> *      -EPERM:      Failed to Get the Dev Object</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *device_obj != NULL</span>
<span class="cm"> *      -EPERM:      *device_obj = NULL</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drv_get_dev_object</span><span class="p">(</span><span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">hdrv_obj</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">**</span><span class="n">device_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_get_next_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Returns the Ptr to the Next Device Object from the the List</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to the Device Object</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DRV Initialized</span>
<span class="cm"> *      hdev_obj != 0</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      dw_dev_object:    Ptr to the Next Dev Object as a u32</span>
<span class="cm"> *      0:              If it fail to get the next Dev Object.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">drv_get_next_dev_object</span><span class="p">(</span><span class="n">u32</span> <span class="n">hdev_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_get_next_dev_extension ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Returns the Ptr to the Next Device Extension from the the List</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_extension:      Handle to the Device Extension</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DRV Initialized</span>
<span class="cm"> *      dev_extension != 0.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      dw_dev_extension:     Ptr to the Next Dev Extension</span>
<span class="cm"> *      0:                  If it fail to Get the next Dev Extension</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">drv_get_next_dev_extension</span><span class="p">(</span><span class="n">u32</span> <span class="n">dev_extension</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_insert_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Insert a DeviceObject into the list of Driver object.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      driver_obj:     Handle to DrvObject</span>
<span class="cm"> *      hdev_obj:     Handle to DeviceObject to insert.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        If successful.</span>
<span class="cm"> *      -EPERM:      General Failure:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      hdrv_obj != NULL and Valid DRV Handle.</span>
<span class="cm"> *      hdev_obj != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        Device Object is inserted and the List is not empty.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drv_insert_dev_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">driver_obj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_remove_dev_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Search for and remove a Device object from the given list of Device Obj</span>
<span class="cm"> *      objects.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      driver_obj:     Handle to DrvObject</span>
<span class="cm"> *      hdev_obj:     Handle to DevObject to Remove</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EPERM:      Unable to find dev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      hdrv_obj != NULL and a Valid DRV Handle.</span>
<span class="cm"> *      hdev_obj != NULL.</span>
<span class="cm"> *      List exists and is not empty.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      List either does not exist (NULL), or is not empty if it does exist.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drv_remove_dev_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">driver_obj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_request_resources ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Assigns the Resources or Releases them.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dw_context:          Path to the driver Registry Key.</span>
<span class="cm"> *      dev_node_strg:     Ptr to dev_node String stored in the Device Ext.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      TRUE if success; FALSE otherwise.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      The Resources are assigned based on Bus type.</span>
<span class="cm"> *      The hardware is initialized. Resource information is</span>
<span class="cm"> *      gathered from the Registry(ISA, PCMCIA)or scanned(PCI)</span>
<span class="cm"> *      Resource structure is stored in the registry which will be</span>
<span class="cm"> *      later used by the CFG module.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drv_request_resources</span><span class="p">(</span><span class="n">u32</span> <span class="n">dw_context</span><span class="p">,</span>
					<span class="n">u32</span> <span class="o">*</span><span class="n">dev_node_strg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== drv_release_resources ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Assigns the Resources or Releases them.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dw_context:      Path to the driver Registry Key.</span>
<span class="cm"> *      hdrv_obj:     Handle to the Driver Object.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      TRUE if success; FALSE otherwise.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      The Resources are released based on Bus type.</span>
<span class="cm"> *      Resource structure is deleted from the registry</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drv_release_resources</span><span class="p">(</span><span class="n">u32</span> <span class="n">dw_context</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">hdrv_obj</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drv_request_bridge_res_dsp() - Reserves shared memory for bridge.</span>
<span class="cm"> * @phost_resources:  pointer to host resources.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">drv_request_bridge_res_dsp</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">phost_resources</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TIDSPBRIDGE_RECOVERY</span>
<span class="kt">void</span> <span class="n">bridge_recover_schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== mem_ext_phys_pool_init ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Uses the physical memory chunk passed for internal consistent memory</span>
<span class="cm"> *      allocations.</span>
<span class="cm"> *      physical address based on the page frame address.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      pool_phys_base  starting address of the physical memory pool.</span>
<span class="cm"> *      pool_size      size of the physical memory pool.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      none.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      - MEM initialized.</span>
<span class="cm"> *      - valid physical address for the base and size &gt; 0</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mem_ext_phys_pool_init</span><span class="p">(</span><span class="n">u32</span> <span class="n">pool_phys_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pool_size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== mem_ext_phys_pool_release ========</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mem_ext_phys_pool_release</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*  ======== mem_alloc_phys_mem ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Allocate physically contiguous, uncached memory</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      byte_size:     Number of bytes to allocate.</span>
<span class="cm"> *      align_mask:    Alignment Mask.</span>
<span class="cm"> *      physical_address: Physical address of allocated memory.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      Pointer to a block of memory;</span>
<span class="cm"> *      NULL if memory couldn&#39;t be allocated, or if byte_size == 0.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      MEM initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      The returned pointer, if not NULL, points to a valid memory block of</span>
<span class="cm"> *      the size requested.  Returned physical address refers to physical</span>
<span class="cm"> *      location of memory.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_alloc_phys_mem</span><span class="p">(</span><span class="n">u32</span> <span class="n">byte_size</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">align_mask</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">physical_address</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== mem_free_phys_mem ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Free the given block of physically contiguous memory.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      virtual_address:  Pointer to virtual memory region allocated</span>
<span class="cm"> *      by mem_alloc_phys_mem().</span>
<span class="cm"> *      physical_address:  Pointer to physical memory region  allocated</span>
<span class="cm"> *      by mem_alloc_phys_mem().</span>
<span class="cm"> *      byte_size:  Size of the memory region allocated by mem_alloc_phys_mem().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      MEM initialized.</span>
<span class="cm"> *      virtual_address is a valid memory address returned by</span>
<span class="cm"> *          mem_alloc_phys_mem()</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      virtual_address is no longer a valid pointer to memory.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mem_free_phys_mem</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">virtual_address</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">physical_address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">byte_size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== MEM_LINEAR_ADDRESS ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Get the linear address corresponding to the given physical address.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      phys_addr:  Physical address to be mapped.</span>
<span class="cm"> *      byte_size:     Number of bytes in physical range to map.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      The corresponding linear address, or NULL if unsuccessful.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      MEM initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *  Notes:</span>
<span class="cm"> *      If valid linear address is returned, be sure to call</span>
<span class="cm"> *      MEM_UNMAP_LINEAR_ADDRESS().</span>
<span class="cm"> */</span>
<span class="cp">#define MEM_LINEAR_ADDRESS(phy_addr, byte_size) phy_addr</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== MEM_UNMAP_LINEAR_ADDRESS ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Unmap the linear address mapped in MEM_LINEAR_ADDRESS.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      base_addr: Ptr to mapped memory (as returned by MEM_LINEAR_ADDRESS()).</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      - MEM initialized.</span>
<span class="cm"> *      - base_addr is a valid linear address mapped in MEM_LINEAR_ADDRESS.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      - base_addr no longer points to a valid linear address.</span>
<span class="cm"> */</span>
<span class="cp">#define MEM_UNMAP_LINEAR_ADDRESS(base_addr) {}</span>

<span class="cp">#endif </span><span class="cm">/* DRV_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
