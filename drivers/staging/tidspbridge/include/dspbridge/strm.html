<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › include › dspbridge › strm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>strm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * strm.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * DSPBridge Stream Manager.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef STRM_</span>
<span class="cp">#define STRM_</span>

<span class="cp">#include &lt;dspbridge/dev.h&gt;</span>

<span class="cp">#include &lt;dspbridge/strmdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/proc.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_allocate_buffer ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Allocate data buffer(s) for use with a stream.</span>
<span class="cm"> *  Parameter:</span>
<span class="cm"> *      strmres:     Stream resource info handle returned from strm_open().</span>
<span class="cm"> *      usize:          Size (GPP bytes) of the buffer(s).</span>
<span class="cm"> *      num_bufs:       Number of buffers to allocate.</span>
<span class="cm"> *      ap_buffer:       Array to hold buffer addresses.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid stream_obj.</span>
<span class="cm"> *      -ENOMEM:    Insufficient memory.</span>
<span class="cm"> *      -EPERM:      Failure occurred, unable to allocate buffers.</span>
<span class="cm"> *      -EINVAL:      usize must be &gt; 0 bytes.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      ap_buffer != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_allocate_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_res_object</span> <span class="o">*</span><span class="n">strmres</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">usize</span><span class="p">,</span>
				       <span class="n">u8</span> <span class="o">**</span><span class="n">ap_buffer</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">num_bufs</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_close ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Close a stream opened with strm_open().</span>
<span class="cm"> *  Parameter:</span>
<span class="cm"> *      strmres:          Stream resource info handle returned from strm_open().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid stream_obj.</span>
<span class="cm"> *      -EPIPE:   Some data buffers issued to the stream have not</span>
<span class="cm"> *                      been reclaimed.</span>
<span class="cm"> *      -EPERM:      Failure to close stream.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_res_object</span> <span class="o">*</span><span class="n">strmres</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create a STRM manager object. This object holds information about the</span>
<span class="cm"> *      device needed to open streams.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      strm_man:       Location to store handle to STRM manager object on</span>
<span class="cm"> *                      output.</span>
<span class="cm"> *      dev_obj:           Device for this processor.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success;</span>
<span class="cm"> *      -ENOMEM:    Insufficient memory for requested resources.</span>
<span class="cm"> *      -EPERM:      General failure.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      strm_man != NULL.</span>
<span class="cm"> *      dev_obj != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        Valid *strm_man.</span>
<span class="cm"> *      error:          *strm_man == NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_mgr</span> <span class="o">**</span><span class="n">strm_man</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_delete ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Delete the STRM Object.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      strm_mgr_obj:       Handle to STRM manager object from strm_create.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid strm_mgr_obj.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      strm_mgr_obj is not valid.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">strm_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_mgr</span> <span class="o">*</span><span class="n">strm_mgr_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_free_buffer ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Free buffer(s) allocated with strm_allocate_buffer.</span>
<span class="cm"> *  Parameter:</span>
<span class="cm"> *      strmres:     Stream resource info handle returned from strm_open().</span>
<span class="cm"> *      ap_buffer:       Array containing buffer addresses.</span>
<span class="cm"> *      num_bufs:       Number of buffers to be freed.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid stream handle.</span>
<span class="cm"> *      -EPERM:      Failure occurred, unable to free buffers.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      ap_buffer != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_free_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_res_object</span> <span class="o">*</span><span class="n">strmres</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="o">**</span><span class="n">ap_buffer</span><span class="p">,</span> <span class="n">u32</span> <span class="n">num_bufs</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_get_info ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Get information about a stream. User&#39;s dsp_streaminfo is contained</span>
<span class="cm"> *      in stream_info struct. stream_info also contains Bridge private info.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      stream_obj:         Stream handle returned from strm_open().</span>
<span class="cm"> *      stream_info:        Location to store stream info on output.</span>
<span class="cm"> *      uSteamInfoSize:     Size of user&#39;s dsp_streaminfo structure.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -EFAULT:        Invalid stream_obj.</span>
<span class="cm"> *      -EINVAL:          stream_info_size &lt; sizeof(dsp_streaminfo).</span>
<span class="cm"> *      -EPERM:          Unable to get stream info.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      stream_info != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_get_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_object</span> <span class="o">*</span><span class="n">stream_obj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">stream_info</span> <span class="o">*</span><span class="n">stream_info</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">stream_info_size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_idle ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Idle a stream and optionally flush output data buffers.</span>
<span class="cm"> *      If this is an output stream and flush_data is TRUE, all data currently</span>
<span class="cm"> *      enqueued will be discarded.</span>
<span class="cm"> *      If this is an output stream and flush_data is FALSE, this function</span>
<span class="cm"> *      will block until all currently buffered data is output, or the timeout</span>
<span class="cm"> *      specified has been reached.</span>
<span class="cm"> *      After a successful call to strm_idle(), all buffers can immediately</span>
<span class="cm"> *      be reclaimed.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      stream_obj:     Stream handle returned from strm_open().</span>
<span class="cm"> *      flush_data:     If TRUE, discard output buffers.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid stream_obj.</span>
<span class="cm"> *      -ETIME:   A timeout occurred before the stream could be idled.</span>
<span class="cm"> *      -EPERM:      Unable to idle stream.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_object</span> <span class="o">*</span><span class="n">stream_obj</span><span class="p">,</span> <span class="n">bool</span> <span class="n">flush_data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_issue ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Send a buffer of data to a stream.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      stream_obj:         Stream handle returned from strm_open().</span>
<span class="cm"> *      pbuf:               Pointer to buffer of data to be sent to the stream.</span>
<span class="cm"> *      ul_bytes:            Number of bytes of data in the buffer.</span>
<span class="cm"> *      ul_buf_size:          Actual buffer size in bytes.</span>
<span class="cm"> *      dw_arg:              A user argument that travels with the buffer.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -EFAULT:        Invalid stream_obj.</span>
<span class="cm"> *      -ENOSR:    The stream is full.</span>
<span class="cm"> *      -EPERM:          Failure occurred, unable to issue buffer.</span>
<span class="cm"> *  Requires:</span>
<span class="cm">*      pbuf != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_object</span> <span class="o">*</span><span class="n">stream_obj</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">pbuf</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">ul_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_buf_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dw_arg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_open ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Open a stream for sending/receiving data buffers to/from a task of</span>
<span class="cm"> *      DAIS socket node on the DSP.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:          Node handle returned from node_allocate().</span>
<span class="cm"> *      dir:           DSP_TONODE or DSP_FROMNODE.</span>
<span class="cm"> *      index:         Stream index.</span>
<span class="cm"> *      pattr:          Pointer to structure containing attributes to be</span>
<span class="cm"> *                      applied to stream. Cannot be NULL.</span>
<span class="cm"> *      strmres:     Location to store stream resuorce info handle on output.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hnode.</span>
<span class="cm"> *      -EPERM: Invalid direction.</span>
<span class="cm"> *              hnode is not a task or DAIS socket node.</span>
<span class="cm"> *              Unable to open stream.</span>
<span class="cm"> *      -EINVAL:     Invalid index.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      strmres != NULL.</span>
<span class="cm"> *      pattr != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *strmres is valid.</span>
<span class="cm"> *      error:          *strmres == NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dir</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">strm_attr</span> <span class="o">*</span><span class="n">pattr</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">strm_res_object</span> <span class="o">**</span><span class="n">strmres</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_reclaim ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Request a buffer back from a stream.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      stream_obj:          Stream handle returned from strm_open().</span>
<span class="cm"> *      buf_ptr:        Location to store pointer to reclaimed buffer.</span>
<span class="cm"> *      nbytes:         Location where number of bytes of data in the</span>
<span class="cm"> *                      buffer will be written.</span>
<span class="cm"> *      buff_size:      Location where actual buffer size will be written.</span>
<span class="cm"> *      pdw_arg:         Location where user argument that travels with</span>
<span class="cm"> *                      the buffer will be written.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid stream_obj.</span>
<span class="cm"> *      -ETIME:   A timeout occurred before a buffer could be</span>
<span class="cm"> *                      retrieved.</span>
<span class="cm"> *      -EPERM:      Failure occurred, unable to reclaim buffer.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      buf_ptr != NULL.</span>
<span class="cm"> *      nbytes != NULL.</span>
<span class="cm"> *      pdw_arg != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_object</span> <span class="o">*</span><span class="n">stream_obj</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">**</span><span class="n">buf_ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">nbytes</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="o">*</span><span class="n">buff_size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pdw_arg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_register_notify ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Register to be notified on specific events for this stream.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      stream_obj:     Stream handle returned by strm_open().</span>
<span class="cm"> *      event_mask:     Mask of types of events to be notified about.</span>
<span class="cm"> *      notify_type:    Type of notification to be sent.</span>
<span class="cm"> *      hnotification:  Handle to be used for notification.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid stream_obj.</span>
<span class="cm"> *      -ENOMEM:    Insufficient memory on GPP.</span>
<span class="cm"> *      -EINVAL:     event_mask is invalid.</span>
<span class="cm"> *      -ENOSYS:   Notification type specified by notify_type is not</span>
<span class="cm"> *                      supported.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      hnotification != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_register_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_object</span> <span class="o">*</span><span class="n">stream_obj</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">event_mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">notify_type</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dsp_notification</span>
				       <span class="o">*</span><span class="n">hnotification</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== strm_select ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Select a ready stream.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      strm_tab:       Array of stream handles returned from strm_open().</span>
<span class="cm"> *      strms:          Number of stream handles in array.</span>
<span class="cm"> *      pmask:          Location to store mask of ready streams on output.</span>
<span class="cm"> *      utimeout:       Timeout value (milliseconds).</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EDOM:     strms out of range.</span>

<span class="cm"> *      -EFAULT:    Invalid stream handle in array.</span>
<span class="cm"> *      -ETIME:   A timeout occurred before a stream became ready.</span>
<span class="cm"> *      -EPERM:      Failure occurred, unable to select a stream.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      strm_tab != NULL.</span>
<span class="cm"> *      strms &gt; 0.</span>
<span class="cm"> *      pmask != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *pmask != 0 || utimeout == 0.</span>
<span class="cm"> *      Error:          *pmask == 0.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">strm_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">strm_object</span> <span class="o">**</span><span class="n">strm_tab</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">strms</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pmask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">utimeout</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* STRM_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
