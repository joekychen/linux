<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › include › dspbridge › node.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>node.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * node.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * DSP/BIOS Bridge Node Manager.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef NODE_</span>
<span class="cp">#define NODE_</span>

<span class="cp">#include &lt;dspbridge/procpriv.h&gt;</span>

<span class="cp">#include &lt;dspbridge/nodedefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/disp.h&gt;</span>
<span class="cp">#include &lt;dspbridge/nldrdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/drv.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_allocate ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Allocate GPP resources to manage a node on the DSP.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hprocessor:         Handle of processor that is allocating the node.</span>
<span class="cm"> *      node_uuid:          Pointer to a dsp_uuid for the node.</span>
<span class="cm"> *      pargs:              Optional arguments to be passed to the node.</span>
<span class="cm"> *      attr_in:            Optional pointer to node attributes (priority,</span>
<span class="cm"> *                          timeout...)</span>
<span class="cm"> *      noderes:             Location to store node resource info.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -ENOMEM:        Insufficient memory on GPP.</span>
<span class="cm"> *      -ENOKEY:          Node UUID has not been registered.</span>
<span class="cm"> *      -ESPIPE:        iAlg functions not found for a DAIS node.</span>
<span class="cm"> *      -EDOM:         attr_in != NULL and attr_in-&gt;prio out of</span>
<span class="cm"> *                          range.</span>
<span class="cm"> *      -EPERM:          A failure occurred, unable to allocate node.</span>
<span class="cm"> *      -EBADR:    Proccessor is not in the running state.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      hprocessor != NULL.</span>
<span class="cm"> *      node_uuid != NULL.</span>
<span class="cm"> *      noderes != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:            IsValidNode(*ph_node).</span>
<span class="cm"> *      error:              *noderes == NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc_object</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">node_uuid</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_cbdata</span>
				<span class="o">*</span><span class="n">pargs</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_nodeattrin</span>
				<span class="o">*</span><span class="n">attr_in</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">**</span><span class="n">noderes</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_alloc_msg_buf ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Allocate and Prepare a buffer whose descriptor will be passed to a</span>
<span class="cm"> *      Node within a (dsp_msg)message</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:          The node handle.</span>
<span class="cm"> *      usize:          The size of the buffer to be allocated.</span>
<span class="cm"> *      pattr:          Pointer to a dsp_bufferattr structure.</span>
<span class="cm"> *      pbuffer:        Location to store the address of the allocated</span>
<span class="cm"> *                      buffer on output.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid node handle.</span>
<span class="cm"> *      -ENOMEM:    Insufficent memory.</span>
<span class="cm"> *      -EPERM:      General Failure.</span>
<span class="cm"> *      -EINVAL:      Invalid Size.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      pbuffer != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_alloc_msg_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">usize</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dsp_bufferattr</span>
				     <span class="o">*</span><span class="n">pattr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">**</span><span class="n">pbuffer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_change_priority ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Change the priority of an allocated node.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:              Node handle returned from node_allocate.</span>
<span class="cm"> *      prio:          New priority level to set node&#39;s priority to.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -EFAULT:        Invalid hnode.</span>
<span class="cm"> *      -EDOM:         prio is out of range.</span>
<span class="cm"> *      -EPERM: The specified node is not a task node.</span>
<span class="cm"> *              Unable to change node&#39;s runtime priority level.</span>
<span class="cm"> *      -EBADR:    Node is not in the NODE_ALLOCATED, NODE_PAUSED,</span>
<span class="cm"> *                          or NODE_RUNNING state.</span>
<span class="cm"> *      -ETIME:       A timeout occurred before the DSP responded.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0 &amp;&amp; (Node&#39;s current priority == prio)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_change_priority</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">s32</span> <span class="n">prio</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_connect ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Connect two nodes on the DSP, or a node on the DSP to the GPP. In the</span>
<span class="cm"> *      case that the connection is being made between a node on the DSP and</span>
<span class="cm"> *      the GPP, one of the node handles (either node1 or node2) must be</span>
<span class="cm"> *      the constant NODE_HGPPNODE.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      node1:         Handle of first node to connect to second node. If</span>
<span class="cm"> *                      this is a connection from the GPP to node2, node1</span>
<span class="cm"> *                      must be the constant NODE_HGPPNODE. Otherwise, node1</span>
<span class="cm"> *                      must be a node handle returned from a successful call</span>
<span class="cm"> *                      to Node_Allocate().</span>
<span class="cm"> *      node2:         Handle of second node. Must be either NODE_HGPPNODE</span>
<span class="cm"> *                      if this is a connection from DSP node to GPP, or a</span>
<span class="cm"> *                      node handle returned from a successful call to</span>
<span class="cm"> *                      node_allocate().</span>
<span class="cm"> *      stream1:        Output stream index on first node, to be connected</span>
<span class="cm"> *                      to second node&#39;s input stream. Value must range from</span>
<span class="cm"> *                      0 &lt;= stream1 &lt; number of output streams.</span>
<span class="cm"> *      stream2:        Input stream index on second node. Value must range</span>
<span class="cm"> *                      from 0 &lt;= stream2 &lt; number of input streams.</span>
<span class="cm"> *      pattrs:         Stream attributes (NULL ==&gt; use defaults).</span>
<span class="cm"> *      conn_param:     A pointer to a dsp_cbdata structure that defines</span>
<span class="cm"> *                      connection parameter for device nodes to pass to DSP</span>
<span class="cm"> *                      side.</span>
<span class="cm"> *                      If the value of this parameter is NULL, then this API</span>
<span class="cm"> *                      behaves like DSPNode_Connect. This parameter will have</span>
<span class="cm"> *                      length of the string and the null terminated string in</span>
<span class="cm"> *                      dsp_cbdata struct. This can be extended in future tp</span>
<span class="cm"> *                      pass binary data.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:                Success.</span>
<span class="cm"> *      -EFAULT:            Invalid node1 or node2.</span>
<span class="cm"> *      -ENOMEM:            Insufficient host memory.</span>
<span class="cm"> *      -EINVAL:             A stream index parameter is invalid.</span>
<span class="cm"> *      -EISCONN:  A connection already exists for one of the</span>
<span class="cm"> *                              indices stream1 or stream2.</span>
<span class="cm"> *      -EBADR:        Either node1 or node2 is not in the</span>
<span class="cm"> *                              NODE_ALLOCATED state.</span>
<span class="cm"> *      -ECONNREFUSED: No more connections available.</span>
<span class="cm"> *      -EPERM:              Attempt to make an illegal connection (eg,</span>
<span class="cm"> *                              Device node to device node, or device node to</span>
<span class="cm"> *                              GPP), the two nodes are on different DSPs.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">node1</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">stream1</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">node2</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">stream2</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dsp_strmattr</span> <span class="o">*</span><span class="n">pattrs</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dsp_cbdata</span>
			       <span class="o">*</span><span class="n">conn_param</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create a node on the DSP by remotely calling the node&#39;s create</span>
<span class="cm"> *      function. If necessary, load code that contains the node&#39;s create</span>
<span class="cm"> *      function.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:              Node handle returned from node_allocate().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -EFAULT:        Invalid hnode.</span>
<span class="cm"> *      -ESPIPE:        Create function not found in the COFF file.</span>
<span class="cm"> *      -EBADR:    Node is not in the NODE_ALLOCATED state.</span>
<span class="cm"> *      -ENOMEM:        Memory allocation failure on the DSP.</span>
<span class="cm"> *      -ETIME:       A timeout occurred before the DSP responded.</span>
<span class="cm"> *      -EPERM:          A failure occurred, unable to create node.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_create_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create a NODE Manager object. This object handles the creation,</span>
<span class="cm"> *      deletion, and execution of nodes on the DSP target. The NODE Manager</span>
<span class="cm"> *      also maintains a pipe map of used and available node connections.</span>
<span class="cm"> *      Each DEV object should have exactly one NODE Manager object.</span>
<span class="cm"> *</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      node_man:       Location to store node manager handle on output.</span>
<span class="cm"> *      hdev_obj:     Device for this processor.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success;</span>
<span class="cm"> *      -ENOMEM:    Insufficient memory for requested resources.</span>
<span class="cm"> *      -EPERM:      General failure.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      node_man != NULL.</span>
<span class="cm"> *      hdev_obj != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        Valide *node_man.</span>
<span class="cm"> *      error:          *node_man == NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_create_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">**</span><span class="n">node_man</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_delete ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Delete resources allocated in node_allocate(). If the node was</span>
<span class="cm"> *      created, delete the node on the DSP by remotely calling the node&#39;s</span>
<span class="cm"> *      delete function. Loads the node&#39;s delete function if necessary.</span>
<span class="cm"> *      GPP side resources are freed after node&#39;s delete function returns.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      noderes:              Node resource info handle returned from</span>
<span class="cm"> *                                 node_allocate().</span>
<span class="cm"> *      pr_ctxt:                Poninter to process context data.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -EFAULT:        Invalid hnode.</span>
<span class="cm"> *      -ETIME:       A timeout occurred before the DSP responded.</span>
<span class="cm"> *      -EPERM:          A failure occurred in deleting the node.</span>
<span class="cm"> *      -ESPIPE:        Delete function not found in the COFF file.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:            hnode is invalid.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_res_object</span> <span class="o">*</span><span class="n">noderes</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">process_context</span> <span class="o">*</span><span class="n">pr_ctxt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_delete_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Delete the NODE Manager.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode_mgr:       Node manager object.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid hnode_mgr.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_delete_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_enum_nodes ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Enumerate the nodes currently allocated for the DSP.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode_mgr:       Node manager returned from node_create_mgr().</span>
<span class="cm"> *      node_tab:       Array to copy node handles into.</span>
<span class="cm"> *      node_tab_size:   Number of handles that can be written to node_tab.</span>
<span class="cm"> *      pu_num_nodes:     Location where number of node handles written to</span>
<span class="cm"> *                      node_tab will be written.</span>
<span class="cm"> *      pu_allocated:    Location to write total number of allocated nodes.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EINVAL:      node_tab is too small to hold all node handles.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Valid hnode_mgr.</span>
<span class="cm"> *      node_tab != NULL || node_tab_size == 0.</span>
<span class="cm"> *      pu_num_nodes != NULL.</span>
<span class="cm"> *      pu_allocated != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      - (-EINVAL &amp;&amp; *pu_num_nodes == 0)</span>
<span class="cm"> *      - || (0 &amp;&amp; *pu_num_nodes &lt;= node_tab_size)  &amp;&amp;</span>
<span class="cm"> *        (*pu_allocated == *pu_num_nodes)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_enum_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">**</span><span class="n">node_tab</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">node_tab_size</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="o">*</span><span class="n">pu_num_nodes</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="o">*</span><span class="n">pu_allocated</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_free_msg_buf ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Free a message buffer previously allocated with node_alloc_msg_buf.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:          The node handle.</span>
<span class="cm"> *      pbuffer:        (Address) Buffer allocated by node_alloc_msg_buf.</span>
<span class="cm"> *      pattr:          Same buffer attributes passed to node_alloc_msg_buf.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid node handle.</span>
<span class="cm"> *      -EPERM:      Failure to free the buffer.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      pbuffer != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_free_msg_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="o">*</span><span class="n">pbuffer</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dsp_bufferattr</span>
				    <span class="o">*</span><span class="n">pattr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_attr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Copy the current attributes of the specified node into a dsp_nodeattr</span>
<span class="cm"> *      structure.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:          Node object allocated from node_allocate().</span>
<span class="cm"> *      pattr:          Pointer to dsp_nodeattr structure to copy node&#39;s</span>
<span class="cm"> *                      attributes.</span>
<span class="cm"> *      attr_size:      Size of pattr.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hnode.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      pattr != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *pattrs contains the node&#39;s current attributes.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_get_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dsp_nodeattr</span> <span class="o">*</span><span class="n">pattr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">attr_size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_message ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve a message from a node on the DSP. The node must be either a</span>
<span class="cm"> *      message node, task node, or XDAIS socket node.</span>
<span class="cm"> *      If a message is not available, this function will block until a</span>
<span class="cm"> *      message is available, or the node&#39;s timeout value is reached.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:          Node handle returned from node_allocate().</span>
<span class="cm"> *      message:       Pointer to dsp_msg structure to copy the</span>
<span class="cm"> *                      message into.</span>
<span class="cm"> *      utimeout:       Timeout in milliseconds to wait for message.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hnode.</span>
<span class="cm"> *      -EPERM: Cannot retrieve messages from this type of node.</span>
<span class="cm"> *              Error occurred while trying to retrieve a message.</span>
<span class="cm"> *      -ETIME:   Timeout occurred and no message is available.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      message != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_get_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dsp_msg</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="n">u32</span> <span class="n">utimeout</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_nldr_obj ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the Nldr manager</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode_mgr:       Node Manager</span>
<span class="cm"> *      nldr_ovlyobj:   Pointer to a Nldr manager handle</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hnode.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_get_nldr_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">hnode_mgr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">nldr_object</span> <span class="o">**</span><span class="n">nldr_ovlyobj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_on_exit ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Gets called when RMS_EXIT is received for a node. PROC needs to pass</span>
<span class="cm"> *      this function as a parameter to msg_create(). This function then gets</span>
<span class="cm"> *      called by the Bridge driver when an exit message for a node is received.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:      Handle of the node that the exit message is for.</span>
<span class="cm"> *      node_status:    Return status of the node&#39;s execute phase.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">node_on_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span> <span class="n">s32</span> <span class="n">node_status</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_pause ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Suspend execution of a node currently running on the DSP.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:              Node object representing a node currently</span>
<span class="cm"> *                          running on the DSP.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -EFAULT:        Invalid hnode.</span>
<span class="cm"> *      -EPERM: Node is not a task or socket node.</span>
<span class="cm"> *              Failed to pause node.</span>
<span class="cm"> *      -ETIME:       A timeout occurred before the DSP responded.</span>
<span class="cm"> *      DSP_EWRONGSTSATE:   Node is not in NODE_RUNNING state.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_put_message ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Send a message to a message node, task node, or XDAIS socket node.</span>
<span class="cm"> *      This function will block until the message stream can accommodate</span>
<span class="cm"> *      the message, or a timeout occurs. The message will be copied, so Msg</span>
<span class="cm"> *      can be re-used immediately after return.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:              Node handle returned by node_allocate().</span>
<span class="cm"> *      pmsg:               Location of message to be sent to the node.</span>
<span class="cm"> *      utimeout:           Timeout in msecs to wait.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -EFAULT:        Invalid hnode.</span>
<span class="cm"> *      -EPERM: Messages can&#39;t be sent to this type of node.</span>
<span class="cm"> *              Unable to send message.</span>
<span class="cm"> *      -ETIME:       Timeout occurred before message could be set.</span>
<span class="cm"> *      -EBADR:    Node is in invalid state for sending messages.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      pmsg != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_put_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_msg</span> <span class="o">*</span><span class="n">pmsg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">utimeout</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_register_notify ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Register to be notified on specific events for this node.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:          Node handle returned by node_allocate().</span>
<span class="cm"> *      event_mask:     Mask of types of events to be notified about.</span>
<span class="cm"> *      notify_type:    Type of notification to be sent.</span>
<span class="cm"> *      hnotification:  Handle to be used for notification.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hnode.</span>
<span class="cm"> *      -ENOMEM:    Insufficient memory on GPP.</span>
<span class="cm"> *      -EINVAL:     event_mask is invalid.</span>
<span class="cm"> *      -ENOSYS:   Notification type specified by notify_type is not</span>
<span class="cm"> *                      supported.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      hnotification != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_register_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">event_mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">notify_type</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dsp_notification</span>
				       <span class="o">*</span><span class="n">hnotification</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_run ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Start execution of a node&#39;s execute phase, or resume execution of</span>
<span class="cm"> *      a node that has been suspended (via node_pause()) on the DSP. Load</span>
<span class="cm"> *      the node&#39;s execute function if necessary.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:              Node object representing a node currently</span>
<span class="cm"> *                          running on the DSP.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -EFAULT:        Invalid hnode.</span>
<span class="cm"> *      -EPERM: hnode doesn&#39;t represent a message, task or dais socket node.</span>
<span class="cm"> *              Unable to start or resume execution.</span>
<span class="cm"> *      -ETIME:       A timeout occurred before the DSP responded.</span>
<span class="cm"> *      DSP_EWRONGSTSATE:   Node is not in NODE_PAUSED or NODE_CREATED state.</span>
<span class="cm"> *      -ESPIPE:        Execute function not found in the COFF file.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_terminate ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Signal a node running on the DSP that it should exit its execute</span>
<span class="cm"> *      phase function.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hnode:              Node object representing a node currently</span>
<span class="cm"> *                          running on the DSP.</span>
<span class="cm"> *      pstatus:            Location to store execute-phase function return</span>
<span class="cm"> *                          value.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -EFAULT:        Invalid hnode.</span>
<span class="cm"> *      -ETIME:       A timeout occurred before the DSP responded.</span>
<span class="cm"> *      -EPERM: Type of node specified cannot be terminated.</span>
<span class="cm"> *              Unable to terminate the node.</span>
<span class="cm"> *      -EBADR:    Operation not valid for the current node state.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      pstatus != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_terminate</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_object</span> <span class="o">*</span><span class="n">hnode</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="o">*</span><span class="n">pstatus</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== node_get_uuid_props ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Fetch Node properties given the UUID</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_get_uuid_props</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">node_uuid</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dsp_ndbprops</span>
				      <span class="o">*</span><span class="n">node_props</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE</span>
<span class="cm">/**</span>
<span class="cm"> * node_find_addr() - Find the closest symbol to the given address.</span>
<span class="cm"> *</span>
<span class="cm"> * @node_mgr:		Node manager handle</span>
<span class="cm"> * @sym_addr:		Given address to find the closest symbol</span>
<span class="cm"> * @offset_range:		offset range to look fo the closest symbol</span>
<span class="cm"> * @sym_addr_output:	Symbol Output address</span>
<span class="cm"> * @sym_name:		String with the symbol name of the closest symbol</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function finds the closest symbol to the address where a MMU</span>
<span class="cm"> *	Fault occurred on the DSP side.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">node_find_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">node_mgr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sym_addr</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">offset_range</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sym_addr_output</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">sym_name</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">node_state</span> <span class="n">node_get_state</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hnode</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* NODE_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
