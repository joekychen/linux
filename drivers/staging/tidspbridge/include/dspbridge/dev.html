<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › include › dspbridge › dev.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>dev.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * dev.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Bridge Bridge driver device operations.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef DEV_</span>
<span class="cp">#define DEV_</span>

<span class="cm">/*  ----------------------------------- Module Dependent Headers */</span>
<span class="cp">#include &lt;dspbridge/chnldefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/cmm.h&gt;</span>
<span class="cp">#include &lt;dspbridge/cod.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspdeh.h&gt;</span>
<span class="cp">#include &lt;dspbridge/nodedefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/disp.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dmm.h&gt;</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>

<span class="cm">/*  ----------------------------------- This */</span>
<span class="cp">#include &lt;dspbridge/devdefs.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_brd_write_fxn ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Exported function to be used as the COD write function.  This function</span>
<span class="cm"> *      is passed a handle to a DEV_hObject by ZL in arb, then calls the</span>
<span class="cm"> *      device&#39;s bridge_brd_write() function.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      arb:           Handle to a Device Object.</span>
<span class="cm"> *      dev_ctxt:    Handle to Bridge driver defined device info.</span>
<span class="cm"> *      dsp_addr:       Address on DSP board (Destination).</span>
<span class="cm"> *      host_buf:       Pointer to host buffer (Source).</span>
<span class="cm"> *      ul_num_bytes:     Number of bytes to transfer.</span>
<span class="cm"> *      mem_type:       Memory space on DSP to which to transfer.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      Number of bytes written.  Returns 0 if the DEV_hObject passed in via</span>
<span class="cm"> *      arb is invalid.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *      host_buf != NULL</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">dev_brd_write_fxn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arb</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">dsp_add</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">host_buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_space</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_create_device ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Called by the operating system to load the Bridge Driver for a</span>
<span class="cm"> *      &#39;Bridge device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      device_obj:     Ptr to location to receive the device object handle.</span>
<span class="cm"> *      driver_file_name: Name of Bridge driver PE DLL file to load.  If the</span>
<span class="cm"> *                      absolute path is not provided, the file is loaded</span>
<span class="cm"> *                      through &#39;Bridge&#39;s module search path.</span>
<span class="cm"> *      host_config:    Host configuration information, to be passed down</span>
<span class="cm"> *                      to the Bridge driver when bridge_dev_create() is called.</span>
<span class="cm"> *      pDspConfig:     DSP resources, to be passed down to the Bridge driver</span>
<span class="cm"> *                      when bridge_dev_create() is called.</span>
<span class="cm"> *      dev_node_obj:       Platform specific device node.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Module is loaded, device object has been created</span>
<span class="cm"> *      -ENOMEM:        Insufficient memory to create needed resources.</span>
<span class="cm"> *      -EPERM:              Unable to find Bridge driver entry point function.</span>
<span class="cm"> *      -ESPIPE:   Unable to load ZL DLL.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *      device_obj != NULL.</span>
<span class="cm"> *      driver_file_name != NULL.</span>
<span class="cm"> *      host_config != NULL.</span>
<span class="cm"> *      pDspConfig != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:  *device_obj will contain handle to the new device object.</span>
<span class="cm"> *      Otherwise, does not create the device object, ensures the Bridge driver</span>
<span class="cm"> *      module is unloaded, and sets *device_obj to NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_create_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span>
				    <span class="o">**</span><span class="n">device_obj</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_file_name</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_create2 ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      After successful loading of the image from api_init_complete2</span>
<span class="cm"> *      (PROC Auto_Start) or proc_load this fxn is called. This creates</span>
<span class="cm"> *      the Node Manager and updates the DEV Object.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj: Handle to device object created with dev_create_device().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:    Successful Creation of Node Manager</span>
<span class="cm"> *      -EPERM:  Some Error Occurred.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV Initialized</span>
<span class="cm"> *      Valid hdev_obj</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0 and hdev_obj-&gt;node_mgr != NULL</span>
<span class="cm"> *      else    hdev_obj-&gt;node_mgr == NULL</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_create2</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_destroy2 ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Destroys the Node manager for this device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj: Handle to device object created with dev_create_device().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:    Successful Creation of Node Manager</span>
<span class="cm"> *      -EPERM:  Some Error Occurred.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV Initialized</span>
<span class="cm"> *      Valid hdev_obj</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0 and hdev_obj-&gt;node_mgr == NULL</span>
<span class="cm"> *      else    -EPERM.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_destroy2</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_destroy_device ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Destroys the channel manager for this device, if any, calls</span>
<span class="cm"> *      bridge_dev_destroy(), and then attempts to unload the Bridge module.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *      -EPERM:     The Bridge driver failed it&#39;s bridge_dev_destroy() function.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_destroy_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span>
				     <span class="o">*</span><span class="n">hdev_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_chnl_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the handle to the channel manager created for this device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *      *mgr:           Ptr to location to store handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      mgr != NULL.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *mgr contains a handle to a channel manager object,</span>
<span class="cm"> *                      or NULL.</span>
<span class="cm"> *      else:           *mgr is NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_chnl_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">**</span><span class="n">mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_cmm_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the handle to the shared memory manager created for this</span>
<span class="cm"> *      device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *      *mgr:           Ptr to location to store handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      mgr != NULL.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *mgr contains a handle to a channel manager object,</span>
<span class="cm"> *                      or NULL.</span>
<span class="cm"> *      else:           *mgr is NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_cmm_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">**</span><span class="n">mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_dmm_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the handle to the dynamic memory manager created for this</span>
<span class="cm"> *      device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *      *mgr:           Ptr to location to store handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      mgr != NULL.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *mgr contains a handle to a channel manager object,</span>
<span class="cm"> *                      or NULL.</span>
<span class="cm"> *      else:           *mgr is NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_dmm_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">**</span><span class="n">mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_cod_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the COD manager create for this device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *      *cod_mgr:       Ptr to location to store handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      cod_mgr != NULL.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *cod_mgr contains a handle to a COD manager object.</span>
<span class="cm"> *      else:           *cod_mgr is NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_cod_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">**</span><span class="n">cod_mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_deh_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the DEH manager created for this device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj: Handle to device object created with dev_create_device().</span>
<span class="cm"> *      *deh_manager:  Ptr to location to store handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:    Success.</span>
<span class="cm"> *      -EFAULT:   Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      deh_manager != NULL.</span>
<span class="cm"> *      DEH Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:    *deh_manager contains a handle to a DEH manager object.</span>
<span class="cm"> *      else:       *deh_manager is NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_deh_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">deh_mgr</span> <span class="o">**</span><span class="n">deh_manager</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_dev_node ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the platform specific device ID for this device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *      dev_nde:        Ptr to location to get the device node handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Returns a DEVNODE in *dev_node_obj.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_nde != NULL.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *dev_nde contains a platform specific device ID;</span>
<span class="cm"> *      else:           *dev_nde is NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_dev_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">**</span><span class="n">dev_nde</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_dev_type ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the platform specific device ID for this device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *      dev_nde:        Ptr to location to get the device node handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      dev_nde != NULL.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *dev_nde contains a platform specific device ID;</span>
<span class="cm"> *      else:           *dev_nde is NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_dev_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">device_obj</span><span class="p">,</span>
					<span class="n">u8</span> <span class="o">*</span><span class="n">dev_type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_first ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the first Device Object handle from an internal linked list of</span>
<span class="cm"> *      of DEV_OBJECTs maintained by DEV.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      NULL if there are no device objects stored; else</span>
<span class="cm"> *      a valid DEV_HOBJECT.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      No calls to dev_create_device or dev_destroy_device (which my modify the</span>
<span class="cm"> *      internal device object list) may occur between calls to dev_get_first</span>
<span class="cm"> *      and dev_get_next.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      The DEV_HOBJECT returned is valid.</span>
<span class="cm"> *      A subsequent call to dev_get_next will return the next device object in</span>
<span class="cm"> *      the list.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_get_first</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_intf_fxns ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the Bridge driver interface function structure for the</span>
<span class="cm"> *      loaded Bridge driver.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *      *if_fxns:       Ptr to location to store fxn interface.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      if_fxns != NULL.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *if_fxns contains a pointer to the Bridge</span>
<span class="cm"> *                      driver interface;</span>
<span class="cm"> *      else:           *if_fxns is NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_intf_fxns</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">**</span><span class="n">if_fxns</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_io_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the handle to the IO manager created for this device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *      *mgr:           Ptr to location to store handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      mgr != NULL.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *mgr contains a handle to an IO manager object.</span>
<span class="cm"> *      else:           *mgr is NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_io_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">**</span><span class="n">mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_next ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the next Device Object handle from an internal linked list of</span>
<span class="cm"> *      of DEV_OBJECTs maintained by DEV, after having previously called</span>
<span class="cm"> *      dev_get_first() and zero or more dev_get_next</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj: Handle to the device object returned from a previous</span>
<span class="cm"> *                  call to dev_get_first() or dev_get_next().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      NULL if there are no further device objects on the list or hdev_obj</span>
<span class="cm"> *      was invalid;</span>
<span class="cm"> *      else the next valid DEV_HOBJECT in the list.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      No calls to dev_create_device or dev_destroy_device (which my modify the</span>
<span class="cm"> *      internal device object list) may occur between calls to dev_get_first</span>
<span class="cm"> *      and dev_get_next.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      The DEV_HOBJECT returned is valid.</span>
<span class="cm"> *      A subsequent call to dev_get_next will return the next device object in</span>
<span class="cm"> *      the list.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_get_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span>
				       <span class="o">*</span><span class="n">hdev_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ========= dev_get_msg_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the msg_ctrl Manager Handle from the DevObject.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj: Handle to the Dev Object</span>
<span class="cm"> *      msg_man:    Location where msg_ctrl Manager handle will be returned.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *      Valid hdev_obj.</span>
<span class="cm"> *      node_man != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_get_msg_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">**</span><span class="n">msg_man</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ========= dev_get_node_manager ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the Node Manager Handle from the DevObject. It is an</span>
<span class="cm"> *      accessor function</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to the Dev Object</span>
<span class="cm"> *      node_man:       Location where Handle to the Node Manager will be</span>
<span class="cm"> *                      returned..</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success</span>
<span class="cm"> *      -EFAULT:    Invalid Dev Object handle.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *      node_man is not null</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *node_man contains a handle to a Node manager object.</span>
<span class="cm"> *      else:           *node_man is NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_node_manager</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span>
				       <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">**</span><span class="n">node_man</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_symbol ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Get the value of a symbol in the currently loaded program.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *      str_sym:        Name of symbol to look up.</span>
<span class="cm"> *      pul_value:       Ptr to symbol value.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *      -ESPIPE: Symbols couldn not be found or have not been loaded onto</span>
<span class="cm"> *               the board.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      str_sym != NULL.</span>
<span class="cm"> *      pul_value != NULL.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *pul_value contains the symbol value;</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_symbol</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str_sym</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">pul_value</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_bridge_context ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the Bridge Context handle, as returned by the</span>
<span class="cm"> *      bridge_dev_create fxn.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with dev_create_device()</span>
<span class="cm"> *      *phbridge_context:  Ptr to location to store context handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      phbridge_context != NULL.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0:        *phbridge_context contains context handle;</span>
<span class="cm"> *      else:           *phbridge_context is NULL;</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">bridge_dev_context</span>
				      <span class="o">**</span><span class="n">phbridge_context</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_insert_proc_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Inserts the Processor Object into the List of PROC Objects</span>
<span class="cm"> *      kept in the DEV Object</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      proc_obj:    Handle to the Proc Object</span>
<span class="cm"> *      hdev_obj      Handle to the Dev Object</span>
<span class="cm"> *      bAttachedNew    Specifies if there are already processors attached</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Successfully inserted into the list</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      proc_obj is not NULL</span>
<span class="cm"> *      hdev_obj is a valid handle to the DEV.</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *      List(of Proc object in Dev) Exists.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0 &amp; the PROC Object is inserted and the list is not empty</span>
<span class="cm"> *  Details:</span>
<span class="cm"> *      If the List of Proc Object is empty bAttachedNew is TRUE, it indicated</span>
<span class="cm"> *      this is the first Processor attaching.</span>
<span class="cm"> *      If it is False, there are already processors attached.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_insert_proc_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span>
					 <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">proc_obj</span><span class="p">,</span>
					 <span class="n">bool</span> <span class="o">*</span><span class="n">already_attached</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_remove_proc_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Search for and remove a Proc object from the given list maintained</span>
<span class="cm"> *      by the DEV</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      p_proc_object:        Ptr to ProcObject to insert.</span>
<span class="cm"> *      dev_obj:         Ptr to Dev Object where the list is.</span>
<span class="cm"> *      already_attached:  Ptr to return the bool</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            If successful.</span>
<span class="cm"> *      -EPERM           Failure to Remove the PROC Object from the list</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DevObject is Valid</span>
<span class="cm"> *      proc_obj != 0</span>
<span class="cm"> *      dev_obj-&gt;proc_list != NULL</span>
<span class="cm"> *      !LST_IS_EMPTY(dev_obj-&gt;proc_list)</span>
<span class="cm"> *      already_attached !=NULL</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *  Details:</span>
<span class="cm"> *      List will be deleted when the DEV is destroyed.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_remove_proc_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span>
					 <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="n">u32</span> <span class="n">proc_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_notify_clients ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Notify all clients of this device of a change in device status.</span>
<span class="cm"> *      Clients may include multiple users of BRD, as well as CHNL.</span>
<span class="cm"> *      This function is asychronous, and may be called by a timer event</span>
<span class="cm"> *      set up by a watchdog timer.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:  Handle to device object created with dev_create_device().</span>
<span class="cm"> *      ret:         A status word, most likely a BRD_STATUS.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:     All registered clients were asynchronously notified.</span>
<span class="cm"> *      -EINVAL:   Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0: Notifications are queued by the operating system to be</span>
<span class="cm"> *      delivered to clients.  This function does not ensure that</span>
<span class="cm"> *      the notifications will ever be delivered.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_notify_clients</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ret</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_remove_device ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Destroys the Device Object created by dev_start_device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_node_obj:       Device node as it is know to OS.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        If success;</span>
<span class="cm"> *      &lt;error code&gt;    Otherwise.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_set_chnl_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Set the channel manager for this device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj:     Handle to device object created with</span>
<span class="cm"> *                      dev_create_device().</span>
<span class="cm"> *      hmgr:           Handle to a channel manager, or NULL.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_set_chnl_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">hmgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_set_msg_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Set the Message manager for this device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdev_obj: Handle to device object created with dev_create_device().</span>
<span class="cm"> *      hmgr:       Handle to a message manager, or NULL.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV Initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_set_msg_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_start_device ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Initializes the new device with bridge environment.  This involves</span>
<span class="cm"> *      querying CM for allocated resources, querying the registry for</span>
<span class="cm"> *      necessary dsp resources (requested in the INF file), and using this</span>
<span class="cm"> *      information to create a bridge device object.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_node_obj:       Device node as it is know to OS.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        If success;</span>
<span class="cm"> *      &lt;error code&gt;    Otherwise.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DEV initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_start_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* DEV_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
