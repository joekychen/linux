<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › include › dspbridge › dbdcd.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>dbdcd.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * dbdcd.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Defines the DSP/BIOS Bridge Configuration Database (DCD) API.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef DBDCD_</span>
<span class="cp">#define DBDCD_</span>

<span class="cp">#include &lt;dspbridge/dbdcddef.h&gt;</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>
<span class="cp">#include &lt;dspbridge/nldrdefs.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_auto_register ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function automatically registers DCD objects specified in a</span>
<span class="cm"> *      special COFF section called &quot;.dcd_register&quot;</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdcd_mgr:                A DCD manager handle.</span>
<span class="cm"> *      sz_coff_path:           Pointer to name of COFF file containing DCD</span>
<span class="cm"> *                              objects to be registered.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:                Success.</span>
<span class="cm"> *      -EACCES: Unable to find auto-registration/read/load section.</span>
<span class="cm"> *      -EFAULT:            Invalid DCD_HMANAGER handle..</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *  Note:</span>
<span class="cm"> *      Due to the DCD database construction, it is essential for a DCD-enabled</span>
<span class="cm"> *      COFF file to contain the right COFF sections, especially</span>
<span class="cm"> *      &quot;.dcd_register&quot;, which is used for auto registration.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_auto_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_mgr</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">*</span><span class="n">sz_coff_path</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_auto_unregister ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function automatically unregisters DCD objects specified in a</span>
<span class="cm"> *      special COFF section called &quot;.dcd_register&quot;</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdcd_mgr:                A DCD manager handle.</span>
<span class="cm"> *      sz_coff_path:           Pointer to name of COFF file containing</span>
<span class="cm"> *                              DCD objects to be unregistered.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:                Success.</span>
<span class="cm"> *      -EACCES: Unable to find auto-registration/read/load section.</span>
<span class="cm"> *      -EFAULT:            Invalid DCD_HMANAGER handle..</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *  Note:</span>
<span class="cm"> *      Due to the DCD database construction, it is essential for a DCD-enabled</span>
<span class="cm"> *      COFF file to contain the right COFF sections, especially</span>
<span class="cm"> *      &quot;.dcd_register&quot;, which is used for auto unregistration.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_auto_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_mgr</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="o">*</span><span class="n">sz_coff_path</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_create_manager ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function creates a DCD module manager.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      sz_zl_dll_name: Pointer to a DLL name string.</span>
<span class="cm"> *      dcd_mgr:        A pointer to a DCD manager handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ENOMEM:    Unable to allocate memory for DCD manager handle.</span>
<span class="cm"> *      -EPERM:      General failure.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *      sz_zl_dll_name is non-NULL.</span>
<span class="cm"> *      dcd_mgr is non-NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      A DCD manager handle is created.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_create_manager</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">sz_zl_dll_name</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">**</span><span class="n">dcd_mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_destroy_manager ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function destroys a DCD module manager.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdcd_mgr:        A DCD manager handle.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EFAULT:    Invalid DCD manager handle.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_destroy_manager</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_mgr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_enumerate_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function enumerates currently visible DSP/BIOS Bridge objects</span>
<span class="cm"> *      and returns the UUID and type of each enumerated object.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      index:              The object enumeration index.</span>
<span class="cm"> *      obj_type:            Type of object to enumerate.</span>
<span class="cm"> *      uuid_obj:              Pointer to a dsp_uuid object.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            Success.</span>
<span class="cm"> *      -EPERM:          Unable to enumerate through the DCD database.</span>
<span class="cm"> *      ENODATA:  Enumeration completed. This is not an error code.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *      uuid_obj is a valid pointer.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *  Details:</span>
<span class="cm"> *      This function can be used in conjunction with dcd_get_object_def to</span>
<span class="cm"> *      retrieve object properties.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_enumerate_object</span><span class="p">(</span><span class="n">s32</span> <span class="n">index</span><span class="p">,</span>
				       <span class="k">enum</span> <span class="n">dsp_dcdobjtype</span> <span class="n">obj_type</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">uuid_obj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_exit ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function cleans up the DCD module.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dcd_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_get_dep_libs ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Given the uuid of a library and size of array of uuids, this function</span>
<span class="cm"> *      fills the array with the uuids of all dependent libraries of the input</span>
<span class="cm"> *      library.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdcd_mgr: A DCD manager handle.</span>
<span class="cm"> *      uuid_obj: Pointer to a dsp_uuid for a library.</span>
<span class="cm"> *      num_libs: Size of uuid array (number of library uuids).</span>
<span class="cm"> *      dep_lib_uuids: Array of dependent library uuids to be filled in.</span>
<span class="cm"> *      prstnt_dep_libs:    Array indicating if corresponding lib is persistent.</span>
<span class="cm"> *      phase: phase to obtain correct input library</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0: Success.</span>
<span class="cm"> *      -ENOMEM: Memory allocation failure.</span>
<span class="cm"> *      -EACCES: Failure to read section containing library info.</span>
<span class="cm"> *      -EPERM: General failure.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *      Valid hdcd_mgr.</span>
<span class="cm"> *      uuid_obj != NULL</span>
<span class="cm"> *      dep_lib_uuids != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_get_dep_libs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_mgr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">uuid_obj</span><span class="p">,</span>
				   <span class="n">u16</span> <span class="n">num_libs</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">dep_lib_uuids</span><span class="p">,</span>
				   <span class="n">bool</span> <span class="o">*</span><span class="n">prstnt_dep_libs</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_get_num_dep_libs ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Given the uuid of a library, determine its number of dependent</span>
<span class="cm"> *      libraries.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdcd_mgr:        A DCD manager handle.</span>
<span class="cm"> *      uuid_obj:          Pointer to a dsp_uuid for a library.</span>
<span class="cm"> *      num_libs:       Size of uuid array (number of library uuids).</span>
<span class="cm"> *      num_pers_libs:  number of persistent dependent library.</span>
<span class="cm"> *      phase:          Phase to obtain correct input library</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0: Success.</span>
<span class="cm"> *      -ENOMEM: Memory allocation failure.</span>
<span class="cm"> *      -EACCES: Failure to read section containing library info.</span>
<span class="cm"> *      -EPERM: General failure.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *      Valid hdcd_mgr.</span>
<span class="cm"> *      uuid_obj != NULL</span>
<span class="cm"> *      num_libs != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_get_num_dep_libs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_mgr</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">uuid_obj</span><span class="p">,</span>
				       <span class="n">u16</span> <span class="o">*</span><span class="n">num_libs</span><span class="p">,</span>
				       <span class="n">u16</span> <span class="o">*</span><span class="n">num_pers_libs</span><span class="p">,</span>
				       <span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_get_library_name ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function returns the name of a (dynamic) library for a given</span>
<span class="cm"> *      UUID.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdcd_mgr: A DCD manager handle.</span>
<span class="cm"> *      uuid_obj:	Pointer to a dsp_uuid that represents a unique DSP/BIOS</span>
<span class="cm"> *                      Bridge object.</span>
<span class="cm"> *      str_lib_name: Buffer to hold library name.</span>
<span class="cm"> *      buff_size: Contains buffer size. Set to string size on output.</span>
<span class="cm"> *      phase:          Which phase to load</span>
<span class="cm"> *      phase_split:    Are phases in multiple libraries</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0: Success.</span>
<span class="cm"> *      -EPERM: General failure.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *      Valid hdcd_mgr.</span>
<span class="cm"> *      str_lib_name != NULL.</span>
<span class="cm"> *      uuid_obj != NULL</span>
<span class="cm"> *      buff_size != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_get_library_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_mgr</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">uuid_obj</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="o">*</span><span class="n">str_lib_name</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="o">*</span><span class="n">buff_size</span><span class="p">,</span>
				       <span class="k">enum</span> <span class="n">nldr_phase</span> <span class="n">phase</span><span class="p">,</span>
				       <span class="n">bool</span> <span class="o">*</span><span class="n">phase_split</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_get_object_def ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function returns the properties/attributes of a DSP/BIOS Bridge</span>
<span class="cm"> *      object.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdcd_mgr:            A DCD manager handle.</span>
<span class="cm"> *      uuid_obj:              Pointer to a dsp_uuid that represents a unique</span>
<span class="cm"> *                          DSP/BIOS Bridge object.</span>
<span class="cm"> *      obj_type:            The type of DSP/BIOS Bridge object to be</span>
<span class="cm"> *                          referenced (node, processor, etc).</span>
<span class="cm"> *      obj_def:            Pointer to an object definition structure. A</span>
<span class="cm"> *                          union of various possible DCD object types.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0: Success.</span>
<span class="cm"> *      -EACCES: Unable to access/read/parse/load content of object code</span>
<span class="cm"> *               section.</span>
<span class="cm"> *      -EPERM:          General failure.</span>
<span class="cm"> *      -EFAULT:        Invalid DCD_HMANAGER handle.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *      obj_uuid is non-NULL.</span>
<span class="cm"> *      obj_def is non-NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_get_object_def</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_mgr</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">obj_uuid</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">dsp_dcdobjtype</span> <span class="n">obj_type</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dcd_genericobj</span> <span class="o">*</span><span class="n">obj_def</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_get_objects ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function finds all DCD objects specified in a special</span>
<span class="cm"> *      COFF section called &quot;.dcd_register&quot;, and for each object,</span>
<span class="cm"> *      call a &quot;register&quot; function.  The &quot;register&quot; function may perform</span>
<span class="cm"> *      various actions, such as 1) register nodes in the node database, 2)</span>
<span class="cm"> *      unregister nodes from the node database, and 3) add overlay nodes.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      hdcd_mgr:                A DCD manager handle.</span>
<span class="cm"> *      sz_coff_path:           Pointer to name of COFF file containing DCD</span>
<span class="cm"> *                              objects.</span>
<span class="cm"> *      register_fxn:           Callback fxn to be applied on each located</span>
<span class="cm"> *                              DCD object.</span>
<span class="cm"> *      handle:                 Handle to pass to callback.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:                Success.</span>
<span class="cm"> *      -EACCES: Unable to access/read/parse/load content of object code</span>
<span class="cm"> *               section.</span>
<span class="cm"> *      -EFAULT:            Invalid DCD_HMANAGER handle..</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *  Note:</span>
<span class="cm"> *      Due to the DCD database construction, it is essential for a DCD-enabled</span>
<span class="cm"> *      COFF file to contain the right COFF sections, especially</span>
<span class="cm"> *      &quot;.dcd_register&quot;, which is used for auto registration.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_get_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcd_manager</span> <span class="o">*</span><span class="n">hdcd_mgr</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="o">*</span><span class="n">sz_coff_path</span><span class="p">,</span>
				  <span class="n">dcd_registerfxn</span> <span class="n">register_fxn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_init ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function initializes DCD.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      FALSE:  Initialization failed.</span>
<span class="cm"> *      TRUE:   Initialization succeeded.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">dcd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_register_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function registers a DSP/BIOS Bridge object in the DCD database.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      uuid_obj:          Pointer to a dsp_uuid that identifies a DSP/BIOS</span>
<span class="cm"> *                      Bridge object.</span>
<span class="cm"> *      obj_type:        Type of object.</span>
<span class="cm"> *      psz_path_name:    Path to the object&#39;s COFF file.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -EPERM:      Failed to register object.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *      uuid_obj and szPathName are non-NULL values.</span>
<span class="cm"> *      obj_type is a valid type value.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_register_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">uuid_obj</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">dsp_dcdobjtype</span> <span class="n">obj_type</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="o">*</span><span class="n">psz_path_name</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dcd_unregister_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function de-registers a valid DSP/BIOS Bridge object from the DCD</span>
<span class="cm"> *      database.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      uuid_obj:      Pointer to a dsp_uuid that identifies a DSP/BIOS Bridge</span>
<span class="cm"> *                  object.</span>
<span class="cm"> *      obj_type:    Type of object.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:    Success.</span>
<span class="cm"> *      -EPERM:  Unable to de-register the specified object.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      DCD initialized.</span>
<span class="cm"> *      uuid_obj is a non-NULL value.</span>
<span class="cm"> *      obj_type is a valid type value.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcd_unregister_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">dsp_uuid</span> <span class="o">*</span><span class="n">uuid_obj</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">dsp_dcdobjtype</span> <span class="n">obj_type</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _DBDCD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
