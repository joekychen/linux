<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › include › dspbridge › rmm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>rmm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * rmm.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * This memory manager provides general heap management and arbitrary</span>
<span class="cm"> * alignment for any number of memory segments, and management of overlay</span>
<span class="cm"> * memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef RMM_</span>
<span class="cp">#define RMM_</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== rmm_addr ========</span>
<span class="cm"> *  DSP address + segid</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rmm_addr</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">segid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== rmm_segment ========</span>
<span class="cm"> *  Memory segment on the DSP available for remote allocations.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rmm_segment</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">base</span><span class="p">;</span>		<span class="cm">/* Base of the segment */</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>		<span class="cm">/* Size of the segment (target MAUs) */</span>
	<span class="n">s32</span> <span class="n">space</span><span class="p">;</span>		<span class="cm">/* Code or data */</span>
	<span class="n">u32</span> <span class="n">number</span><span class="p">;</span>		<span class="cm">/* Number of Allocated Blocks */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== RMM_Target ========</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rmm_target_obj</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== rmm_alloc ========</span>
<span class="cm"> *</span>
<span class="cm"> *  rmm_alloc is used to remotely allocate or reserve memory on the DSP.</span>
<span class="cm"> *</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      target          - Target returned from rmm_create().</span>
<span class="cm"> *      segid           - Memory segment to allocate from.</span>
<span class="cm"> *      size            - Size (target MAUS) to allocate.</span>
<span class="cm"> *      align           - alignment.</span>
<span class="cm"> *      dsp_address     - If reserve is FALSE, the location to store allocated</span>
<span class="cm"> *                        address on output, otherwise, the DSP address to</span>
<span class="cm"> *                        reserve.</span>
<span class="cm"> *      reserve         - If TRUE, reserve the memory specified by dsp_address.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:                Success.</span>
<span class="cm"> *      -ENOMEM:            Memory allocation on GPP failed.</span>
<span class="cm"> *      -ENXIO:     Cannot &quot;allocate&quot; overlay memory because it&#39;s</span>
<span class="cm"> *                              already in use.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      RMM initialized.</span>
<span class="cm"> *      Valid target.</span>
<span class="cm"> *      dsp_address != NULL.</span>
<span class="cm"> *      size &gt; 0</span>
<span class="cm"> *      reserve || target-&gt;num_segs &gt; 0.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rmm_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmm_target_obj</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">align</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dsp_address</span><span class="p">,</span> <span class="n">bool</span> <span class="n">reserve</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== rmm_create ========</span>
<span class="cm"> *  Create a target object with memory segments for remote allocation. If</span>
<span class="cm"> *  seg_tab == NULL or num_segs == 0, memory can only be reserved through</span>
<span class="cm"> *  rmm_alloc().</span>
<span class="cm"> *</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      target_obj:        - Location to store target on output.</span>
<span class="cm"> *      seg_tab:         - Table of memory segments.</span>
<span class="cm"> *      num_segs:        - Number of memory segments.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ENOMEM:    Memory allocation failed.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      RMM initialized.</span>
<span class="cm"> *      target_obj != NULL.</span>
<span class="cm"> *      num_segs == 0 || seg_tab != NULL.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      Success:        Valid *target_obj.</span>
<span class="cm"> *      Failure:        *target_obj == NULL.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rmm_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmm_target_obj</span> <span class="o">**</span><span class="n">target_obj</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">rmm_segment</span> <span class="n">seg_tab</span><span class="p">[],</span> <span class="n">u32</span> <span class="n">num_segs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== rmm_delete ========</span>
<span class="cm"> *  Delete target allocated in rmm_create().</span>
<span class="cm"> *</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      target          - Target returned from rmm_create().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      RMM initialized.</span>
<span class="cm"> *      Valid target.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rmm_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmm_target_obj</span> <span class="o">*</span><span class="n">target</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== rmm_free ========</span>
<span class="cm"> *  Free or unreserve memory allocated through rmm_alloc().</span>
<span class="cm"> *</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      target:         - Target returned from rmm_create().</span>
<span class="cm"> *      segid:          - Segment of memory to free.</span>
<span class="cm"> *      dsp_address:    - Address to free or unreserve.</span>
<span class="cm"> *      size:           - Size of memory to free or unreserve.</span>
<span class="cm"> *      reserved:       - TRUE if memory was reserved only, otherwise FALSE.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      RMM initialized.</span>
<span class="cm"> *      Valid target.</span>
<span class="cm"> *      reserved || segid &lt; target-&gt;num_segs.</span>
<span class="cm"> *      reserve || [dsp_address, dsp_address + size] is a valid memory range.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">rmm_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmm_target_obj</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span>
		     <span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="n">bool</span> <span class="n">reserved</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== rmm_stat ========</span>
<span class="cm"> *  Obtain  memory segment status</span>
<span class="cm"> *</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      segid:       Segment ID of the dynamic loading segment.</span>
<span class="cm"> *      mem_stat_buf: Pointer to allocated buffer into which memory stats are</span>
<span class="cm"> *                   placed.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      TRUE:   Success.</span>
<span class="cm"> *      FALSE:  Failure.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      segid &lt; target-&gt;num_segs</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">rmm_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmm_target_obj</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dsp_memtype</span> <span class="n">segid</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">dsp_memstat</span> <span class="o">*</span><span class="n">mem_stat_buf</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* RMM_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
