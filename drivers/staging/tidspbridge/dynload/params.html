<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › dynload › params.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>params.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * params.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * This file defines host and target properties for all machines</span>
<span class="cm"> * supported by the dynamic loader.  To be tedious...</span>
<span class="cm"> *</span>
<span class="cm"> * host: the machine on which the dynamic loader runs</span>
<span class="cm"> * target: the machine that the dynamic loader is loading</span>
<span class="cm"> *</span>
<span class="cm"> * Host and target may or may not be the same, depending upon the particular</span>
<span class="cm"> * use.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *							Host Properties</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************** */</span>

<span class="cp">#define BITS_PER_BYTE 8		</span><span class="cm">/* bits in the standard PC/SUN byte */</span><span class="cp"></span>
<span class="cp">#define LOG_BITS_PER_BYTE 3	</span><span class="cm">/* log base 2 of same */</span><span class="cp"></span>
<span class="cp">#define BYTE_MASK ((1U&lt;&lt;BITS_PER_BYTE)-1)</span>

<span class="cp">#if defined(__TMS320C55X__) || defined(_TMS320C5XX)</span>
<span class="cp">#define BITS_PER_AU 16</span>
<span class="cp">#define LOG_BITS_PER_AU 4</span>
 <span class="cm">/* use this print string in error messages for uint32_t */</span>
<span class="cp">#define FMT_UI32 &quot;0x%lx&quot;</span>
<span class="cp">#define FMT8_UI32 &quot;%08lx&quot;	</span><span class="cm">/* same but no 0x, fixed width field */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cm">/* bits in the smallest addressable data storage unit */</span>
<span class="cp">#define BITS_PER_AU 8</span>
<span class="cm">/* log base 2 of the same; useful for shift counts */</span>
<span class="cp">#define LOG_BITS_PER_AU 3</span>
<span class="cp">#define FMT_UI32 &quot;0x%x&quot;</span>
<span class="cp">#define FMT8_UI32 &quot;%08x&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/* generic fastest method for swapping bytes and shorts */</span>
<span class="cp">#define SWAP32BY16(zz) (((zz) &lt;&lt; 16) | ((zz) &gt;&gt; 16))</span>
<span class="cp">#define SWAP16BY8(zz) (((zz) &lt;&lt; 8) | ((zz) &gt;&gt; 8))</span>

<span class="cm">/* !! don&#39;t be tempted to insert type definitions here; use &lt;stdint.h&gt; !! */</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *							Target Properties</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************** */</span>

<span class="cm">/*-------------------------------------------------------------------------- */</span>
<span class="cm">/* TMS320C6x Target Specific Parameters (byte-addressable) */</span>
<span class="cm">/*-------------------------------------------------------------------------- */</span>
<span class="cp">#if TMS32060</span>
<span class="cp">#define MEMORG          0x0L	</span><span class="cm">/* Size of configured memory */</span><span class="cp"></span>
<span class="cp">#define MEMSIZE         0x0L	</span><span class="cm">/* (full address space) */</span><span class="cp"></span>

<span class="cp">#define CINIT_ALIGN     8	</span><span class="cm">/* alignment of cinit record in TDATA AUs */</span><span class="cp"></span>
<span class="cp">#define CINIT_COUNT	4	</span><span class="cm">/* width of count field in TDATA AUs */</span><span class="cp"></span>
<span class="cp">#define CINIT_ADDRESS	4	</span><span class="cm">/* width of address field in TDATA AUs */</span><span class="cp"></span>
<span class="cp">#define CINIT_PAGE_BITS	0	</span><span class="cm">/* Number of LSBs of address that</span>
<span class="cm">				 * are page number */</span><span class="cp"></span>

<span class="cp">#define LENIENT_SIGNED_RELEXPS 0	</span><span class="cm">/* DOES SIGNED ALLOW MAX UNSIGNED */</span><span class="cp"></span>

<span class="cp">#undef TARGET_ENDIANNESS	</span><span class="cm">/* may be big or little endian */</span><span class="cp"></span>

<span class="cm">/* align a target address to a word boundary */</span>
<span class="cp">#define TARGET_WORD_ALIGN(zz) (((zz) + 0x3) &amp; -0x4)</span>
<span class="cp">#endif</span>

<span class="cm">/*--------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *			DEFAULT SETTINGS and DERIVED PROPERTIES</span>
<span class="cm"> *</span>
<span class="cm"> * This section establishes defaults for values not specified above</span>
<span class="cm"> *-------------------------------------------------------------------------- */</span>
<span class="cp">#ifndef TARGET_AU_BITS</span>
<span class="cp">#define TARGET_AU_BITS 8	</span><span class="cm">/* width of the target addressable unit */</span><span class="cp"></span>
<span class="cp">#define LOG_TARGET_AU_BITS 3	</span><span class="cm">/* log2 of same */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CINIT_DEFAULT_PAGE</span>
<span class="cp">#define CINIT_DEFAULT_PAGE 0	</span><span class="cm">/* default .cinit page number */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifndef DATA_RUN2LOAD</span>
<span class="cp">#define DATA_RUN2LOAD(zz) (zz)	</span><span class="cm">/* translate data run address to load address */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifndef DBG_LIST_PAGE</span>
<span class="cp">#define DBG_LIST_PAGE 0		</span><span class="cm">/* page number for .dllview section */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifndef TARGET_WORD_ALIGN</span>
<span class="cm">/* align a target address to a word boundary */</span>
<span class="cp">#define TARGET_WORD_ALIGN(zz) (zz)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef TDATA_TO_TADDR</span>
<span class="cp">#define TDATA_TO_TADDR(zz) (zz)	</span><span class="cm">/* target data address to target AU address */</span><span class="cp"></span>
<span class="cp">#define TADDR_TO_TDATA(zz) (zz)	</span><span class="cm">/* target AU address to target data address */</span><span class="cp"></span>
<span class="cp">#define TDATA_AU_BITS	TARGET_AU_BITS	</span><span class="cm">/* bits per data AU */</span><span class="cp"></span>
<span class="cp">#define LOG_TDATA_AU_BITS	LOG_TARGET_AU_BITS</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Useful properties and conversions derived from the above</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Conversions between host and target addresses</span>
<span class="cm"> */</span>
<span class="cp">#if LOG_BITS_PER_AU == LOG_TARGET_AU_BITS</span>
<span class="cm">/* translate target addressable unit to host address */</span>
<span class="cp">#define TADDR_TO_HOST(x) (x)</span>
<span class="cm">/* translate host address to target addressable unit */</span>
<span class="cp">#define HOST_TO_TADDR(x) (x)</span>
<span class="cp">#elif LOG_BITS_PER_AU &gt; LOG_TARGET_AU_BITS</span>
<span class="cp">#define TADDR_TO_HOST(x) ((x) &gt;&gt; (LOG_BITS_PER_AU-LOG_TARGET_AU_BITS))</span>
<span class="cp">#define HOST_TO_TADDR(x) ((x) &lt;&lt; (LOG_BITS_PER_AU-LOG_TARGET_AU_BITS))</span>
<span class="cp">#else</span>
<span class="cp">#define TADDR_TO_HOST(x) ((x) &lt;&lt; (LOG_TARGET_AU_BITS-LOG_BITS_PER_AU))</span>
<span class="cp">#define HOST_TO_TADDR(x) ((x) &gt;&gt; (LOG_TARGET_AU_BITS-LOG_BITS_PER_AU))</span>
<span class="cp">#endif</span>

<span class="cp">#if LOG_BITS_PER_AU == LOG_TDATA_AU_BITS</span>
<span class="cm">/* translate target addressable unit to host address */</span>
<span class="cp">#define TDATA_TO_HOST(x) (x)</span>
<span class="cm">/* translate host address to target addressable unit */</span>
<span class="cp">#define HOST_TO_TDATA(x) (x)</span>
<span class="cm">/* translate host address to target addressable unit, round up */</span>
<span class="cp">#define HOST_TO_TDATA_ROUND(x) (x)</span>
<span class="cm">/* byte offset to host offset, rounded up for TDATA size */</span>
<span class="cp">#define BYTE_TO_HOST_TDATA_ROUND(x) BYTE_TO_HOST_ROUND(x)</span>
<span class="cp">#elif LOG_BITS_PER_AU &gt; LOG_TDATA_AU_BITS</span>
<span class="cp">#define TDATA_TO_HOST(x) ((x) &gt;&gt; (LOG_BITS_PER_AU-LOG_TDATA_AU_BITS))</span>
<span class="cp">#define HOST_TO_TDATA(x) ((x) &lt;&lt; (LOG_BITS_PER_AU-LOG_TDATA_AU_BITS))</span>
<span class="cp">#define HOST_TO_TDATA_ROUND(x) ((x) &lt;&lt; (LOG_BITS_PER_AU-LOG_TDATA_AU_BITS))</span>
<span class="cp">#define BYTE_TO_HOST_TDATA_ROUND(x) BYTE_TO_HOST_ROUND(x)</span>
<span class="cp">#else</span>
<span class="cp">#define TDATA_TO_HOST(x) ((x) &lt;&lt; (LOG_TDATA_AU_BITS-LOG_BITS_PER_AU))</span>
<span class="cp">#define HOST_TO_TDATA(x) ((x) &gt;&gt; (LOG_TDATA_AU_BITS-LOG_BITS_PER_AU))</span>
<span class="cp">#define HOST_TO_TDATA_ROUND(x) (((x) +\</span>
<span class="cp">				(1&lt;&lt;(LOG_TDATA_AU_BITS-LOG_BITS_PER_AU))-1) &gt;&gt;\</span>
<span class="cp">				(LOG_TDATA_AU_BITS-LOG_BITS_PER_AU))</span>
<span class="cp">#define BYTE_TO_HOST_TDATA_ROUND(x) (BYTE_TO_HOST((x) +\</span>
<span class="cp">	(1&lt;&lt;(LOG_TDATA_AU_BITS-LOG_BITS_PER_BYTE))-1) &amp;\</span>
<span class="cp">	-(TDATA_AU_BITS/BITS_PER_AU))</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Input in DOFF format is always expresed in bytes, regardless of loading host</span>
<span class="cm"> * so we wind up converting from bytes to target and host units even when the</span>
<span class="cm"> * host is not a byte machine.</span>
<span class="cm"> */</span>
<span class="cp">#if LOG_BITS_PER_AU == LOG_BITS_PER_BYTE</span>
<span class="cp">#define BYTE_TO_HOST(x) (x)</span>
<span class="cp">#define BYTE_TO_HOST_ROUND(x) (x)</span>
<span class="cp">#define HOST_TO_BYTE(x) (x)</span>
<span class="cp">#elif LOG_BITS_PER_AU &gt;= LOG_BITS_PER_BYTE</span>
<span class="cp">#define BYTE_TO_HOST(x) ((x) &gt;&gt; (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE))</span>
<span class="cp">#define BYTE_TO_HOST_ROUND(x) ((x + (BITS_PER_AU/BITS_PER_BYTE-1)) &gt;&gt;\</span>
<span class="cp">			      (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE))</span>
<span class="cp">#define HOST_TO_BYTE(x) ((x) &lt;&lt; (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE))</span>
<span class="cp">#else</span>
<span class="cm">/* lets not try to deal with sub-8-bit byte machines */</span>
<span class="cp">#endif</span>

<span class="cp">#if LOG_TARGET_AU_BITS == LOG_BITS_PER_BYTE</span>
<span class="cm">/* translate target addressable unit to byte address */</span>
<span class="cp">#define TADDR_TO_BYTE(x) (x)</span>
<span class="cm">/* translate byte address to target addressable unit */</span>
<span class="cp">#define BYTE_TO_TADDR(x) (x)</span>
<span class="cp">#elif LOG_TARGET_AU_BITS &gt; LOG_BITS_PER_BYTE</span>
<span class="cp">#define TADDR_TO_BYTE(x) ((x) &lt;&lt; (LOG_TARGET_AU_BITS-LOG_BITS_PER_BYTE))</span>
<span class="cp">#define BYTE_TO_TADDR(x) ((x) &gt;&gt; (LOG_TARGET_AU_BITS-LOG_BITS_PER_BYTE))</span>
<span class="cp">#else</span>
<span class="cm">/* lets not try to deal with sub-8-bit byte machines */</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef _BIG_ENDIAN</span>
<span class="cp">#define HOST_ENDIANNESS 1</span>
<span class="cp">#else</span>
<span class="cp">#define HOST_ENDIANNESS 0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef TARGET_ENDIANNESS</span>
<span class="cp">#define TARGET_ENDIANNESS_DIFFERS(rtend) (HOST_ENDIANNESS^TARGET_ENDIANNESS)</span>
<span class="cp">#elif HOST_ENDIANNESS</span>
<span class="cp">#define TARGET_ENDIANNESS_DIFFERS(rtend) (!(rtend))</span>
<span class="cp">#else</span>
<span class="cp">#define TARGET_ENDIANNESS_DIFFERS(rtend) (rtend)</span>
<span class="cp">#endif</span>

<span class="cm">/* the unit in which we process target image data */</span>
<span class="cp">#if TARGET_AU_BITS &lt;= 8</span>
<span class="k">typedef</span> <span class="n">u8</span> <span class="n">tgt_au_t</span><span class="p">;</span>
<span class="cp">#elif TARGET_AU_BITS &lt;= 16</span>
<span class="k">typedef</span> <span class="n">u16</span> <span class="n">tgt_au_t</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="n">u32</span> <span class="n">tgt_au_t</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* size of that unit */</span>
<span class="cp">#if TARGET_AU_BITS &lt; BITS_PER_AU</span>
<span class="cp">#define TGTAU_BITS BITS_PER_AU</span>
<span class="cp">#define LOG_TGTAU_BITS LOG_BITS_PER_AU</span>
<span class="cp">#else</span>
<span class="cp">#define TGTAU_BITS TARGET_AU_BITS</span>
<span class="cp">#define LOG_TGTAU_BITS LOG_TARGET_AU_BITS</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
