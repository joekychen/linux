<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › dynload › tramp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tramp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * tramp.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;header.h&quot;</span>

<span class="cp">#if TMS32060</span>
<span class="cp">#include &quot;tramp_table_c6000.c&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#define MAX_RELOS_PER_PASS	4</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tramp_sect_tgt_alloc</span>
<span class="cm"> * Description: Allocate target memory for the trampoline section.  The</span>
<span class="cm"> *	  target mem size is easily obtained as the next available address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">priv_tramp_sect_tgt_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="n">sect_info</span><span class="p">;</span>

	<span class="cm">/*  Populate the trampoline loader section and allocate it on the</span>
<span class="cm">	 * target.  The section name is ALWAYS the first string in the final</span>
<span class="cm">	 * string table for trampolines.  The trampoline section is always</span>
<span class="cm">	 * 1 beyond the total number of allocated sections. */</span>
	<span class="n">sect_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">[</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">];</span>

	<span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">final_string_table</span><span class="p">;</span>
	<span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sect_next_addr</span><span class="p">;</span>
	<span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span>
	    <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">DLOAD_TEXT</span> <span class="o">|</span> <span class="n">DS_ALLOCATE_MASK</span> <span class="o">|</span> <span class="n">DS_DOWNLOAD_MASK</span><span class="p">;</span>
	<span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">run_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">load_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myalloc</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myalloc</span><span class="p">,</span>
						  <span class="n">sect_info</span><span class="p">,</span>
						  <span class="n">ds_alignment</span>
						  <span class="p">(</span><span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Failed to allocate target memory for&quot;</span>
			    <span class="s">&quot; trampoline&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_h2a</span>
<span class="cm"> * Description: Helper function to convert a hex value to its ASCII</span>
<span class="cm"> *	  representation.  Used for trampoline symbol name generation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">priv_h2a</span><span class="p">(</span><span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mh">0xF</span><span class="p">)</span>
		<span class="k">return</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">+=</span> <span class="mh">0x30</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">value</span> <span class="o">+=</span> <span class="mh">0x37</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tramp_sym_gen_name</span>
<span class="cm"> * Description: Generate a trampoline symbol name (ASCII) using the value</span>
<span class="cm"> *	  of the symbol.  This places the new name into the user buffer.</span>
<span class="cm"> *	  The name is fixed in length and of the form: __$dbTR__xxxxxxxx</span>
<span class="cm"> *	  (where &quot;xxxxxxxx&quot; is the hex value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">priv_tramp_sym_gen_name</span><span class="p">(</span><span class="n">u32</span> <span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">TRAMP_SYM_PREFIX</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dst_local</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/*  Clear out the destination, including the ending NULL */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">TRAMP_SYM_PREFIX_LEN</span> <span class="o">+</span> <span class="n">TRAMP_SYM_HEX_ASCII_LEN</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">dst_local</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*  Copy the prefix to start */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">TRAMP_SYM_PREFIX</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dst_local</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">dst_local</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  Now convert the value passed in to a string equiv of the hex */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef _BIG_ENDIAN</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dst_local</span> <span class="o">=</span> <span class="n">priv_h2a</span><span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">dst_local</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dst_local</span> <span class="o">=</span> <span class="n">priv_h2a</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">);</span>
		<span class="n">dst_local</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dst_local</span> <span class="o">=</span> <span class="n">priv_h2a</span><span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">dst_local</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dst_local</span> <span class="o">=</span> <span class="n">priv_h2a</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">);</span>
		<span class="n">dst_local</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/*  NULL terminate */</span>
	<span class="o">*</span><span class="n">dst_local</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tramp_string_create</span>
<span class="cm"> * Description: Create a new string specific to the trampoline loading and add</span>
<span class="cm"> *	  it to the trampoline string list.  This list contains the</span>
<span class="cm"> *	  trampoline section name and trampoline point symbols.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="nf">priv_tramp_string_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
						     <span class="n">u32</span> <span class="n">str_len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="n">new_string</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*  Create a new string object with the specified size. */</span>
	<span class="n">new_string</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
								 <span class="p">(</span><span class="k">sizeof</span>
								  <span class="p">(</span><span class="k">struct</span>
								   <span class="n">tramp_string</span><span class="p">)</span>
								  <span class="o">+</span> <span class="n">str_len</span> <span class="o">+</span>
								  <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_string</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  Clear the string first.  This ensures the ending NULL is</span>
<span class="cm">		 * present and the optimizer won&#39;t touch it. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tramp_string</span><span class="p">)</span> <span class="o">+</span> <span class="n">str_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		     <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">new_string</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*  Add this string to our virtual table by assigning it the</span>
<span class="cm">		 * next index and pushing it to the tail of the list. */</span>
		<span class="n">new_string</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_string_next_index</span><span class="p">;</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_string_next_index</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_string_size</span> <span class="o">+=</span> <span class="n">str_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">new_string</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_head</span> <span class="o">=</span> <span class="n">new_string</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_string</span><span class="p">;</span>

		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_tail</span> <span class="o">=</span> <span class="n">new_string</span><span class="p">;</span>

		<span class="cm">/*  Copy the string over to the new object */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">new_string</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">new_string</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tramp_string_find</span>
<span class="cm"> * Description: Walk the trampoline string list and find a match for the</span>
<span class="cm"> *	  provided string.  If not match is found, NULL is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="nf">priv_tramp_string_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
						   <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="n">cur_str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="n">ret_val</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">str_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cur_str</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_head</span><span class="p">;</span>
	     <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cur_str</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span> <span class="n">cur_str</span> <span class="o">=</span> <span class="n">cur_str</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  If the string lengths aren&#39;t equal, don&#39;t bother</span>
<span class="cm">		 * comparing */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">str_len</span> <span class="o">!=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cur_str</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*  Walk the strings until one of them ends */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  If they don&#39;t match in the current position then</span>
<span class="cm">			 * break out now, no sense in continuing to look at</span>
<span class="cm">			 * this string. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cur_str</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">str_len</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">cur_str</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_string_tbl_finalize</span>
<span class="cm"> * Description: Flatten the trampoline string list into a table of NULL</span>
<span class="cm"> *	  terminated strings.  This is the same format of string table</span>
<span class="cm"> *	  as used by the COFF/DOFF file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">priv_string_tbl_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="n">cur_string</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cur_loc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/*  Allocate enough space for all strings that have been created.  The</span>
<span class="cm">	 * table is simply all strings concatenated together will NULL</span>
<span class="cm">	 * endings. */</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">final_string_table</span> <span class="o">=</span>
	    <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
						  <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span>
						  <span class="n">tramp_string_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">final_string_table</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  We got our buffer, walk the list and release the nodes as*</span>
<span class="cm">		 * we go */</span>
		<span class="n">cur_loc</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">final_string_table</span><span class="p">;</span>
		<span class="n">cur_string</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_head</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cur_string</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  Move the head/tail pointers */</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_head</span> <span class="o">=</span> <span class="n">cur_string</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_tail</span> <span class="o">==</span> <span class="n">cur_string</span><span class="p">)</span>
				<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/*  Copy the string contents */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">cur_string</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">;</span>
			     <span class="o">*</span><span class="n">tmp</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">tmp</span><span class="o">++</span><span class="p">,</span> <span class="n">cur_loc</span><span class="o">++</span><span class="p">)</span>
				<span class="o">*</span><span class="n">cur_loc</span> <span class="o">=</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

			<span class="cm">/*  Pick up the NULL termination since it was missed by</span>
<span class="cm">			 * breaking using it to end the above loop. */</span>
			<span class="o">*</span><span class="n">cur_loc</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="n">cur_loc</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/*  Free the string node, we don&#39;t need it any more. */</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
							<span class="n">cur_string</span><span class="p">);</span>

			<span class="cm">/*  Move our pointer to the next one */</span>
			<span class="n">cur_string</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_head</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*  Update our return value to success */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Failed to allocate trampoline &quot;</span>
			    <span class="s">&quot;string table&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tramp_sect_alloc</span>
<span class="cm"> * Description: Virtually allocate space from the trampoline section.  This</span>
<span class="cm"> *	  function returns the next offset within the trampoline section</span>
<span class="cm"> *	  that is available and moved the next available offset by the</span>
<span class="cm"> *	  requested size.  NO TARGET ALLOCATION IS DONE AT THIS TIME.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">priv_tramp_sect_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tramp_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*  If the next available address is 0, this is our first allocation.</span>
<span class="cm">	 * Create a section name string to go into the string table . */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sect_next_addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dload_syms_error</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="s">&quot;*** WARNING ***  created &quot;</span>
				 <span class="s">&quot;dynamic TRAMPOLINE section for module %s&quot;</span><span class="p">,</span>
				 <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_head</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*  Reserve space for the new trampoline */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sect_next_addr</span><span class="p">;</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sect_next_addr</span> <span class="o">+=</span> <span class="n">tramp_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tramp_sym_create</span>
<span class="cm"> * Description: Allocate and create a new trampoline specific symbol and add</span>
<span class="cm"> *	  it to the trampoline symbol list.  These symbols will include</span>
<span class="cm"> *	  trampoline points as well as the external symbols they</span>
<span class="cm"> *	  reference.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="nf">priv_tramp_sym_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
					       <span class="n">u32</span> <span class="n">str_index</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">local_symbol</span> <span class="o">*</span><span class="n">tmp_sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">new_sym</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*  Allocate new space for the symbol in the symbol table. */</span>
	<span class="n">new_sym</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
					      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tramp_sym</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_sym</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tramp_sym</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">new_sym</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*  Assign this symbol the next symbol index for easier</span>
<span class="cm">		 * reference later during relocation. */</span>
		<span class="n">new_sym</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sym_next_index</span><span class="p">;</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sym_next_index</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*  Populate the symbol information.  At this point any</span>
<span class="cm">		 * trampoline symbols will be the offset location, not the</span>
<span class="cm">		 * final.  Copy over the symbol info to start, then be sure to</span>
<span class="cm">		 * get the string index from the trampoline string table. */</span>
		<span class="n">new_sym</span><span class="o">-&gt;</span><span class="n">sym_info</span> <span class="o">=</span> <span class="o">*</span><span class="n">tmp_sym</span><span class="p">;</span>
		<span class="n">new_sym</span><span class="o">-&gt;</span><span class="n">str_index</span> <span class="o">=</span> <span class="n">str_index</span><span class="p">;</span>

		<span class="cm">/*  Push the new symbol to the tail of the symbol table list */</span>
		<span class="n">new_sym</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">symbol_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">symbol_head</span> <span class="o">=</span> <span class="n">new_sym</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">symbol_tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_sym</span><span class="p">;</span>

		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">symbol_tail</span> <span class="o">=</span> <span class="n">new_sym</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">new_sym</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tramp_sym_get</span>
<span class="cm"> * Description: Search for the symbol with the matching string index (from</span>
<span class="cm"> *	  the trampoline string table) and return the trampoline</span>
<span class="cm"> *	  symbol object, if found.  Otherwise return NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="nf">priv_tramp_sym_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
					    <span class="n">u32</span> <span class="n">string_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">sym_found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*  Walk the symbol table list and search vs. the string index */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sym_found</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">symbol_head</span><span class="p">;</span>
	     <span class="n">sym_found</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">sym_found</span> <span class="o">=</span> <span class="n">sym_found</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym_found</span><span class="o">-&gt;</span><span class="n">str_index</span> <span class="o">==</span> <span class="n">string_index</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sym_found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tramp_sym_find</span>
<span class="cm"> * Description: Search for a trampoline symbol based on the string name of</span>
<span class="cm"> *	  the symbol.  Return the symbol object, if found, otherwise</span>
<span class="cm"> *	  return NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="nf">priv_tramp_sym_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
					     <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">sym_found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="n">str_found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*  First, search for the string, then search for the sym based on the</span>
<span class="cm">	   string index. */</span>
	<span class="n">str_found</span> <span class="o">=</span> <span class="n">priv_tramp_string_find</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">str_found</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">sym_found</span> <span class="o">=</span> <span class="n">priv_tramp_sym_get</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">str_found</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sym_found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tramp_sym_finalize</span>
<span class="cm"> * Description: Allocate a flat symbol table for the trampoline section,</span>
<span class="cm"> *	  put each trampoline symbol into the table, adjust the</span>
<span class="cm"> *	  symbol value based on the section address on the target and</span>
<span class="cm"> *	  free the trampoline symbol list nodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">priv_tramp_sym_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">cur_sym</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="n">tramp_sect</span> <span class="o">=</span>
	    <span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">[</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">local_symbol</span> <span class="o">*</span><span class="n">new_sym</span><span class="p">;</span>

	<span class="cm">/*  Allocate a table to hold a flattened version of all symbols</span>
<span class="cm">	 * created. */</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">final_sym_table</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">local_symbol</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
				 <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">local_symbol</span><span class="p">)</span> <span class="o">*</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span>
						  <span class="n">tramp_sym_next_index</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">final_sym_table</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  Walk the list of all symbols, copy it over to the flattened</span>
<span class="cm">		 * table. After it has been copied, the node can be freed as</span>
<span class="cm">		 * it is no longer needed. */</span>
		<span class="n">new_sym</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">final_sym_table</span><span class="p">;</span>
		<span class="n">cur_sym</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">symbol_head</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cur_sym</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  Pop it off the list */</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">symbol_head</span> <span class="o">=</span> <span class="n">cur_sym</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur_sym</span> <span class="o">==</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">symbol_tail</span><span class="p">)</span>
				<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">symbol_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/*  Copy the symbol contents into the flat table */</span>
			<span class="o">*</span><span class="n">new_sym</span> <span class="o">=</span> <span class="n">cur_sym</span><span class="o">-&gt;</span><span class="n">sym_info</span><span class="p">;</span>

			<span class="cm">/*  Now finaize the symbol.  If it is in the tramp</span>
<span class="cm">			 * section, we need to adjust for the section start.</span>
<span class="cm">			 * If it is external then we don&#39;t need to adjust at</span>
<span class="cm">			 * all.</span>
<span class="cm">			 * NOTE: THIS CODE ASSUMES THAT THE TRAMPOLINE IS</span>
<span class="cm">			 * REFERENCED LIKE A CALL TO AN EXTERNAL SO VALUE AND</span>
<span class="cm">			 * DELTA ARE THE SAME.  SEE THE FUNCTION dload_symbols</span>
<span class="cm">			 * WHERE DN_UNDEF IS HANDLED FOR MORE REFERENCE. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_sym</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_sym</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">+=</span> <span class="n">tramp_sect</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">;</span>
				<span class="n">new_sym</span><span class="o">-&gt;</span><span class="n">delta</span> <span class="o">=</span> <span class="n">new_sym</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*  Let go of the symbol node */</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">cur_sym</span><span class="p">);</span>

			<span class="cm">/*  Move to the next node */</span>
			<span class="n">cur_sym</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">symbol_head</span><span class="p">;</span>
			<span class="n">new_sym</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Failed to alloc trampoline sym table&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tgt_img_gen</span>
<span class="cm"> * Description: Allocate storage for and copy the target specific image data</span>
<span class="cm"> *	and fix up its relocations for the new external symbol.  If</span>
<span class="cm"> *	a trampoline image packet was successfully created it is added</span>
<span class="cm"> *	to the trampoline list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">priv_tgt_img_gen</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">u32</span> <span class="n">base</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">gen_index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">new_ext_sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_img_pkt</span> <span class="o">*</span><span class="n">new_img_pkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pkt_size</span> <span class="o">=</span> <span class="n">tramp_img_pkt_size_get</span><span class="p">();</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">gen_tbl_entry</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pkt_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">cur_relo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*  Allocate a new image packet and set it up. */</span>
	<span class="n">new_img_pkt</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">tramp_img_pkt</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
								  <span class="n">pkt_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_img_pkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  Save the base, this is where it goes in the section */</span>
		<span class="n">new_img_pkt</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>

		<span class="cm">/*  Copy over the image data and relos from the target table */</span>
		<span class="n">pkt_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">new_img_pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
		<span class="n">gen_tbl_entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tramp_gen_info</span><span class="p">[</span><span class="n">gen_index</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pkt_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">pkt_data</span> <span class="o">=</span> <span class="o">*</span><span class="n">gen_tbl_entry</span><span class="p">;</span>
			<span class="n">pkt_data</span><span class="o">++</span><span class="p">;</span>
			<span class="n">gen_tbl_entry</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*  Update the relocations to point to the external symbol */</span>
		<span class="n">cur_relo</span> <span class="o">=</span>
		    <span class="p">(</span><span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">new_img_pkt</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span>
					      <span class="n">new_img_pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">relo_offset</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">new_img_pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">num_relos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">cur_relo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">SYMNDX</span> <span class="o">=</span> <span class="n">new_ext_sym</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

		<span class="cm">/*  Add it to the trampoline list. */</span>
		<span class="n">new_img_pkt</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_pkts</span><span class="p">;</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_pkts</span> <span class="o">=</span> <span class="n">new_img_pkt</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_pkt_relo</span>
<span class="cm"> * Description: Take the provided image data and the collection of relocations</span>
<span class="cm"> *	  for it and perform the relocations.  Note that all relocations</span>
<span class="cm"> *	  at this stage are considered SECOND PASS since the original</span>
<span class="cm"> *	  image has already been processed in the first pass.  This means</span>
<span class="cm"> *	  TRAMPOLINES ARE TREATED AS 2ND PASS even though this is really</span>
<span class="cm"> *	  the first (and only) relocation that will be performed on them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">priv_pkt_relo</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">tgt_au_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">[],</span> <span class="n">u32</span> <span class="n">relo_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/*  Walk through all of the relos and process them.  This function is</span>
<span class="cm">	 * the equivalent of relocate_packet() from cload.c, but specialized</span>
<span class="cm">	 * for trampolines and 2nd phase relocations. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">relo_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dload_relocate</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_tramp_pkt_finalize</span>
<span class="cm"> * Description: Walk the list of all trampoline packets and finalize them.</span>
<span class="cm"> *	  Each trampoline image packet will be relocated now that the</span>
<span class="cm"> *	  trampoline section has been allocated on the target.  Once</span>
<span class="cm"> *	  all of the relocations are done the trampoline image data</span>
<span class="cm"> *	  is written into target memory and the trampoline packet</span>
<span class="cm"> *	  is freed: it is no longer needed after this point.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">priv_tramp_pkt_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_img_pkt</span> <span class="o">*</span><span class="n">cur_pkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">relos</span><span class="p">[</span><span class="n">MAX_RELOS_PER_PASS</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">relos_done</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">cur_relo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="n">sect_info</span> <span class="o">=</span>
	    <span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">[</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">];</span>

	<span class="cm">/*  Walk the list of trampoline packets and relocate each packet.  This</span>
<span class="cm">	 * function is the trampoline equivalent of dload_data() from</span>
<span class="cm">	 * cload.c. */</span>
	<span class="n">cur_pkt</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_pkts</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cur_pkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*  Remove the pkt from the list */</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_pkts</span> <span class="o">=</span> <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="cm">/*  Setup section and image offset information for the relo */</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span> <span class="o">=</span> <span class="n">sect_info</span><span class="p">;</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span> <span class="o">=</span> <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">delta_runaddr</span> <span class="o">=</span> <span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">run_addr</span><span class="p">;</span>

		<span class="cm">/*  Walk through all relos for the packet */</span>
		<span class="n">relos_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cur_relo</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span>
						     <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">relo_offset</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">relos_done</span> <span class="o">&lt;</span> <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">num_relos</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef ENABLE_TRAMP_DEBUG</span>
			<span class="n">dload_syms_error</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
					 <span class="s">&quot;===&gt; Trampoline %x branches to %x&quot;</span><span class="p">,</span>
					 <span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">run_addr</span> <span class="o">+</span>
					 <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span><span class="p">,</span>
					 <span class="n">dlthis</span><span class="o">-&gt;</span>
					 <span class="n">tramp</span><span class="p">.</span><span class="n">final_sym_table</span><span class="p">[</span><span class="n">cur_relo</span><span class="o">-&gt;</span>
							       <span class="n">SYMNDX</span><span class="p">].</span><span class="n">value</span><span class="p">);</span>
<span class="cp">#endif</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			     <span class="p">((</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_RELOS_PER_PASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			      <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">relos_done</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">num_relos</span><span class="p">));</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">relos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_relo</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

			<span class="cm">/*  Do the actual relo */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">priv_pkt_relo</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
						<span class="p">(</span><span class="n">tgt_au_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span>
						<span class="n">relos</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
					    <span class="s">&quot;Relocation of trampoline pkt at %x&quot;</span>
					    <span class="s">&quot; failed&quot;</span><span class="p">,</span> <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span>
					    <span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">run_addr</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">relos_done</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">cur_relo</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*  Make sure we didn&#39;t hit a problem */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  Relos are done for the packet, write it to the</span>
<span class="cm">			 * target */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="o">-&gt;</span><span class="n">writemem</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span>
							 <span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">load_addr</span> <span class="o">+</span>
							 <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
							 <span class="n">sect_info</span><span class="p">,</span>
							 <span class="n">BYTE_TO_HOST</span>
							 <span class="p">(</span><span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span>
							  <span class="n">tramp_code_size</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
					    <span class="s">&quot;Write to &quot;</span> <span class="n">FMT_UI32</span> <span class="s">&quot; failed&quot;</span><span class="p">,</span>
					    <span class="n">sect_info</span><span class="o">-&gt;</span><span class="n">load_addr</span> <span class="o">+</span>
					    <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*  Done with the pkt, let it go */</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">cur_pkt</span><span class="p">);</span>

			<span class="cm">/*  Get the next packet to process */</span>
			<span class="n">cur_pkt</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_pkts</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_dup_pkt_finalize</span>
<span class="cm"> * Description: Walk the list of duplicate image packets and finalize them.</span>
<span class="cm"> *	  Each duplicate packet will be relocated again for the</span>
<span class="cm"> *	  relocations that previously failed and have been adjusted</span>
<span class="cm"> *	  to point at a trampoline.  Once all relocations for a packet</span>
<span class="cm"> *	  have been done, write the packet into target memory.  The</span>
<span class="cm"> *	  duplicate packet and its relocation chain are all freed</span>
<span class="cm"> *	  after use here as they are no longer needed after this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">priv_dup_pkt_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span> <span class="o">*</span><span class="n">cur_pkt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_relo</span> <span class="o">*</span><span class="n">cur_relo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">relos</span><span class="p">[</span><span class="n">MAX_RELOS_PER_PASS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">doff_scnhdr_t</span> <span class="o">*</span><span class="n">sect_hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Similar to the trampoline pkt finalize, this function walks each dup</span>
<span class="cm">	 * pkt that was generated and performs all relocations that were</span>
<span class="cm">	 * deferred to a 2nd pass.  This is the equivalent of dload_data() from</span>
<span class="cm">	 * cload.c, but does not need the additional reorder and checksum</span>
<span class="cm">	 * processing as it has already been done. */</span>
	<span class="n">cur_pkt</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">dup_pkts</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cur_pkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*  Remove the node from the list, we&#39;ll be freeing it</span>
<span class="cm">		 * shortly */</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">dup_pkts</span> <span class="o">=</span> <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="cm">/*  Setup the section and image offset for relocation */</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">[</span><span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">secnn</span><span class="p">];</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span> <span class="o">=</span> <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>

		<span class="cm">/*  In order to get the delta run address, we need to reference</span>
<span class="cm">		 * the original section header.  It&#39;s a bit ugly, but needed</span>
<span class="cm">		 * for relo. */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span> <span class="o">-</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">);</span>
		<span class="n">sect_hdr</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">sect_hdrs</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">delta_runaddr</span> <span class="o">=</span> <span class="n">sect_hdr</span><span class="o">-&gt;</span><span class="n">ds_paddr</span><span class="p">;</span>

		<span class="cm">/*  Walk all relos in the chain and process each. */</span>
		<span class="n">cur_relo</span> <span class="o">=</span> <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">relo_chain</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cur_relo</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  Process them a chunk at a time to be efficient */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_RELOS_PER_PASS</span><span class="p">)</span>
			     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cur_relo</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
			     <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">cur_relo</span> <span class="o">=</span> <span class="n">cur_relo</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">relos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cur_relo</span><span class="o">-&gt;</span><span class="n">relo</span><span class="p">;</span>
				<span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">relo_chain</span> <span class="o">=</span> <span class="n">cur_relo</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*  Do the actual relo */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">priv_pkt_relo</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
						<span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">img_pkt</span><span class="p">.</span><span class="n">img_data</span><span class="p">,</span>
						<span class="n">relos</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
					    <span class="s">&quot;Relocation of dup pkt at %x&quot;</span>
					    <span class="s">&quot; failed&quot;</span><span class="p">,</span> <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span>
					    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="o">-&gt;</span><span class="n">run_addr</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*  Release all of these relos, we&#39;re done with them */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
						<span class="n">GET_CONTAINER</span>
						<span class="p">(</span><span class="n">relos</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
						 <span class="k">struct</span> <span class="n">tramp_img_dup_relo</span><span class="p">,</span>
						 <span class="n">relo</span><span class="p">));</span>
				<span class="n">i</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*  DO NOT ADVANCE cur_relo, IT IS ALREADY READY TO</span>
<span class="cm">			 * GO! */</span>
		<span class="p">}</span>

		<span class="cm">/* Done with all relos.  Make sure we didn&#39;t have a problem and</span>
<span class="cm">		 * write it out to the target */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="o">-&gt;</span><span class="n">writemem</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="p">,</span>
							 <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">img_pkt</span><span class="p">.</span>
							 <span class="n">img_data</span><span class="p">,</span>
							 <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="o">-&gt;</span>
							 <span class="n">load_addr</span> <span class="o">+</span>
							 <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
							 <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="p">,</span>
							 <span class="n">BYTE_TO_HOST</span>
							 <span class="p">(</span><span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">img_pkt</span><span class="p">.</span>
							  <span class="n">packet_size</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
					    <span class="s">&quot;Write to &quot;</span> <span class="n">FMT_UI32</span> <span class="s">&quot; failed&quot;</span><span class="p">,</span>
					    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="o">-&gt;</span><span class="n">load_addr</span> <span class="o">+</span>
					    <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">cur_pkt</span><span class="p">);</span>

			<span class="cm">/*  Advance to the next packet */</span>
			<span class="n">cur_pkt</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">dup_pkts</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_dup_find</span>
<span class="cm"> * Description: Walk the list of existing duplicate packets and find a</span>
<span class="cm"> *	  match based on the section number and image offset.  Return</span>
<span class="cm"> *	  the duplicate packet if found, otherwise NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span> <span class="o">*</span><span class="nf">priv_dup_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
					       <span class="n">s16</span> <span class="n">secnn</span><span class="p">,</span> <span class="n">u32</span> <span class="n">image_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span> <span class="o">*</span><span class="n">cur_pkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cur_pkt</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">dup_pkts</span><span class="p">;</span>
	     <span class="n">cur_pkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cur_pkt</span> <span class="o">=</span> <span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">==</span> <span class="n">secnn</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cur_pkt</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">==</span> <span class="n">image_offset</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*  Found a match, break out */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cur_pkt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	priv_img_pkt_dup</span>
<span class="cm"> * Description: Duplicate the original image packet.  If this is the first</span>
<span class="cm"> *	  time this image packet has been seen (based on section number</span>
<span class="cm"> *	  and image offset), create a new duplicate packet and add it</span>
<span class="cm"> *	  to the dup packet list.  If not, just get the existing one and</span>
<span class="cm"> *	  update it with the current packet contents (since relocation</span>
<span class="cm"> *	  on the packet is still ongoing in first pass.)  Create a</span>
<span class="cm"> *	  duplicate of the provided relocation, but update it to point</span>
<span class="cm"> *	  to the new trampoline symbol.  Add the new relocation dup to</span>
<span class="cm"> *	  the dup packet&#39;s relo chain for 2nd pass relocation later.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">priv_img_pkt_dup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
			    <span class="n">s16</span> <span class="n">secnn</span><span class="p">,</span> <span class="n">u32</span> <span class="n">image_offset</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">image_packet_t</span> <span class="o">*</span><span class="n">ipacket</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">new_tramp_sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span> <span class="o">*</span><span class="n">dup_pkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_dup_size</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_relo</span> <span class="o">*</span><span class="n">dup_relo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*  Determinne if this image packet is already being tracked in the</span>
<span class="cm">	   dup list for other trampolines. */</span>
	<span class="n">dup_pkt</span> <span class="o">=</span> <span class="n">priv_dup_find</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">secnn</span><span class="p">,</span> <span class="n">image_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dup_pkt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  This image packet does not exist in our tracking, so create</span>
<span class="cm">		 * a new one and add it to the head of the list. */</span>
		<span class="n">new_dup_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span><span class="p">)</span> <span class="o">+</span>
		    <span class="n">ipacket</span><span class="o">-&gt;</span><span class="n">packet_size</span><span class="p">;</span>

		<span class="n">dup_pkt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span> <span class="o">*</span><span class="p">)</span>
		    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">new_dup_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dup_pkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  Save off the section and offset information */</span>
			<span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">=</span> <span class="n">secnn</span><span class="p">;</span>
			<span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">image_offset</span><span class="p">;</span>
			<span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">relo_chain</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/*  Copy the original packet content */</span>
			<span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">img_pkt</span> <span class="o">=</span> <span class="o">*</span><span class="n">ipacket</span><span class="p">;</span>
			<span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">img_pkt</span><span class="p">.</span><span class="n">img_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">dup_pkt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ipacket</span><span class="o">-&gt;</span><span class="n">packet_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="o">*</span><span class="p">(</span><span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">img_pkt</span><span class="p">.</span><span class="n">img_data</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span>
				    <span class="o">*</span><span class="p">(</span><span class="n">ipacket</span><span class="o">-&gt;</span><span class="n">img_data</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

			<span class="cm">/*  Add the packet to the dup list */</span>
			<span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">dup_pkts</span><span class="p">;</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">dup_pkts</span> <span class="o">=</span> <span class="n">dup_pkt</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Failed to create dup packet!&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*  The image packet contents could have changed since</span>
<span class="cm">		 * trampoline detection happens during relocation of the image</span>
<span class="cm">		 * packets.  So, we need to update the image packet contents</span>
<span class="cm">		 * before adding relo information. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">img_pkt</span><span class="p">.</span><span class="n">packet_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">img_pkt</span><span class="p">.</span><span class="n">img_data</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span>
			    <span class="o">*</span><span class="p">(</span><span class="n">ipacket</span><span class="o">-&gt;</span><span class="n">img_data</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*  Since the previous code may have allocated a new dup packet for us,</span>
<span class="cm">	   double check that we actually have one. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dup_pkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  Allocate a new node for the relo chain.  Each image packet</span>
<span class="cm">		 * can potentially have multiple relocations that cause a</span>
<span class="cm">		 * trampoline to be generated.  So, we keep them in a chain,</span>
<span class="cm">		 * order is not important. */</span>
		<span class="n">dup_relo</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tramp_img_dup_relo</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dup_relo</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  Copy the relo contents, adjust for the new</span>
<span class="cm">			 * trampoline and add it to the list. */</span>
			<span class="n">dup_relo</span><span class="o">-&gt;</span><span class="n">relo</span> <span class="o">=</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
			<span class="n">dup_relo</span><span class="o">-&gt;</span><span class="n">relo</span><span class="p">.</span><span class="n">SYMNDX</span> <span class="o">=</span> <span class="n">new_tramp_sym</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

			<span class="n">dup_relo</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">relo_chain</span><span class="p">;</span>
			<span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">relo_chain</span> <span class="o">=</span> <span class="n">dup_relo</span><span class="p">;</span>

			<span class="cm">/*  That&#39;s it, we&#39;re done.  Make sure we update our</span>
<span class="cm">			 * return value to be success since everything finished</span>
<span class="cm">			 * ok */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Unable to alloc dup relo&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	dload_tramp_avail</span>
<span class="cm"> * Description: Check to see if the target supports a trampoline for this type</span>
<span class="cm"> *	  of relocation.  Return true if it does, otherwise false.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">dload_tramp_avail</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">map_index</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">gen_index</span><span class="p">;</span>

	<span class="cm">/*  Check type hash vs. target tramp table */</span>
	<span class="n">map_index</span> <span class="o">=</span> <span class="n">HASH_FUNC</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">TYPE</span><span class="p">);</span>
	<span class="n">gen_index</span> <span class="o">=</span> <span class="n">tramp_map</span><span class="p">[</span><span class="n">map_index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gen_index</span> <span class="o">!=</span> <span class="n">TRAMP_NO_GEN_AVAIL</span><span class="p">)</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	dload_tramp_generate</span>
<span class="cm"> * Description: Create a new trampoline for the provided image packet and</span>
<span class="cm"> *	  relocation causing problems.  This will create the trampoline</span>
<span class="cm"> *	  as well as duplicate/update the image packet and relocation</span>
<span class="cm"> *	  causing the problem, which will be relo&#39;d again during</span>
<span class="cm"> *	  finalization.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dload_tramp_generate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">s16</span> <span class="n">secnn</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">image_offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">image_packet_t</span> <span class="o">*</span><span class="n">ipacket</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">map_index</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">gen_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tramp_sym_str</span><span class="p">[</span><span class="n">TRAMP_SYM_PREFIX_LEN</span> <span class="o">+</span> <span class="n">TRAMP_SYM_HEX_ASCII_LEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">local_symbol</span> <span class="o">*</span><span class="n">ref_sym</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">new_tramp_sym</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">new_ext_sym</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="n">new_tramp_str</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_tramp_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">local_symbol</span> <span class="n">tmp_sym</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">local_symbol</span> <span class="n">ext_tmp_sym</span><span class="p">;</span>

	<span class="cm">/*  Hash the relo type to get our generator information */</span>
	<span class="n">map_index</span> <span class="o">=</span> <span class="n">HASH_FUNC</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">TYPE</span><span class="p">);</span>
	<span class="n">gen_index</span> <span class="o">=</span> <span class="n">tramp_map</span><span class="p">[</span><span class="n">map_index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gen_index</span> <span class="o">!=</span> <span class="n">TRAMP_NO_GEN_AVAIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  If this is the first trampoline, create the section name in</span>
<span class="cm">		 * our string table for debug help later. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">string_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv_tramp_string_create</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
						 <span class="n">strlen</span><span class="p">(</span><span class="n">TRAMP_SECT_NAME</span><span class="p">),</span>
						 <span class="n">TRAMP_SECT_NAME</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#ifdef ENABLE_TRAMP_DEBUG</span>
		<span class="n">dload_syms_error</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
				 <span class="s">&quot;Trampoline at img loc %x, references %x&quot;</span><span class="p">,</span>
				 <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">[</span><span class="n">secnn</span><span class="p">].</span><span class="n">run_addr</span> <span class="o">+</span>
				 <span class="n">image_offset</span> <span class="o">+</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span>
				 <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">local_symtab</span><span class="p">[</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SYMNDX</span><span class="p">].</span><span class="n">value</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="cm">/*  Generate the trampoline string, check if already defined.</span>
<span class="cm">		 * If the relo symbol index is -1, it means we need the section</span>
<span class="cm">		 * info for relo later.  To do this we&#39;ll dummy up a symbol</span>
<span class="cm">		 * with the section delta and run addresses. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SYMNDX</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext_tmp_sym</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span>
			    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">[</span><span class="n">secnn</span><span class="p">].</span><span class="n">run_addr</span><span class="p">;</span>
			<span class="n">ext_tmp_sym</span><span class="p">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">sect_hdrs</span><span class="p">[</span><span class="n">secnn</span><span class="p">].</span><span class="n">ds_paddr</span><span class="p">;</span>
			<span class="n">ref_sym</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext_tmp_sym</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ref_sym</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">local_symtab</span><span class="p">[</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SYMNDX</span><span class="p">]);</span>

		<span class="n">priv_tramp_sym_gen_name</span><span class="p">(</span><span class="n">ref_sym</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">tramp_sym_str</span><span class="p">);</span>
		<span class="n">new_tramp_sym</span> <span class="o">=</span> <span class="n">priv_tramp_sym_find</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">tramp_sym_str</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_tramp_sym</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  If tramp string not defined, create it and a new</span>
<span class="cm">			 * string, and symbol for it as well as the original</span>
<span class="cm">			 * symbol which caused the trampoline. */</span>
			<span class="n">new_tramp_str</span> <span class="o">=</span> <span class="n">priv_tramp_string_create</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
								<span class="n">strlen</span>
								<span class="p">(</span><span class="n">tramp_sym_str</span><span class="p">),</span>
								 <span class="n">tramp_sym_str</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_tramp_str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Failed to create new &quot;</span>
					    <span class="s">&quot;trampoline string</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*  Allocate tramp section space for the new</span>
<span class="cm">				 * tramp from the target */</span>
				<span class="n">new_tramp_base</span> <span class="o">=</span> <span class="n">priv_tramp_sect_alloc</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
						       <span class="n">tramp_size_get</span><span class="p">());</span>

				<span class="cm">/*  We have a string, create the new symbol and</span>
<span class="cm">				 * duplicate the external. */</span>
				<span class="n">tmp_sym</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_tramp_base</span><span class="p">;</span>
				<span class="n">tmp_sym</span><span class="p">.</span><span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">tmp_sym</span><span class="p">.</span><span class="n">secnn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="n">tmp_sym</span><span class="p">.</span><span class="n">sclass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">new_tramp_sym</span> <span class="o">=</span> <span class="n">priv_tramp_sym_create</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
							      <span class="n">new_tramp_str</span><span class="o">-&gt;</span>
							      <span class="n">index</span><span class="p">,</span>
							      <span class="o">&amp;</span><span class="n">tmp_sym</span><span class="p">);</span>

				<span class="n">new_ext_sym</span> <span class="o">=</span> <span class="n">priv_tramp_sym_create</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
								    <span class="n">ref_sym</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">new_tramp_sym</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">new_ext_sym</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/*  Call the image generator to get the</span>
<span class="cm">					 * new image data and fix up its</span>
<span class="cm">					 * relocations for the external</span>
<span class="cm">					 * symbol. */</span>
					<span class="n">ret_val</span> <span class="o">=</span> <span class="n">priv_tgt_img_gen</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
								 <span class="n">new_tramp_base</span><span class="p">,</span>
								 <span class="n">gen_index</span><span class="p">,</span>
								 <span class="n">new_ext_sym</span><span class="p">);</span>

					<span class="cm">/*  Add generated image data to tramp</span>
<span class="cm">					 * image list */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Failed to &quot;</span>
							    <span class="s">&quot;create img pkt for&quot;</span>
							    <span class="s">&quot; trampoline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Failed to create &quot;</span>
						    <span class="s">&quot;new tramp syms &quot;</span>
						    <span class="s">&quot;(%8.8X, %8.8X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						    <span class="n">new_tramp_sym</span><span class="p">,</span> <span class="n">new_ext_sym</span><span class="p">);</span>
					<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*  Duplicate the image data and relo record that caused the</span>
<span class="cm">		 * tramp, including update the relo data to point to the tramp</span>
<span class="cm">		 * symbol. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">priv_img_pkt_dup</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">secnn</span><span class="p">,</span> <span class="n">image_offset</span><span class="p">,</span>
						   <span class="n">ipacket</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">new_tramp_sym</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Failed to create dup of &quot;</span>
					    <span class="s">&quot;original img pkt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	dload_tramp_pkt_update</span>
<span class="cm"> * Description: Update the duplicate copy of this image packet, which the</span>
<span class="cm"> *	  trampoline layer is already tracking.  This is call is critical</span>
<span class="cm"> *	  to make if trampolines were generated anywhere within the</span>
<span class="cm"> *	  packet and first pass relo continued on the remainder.  The</span>
<span class="cm"> *	  trampoline layer needs the updates image data so when 2nd</span>
<span class="cm"> *	  pass relo is done during finalize the image packet can be</span>
<span class="cm"> *	  written to the target since all relo is done.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dload_tramp_pkt_udpate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">s16</span> <span class="n">secnn</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">image_offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">image_packet_t</span> <span class="o">*</span><span class="n">ipacket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span> <span class="o">*</span><span class="n">dup_pkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*  Find the image packet in question, the caller needs us to update it</span>
<span class="cm">	   since a trampoline was previously generated. */</span>
	<span class="n">dup_pkt</span> <span class="o">=</span> <span class="n">priv_dup_find</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">secnn</span><span class="p">,</span> <span class="n">image_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dup_pkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">img_pkt</span><span class="p">.</span><span class="n">packet_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">dup_pkt</span><span class="o">-&gt;</span><span class="n">img_pkt</span><span class="p">.</span><span class="n">img_data</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span>
			    <span class="o">*</span><span class="p">(</span><span class="n">ipacket</span><span class="o">-&gt;</span><span class="n">img_data</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
			    <span class="s">&quot;Unable to find existing DUP pkt for %x, offset %x&quot;</span><span class="p">,</span>
			    <span class="n">secnn</span><span class="p">,</span> <span class="n">image_offset</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	dload_tramp_finalize</span>
<span class="cm"> * Description: If any trampolines were created, finalize everything on the</span>
<span class="cm"> *	  target by allocating the trampoline section on the target,</span>
<span class="cm"> *	  finalizing the trampoline symbols, finalizing the trampoline</span>
<span class="cm"> *	  packets (write the new section to target memory) and finalize</span>
<span class="cm"> *	  the duplicate packets by doing 2nd pass relo over them.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dload_tramp_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sect_next_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  Finalize strings into a flat table.  This is needed so it</span>
<span class="cm">		 * can be added to the debug string table later. */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">priv_string_tbl_finalize</span><span class="p">(</span><span class="n">dlthis</span><span class="p">);</span>

		<span class="cm">/*  Do target allocation for section BEFORE finalizing</span>
<span class="cm">		 * symbols. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">priv_tramp_sect_tgt_alloc</span><span class="p">(</span><span class="n">dlthis</span><span class="p">);</span>

		<span class="cm">/*  Finalize symbols with their correct target information and</span>
<span class="cm">		 * flatten */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">priv_tramp_sym_finalize</span><span class="p">(</span><span class="n">dlthis</span><span class="p">);</span>

		<span class="cm">/*  Finalize all trampoline packets.  This performs the</span>
<span class="cm">		 * relocation on the packets as well as writing them to target</span>
<span class="cm">		 * memory. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">priv_tramp_pkt_finalize</span><span class="p">(</span><span class="n">dlthis</span><span class="p">);</span>

		<span class="cm">/*  Perform a 2nd pass relocation on the dup list. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">priv_dup_pkt_finalize</span><span class="p">(</span><span class="n">dlthis</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	dload_tramp_cleanup</span>
<span class="cm"> * Description: Release all temporary resources used in the trampoline layer.</span>
<span class="cm"> *	  Note that the target memory which may have been allocated and</span>
<span class="cm"> *	  written to store the trampolines is NOT RELEASED HERE since it</span>
<span class="cm"> *	  is potentially still in use.  It is automatically released</span>
<span class="cm"> *	  when the module is unloaded.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dload_tramp_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_info</span> <span class="o">*</span><span class="n">tramp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">cur_sym</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="n">cur_string</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_img_pkt</span> <span class="o">*</span><span class="n">cur_tramp_pkt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span> <span class="o">*</span><span class="n">cur_dup_pkt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_relo</span> <span class="o">*</span><span class="n">cur_dup_relo</span><span class="p">;</span>

	<span class="cm">/*  If there were no tramps generated, just return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tramp</span><span class="o">-&gt;</span><span class="n">tramp_sect_next_addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*  Destroy all tramp information */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cur_sym</span> <span class="o">=</span> <span class="n">tramp</span><span class="o">-&gt;</span><span class="n">symbol_head</span><span class="p">;</span>
	     <span class="n">cur_sym</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cur_sym</span> <span class="o">=</span> <span class="n">tramp</span><span class="o">-&gt;</span><span class="n">symbol_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tramp</span><span class="o">-&gt;</span><span class="n">symbol_head</span> <span class="o">=</span> <span class="n">cur_sym</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tramp</span><span class="o">-&gt;</span><span class="n">symbol_tail</span> <span class="o">==</span> <span class="n">cur_sym</span><span class="p">)</span>
			<span class="n">tramp</span><span class="o">-&gt;</span><span class="n">symbol_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">cur_sym</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tramp</span><span class="o">-&gt;</span><span class="n">final_sym_table</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
						<span class="n">tramp</span><span class="o">-&gt;</span><span class="n">final_sym_table</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cur_string</span> <span class="o">=</span> <span class="n">tramp</span><span class="o">-&gt;</span><span class="n">string_head</span><span class="p">;</span>
	     <span class="n">cur_string</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cur_string</span> <span class="o">=</span> <span class="n">tramp</span><span class="o">-&gt;</span><span class="n">string_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tramp</span><span class="o">-&gt;</span><span class="n">string_head</span> <span class="o">=</span> <span class="n">cur_string</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tramp</span><span class="o">-&gt;</span><span class="n">string_tail</span> <span class="o">==</span> <span class="n">cur_string</span><span class="p">)</span>
			<span class="n">tramp</span><span class="o">-&gt;</span><span class="n">string_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">cur_string</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tramp</span><span class="o">-&gt;</span><span class="n">final_string_table</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
						<span class="n">tramp</span><span class="o">-&gt;</span><span class="n">final_string_table</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cur_tramp_pkt</span> <span class="o">=</span> <span class="n">tramp</span><span class="o">-&gt;</span><span class="n">tramp_pkts</span><span class="p">;</span>
	     <span class="n">cur_tramp_pkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cur_tramp_pkt</span> <span class="o">=</span> <span class="n">tramp</span><span class="o">-&gt;</span><span class="n">tramp_pkts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tramp</span><span class="o">-&gt;</span><span class="n">tramp_pkts</span> <span class="o">=</span> <span class="n">cur_tramp_pkt</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">cur_tramp_pkt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cur_dup_pkt</span> <span class="o">=</span> <span class="n">tramp</span><span class="o">-&gt;</span><span class="n">dup_pkts</span><span class="p">;</span>
	     <span class="n">cur_dup_pkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cur_dup_pkt</span> <span class="o">=</span> <span class="n">tramp</span><span class="o">-&gt;</span><span class="n">dup_pkts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tramp</span><span class="o">-&gt;</span><span class="n">dup_pkts</span> <span class="o">=</span> <span class="n">cur_dup_pkt</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">cur_dup_relo</span> <span class="o">=</span> <span class="n">cur_dup_pkt</span><span class="o">-&gt;</span><span class="n">relo_chain</span><span class="p">;</span>
		     <span class="n">cur_dup_relo</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
		     <span class="n">cur_dup_relo</span> <span class="o">=</span> <span class="n">cur_dup_pkt</span><span class="o">-&gt;</span><span class="n">relo_chain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cur_dup_pkt</span><span class="o">-&gt;</span><span class="n">relo_chain</span> <span class="o">=</span> <span class="n">cur_dup_relo</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
							<span class="n">cur_dup_relo</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">cur_dup_pkt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
