<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › dynload › dload_internal.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>dload_internal.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * dload_internal.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _DLOAD_INTERNAL_</span>
<span class="cp">#define _DLOAD_INTERNAL_</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Internal state definitions for the dynamic loader</span>
<span class="cm"> */</span>

<span class="cm">/* type used for relocation intermediate results */</span>
<span class="k">typedef</span> <span class="n">s32</span> <span class="n">rvalue</span><span class="p">;</span>

<span class="cm">/* unsigned version of same; must have at least as many bits */</span>
<span class="k">typedef</span> <span class="n">u32</span> <span class="n">urvalue</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Dynamic loader configuration constants</span>
<span class="cm"> */</span>
<span class="cm">/* error issued if input has more sections than this limit */</span>
<span class="cp">#define REASONABLE_SECTION_LIMIT 100</span>

<span class="cm">/* (Addressable unit) value used to clear BSS section */</span>
<span class="cp">#define DLOAD_FILL_BSS 0</span>

<span class="cm">/*</span>
<span class="cm"> * Reorder maps explained (?)</span>
<span class="cm"> *</span>
<span class="cm"> * The doff file format defines a 32-bit pattern used to determine the</span>
<span class="cm"> * byte order of an image being read.  That value is</span>
<span class="cm"> * BYTE_RESHUFFLE_VALUE == 0x00010203</span>
<span class="cm"> * For purposes of the reorder routine, we would rather have the all-is-OK</span>
<span class="cm"> * for 32-bits pattern be 0x03020100.  This first macro makes the</span>
<span class="cm"> * translation from doff file header value to MAP value: */</span>
<span class="cp">#define REORDER_MAP(rawmap) ((rawmap) ^ 0x3030303)</span>
<span class="cm">/* This translation is made in dload_headers.  Thereafter, the all-is-OK</span>
<span class="cm"> * value for the maps stored in dlthis is REORDER_MAP(BYTE_RESHUFFLE_VALUE).</span>
<span class="cm"> * But sadly, not all bits of the doff file are 32-bit integers.</span>
<span class="cm"> * The notable exceptions are strings and image bits.</span>
<span class="cm"> * Strings obey host byte order: */</span>
<span class="cp">#if defined(_BIG_ENDIAN)</span>
<span class="cp">#define HOST_BYTE_ORDER(cookedmap) ((cookedmap) ^ 0x3030303)</span>
<span class="cp">#else</span>
<span class="cp">#define HOST_BYTE_ORDER(cookedmap) (cookedmap)</span>
<span class="cp">#endif</span>
<span class="cm">/* Target bits consist of target AUs (could be bytes, or 16-bits,</span>
<span class="cm"> * or 32-bits) stored as an array in host order.  A target order</span>
<span class="cm"> * map is defined by: */</span>
<span class="cp">#if !defined(_BIG_ENDIAN) || TARGET_AU_BITS &gt; 16</span>
<span class="cp">#define TARGET_ORDER(cookedmap) (cookedmap)</span>
<span class="cp">#elif TARGET_AU_BITS &gt; 8</span>
<span class="cp">#define TARGET_ORDER(cookedmap) ((cookedmap) ^ 0x2020202)</span>
<span class="cp">#else</span>
<span class="cp">#define TARGET_ORDER(cookedmap) ((cookedmap) ^ 0x3030303)</span>
<span class="cp">#endif</span>

<span class="cm">/* forward declaration for handle returned by dynamic loader */</span>
<span class="k">struct</span> <span class="n">my_handle</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * a list of module handles, which mirrors the debug list on the target</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dbg_mirror_root</span> <span class="p">{</span>
	<span class="cm">/* must be same as dbg_mirror_list; __DLModules address on target */</span>
	<span class="n">u32</span> <span class="n">dbthis</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">my_handle</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/* must be same as dbg_mirror_list */</span>
	<span class="n">u16</span> <span class="n">changes</span><span class="p">;</span>		<span class="cm">/* change counter */</span>
	<span class="n">u16</span> <span class="n">refcount</span><span class="p">;</span>		<span class="cm">/* number of modules referencing this root */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dbg_mirror_list</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">dbthis</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">my_handle</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dbg_mirror_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dbsiz</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">context</span><span class="p">;</span>	<span class="cm">/* Save context for .dllview memory allocation */</span>
<span class="p">};</span>

<span class="cp">#define VARIABLE_SIZE 1</span>
<span class="cm">/*</span>
<span class="cm"> * the structure we actually return as an opaque module handle</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">my_handle</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dbg_mirror_list</span> <span class="n">dm</span><span class="p">;</span>	<span class="cm">/* !!! must be first !!! */</span>
	<span class="cm">/* sections following &lt;&lt; 1, LSB is set for big-endian target */</span>
	<span class="n">u16</span> <span class="n">secn_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="n">secns</span><span class="p">[</span><span class="n">VARIABLE_SIZE</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define MY_HANDLE_SIZE (sizeof(struct my_handle) -\</span>
<span class="cp">			sizeof(struct ldr_section_info))</span>
<span class="cm">/* real size of my_handle */</span>

<span class="cm">/*</span>
<span class="cm"> * reduced symbol structure used for symbols during relocation</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">local_symbol</span> <span class="p">{</span>
	<span class="n">s32</span> <span class="n">value</span><span class="p">;</span>		<span class="cm">/* Relocated symbol value */</span>
	<span class="n">s32</span> <span class="n">delta</span><span class="p">;</span>		<span class="cm">/* Original value in input file */</span>
	<span class="n">s16</span> <span class="n">secnn</span><span class="p">;</span>		<span class="cm">/* section number */</span>
	<span class="n">s16</span> <span class="n">sclass</span><span class="p">;</span>		<span class="cm">/* symbol class */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Trampoline data structures</span>
<span class="cm"> */</span>
<span class="cp">#define TRAMP_NO_GEN_AVAIL              65535</span>
<span class="cp">#define TRAMP_SYM_PREFIX                &quot;__$dbTR__&quot;</span>
<span class="cp">#define TRAMP_SECT_NAME                 &quot;.dbTR&quot;</span>
<span class="cm">/* MUST MATCH THE LENGTH ABOVE!! */</span>
<span class="cp">#define TRAMP_SYM_PREFIX_LEN            9</span>
<span class="cm">/* Includes NULL termination */</span>
<span class="cp">#define TRAMP_SYM_HEX_ASCII_LEN         9</span>

<span class="cp">#define GET_CONTAINER(ptr, type, field) ((type *)((unsigned long)ptr -\</span>
<span class="cp">				(unsigned long)(&amp;((type *)0)-&gt;field)))</span>
<span class="cp">#ifndef FIELD_OFFSET</span>
<span class="cp">#define FIELD_OFFSET(type, field)       ((unsigned long)(&amp;((type *)0)-&gt;field))</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">    The trampoline code for the target is located in a table called</span>
<span class="cm">    &quot;tramp_gen_info&quot; with is indexed by looking up the index in the table</span>
<span class="cm">    &quot;tramp_map&quot;.  The tramp_map index is acquired using the target</span>
<span class="cm">    HASH_FUNC on the relocation type that caused the trampoline.  Each</span>
<span class="cm">    trampoline code table entry MUST follow this format:</span>

<span class="cm">    |----------------------------------------------|</span>
<span class="cm">    |  tramp_gen_code_hdr                          |</span>
<span class="cm">    |----------------------------------------------|</span>
<span class="cm">    |  Trampoline image code                       |</span>
<span class="cm">    |  (the raw instruction code for the target)   |</span>
<span class="cm">    |----------------------------------------------|</span>
<span class="cm">    |  Relocation entries for the image code       |</span>
<span class="cm">    |----------------------------------------------|</span>

<span class="cm">    This is very similar to how image data is laid out in the DOFF file</span>
<span class="cm">    itself.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tramp_gen_code_hdr</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">tramp_code_size</span><span class="p">;</span>	<span class="cm">/*  in BYTES */</span>
	<span class="n">u32</span> <span class="n">num_relos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">relo_offset</span><span class="p">;</span>	<span class="cm">/*  in BYTES */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tramp_img_pkt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_img_pkt</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/*  MUST BE FIRST */</span>
	<span class="n">u32</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_gen_code_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">payload</span><span class="p">[</span><span class="n">VARIABLE_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tramp_img_dup_relo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_relo</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="n">relo</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/*  MUST BE FIRST */</span>
	<span class="n">s16</span> <span class="n">secnn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">image_packet_t</span> <span class="n">img_pkt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_relo</span> <span class="o">*</span><span class="n">relo_chain</span><span class="p">;</span>

	<span class="cm">/*  PAYLOAD OF IMG PKT FOLLOWS */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/*  MUST BE FIRST */</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">str_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">local_symbol</span> <span class="n">sym_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tramp_string</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/*  MUST BE FIRST */</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">VARIABLE_SIZE</span><span class="p">];</span>	<span class="cm">/*  NULL terminated */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tramp_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">tramp_sect_next_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="n">sect_info</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">symbol_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_sym</span> <span class="o">*</span><span class="n">symbol_tail</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tramp_sym_next_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">local_symbol</span> <span class="o">*</span><span class="n">final_sym_table</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="n">string_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_string</span> <span class="o">*</span><span class="n">string_tail</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tramp_string_next_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tramp_string_size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">final_string_table</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tramp_img_pkt</span> <span class="o">*</span><span class="n">tramp_pkts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tramp_img_dup_pkt</span> <span class="o">*</span><span class="n">dup_pkts</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * States of the .cinit state machine</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">cinit_mode</span> <span class="p">{</span>
	<span class="n">CI_COUNT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>		<span class="cm">/* expecting a count */</span>
	<span class="n">CI_ADDRESS</span><span class="p">,</span>		<span class="cm">/* expecting an address */</span>
<span class="cp">#if CINIT_ALIGN &lt; CINIT_ADDRESS	</span><span class="cm">/* handle case of partial address field */</span><span class="cp"></span>
	<span class="n">CI_PARTADDRESS</span><span class="p">,</span>		<span class="cm">/* have only part of the address */</span>
<span class="cp">#endif</span>
	<span class="n">CI_COPY</span><span class="p">,</span>		<span class="cm">/* in the middle of copying data */</span>
	<span class="n">CI_DONE</span>			<span class="cm">/* end of .cinit table */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The internal state of the dynamic loader, which is passed around as</span>
<span class="cm"> * an object</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dload_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dynamic_loader_stream</span> <span class="o">*</span><span class="n">strm</span><span class="p">;</span>	<span class="cm">/* The module input stream */</span>
	<span class="k">struct</span> <span class="n">dynamic_loader_sym</span> <span class="o">*</span><span class="n">mysym</span><span class="p">;</span>	<span class="cm">/* Symbols for this session */</span>
	<span class="cm">/* target memory allocator */</span>
	<span class="k">struct</span> <span class="n">dynamic_loader_allocate</span> <span class="o">*</span><span class="n">myalloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dynamic_loader_initialize</span> <span class="o">*</span><span class="n">myio</span><span class="p">;</span>	<span class="cm">/* target memory initializer */</span>
	<span class="kt">unsigned</span> <span class="n">myoptions</span><span class="p">;</span>	<span class="cm">/* Options parameter dynamic_load_module */</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">str_head</span><span class="p">;</span>		<span class="cm">/* Pointer to string table */</span>
<span class="cp">#if BITS_PER_AU &gt; BITS_PER_BYTE</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str_temp</span><span class="p">;</span>		<span class="cm">/* Pointer to temporary buffer for strings */</span>
	<span class="cm">/* big enough to hold longest string */</span>
	<span class="kt">unsigned</span> <span class="n">temp_len</span><span class="p">;</span>	<span class="cm">/* length of last temporary string */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">xstrings</span><span class="p">;</span>		<span class="cm">/* Pointer to buffer for expanded */</span>
	<span class="cm">/* strings for sec names */</span>
<span class="cp">#endif</span>
	<span class="cm">/* Total size of strings for DLLView section names */</span>
	<span class="kt">unsigned</span> <span class="n">debug_string_size</span><span class="p">;</span>
	<span class="cm">/* Pointer to parallel section info for allocated sections only */</span>
	<span class="k">struct</span> <span class="n">doff_scnhdr_t</span> <span class="o">*</span><span class="n">sect_hdrs</span><span class="p">;</span>	<span class="cm">/* Pointer to section table */</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="n">ldr_sections</span><span class="p">;</span>
<span class="cp">#if TMS32060</span>
	<span class="cm">/* The address of the start of the .bss section */</span>
	<span class="n">ldr_addr</span> <span class="n">bss_run_base</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">local_symbol</span> <span class="o">*</span><span class="n">local_symtab</span><span class="p">;</span>	<span class="cm">/* Relocation symbol table */</span>

	<span class="cm">/* pointer to DL section info for the section being relocated */</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="n">image_secn</span><span class="p">;</span>
	<span class="cm">/* change in run address for current section during relocation */</span>
	<span class="n">ldr_addr</span> <span class="n">delta_runaddr</span><span class="p">;</span>
	<span class="n">ldr_addr</span> <span class="n">image_offset</span><span class="p">;</span>	<span class="cm">/* offset of current packet in section */</span>
	<span class="k">enum</span> <span class="n">cinit_mode</span> <span class="n">cinit_state</span><span class="p">;</span>	<span class="cm">/* current state of cload_cinit() */</span>
	<span class="kt">int</span> <span class="n">cinit_count</span><span class="p">;</span>	<span class="cm">/* the current count */</span>
	<span class="n">ldr_addr</span> <span class="n">cinit_addr</span><span class="p">;</span>	<span class="cm">/* the current address */</span>
	<span class="n">s16</span> <span class="n">cinit_page</span><span class="p">;</span>		<span class="cm">/* the current page */</span>
	<span class="cm">/* Handle to be returned by dynamic_load_module */</span>
	<span class="k">struct</span> <span class="n">my_handle</span> <span class="o">*</span><span class="n">myhandle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">dload_errcount</span><span class="p">;</span>	<span class="cm">/* Total # of errors reported so far */</span>
	<span class="cm">/* Number of target sections that require allocation and relocation */</span>
	<span class="kt">unsigned</span> <span class="n">allocated_secn_count</span><span class="p">;</span>
<span class="cp">#ifndef TARGET_ENDIANNESS</span>
	<span class="kt">int</span> <span class="n">big_e_target</span><span class="p">;</span>	<span class="cm">/* Target data in big-endian format */</span>
<span class="cp">#endif</span>
	<span class="cm">/* map for reordering bytes, 0 if not needed */</span>
	<span class="n">u32</span> <span class="n">reorder_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doff_filehdr_t</span> <span class="n">dfile_hdr</span><span class="p">;</span>	<span class="cm">/* DOFF file header structure */</span>
	<span class="k">struct</span> <span class="n">doff_verify_rec_t</span> <span class="n">verify</span><span class="p">;</span>	<span class="cm">/* Verify record */</span>

	<span class="k">struct</span> <span class="n">tramp_info</span> <span class="n">tramp</span><span class="p">;</span>	<span class="cm">/* Trampoline data, if needed */</span>

	<span class="kt">int</span> <span class="n">relstkidx</span><span class="p">;</span>		<span class="cm">/* index into relocation value stack */</span>
	<span class="cm">/* relocation value stack used in relexp.c */</span>
	<span class="n">rvalue</span> <span class="n">relstk</span><span class="p">[</span><span class="n">STATIC_EXPR_STK_SIZE</span><span class="p">];</span>

<span class="p">};</span>

<span class="cp">#ifdef TARGET_ENDIANNESS</span>
<span class="cp">#define TARGET_BIG_ENDIAN TARGET_ENDIANNESS</span>
<span class="cp">#else</span>
<span class="cp">#define TARGET_BIG_ENDIAN (dlthis-&gt;big_e_target)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Exports from cload.c to rest of the world</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dload_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errtxt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dload_syms_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">dynamic_loader_sym</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errtxt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dload_headers</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dload_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sec_names_only</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dload_sections</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dload_reorder</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dsiz</span><span class="p">,</span> <span class="n">u32</span> <span class="n">map</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">dload_checksum</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">siz</span><span class="p">);</span>

<span class="cp">#if HOST_ENDIANNESS</span>
<span class="k">extern</span> <span class="kt">uint32_t</span> <span class="n">dload_reverse_checksum</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">siz</span><span class="p">);</span>
<span class="cp">#if (TARGET_AU_BITS &gt; 8) &amp;&amp; (TARGET_AU_BITS &lt; 32)</span>
<span class="k">extern</span> <span class="kt">uint32_t</span> <span class="n">dload_reverse_checksum16</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">siz</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * exported by reloc.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dload_relocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">tgt_au_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span> <span class="n">tramps_generated</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">second_pass</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">rvalue</span> <span class="n">dload_unpack</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">tgt_au_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">fieldsz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">sgn</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">dload_repack</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">rvalue</span> <span class="n">val</span><span class="p">,</span> <span class="n">tgt_au_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">fieldsz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">sgn</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * exported by tramp.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">dload_tramp_avail</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">dload_tramp_generate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">s16</span> <span class="n">secnn</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">image_offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">image_packet_t</span> <span class="o">*</span><span class="n">ipacket</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">dload_tramp_pkt_udpate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
				  <span class="n">s16</span> <span class="n">secnn</span><span class="p">,</span> <span class="n">u32</span> <span class="n">image_offset</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">image_packet_t</span> <span class="o">*</span><span class="n">ipacket</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">dload_tramp_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">dload_tramp_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _DLOAD_INTERNAL_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
