<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › dynload › cload.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>cload.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * cload.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;header.h&quot;</span>

<span class="cp">#include &quot;module_list.h&quot;</span>
<span class="cp">#define LINKER_MODULES_HEADER (&quot;_&quot; MODULES_HEADER)</span>

<span class="cm">/*</span>
<span class="cm"> * forward references</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dload_symbols</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dload_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">allocate_sections</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">string_table_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">symbol_table_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">section_table_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">init_module_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">);</span>
<span class="cp">#if BITS_PER_AU &gt; BITS_PER_BYTE</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unpack_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">u32</span> <span class="n">soffset</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">cinitname</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;.cinit&quot;</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">loader_dllview_root</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;?DLModules?&quot;</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Error strings</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">readstrm</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Error reading %s from input stream&quot;</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">err_alloc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Syms-&gt;dload_allocate( %d ) failed&quot;</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">tgtalloc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Target memory allocate failed, section %s size &quot;</span> <span class="n">FMT_UI32</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">initfail</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;%s to target address &quot;</span> <span class="n">FMT_UI32</span> <span class="s">&quot; failed&quot;</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">dlvwrite</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Write to DLLview list failed&quot;</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">iconnect</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Connect call to init interface failed&quot;</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">err_checksum</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Checksum failed on %s&quot;</span> <span class="p">};</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dload_error</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	errtxt	description of the error, printf style</span>
<span class="cm"> *	...		additional information</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Reports or records the error as appropriate.</span>
<span class="cm"> *********************************************************************** */</span>
<span class="kt">void</span> <span class="nf">dload_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errtxt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">errtxt</span><span class="p">);</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">error_report</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">errtxt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dload_errcount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

<span class="p">}</span>				<span class="cm">/* dload_error */</span>

<span class="cp">#define DL_ERROR(zza, zzb) dload_error(dlthis, zza, zzb)</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dload_syms_error</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	errtxt	description of the error, printf style</span>
<span class="cm"> *	...		additional information</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Reports or records the error as appropriate.</span>
<span class="cm"> *********************************************************************** */</span>
<span class="kt">void</span> <span class="nf">dload_syms_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">dynamic_loader_sym</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errtxt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">errtxt</span><span class="p">);</span>
	<span class="n">syms</span><span class="o">-&gt;</span><span class="n">error_report</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">errtxt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dynamic_load_module</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	module	The input stream that supplies the module image</span>
<span class="cm"> *	syms	Host-side symbol table and malloc/free functions</span>
<span class="cm"> *	alloc	Target-side memory allocation</span>
<span class="cm"> *	init	Target-side memory initialization</span>
<span class="cm"> *	options	Option flags DLOAD_*</span>
<span class="cm"> *	mhandle	A module handle for use with Dynamic_Unload</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	The module image is read using *module.  Target storage for the new</span>
<span class="cm"> *	image is</span>
<span class="cm"> * obtained from *alloc.  Symbols defined and referenced by the module are</span>
<span class="cm"> * managed using *syms.  The image is then relocated and references</span>
<span class="cm"> *	resolved as necessary, and the resulting executable bits are placed</span>
<span class="cm"> *	into target memory using *init.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	On a successful load, a module handle is placed in *mhandle,</span>
<span class="cm"> *	and zero is returned.  On error, the number of errors detected is</span>
<span class="cm"> *	returned.  Individual errors are reported during the load process</span>
<span class="cm"> *	using syms-&gt;error_report().</span>
<span class="cm"> ********************************************************************** */</span>
<span class="kt">int</span> <span class="nf">dynamic_load_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">dynamic_loader_stream</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dynamic_loader_sym</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dynamic_loader_allocate</span> <span class="o">*</span><span class="n">alloc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dynamic_loader_initialize</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">options</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">mhandle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="n">sz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dload_state</span> <span class="n">dl_state</span><span class="p">;</span>	<span class="cm">/* internal state for this call */</span>

	<span class="cm">/* blast our internal state */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dl_state</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">);</span> <span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sz</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dp</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Enable _only_ BSS initialization if enabled by user */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">DLOAD_INITBSS</span><span class="p">)</span> <span class="o">==</span> <span class="n">DLOAD_INITBSS</span><span class="p">)</span>
		<span class="n">dl_state</span><span class="p">.</span><span class="n">myoptions</span> <span class="o">=</span> <span class="n">DLOAD_INITBSS</span><span class="p">;</span>

	<span class="cm">/* Check that mandatory arguments are present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">module</span> <span class="o">||</span> <span class="o">!</span><span class="n">syms</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">,</span> <span class="s">&quot;Required parameter is NULL&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dl_state</span><span class="p">.</span><span class="n">strm</span> <span class="o">=</span> <span class="n">module</span><span class="p">;</span>
		<span class="n">dl_state</span><span class="p">.</span><span class="n">mysym</span> <span class="o">=</span> <span class="n">syms</span><span class="p">;</span>
		<span class="n">dload_headers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span>
			<span class="n">dload_strings</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span>
			<span class="n">dload_sections</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">init</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">connect</span><span class="p">(</span><span class="n">init</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dl_state</span><span class="p">.</span><span class="n">myio</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>
				<span class="n">dl_state</span><span class="p">.</span><span class="n">myalloc</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">;</span>
				<span class="cm">/* do now, before reducing symbols */</span>
				<span class="n">allocate_sections</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">,</span> <span class="n">iconnect</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* fix up entry point address */</span>
			<span class="kt">unsigned</span> <span class="n">sref</span> <span class="o">=</span> <span class="n">dl_state</span><span class="p">.</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_entry_secn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sref</span> <span class="o">&lt;</span> <span class="n">dl_state</span><span class="p">.</span><span class="n">allocated_secn_count</span><span class="p">)</span>
				<span class="n">dl_state</span><span class="p">.</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_entrypt</span> <span class="o">+=</span>
				    <span class="n">dl_state</span><span class="p">.</span><span class="n">ldr_sections</span><span class="p">[</span><span class="n">sref</span><span class="p">].</span><span class="n">run_addr</span><span class="p">;</span>

			<span class="n">dload_symbols</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">init</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span>
			<span class="n">dload_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>

		<span class="n">init_module_handle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>

		<span class="cm">/* dl_state.myio is init or 0 at this point. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dl_state</span><span class="p">.</span><span class="n">myio</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_entry_secn</span> <span class="o">!=</span> <span class="n">DN_UNDEF</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">init</span><span class="p">,</span>
					    <span class="n">dl_state</span><span class="p">.</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_entrypt</span><span class="p">)))</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">,</span> <span class="s">&quot;Init-&gt;Execute Failed&quot;</span><span class="p">);</span>
			<span class="n">init</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">init</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">symbol_table_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
		<span class="n">section_table_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
		<span class="n">string_table_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
		<span class="n">dload_tramp_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dynamic_unload_module</span><span class="p">(</span><span class="n">dl_state</span><span class="p">.</span><span class="n">myhandle</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">alloc</span><span class="p">,</span>
					      <span class="n">init</span><span class="p">);</span>
			<span class="n">dl_state</span><span class="p">.</span><span class="n">myhandle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mhandle</span><span class="p">)</span>
		<span class="o">*</span><span class="n">mhandle</span> <span class="o">=</span> <span class="n">dl_state</span><span class="p">.</span><span class="n">myhandle</span><span class="p">;</span>	<span class="cm">/* give back the handle */</span>

	<span class="k">return</span> <span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* DLOAD_File */</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dynamic_open_module</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *      module  The input stream that supplies the module image</span>
<span class="cm"> *      syms    Host-side symbol table and malloc/free functions</span>
<span class="cm"> *      alloc   Target-side memory allocation</span>
<span class="cm"> *      init    Target-side memory initialization</span>
<span class="cm"> *      options Option flags DLOAD_*</span>
<span class="cm"> *      mhandle A module handle for use with Dynamic_Unload</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *      The module image is read using *module.  Target storage for the new</span>
<span class="cm"> *      image is</span>
<span class="cm"> * 	obtained from *alloc.  Symbols defined and referenced by the module are</span>
<span class="cm"> * 	managed using *syms.  The image is then relocated and references</span>
<span class="cm"> *      resolved as necessary, and the resulting executable bits are placed</span>
<span class="cm"> *      into target memory using *init.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *      On a successful load, a module handle is placed in *mhandle,</span>
<span class="cm"> *      and zero is returned.  On error, the number of errors detected is</span>
<span class="cm"> *      returned.  Individual errors are reported during the load process</span>
<span class="cm"> *      using syms-&gt;error_report().</span>
<span class="cm"> ********************************************************************** */</span>
<span class="kt">int</span>
<span class="nf">dynamic_open_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">dynamic_loader_stream</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">dynamic_loader_sym</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">dynamic_loader_allocate</span> <span class="o">*</span><span class="n">alloc</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">dynamic_loader_initialize</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="n">options</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">mhandle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="n">sz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dload_state</span> <span class="n">dl_state</span><span class="p">;</span>	<span class="cm">/* internal state for this call */</span>

	<span class="cm">/* blast our internal state */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dl_state</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">);</span> <span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sz</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dp</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Enable _only_ BSS initialization if enabled by user */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">DLOAD_INITBSS</span><span class="p">)</span> <span class="o">==</span> <span class="n">DLOAD_INITBSS</span><span class="p">)</span>
		<span class="n">dl_state</span><span class="p">.</span><span class="n">myoptions</span> <span class="o">=</span> <span class="n">DLOAD_INITBSS</span><span class="p">;</span>

	<span class="cm">/* Check that mandatory arguments are present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">module</span> <span class="o">||</span> <span class="o">!</span><span class="n">syms</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">,</span> <span class="s">&quot;Required parameter is NULL&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dl_state</span><span class="p">.</span><span class="n">strm</span> <span class="o">=</span> <span class="n">module</span><span class="p">;</span>
		<span class="n">dl_state</span><span class="p">.</span><span class="n">mysym</span> <span class="o">=</span> <span class="n">syms</span><span class="p">;</span>
		<span class="n">dload_headers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span>
			<span class="n">dload_strings</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span>
			<span class="n">dload_sections</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">init</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">connect</span><span class="p">(</span><span class="n">init</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dl_state</span><span class="p">.</span><span class="n">myio</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>
				<span class="n">dl_state</span><span class="p">.</span><span class="n">myalloc</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">;</span>
				<span class="cm">/* do now, before reducing symbols */</span>
				<span class="n">allocate_sections</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">,</span> <span class="n">iconnect</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* fix up entry point address */</span>
			<span class="kt">unsigned</span> <span class="n">sref</span> <span class="o">=</span> <span class="n">dl_state</span><span class="p">.</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_entry_secn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sref</span> <span class="o">&lt;</span> <span class="n">dl_state</span><span class="p">.</span><span class="n">allocated_secn_count</span><span class="p">)</span>
				<span class="n">dl_state</span><span class="p">.</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_entrypt</span> <span class="o">+=</span>
				    <span class="n">dl_state</span><span class="p">.</span><span class="n">ldr_sections</span><span class="p">[</span><span class="n">sref</span><span class="p">].</span><span class="n">run_addr</span><span class="p">;</span>

			<span class="n">dload_symbols</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">init_module_handle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>

		<span class="cm">/* dl_state.myio is either 0 or init at this point. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dl_state</span><span class="p">.</span><span class="n">myio</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_entry_secn</span> <span class="o">!=</span> <span class="n">DN_UNDEF</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">init</span><span class="p">,</span>
					    <span class="n">dl_state</span><span class="p">.</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_entrypt</span><span class="p">)))</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">,</span> <span class="s">&quot;Init-&gt;Execute Failed&quot;</span><span class="p">);</span>
			<span class="n">init</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">init</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">symbol_table_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
		<span class="n">section_table_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>
		<span class="n">string_table_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_state</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dynamic_unload_module</span><span class="p">(</span><span class="n">dl_state</span><span class="p">.</span><span class="n">myhandle</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">alloc</span><span class="p">,</span>
					      <span class="n">init</span><span class="p">);</span>
			<span class="n">dl_state</span><span class="p">.</span><span class="n">myhandle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mhandle</span><span class="p">)</span>
		<span class="o">*</span><span class="n">mhandle</span> <span class="o">=</span> <span class="n">dl_state</span><span class="p">.</span><span class="n">myhandle</span><span class="p">;</span>	<span class="cm">/* give back the handle */</span>

	<span class="k">return</span> <span class="n">dl_state</span><span class="p">.</span><span class="n">dload_errcount</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* DLOAD_File */</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dload_headers</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	none</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Loads the DOFF header and verify record.  Deals with any byte-order</span>
<span class="cm"> * issues and checks them for validity.</span>
<span class="cm"> *********************************************************************** */</span>
<span class="cp">#define COMBINED_HEADER_SIZE (sizeof(struct doff_filehdr_t)+ \</span>
<span class="cp">			     sizeof(struct doff_verify_rec_t))</span>

<span class="kt">void</span> <span class="nf">dload_headers</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">map</span><span class="p">;</span>

	<span class="cm">/* Read the header and the verify record as one.  If we don&#39;t get it</span>
<span class="cm">	   all, we&#39;re done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">read_buffer</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">,</span>
				      <span class="n">COMBINED_HEADER_SIZE</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">COMBINED_HEADER_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">readstrm</span><span class="p">,</span> <span class="s">&quot;File Headers&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Verify that we have the byte order of the file correct.</span>
<span class="cm">	 * If not, must fix it before we can continue</span>
<span class="cm">	 */</span>
	<span class="n">map</span> <span class="o">=</span> <span class="n">REORDER_MAP</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_byte_reshuffle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">!=</span> <span class="n">REORDER_MAP</span><span class="p">(</span><span class="n">BYTE_RESHUFFLE_VALUE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* input is either byte-shuffled or bad */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">map</span> <span class="o">&amp;</span> <span class="mh">0xFCFCFCFC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* no obviously bogus bits */</span>
			<span class="n">dload_reorder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">,</span> <span class="n">COMBINED_HEADER_SIZE</span><span class="p">,</span>
				      <span class="n">map</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_byte_reshuffle</span> <span class="o">!=</span>
		    <span class="n">BYTE_RESHUFFLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* didn&#39;t fix the problem, the byte swap map is bad */</span>
			<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
				    <span class="s">&quot;Bad byte swap map &quot;</span> <span class="n">FMT_UI32</span> <span class="s">&quot; in header&quot;</span><span class="p">,</span>
				    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_byte_reshuffle</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>	<span class="cm">/* keep map for future use */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify checksum of header and verify record</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">dload_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">doff_filehdr_t</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">~</span><span class="n">dload_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">verify</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">doff_verify_rec_t</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">err_checksum</span><span class="p">,</span> <span class="s">&quot;header or verify record&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if HOST_ENDIANNESS</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_byte_reshuffle</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>	<span class="cm">/* put back for later */</span>
<span class="cp">#endif</span>

	<span class="cm">/* Check for valid target ID */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_target_id</span> <span class="o">!=</span> <span class="n">TARGET_ID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">-</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_target_id</span> <span class="o">!=</span> <span class="n">TMS470_ID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Bad target ID 0x%x and TARGET_ID 0x%x&quot;</span><span class="p">,</span>
			    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_target_id</span><span class="p">,</span> <span class="n">TARGET_ID</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check for valid file format */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_doff_version</span> <span class="o">!=</span> <span class="n">DOFF0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Bad DOFF version 0x%x&quot;</span><span class="p">,</span>
			    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_doff_version</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Apply reasonableness checks to count fields</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_strtab_size</span> <span class="o">&gt;</span> <span class="n">MAX_REASONABLE_STRINGTAB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Excessive string table size &quot;</span> <span class="n">FMT_UI32</span><span class="p">,</span>
			    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_strtab_size</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_no_scns</span> <span class="o">&gt;</span> <span class="n">MAX_REASONABLE_SECTIONS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Excessive section count 0x%x&quot;</span><span class="p">,</span>
			    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_no_scns</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifndef TARGET_ENDIANNESS</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check that endianness does not disagree with explicit specification</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_flags</span> <span class="o">&gt;&gt;</span> <span class="n">ALIGN_COFF_ENDIANNESS</span><span class="p">)</span> <span class="o">&amp;</span>
	    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myoptions</span> <span class="o">&amp;</span> <span class="n">ENDIANNESS_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
			    <span class="s">&quot;Input endianness disagrees with specified option&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">big_e_target</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_flags</span> <span class="o">&amp;</span> <span class="n">DF_BIG</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="p">}</span>				<span class="cm">/* dload_headers */</span>

<span class="cm">/*	COFF Section Processing</span>
<span class="cm"> *</span>
<span class="cm"> *	COFF sections are read in and retained intact.  Each record is embedded</span>
<span class="cm"> * 	in a new structure that records the updated load and</span>
<span class="cm"> * 	run addresses of the section */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">secn_errid</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;section&quot;</span> <span class="p">};</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dload_sections</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	none</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Loads the section records into an internal table.</span>
<span class="cm"> *********************************************************************** */</span>
<span class="kt">void</span> <span class="nf">dload_sections</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s16</span> <span class="n">siz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doff_scnhdr_t</span> <span class="o">*</span><span class="n">shp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nsecs</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_no_scns</span><span class="p">;</span>

	<span class="cm">/* allocate space for the DOFF section records */</span>
	<span class="n">siz</span> <span class="o">=</span> <span class="n">nsecs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">doff_scnhdr_t</span><span class="p">);</span>
	<span class="n">shp</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">doff_scnhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
								  <span class="n">siz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shp</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* not enough storage */</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">err_alloc</span><span class="p">,</span> <span class="n">siz</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">sect_hdrs</span> <span class="o">=</span> <span class="n">shp</span><span class="p">;</span>

	<span class="cm">/* read in the section records */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">read_buffer</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="p">,</span> <span class="n">shp</span><span class="p">,</span> <span class="n">siz</span><span class="p">)</span> <span class="o">!=</span> <span class="n">siz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">readstrm</span><span class="p">,</span> <span class="n">secn_errid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if we need to fix up byte order, do it now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">)</span>
		<span class="n">dload_reorder</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">siz</span><span class="p">,</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">);</span>

	<span class="cm">/* check for validity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">dload_checksum</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">sect_hdrs</span><span class="p">,</span> <span class="n">siz</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">verify</span><span class="p">.</span><span class="n">dv_scn_rec_checksum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">err_checksum</span><span class="p">,</span> <span class="n">secn_errid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>				<span class="cm">/* dload_sections */</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> * Procedure allocate_sections</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	alloc	target memory allocator class</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Assigns new (target) addresses for sections</span>
<span class="cm"> **************************************************************************** */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">allocate_sections</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">curr_sect</span><span class="p">,</span> <span class="n">nsecs</span><span class="p">,</span> <span class="n">siz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doff_scnhdr_t</span> <span class="o">*</span><span class="n">shp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="n">asecs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">my_handle</span> <span class="o">*</span><span class="n">hndl</span><span class="p">;</span>
	<span class="n">nsecs</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_no_scns</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nsecs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myalloc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_target_scns</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="s">&quot;Arg 3 (alloc) required but NULL&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * allocate space for the module handle, which we will keep for unload</span>
<span class="cm">	 * purposes include an additional section store for an auto-generated</span>
<span class="cm">	 * trampoline section in case we need it.</span>
<span class="cm">	 */</span>
	<span class="n">siz</span> <span class="o">=</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_target_scns</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ldr_section_info</span><span class="p">)</span> <span class="o">+</span> <span class="n">MY_HANDLE_SIZE</span><span class="p">;</span>

	<span class="n">hndl</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">my_handle</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
							      <span class="n">siz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hndl</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* not enough storage */</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">err_alloc</span><span class="p">,</span> <span class="n">siz</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* initialize the handle header */</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">hndl</span><span class="p">;</span>	<span class="cm">/* circular list */</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbthis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myhandle</span> <span class="o">=</span> <span class="n">hndl</span><span class="p">;</span>	<span class="cm">/* save away for return */</span>
	<span class="cm">/* pointer to the section list of allocated sections */</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span> <span class="o">=</span> <span class="n">asecs</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">secns</span><span class="p">;</span>
	<span class="cm">/* * Insert names into all sections, make copies of</span>
<span class="cm">	   the sections we allocate */</span>
	<span class="n">shp</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">sect_hdrs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">curr_sect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">curr_sect</span> <span class="o">&lt;</span> <span class="n">nsecs</span><span class="p">;</span> <span class="n">curr_sect</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">soffset</span> <span class="o">=</span> <span class="n">shp</span><span class="o">-&gt;</span><span class="n">ds_offset</span><span class="p">;</span>
<span class="cp">#if BITS_PER_AU &lt;= BITS_PER_BYTE</span>
		<span class="cm">/* attempt to insert the name of this section */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">soffset</span> <span class="o">&lt;</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_strtab_size</span><span class="p">)</span>
			<span class="p">((</span><span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="p">)</span><span class="n">shp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span>
				<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_head</span> <span class="o">+</span> <span class="n">soffset</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Bad name offset in section %d&quot;</span><span class="p">,</span>
				    <span class="n">curr_sect</span><span class="p">);</span>
			<span class="p">((</span><span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="p">)</span><span class="n">shp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="cm">/* allocate target storage for sections that require it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ds_needs_allocation</span><span class="p">(</span><span class="n">shp</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">asecs</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="p">)</span><span class="n">shp</span><span class="p">;</span>
			<span class="n">asecs</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* zero the context field */</span>
<span class="cp">#if BITS_PER_AU &gt; BITS_PER_BYTE</span>
			<span class="n">asecs</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">unpack_name</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">soffset</span><span class="p">);</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">debug_string_size</span> <span class="o">=</span> <span class="n">soffset</span> <span class="o">+</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">temp_len</span><span class="p">;</span>
<span class="cp">#else</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">debug_string_size</span> <span class="o">=</span> <span class="n">soffset</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myalloc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myalloc</span><span class="o">-&gt;</span>
				    <span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myalloc</span><span class="p">,</span> <span class="n">asecs</span><span class="p">,</span>
						   <span class="n">ds_alignment</span><span class="p">(</span><span class="n">asecs</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">tgtalloc</span><span class="p">,</span>
						    <span class="n">asecs</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">asecs</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/* keep address deltas in original section table */</span>
			<span class="n">shp</span><span class="o">-&gt;</span><span class="n">ds_vaddr</span> <span class="o">=</span> <span class="n">asecs</span><span class="o">-&gt;</span><span class="n">load_addr</span> <span class="o">-</span> <span class="n">shp</span><span class="o">-&gt;</span><span class="n">ds_vaddr</span><span class="p">;</span>
			<span class="n">shp</span><span class="o">-&gt;</span><span class="n">ds_paddr</span> <span class="o">=</span> <span class="n">asecs</span><span class="o">-&gt;</span><span class="n">run_addr</span> <span class="o">-</span> <span class="n">shp</span><span class="o">-&gt;</span><span class="n">ds_paddr</span><span class="p">;</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>		<span class="cm">/* allocate target storage */</span>
		<span class="n">shp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">asecs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if BITS_PER_AU &lt;= BITS_PER_BYTE</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">debug_string_size</span> <span class="o">+=</span>
	    <span class="n">strlen</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_head</span> <span class="o">+</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">debug_string_size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>				<span class="cm">/* allocate sections */</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure section_table_free</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	none</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Frees any state used by the symbol table.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING:</span>
<span class="cm"> *	This routine is not allowed to declare errors!</span>
<span class="cm"> *********************************************************************** */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">section_table_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">doff_scnhdr_t</span> <span class="o">*</span><span class="n">shp</span><span class="p">;</span>

	<span class="n">shp</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">sect_hdrs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shp</span><span class="p">)</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">shp</span><span class="p">);</span>

<span class="p">}</span>				<span class="cm">/* section_table_free */</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dload_strings</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *  sec_names_only   If true only read in the &quot;section names&quot;</span>
<span class="cm"> *		     portion of the string table</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Loads the DOFF string table into memory. DOFF keeps all strings in a</span>
<span class="cm"> * big unsorted array.  We just read that array into memory in bulk.</span>
<span class="cm"> *********************************************************************** */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">stringtbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;string table&quot;</span> <span class="p">};</span>

<span class="kt">void</span> <span class="nf">dload_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sec_names_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ssiz</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">strbuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sec_names_only</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ssiz</span> <span class="o">=</span> <span class="n">BYTE_TO_HOST</span><span class="p">(</span><span class="n">DOFF_ALIGN</span>
				    <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_scn_name_size</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ssiz</span> <span class="o">=</span> <span class="n">BYTE_TO_HOST</span><span class="p">(</span><span class="n">DOFF_ALIGN</span>
				    <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_strtab_size</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ssiz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* get some memory for the string table */</span>
<span class="cp">#if BITS_PER_AU &gt; BITS_PER_BYTE</span>
	<span class="n">strbuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">ssiz</span> <span class="o">+</span>
						       <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span>
						       <span class="n">df_max_str_len</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">strbuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">ssiz</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">err_alloc</span><span class="p">,</span> <span class="n">ssiz</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_head</span> <span class="o">=</span> <span class="n">strbuf</span><span class="p">;</span>
<span class="cp">#if BITS_PER_AU &gt; BITS_PER_BYTE</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_temp</span> <span class="o">=</span> <span class="n">strbuf</span> <span class="o">+</span> <span class="n">ssiz</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* read in the strings and verify them */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">read_buffer</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="p">,</span> <span class="n">strbuf</span><span class="p">,</span>
						 <span class="n">ssiz</span><span class="p">))</span> <span class="o">!=</span> <span class="n">ssiz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">readstrm</span><span class="p">,</span> <span class="n">stringtbl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* if we need to fix up byte order, do it now */</span>
<span class="cp">#ifndef _BIG_ENDIAN</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">)</span>
		<span class="n">dload_reorder</span><span class="p">(</span><span class="n">strbuf</span><span class="p">,</span> <span class="n">ssiz</span><span class="p">,</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">sec_names_only</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">dload_checksum</span><span class="p">(</span><span class="n">strbuf</span><span class="p">,</span> <span class="n">ssiz</span><span class="p">)</span> <span class="o">!=</span>
				  <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">verify</span><span class="p">.</span><span class="n">dv_str_tab_checksum</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">err_checksum</span><span class="p">,</span> <span class="n">stringtbl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_byte_reshuffle</span> <span class="o">!=</span>
	    <span class="n">HOST_BYTE_ORDER</span><span class="p">(</span><span class="n">REORDER_MAP</span><span class="p">(</span><span class="n">BYTE_RESHUFFLE_VALUE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* put strings in big-endian order, not in PC order */</span>
		<span class="n">dload_reorder</span><span class="p">(</span><span class="n">strbuf</span><span class="p">,</span> <span class="n">ssiz</span><span class="p">,</span>
			      <span class="n">HOST_BYTE_ORDER</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span>
					      <span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_byte_reshuffle</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">sec_names_only</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">dload_reverse_checksum</span><span class="p">(</span><span class="n">strbuf</span><span class="p">,</span> <span class="n">ssiz</span><span class="p">)</span> <span class="o">!=</span>
				  <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">verify</span><span class="p">.</span><span class="n">dv_str_tab_checksum</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">err_checksum</span><span class="p">,</span> <span class="n">stringtbl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>				<span class="cm">/* dload_strings */</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure string_table_free</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	none</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Frees any state used by the string table.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING:</span>
<span class="cm"> *	This routine is not allowed to declare errors!</span>
<span class="cm"> ************************************************************************ */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">string_table_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_head</span><span class="p">)</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
						<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_head</span><span class="p">);</span>

<span class="p">}</span>				<span class="cm">/* string_table_free */</span>

<span class="cm">/*</span>
<span class="cm"> * Symbol Table Maintenance Functions</span>
<span class="cm"> *</span>
<span class="cm"> * COFF symbols are read by dload_symbols(), which is called after</span>
<span class="cm"> * sections have been allocated.  Symbols which might be used in</span>
<span class="cm"> * relocation (ie, not debug info) are retained in an internal temporary</span>
<span class="cm"> * compressed table (type local_symbol). A particular symbol is recovered</span>
<span class="cm"> * by index by calling dload_find_symbol().  dload_find_symbol</span>
<span class="cm"> * reconstructs a more explicit representation (type SLOTVEC) which is</span>
<span class="cm"> * used by reloc.c</span>
<span class="cm"> */</span>
<span class="cm">/* real size of debug header */</span>
<span class="cp">#define DBG_HDR_SIZE (sizeof(struct dll_module) - sizeof(struct dll_sect))</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">sym_errid</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;symbol&quot;</span> <span class="p">};</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> * Procedure dload_symbols</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	none</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Reads in symbols and retains ones that might be needed for relocation</span>
<span class="cm"> * purposes.</span>
<span class="cm"> *********************************************************************** */</span>
<span class="cm">/* size of symbol buffer no bigger than target data buffer, to limit stack</span>
<span class="cm"> * usage */</span>
<span class="cp">#define MY_SYM_BUF_SIZ (BYTE_TO_HOST(IMAGE_PACKET_SIZE)/\</span>
<span class="cp">			sizeof(struct doff_syment_t))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dload_symbols</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sym_count</span><span class="p">,</span> <span class="n">siz</span><span class="p">,</span> <span class="n">dsiz</span><span class="p">,</span> <span class="n">symbols_left</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">checks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">local_symbol</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dynload_symbol</span> <span class="o">*</span><span class="n">symp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dynload_symbol</span> <span class="o">*</span><span class="n">newsym</span><span class="p">;</span>

	<span class="n">sym_count</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_no_syms</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We keep a local symbol table for all of the symbols in the input.</span>
<span class="cm">	 * This table contains only section &amp; value info, as we do not have</span>
<span class="cm">	 * to do any name processing for locals.  We reuse this storage</span>
<span class="cm">	 * as a temporary for .dllview record construction.</span>
<span class="cm">	 * Allocate storage for the whole table.  Add 1 to the section count</span>
<span class="cm">	 * in case a trampoline section is auto-generated as well as the</span>
<span class="cm">	 * size of the trampoline section name so DLLView doesn&#39;t get lost.</span>
<span class="cm">	 */</span>

	<span class="n">siz</span> <span class="o">=</span> <span class="n">sym_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">local_symbol</span><span class="p">);</span>
	<span class="n">dsiz</span> <span class="o">=</span> <span class="n">DBG_HDR_SIZE</span> <span class="o">+</span>
	    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dll_sect</span><span class="p">)</span> <span class="o">*</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">)</span> <span class="o">+</span>
	    <span class="n">BYTE_TO_HOST_ROUND</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">debug_string_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dsiz</span> <span class="o">&gt;</span> <span class="n">siz</span><span class="p">)</span>
		<span class="n">siz</span> <span class="o">=</span> <span class="n">dsiz</span><span class="p">;</span>	<span class="cm">/* larger of symbols and .dllview temp */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">local_symbol</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
								  <span class="n">siz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">err_alloc</span><span class="p">,</span> <span class="n">siz</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">local_symtab</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
	<span class="cm">/* Read the symbols in the input, store them in the table, and post any</span>
<span class="cm">	 * globals to the global symbol table.  In the process, externals</span>
<span class="cm">	 become defined from the global symbol table */</span>
	<span class="n">checks</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">verify</span><span class="p">.</span><span class="n">dv_sym_tab_checksum</span><span class="p">;</span>
	<span class="n">symbols_left</span> <span class="o">=</span> <span class="n">sym_count</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>			<span class="cm">/* read all symbols */</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">s32</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">doff_syment_t</span> <span class="o">*</span><span class="n">input_sym</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">syms_in_buf</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">doff_syment_t</span> <span class="n">my_sym_buf</span><span class="p">[</span><span class="n">MY_SYM_BUF_SIZ</span><span class="p">];</span>
		<span class="n">input_sym</span> <span class="o">=</span> <span class="n">my_sym_buf</span><span class="p">;</span>
		<span class="n">syms_in_buf</span> <span class="o">=</span> <span class="n">symbols_left</span> <span class="o">&gt;</span> <span class="n">MY_SYM_BUF_SIZ</span> <span class="o">?</span>
		    <span class="n">MY_SYM_BUF_SIZ</span> <span class="o">:</span> <span class="n">symbols_left</span><span class="p">;</span>
		<span class="n">siz</span> <span class="o">=</span> <span class="n">syms_in_buf</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">doff_syment_t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">read_buffer</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="p">,</span> <span class="n">input_sym</span><span class="p">,</span> <span class="n">siz</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">siz</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">readstrm</span><span class="p">,</span> <span class="n">sym_errid</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">)</span>
			<span class="n">dload_reorder</span><span class="p">(</span><span class="n">input_sym</span><span class="p">,</span> <span class="n">siz</span><span class="p">,</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">);</span>

		<span class="n">checks</span> <span class="o">+=</span> <span class="n">dload_checksum</span><span class="p">(</span><span class="n">input_sym</span><span class="p">,</span> <span class="n">siz</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>		<span class="cm">/* process symbols in buffer */</span>
			<span class="n">symbols_left</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* attempt to derive the name of this symbol */</span>
			<span class="n">sname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if BITS_PER_AU &lt;= BITS_PER_BYTE</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_offset</span> <span class="o">&lt;</span>
				    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_strtab_size</span><span class="p">)</span>
					<span class="n">sname</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_head</span> <span class="o">+</span>
					    <span class="n">BYTE_TO_HOST</span><span class="p">(</span><span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_offset</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
						    <span class="s">&quot;Bad name offset in symbol &quot;</span>
						    <span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">symbols_left</span><span class="p">);</span>
<span class="cp">#else</span>
				<span class="n">sname</span> <span class="o">=</span> <span class="n">unpack_name</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
						    <span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_offset</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="p">}</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_value</span><span class="p">;</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_sclass</span><span class="p">;</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">=</span> <span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_scnum</span><span class="p">;</span>
			<span class="cm">/* if this is an undefined symbol,</span>
<span class="cm">			 * define it (or fail) now */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">==</span> <span class="n">DN_UNDEF</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* pointless for static undefined */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_sclass</span> <span class="o">!=</span> <span class="n">DN_EXT</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>

				<span class="cm">/* try to define symbol from previously</span>
<span class="cm">				 * loaded images */</span>
				<span class="n">symp</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">find_matching_symbol</span>
				    <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">sname</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">symp</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">DL_ERROR</span>
					    <span class="p">(</span><span class="s">&quot;Undefined external symbol %s&quot;</span><span class="p">,</span>
					     <span class="n">sname</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">val</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">symp</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
<span class="cp">#ifdef ENABLE_TRAMP_DEBUG</span>
				<span class="n">dload_syms_error</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
						 <span class="s">&quot;===&gt; ext sym [%s] at %x&quot;</span><span class="p">,</span>
						 <span class="n">sname</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="cp">#endif</span>

				<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* symbol defined by this module */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* symbol references a section */</span>
				<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">&lt;=</span>
				    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* section was allocated */</span>
					<span class="k">struct</span> <span class="n">doff_scnhdr_t</span> <span class="o">*</span><span class="n">srefp</span> <span class="o">=</span>
					    <span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">sect_hdrs</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_sclass</span> <span class="o">==</span>
					    <span class="n">DN_STATLAB</span> <span class="o">||</span>
					    <span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_sclass</span> <span class="o">==</span> <span class="n">DN_EXTLAB</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* load */</span>
						<span class="n">delta</span> <span class="o">=</span> <span class="n">srefp</span><span class="o">-&gt;</span><span class="n">ds_vaddr</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="cm">/* run */</span>
						<span class="n">delta</span> <span class="o">=</span> <span class="n">srefp</span><span class="o">-&gt;</span><span class="n">ds_paddr</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">val</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">goto</span> <span class="n">loop_itr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* This symbol is an absolute symbol */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">==</span> <span class="n">DN_ABS</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">==</span> <span class="n">DN_EXT</span><span class="p">)</span> <span class="o">||</span>
						    <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">==</span>
						     <span class="n">DN_EXTLAB</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">symp</span> <span class="o">=</span>
				    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">find_matching_symbol</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span>
									<span class="n">mysym</span><span class="p">,</span>
									<span class="n">sname</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">symp</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">loop_itr</span><span class="p">;</span>
				<span class="cm">/* This absolute symbol is already defined. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">symp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">==</span> <span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_value</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* If symbol values are equal, continue</span>
<span class="cm">					 * but don&#39;t add to the global symbol</span>
<span class="cm">					 * table */</span>
					<span class="n">sp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
					<span class="n">sp</span><span class="o">-&gt;</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
					<span class="n">sp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">input_sym</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* If symbol values are not equal,</span>
<span class="cm">					 * return with redefinition error */</span>
					<span class="n">DL_ERROR</span><span class="p">(</span><span class="s">&quot;Absolute symbol %s is &quot;</span>
						 <span class="s">&quot;defined multiple times with &quot;</span>
						 <span class="s">&quot;different values&quot;</span><span class="p">,</span> <span class="n">sname</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="nl">loop_itr:</span>
			<span class="cm">/* if this is a global symbol, post it to the</span>
<span class="cm">			 * global table */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_sclass</span> <span class="o">==</span> <span class="n">DN_EXT</span> <span class="o">||</span>
			    <span class="n">input_sym</span><span class="o">-&gt;</span><span class="n">dn_sclass</span> <span class="o">==</span> <span class="n">DN_EXTLAB</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Keep this global symbol for subsequent</span>
<span class="cm">				 * modules. Don&#39;t complain on error, to allow</span>
<span class="cm">				 * symbol API to suppress global symbols */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sname</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>

				<span class="n">newsym</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">add_to_symbol_table</span>
				    <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">sname</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myhandle</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">newsym</span><span class="p">)</span>
					<span class="n">newsym</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

			<span class="p">}</span>	<span class="cm">/* global */</span>
<span class="nl">loop_cont:</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">sp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">input_sym</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">syms_in_buf</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* process sym in buf */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">symbols_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* read all symbols */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">checks</span><span class="p">)</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Checksum of symbols failed&quot;</span><span class="p">);</span>

<span class="p">}</span>				<span class="cm">/* dload_symbols */</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> * Procedure symbol_table_free</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	none</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Frees any state used by the symbol table.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING:</span>
<span class="cm"> *	This routine is not allowed to declare errors!</span>
<span class="cm"> **************************************************************************** */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">symbol_table_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">local_symtab</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dload_errcount</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* blow off our symbols */</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">purge_symbol_table</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
							  <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>
							  <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myhandle</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
						<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">local_symtab</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>				<span class="cm">/* symbol_table_free */</span>

<span class="cm">/* .cinit Processing</span>
<span class="cm"> *</span>
<span class="cm"> * The dynamic loader does .cinit interpretation.  cload_cinit()</span>
<span class="cm"> * acts as a special write-to-target function, in that it takes relocated</span>
<span class="cm"> * data from the normal data flow, and interprets it as .cinit actions.</span>
<span class="cm"> * Because the normal data flow does not  necessarily process the whole</span>
<span class="cm"> * .cinit section in one buffer, cload_cinit() must be prepared to</span>
<span class="cm"> * interpret the data piecemeal.  A state machine is used for this</span>
<span class="cm"> * purpose.</span>
<span class="cm"> */</span>

<span class="cm">/* The following are only for use by reloc.c and things it calls */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="n">cinit_info_init</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cinitname</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">(</span><span class="n">ldr_addr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DLOAD_BSS</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure cload_cinit</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	ipacket		Pointer to data packet to be loaded</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Interprets the data in the buffer as .cinit data, and performs the</span>
<span class="cm"> * appropriate initializations.</span>
<span class="cm"> *********************************************************************** */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cload_cinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">image_packet_t</span> <span class="o">*</span><span class="n">ipacket</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if TDATA_TO_HOST(CINIT_COUNT)*BITS_PER_AU &gt; 16</span>
	<span class="n">s32</span> <span class="n">init_count</span><span class="p">,</span> <span class="n">left</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">s16</span> <span class="n">init_count</span><span class="p">,</span> <span class="n">left</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pktp</span> <span class="o">=</span> <span class="n">ipacket</span><span class="o">-&gt;</span><span class="n">img_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pktend</span> <span class="o">=</span> <span class="n">pktp</span> <span class="o">+</span> <span class="n">BYTE_TO_HOST_ROUND</span><span class="p">(</span><span class="n">ipacket</span><span class="o">-&gt;</span><span class="n">packet_size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">ldr_addr</span> <span class="n">atmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="n">cinit_info</span><span class="p">;</span>

	<span class="cm">/*  PROCESS ALL THE INITIALIZATION RECORDS THE BUFFER. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">pktend</span> <span class="o">-</span> <span class="n">pktp</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CI_COUNT</span>:	<span class="cm">/* count field */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">TDATA_TO_HOST</span><span class="p">(</span><span class="n">CINIT_COUNT</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">loopexit</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">dload_unpack</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="p">(</span><span class="n">tgt_au_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pktp</span><span class="p">,</span>
					    <span class="n">CINIT_COUNT</span> <span class="o">*</span> <span class="n">TDATA_AU_BITS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">ROP_SGN</span><span class="p">);</span>
			<span class="n">pktp</span> <span class="o">+=</span> <span class="n">TDATA_TO_HOST</span><span class="p">(</span><span class="n">CINIT_COUNT</span><span class="p">);</span>
			<span class="cm">/* negative signifies BSS table, zero means done */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_state</span> <span class="o">=</span> <span class="n">CI_DONE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_count</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_state</span> <span class="o">=</span> <span class="n">CI_ADDRESS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#if CINIT_ALIGN &lt; CINIT_ADDRESS</span>
		<span class="k">case</span> <span class="n">CI_PARTADDRESS</span>:
			<span class="n">pktp</span> <span class="o">-=</span> <span class="n">TDATA_TO_HOST</span><span class="p">(</span><span class="n">CINIT_ALIGN</span><span class="p">);</span>
			<span class="cm">/* back up pointer into space courtesy of caller */</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pktp</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_addr</span><span class="p">;</span>
			<span class="cm">/* stuff in saved bits  !! FALL THRU !! */</span>
<span class="cp">#endif</span>
		<span class="k">case</span> <span class="n">CI_ADDRESS</span>:	<span class="cm">/* Address field for a copy packet */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">TDATA_TO_HOST</span><span class="p">(</span><span class="n">CINIT_ADDRESS</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#if CINIT_ALIGN &lt; CINIT_ADDRESS</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">TDATA_TO_HOST</span><span class="p">(</span><span class="n">CINIT_ALIGN</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* address broken into halves */</span>
					<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pktp</span><span class="p">;</span>
					<span class="cm">/* remember 1st half */</span>
					<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_state</span> <span class="o">=</span> <span class="n">CI_PARTADDRESS</span><span class="p">;</span>
					<span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
<span class="cp">#endif</span>
				<span class="k">goto</span> <span class="n">loopexit</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">atmp</span> <span class="o">=</span> <span class="n">dload_unpack</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="p">(</span><span class="n">tgt_au_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pktp</span><span class="p">,</span>
					    <span class="n">CINIT_ADDRESS</span> <span class="o">*</span> <span class="n">TDATA_AU_BITS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">ROP_UNS</span><span class="p">);</span>
			<span class="n">pktp</span> <span class="o">+=</span> <span class="n">TDATA_TO_HOST</span><span class="p">(</span><span class="n">CINIT_ADDRESS</span><span class="p">);</span>
<span class="cp">#if CINIT_PAGE_BITS &gt; 0</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_page</span> <span class="o">=</span> <span class="n">atmp</span> <span class="o">&amp;</span>
			    <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CINIT_PAGE_BITS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">atmp</span> <span class="o">&gt;&gt;=</span> <span class="n">CINIT_PAGE_BITS</span><span class="p">;</span>
<span class="cp">#else</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_page</span> <span class="o">=</span> <span class="n">CINIT_DEFAULT_PAGE</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_addr</span> <span class="o">=</span> <span class="n">atmp</span><span class="p">;</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_state</span> <span class="o">=</span> <span class="n">CI_COPY</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CI_COPY</span>:	<span class="cm">/* copy bits to the target */</span>
			<span class="n">init_count</span> <span class="o">=</span> <span class="n">HOST_TO_TDATA</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">init_count</span> <span class="o">&gt;</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_count</span><span class="p">)</span>
				<span class="n">init_count</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_count</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">init_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">loopexit</span><span class="p">;</span>	<span class="cm">/* get more bits */</span>
			<span class="n">cinit_info</span> <span class="o">=</span> <span class="n">cinit_info_init</span><span class="p">;</span>
			<span class="n">cinit_info</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_page</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="o">-&gt;</span><span class="n">writemem</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="p">,</span> <span class="n">pktp</span><span class="p">,</span>
						   <span class="n">TDATA_TO_TADDR</span>
						   <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_addr</span><span class="p">),</span>
						   <span class="o">&amp;</span><span class="n">cinit_info</span><span class="p">,</span>
						   <span class="n">TDATA_TO_HOST</span><span class="p">(</span><span class="n">init_count</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">initfail</span><span class="p">,</span> <span class="s">&quot;write&quot;</span><span class="p">,</span>
					    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_addr</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_count</span> <span class="o">-=</span> <span class="n">init_count</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_state</span> <span class="o">=</span> <span class="n">CI_COUNT</span><span class="p">;</span>
				<span class="n">init_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">init_count</span> <span class="o">+</span> <span class="n">CINIT_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
				    <span class="o">-</span><span class="n">CINIT_ALIGN</span><span class="p">;</span>
				<span class="cm">/* align to next init */</span>
			<span class="p">}</span>
			<span class="n">pktp</span> <span class="o">+=</span> <span class="n">TDATA_TO_HOST</span><span class="p">(</span><span class="n">init_count</span><span class="p">);</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_addr</span> <span class="o">+=</span> <span class="n">init_count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CI_DONE</span>:	<span class="cm">/* no more .cinit to do */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>		<span class="cm">/* switch (cinit_state) */</span>
	<span class="p">}</span>			<span class="cm">/* while */</span>

<span class="nl">loopexit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;%d bytes left over in cinit packet&quot;</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">cinit_state</span> <span class="o">=</span> <span class="n">CI_DONE</span><span class="p">;</span>	<span class="cm">/* left over bytes are bad */</span>
	<span class="p">}</span>
<span class="p">}</span>				<span class="cm">/* cload_cinit */</span>

<span class="cm">/*	Functions to interface to reloc.c</span>
<span class="cm"> *</span>
<span class="cm"> * reloc.c is the relocation module borrowed from the linker, with</span>
<span class="cm"> * minimal (we hope) changes for our purposes.  cload_sect_data() invokes</span>
<span class="cm"> * this module on a section to relocate and load the image data for that</span>
<span class="cm"> * section.  The actual read and write actions are supplied by the global</span>
<span class="cm"> * routines below.</span>
<span class="cm"> */</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> * Procedure relocate_packet</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	ipacket		Pointer to an image packet to relocate</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Performs the required relocations on the packet.  Returns a checksum</span>
<span class="cm"> * of the relocation operations.</span>
<span class="cm"> *********************************************************************** */</span>
<span class="cp">#define MY_RELOC_BUF_SIZ 8</span>
<span class="cm">/* careful! exists at the same time as the image buffer */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">relocate_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">image_packet_t</span> <span class="o">*</span><span class="n">ipacket</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="o">*</span><span class="n">checks</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">tramps_generated</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rnum</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tramps_generated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">rnum</span> <span class="o">=</span> <span class="n">ipacket</span><span class="o">-&gt;</span><span class="n">num_relocs</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>			<span class="cm">/* all relocs */</span>
		<span class="kt">unsigned</span> <span class="n">rinbuf</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">siz</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="n">rrec</span><span class="p">[</span><span class="n">MY_RELOC_BUF_SIZ</span><span class="p">];</span>
		<span class="n">rp</span> <span class="o">=</span> <span class="n">rrec</span><span class="p">;</span>
		<span class="n">rinbuf</span> <span class="o">=</span> <span class="n">rnum</span> <span class="o">&gt;</span> <span class="n">MY_RELOC_BUF_SIZ</span> <span class="o">?</span> <span class="n">MY_RELOC_BUF_SIZ</span> <span class="o">:</span> <span class="n">rnum</span><span class="p">;</span>
		<span class="n">siz</span> <span class="o">=</span> <span class="n">rinbuf</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reloc_record_t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">read_buffer</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">siz</span><span class="p">)</span> <span class="o">!=</span> <span class="n">siz</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">readstrm</span><span class="p">,</span> <span class="s">&quot;relocation&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* reorder the bytes if need be */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">)</span>
			<span class="n">dload_reorder</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">siz</span><span class="p">,</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">);</span>

		<span class="o">*</span><span class="n">checks</span> <span class="o">+=</span> <span class="n">dload_checksum</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">siz</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="cm">/* perform the relocation operation */</span>
			<span class="n">dload_relocate</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="p">(</span><span class="n">tgt_au_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">ipacket</span><span class="o">-&gt;</span><span class="n">img_data</span><span class="p">,</span>
				       <span class="n">rp</span><span class="p">,</span> <span class="n">tramps_generated</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="n">rp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">rnum</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">rinbuf</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rnum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* all relocs */</span>
	<span class="cm">/* If trampoline(s) were generated, we need to do an update of the</span>
<span class="cm">	 * trampoline copy of the packet since a 2nd phase relo will be done</span>
<span class="cm">	 * later. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">tramps_generated</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dload_tramp_pkt_udpate</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span> <span class="o">-</span>
					<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">),</span>
				       <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span><span class="p">,</span> <span class="n">ipacket</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* dload_read_reloc */</span>

<span class="cp">#define IPH_SIZE (sizeof(struct image_packet_t) - sizeof(u32))</span>

<span class="cm">/* VERY dangerous */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">imagepak</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;image packet&quot;</span> <span class="p">};</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dload_data</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	none</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Read image data from input file, relocate it, and download it to the</span>
<span class="cm"> *	target.</span>
<span class="cm"> *********************************************************************** */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dload_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">curr_sect</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doff_scnhdr_t</span> <span class="o">*</span><span class="n">sptr</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">sect_hdrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="n">lptr</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">image_packet_t</span> <span class="n">ipacket</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">bufr</span><span class="p">[</span><span class="n">BYTE_TO_HOST</span><span class="p">(</span><span class="n">IMAGE_PACKET_SIZE</span><span class="p">)];</span>
	<span class="p">}</span> <span class="n">ibuf</span><span class="p">;</span>

	<span class="cm">/* Indicates whether CINIT processing has occurred */</span>
	<span class="n">bool</span> <span class="n">cinit_processed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Loop through the sections and load them one at a time.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">curr_sect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">curr_sect</span> <span class="o">&lt;</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_no_scns</span><span class="p">;</span>
	     <span class="n">curr_sect</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ds_needs_download</span><span class="p">(</span><span class="n">sptr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">s32</span> <span class="n">nip</span><span class="p">;</span>
			<span class="n">ldr_addr</span> <span class="n">image_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* set relocation info for this section */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_sect</span> <span class="o">&lt;</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">)</span>
				<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">delta_runaddr</span> <span class="o">=</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">ds_paddr</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">lptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="p">)</span><span class="n">sptr</span><span class="p">;</span>
				<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">delta_runaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span> <span class="o">=</span> <span class="n">lptr</span><span class="p">;</span>
<span class="cp">#if BITS_PER_AU &gt; BITS_PER_BYTE</span>
			<span class="n">lptr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">unpack_name</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">ds_offset</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">nip</span> <span class="o">=</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">ds_nipacks</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">nip</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* process packets */</span>

				<span class="n">s32</span> <span class="n">ipsize</span><span class="p">;</span>
				<span class="n">u32</span> <span class="n">checks</span><span class="p">;</span>
				<span class="n">bool</span> <span class="n">tramp_generated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

				<span class="cm">/* get the fixed header bits */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">read_buffer</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="p">,</span>
							      <span class="o">&amp;</span><span class="n">ibuf</span><span class="p">.</span><span class="n">ipacket</span><span class="p">,</span>
							      <span class="n">IPH_SIZE</span><span class="p">)</span> <span class="o">!=</span>
				    <span class="n">IPH_SIZE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">readstrm</span><span class="p">,</span> <span class="n">imagepak</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* reorder the header if need be */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dload_reorder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ibuf</span><span class="p">.</span><span class="n">ipacket</span><span class="p">,</span> <span class="n">IPH_SIZE</span><span class="p">,</span>
						      <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/* now read the rest of the packet */</span>
				<span class="n">ipsize</span> <span class="o">=</span>
				    <span class="n">BYTE_TO_HOST</span><span class="p">(</span><span class="n">DOFF_ALIGN</span>
						 <span class="p">(</span><span class="n">ibuf</span><span class="p">.</span><span class="n">ipacket</span><span class="p">.</span><span class="n">packet_size</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ipsize</span> <span class="o">&gt;</span> <span class="n">BYTE_TO_HOST</span><span class="p">(</span><span class="n">IMAGE_PACKET_SIZE</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">DL_ERROR</span><span class="p">(</span><span class="s">&quot;Bad image packet size %d&quot;</span><span class="p">,</span>
						 <span class="n">ipsize</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">dest</span> <span class="o">=</span> <span class="n">ibuf</span><span class="p">.</span><span class="n">bufr</span><span class="p">;</span>
				<span class="cm">/* End of determination */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">read_buffer</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">strm</span><span class="p">,</span>
							      <span class="n">ibuf</span><span class="p">.</span><span class="n">bufr</span><span class="p">,</span>
							      <span class="n">ipsize</span><span class="p">)</span> <span class="o">!=</span>
				    <span class="n">ipsize</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">readstrm</span><span class="p">,</span> <span class="n">imagepak</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ibuf</span><span class="p">.</span><span class="n">ipacket</span><span class="p">.</span><span class="n">img_data</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>

				<span class="cm">/* reorder the bytes if need be */</span>
<span class="cp">#if !defined(_BIG_ENDIAN) || (TARGET_AU_BITS &gt; 16)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dload_reorder</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">ipsize</span><span class="p">,</span>
						      <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">reorder_map</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">checks</span> <span class="o">=</span> <span class="n">dload_checksum</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">ipsize</span><span class="p">);</span>
<span class="cp">#else</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_byte_reshuffle</span> <span class="o">!=</span>
				    <span class="n">TARGET_ORDER</span><span class="p">(</span><span class="n">REORDER_MAP</span>
						 <span class="p">(</span><span class="n">BYTE_RESHUFFLE_VALUE</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* put image bytes in big-endian order,</span>
<span class="cm">					 * not PC order */</span>
					<span class="n">dload_reorder</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">ipsize</span><span class="p">,</span>
						      <span class="n">TARGET_ORDER</span>
						      <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span>
						       <span class="n">df_byte_reshuffle</span><span class="p">));</span>
				<span class="p">}</span>
<span class="cp">#if TARGET_AU_BITS &gt; 8</span>
				<span class="n">checks</span> <span class="o">=</span> <span class="n">dload_reverse_checksum16</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">ipsize</span><span class="p">);</span>
<span class="cp">#else</span>
				<span class="n">checks</span> <span class="o">=</span> <span class="n">dload_reverse_checksum</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">ipsize</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

				<span class="n">checks</span> <span class="o">+=</span> <span class="n">dload_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ibuf</span><span class="p">.</span><span class="n">ipacket</span><span class="p">,</span>
							 <span class="n">IPH_SIZE</span><span class="p">);</span>
				<span class="cm">/* relocate the image bits as needed */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ibuf</span><span class="p">.</span><span class="n">ipacket</span><span class="p">.</span><span class="n">num_relocs</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span> <span class="o">=</span> <span class="n">image_offset</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">relocate_packet</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
							     <span class="o">&amp;</span><span class="n">ibuf</span><span class="p">.</span><span class="n">ipacket</span><span class="p">,</span>
							     <span class="o">&amp;</span><span class="n">checks</span><span class="p">,</span>
							     <span class="o">&amp;</span><span class="n">tramp_generated</span><span class="p">))</span>
						<span class="k">return</span><span class="p">;</span>	<span class="cm">/* serious error */</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">checks</span><span class="p">)</span>
					<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">err_checksum</span><span class="p">,</span> <span class="n">imagepak</span><span class="p">);</span>
				<span class="cm">/* Only write the result to the target if no</span>
<span class="cm">				 * trampoline was generated.  Otherwise it</span>
<span class="cm">				 *will be done during trampoline finalize. */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">tramp_generated</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>

					<span class="cm">/* stuff the result into target</span>
<span class="cm">					 * memory */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">dload_check_type</span><span class="p">(</span><span class="n">sptr</span><span class="p">,</span>
						<span class="n">DLOAD_CINIT</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">cload_cinit</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
							    <span class="o">&amp;</span><span class="n">ibuf</span><span class="p">.</span><span class="n">ipacket</span><span class="p">);</span>
						<span class="n">cinit_processed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="cm">/* FIXME */</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="o">-&gt;</span>
						    <span class="n">writemem</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span>
							<span class="n">myio</span><span class="p">,</span>
							<span class="n">ibuf</span><span class="p">.</span><span class="n">bufr</span><span class="p">,</span>
							<span class="n">lptr</span><span class="o">-&gt;</span>
							<span class="n">load_addr</span> <span class="o">+</span>
							<span class="n">image_offset</span><span class="p">,</span>
							<span class="n">lptr</span><span class="p">,</span>
							<span class="n">BYTE_TO_HOST</span>
							<span class="p">(</span><span class="n">ibuf</span><span class="p">.</span>
							<span class="n">ipacket</span><span class="p">.</span>
							<span class="n">packet_size</span><span class="p">)))</span> <span class="p">{</span>
							<span class="n">DL_ERROR</span>
							  <span class="p">(</span><span class="s">&quot;Write to &quot;</span>
							  <span class="n">FMT_UI32</span>
							  <span class="s">&quot; failed&quot;</span><span class="p">,</span>
							  <span class="n">lptr</span><span class="o">-&gt;</span>
							  <span class="n">load_addr</span> <span class="o">+</span>
							  <span class="n">image_offset</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">image_offset</span> <span class="o">+=</span>
				    <span class="n">BYTE_TO_TADDR</span><span class="p">(</span><span class="n">ibuf</span><span class="p">.</span><span class="n">ipacket</span><span class="p">.</span><span class="n">packet_size</span><span class="p">);</span>
			<span class="p">}</span>	<span class="cm">/* process packets */</span>
			<span class="cm">/* if this is a BSS section, we may want to fill it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dload_check_type</span><span class="p">(</span><span class="n">sptr</span><span class="p">,</span> <span class="n">DLOAD_BSS</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myoptions</span> <span class="o">&amp;</span> <span class="n">DLOAD_INITBSS</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cinit_processed</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Don&#39;t clear BSS after load-time</span>
<span class="cm">				 * initialization */</span>
				<span class="n">DL_ERROR</span>
				    <span class="p">(</span><span class="s">&quot;Zero-initialization at &quot;</span> <span class="n">FMT_UI32</span>
				     <span class="s">&quot; after &quot;</span> <span class="s">&quot;load-time initialization!&quot;</span><span class="p">,</span>
				     <span class="n">lptr</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* fill the .bss area */</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="o">-&gt;</span><span class="n">fillmem</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="p">,</span>
					      <span class="n">TADDR_TO_HOST</span><span class="p">(</span><span class="n">lptr</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">),</span>
					      <span class="n">lptr</span><span class="p">,</span> <span class="n">TADDR_TO_HOST</span><span class="p">(</span><span class="n">lptr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">),</span>
					      <span class="n">DLOAD_FILL_BSS</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* if DS_DOWNLOAD_MASK */</span>
		<span class="cm">/* If not loading, but BSS, zero initialize */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dload_check_type</span><span class="p">(</span><span class="n">sptr</span><span class="p">,</span> <span class="n">DLOAD_BSS</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myoptions</span> <span class="o">&amp;</span> <span class="n">DLOAD_INITBSS</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">curr_sect</span> <span class="o">&gt;=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">)</span>
			<span class="n">lptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="p">)</span><span class="n">sptr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cinit_processed</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*Don&#39;t clear BSS after load-time initialization */</span>
			<span class="n">DL_ERROR</span><span class="p">(</span><span class="s">&quot;Zero-initialization at &quot;</span> <span class="n">FMT_UI32</span>
				 <span class="s">&quot; attempted after &quot;</span>
				 <span class="s">&quot;load-time initialization!&quot;</span><span class="p">,</span> <span class="n">lptr</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">loop_cont</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fill the .bss area */</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="o">-&gt;</span><span class="n">fillmem</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="p">,</span>
				      <span class="n">TADDR_TO_HOST</span><span class="p">(</span><span class="n">lptr</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">),</span> <span class="n">lptr</span><span class="p">,</span>
				      <span class="n">TADDR_TO_HOST</span><span class="p">(</span><span class="n">lptr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">),</span>
				      <span class="n">DLOAD_FILL_BSS</span><span class="p">);</span>
<span class="nl">loop_cont:</span>
		<span class="n">sptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>			<span class="cm">/* load sections */</span>

	<span class="cm">/*  Finalize any trampolines that were created during the load */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dload_tramp_finalize</span><span class="p">(</span><span class="n">dlthis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DL_ERROR</span><span class="p">(</span><span class="s">&quot;Finalization of auto-trampolines (size = &quot;</span> <span class="n">FMT_UI32</span>
			 <span class="s">&quot;) failed&quot;</span><span class="p">,</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sect_next_addr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>				<span class="cm">/* dload_data */</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dload_reorder</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	data	32-bit aligned pointer to data to be byte-swapped</span>
<span class="cm"> *	dsiz	size of the data to be reordered in sizeof() units.</span>
<span class="cm"> *	map		32-bit map defining how to reorder the data.  Value</span>
<span class="cm"> *			must be REORDER_MAP() of some permutation</span>
<span class="cm"> *			of 0x00 01 02 03</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Re-arranges the bytes in each word according to the map specified.</span>
<span class="cm"> *</span>
<span class="cm"> *********************************************************************** */</span>
<span class="cm">/* mask for byte shift count */</span>
<span class="cp">#define SHIFT_COUNT_MASK (3 &lt;&lt; LOG_BITS_PER_BYTE)</span>

<span class="kt">void</span> <span class="nf">dload_reorder</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dsiz</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="n">u32</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmap</span><span class="p">,</span> <span class="n">datv</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">map</span> <span class="o">&lt;&lt;=</span> <span class="n">LOG_BITS_PER_BYTE</span><span class="p">;</span>	<span class="cm">/* align map with SHIFT_COUNT_MASK */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">datv</span> <span class="o">=</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
		<span class="n">tmap</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">datv</span> <span class="o">&amp;</span> <span class="n">BYTE_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">tmap</span> <span class="o">&amp;</span> <span class="n">SHIFT_COUNT_MASK</span><span class="p">);</span>
			<span class="n">tmap</span> <span class="o">&gt;&gt;=</span> <span class="n">BITS_PER_BYTE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">datv</span> <span class="o">&gt;&gt;=</span> <span class="n">BITS_PER_BYTE</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dp</span><span class="o">++</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">dsiz</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>				<span class="cm">/* dload_reorder */</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dload_checksum</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	data	32-bit aligned pointer to data to be checksummed</span>
<span class="cm"> *	siz		size of the data to be checksummed in sizeof() units.</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Returns a checksum of the specified block</span>
<span class="cm"> *</span>
<span class="cm"> *********************************************************************** */</span>
<span class="n">u32</span> <span class="nf">dload_checksum</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">siz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sum</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span><span class="p">;</span>

	<span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">siz</span><span class="p">;</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">left</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">dp</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* dload_checksum */</span>

<span class="cp">#if HOST_ENDIANNESS</span>
<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dload_reverse_checksum</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	data	32-bit aligned pointer to data to be checksummed</span>
<span class="cm"> *	siz		size of the data to be checksummed in sizeof() units.</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Returns a checksum of the specified block, which is assumed to be bytes</span>
<span class="cm"> * in big-endian order.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	In a big-endian host, things like the string table are stored as bytes</span>
<span class="cm"> * in host order. But dllcreate always checksums in little-endian order.</span>
<span class="cm"> * It is most efficient to just handle the difference a word at a time.</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************** */</span>
<span class="n">u32</span> <span class="nf">dload_reverse_checksum</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">siz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sum</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span><span class="p">;</span>

	<span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">siz</span><span class="p">;</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">left</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">dp</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="n">BITS_PER_BYTE</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">temp</span> <span class="o">&gt;&gt;</span> <span class="n">BITS_PER_BYTE</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&gt;&gt;</span> <span class="n">BITS_PER_BYTE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BYTE_MASK</span> <span class="o">&lt;&lt;</span> <span class="n">BITS_PER_BYTE</span><span class="p">);</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BYTE_MASK</span> <span class="o">&lt;&lt;</span> <span class="n">BITS_PER_BYTE</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">BITS_PER_BYTE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* dload_reverse_checksum */</span>

<span class="cp">#if (TARGET_AU_BITS &gt; 8) &amp;&amp; (TARGET_AU_BITS &lt; 32)</span>
<span class="n">u32</span> <span class="nf">dload_reverse_checksum16</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">siz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint_fast32_t</span> <span class="n">sum</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span><span class="p">;</span>

	<span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">siz</span><span class="p">;</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">left</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">dp</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="n">BITS_PER_BYTE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">temp</span> <span class="o">&gt;&gt;</span> <span class="n">BITS_PER_BYTE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* dload_reverse_checksum16 */</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure swap_words</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	data	32-bit aligned pointer to data to be swapped</span>
<span class="cm"> *	siz	size of the data to be swapped.</span>
<span class="cm"> *	bitmap	Bit map of how to swap each 32-bit word; 1 =&gt; 2 shorts,</span>
<span class="cm"> *		0 =&gt; 1 long</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Swaps the specified data according to the specified map</span>
<span class="cm"> *</span>
<span class="cm"> *********************************************************************** */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swap_words</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">siz</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#if TARGET_AU_BITS &lt; 16</span>
	<span class="k">register</span> <span class="n">u16</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">register</span> <span class="n">u32</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>

	<span class="n">siz</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">);</span>

<span class="cp">#if TARGET_AU_BITS &lt; 16</span>
	<span class="cm">/* pass 1: do all the bytes */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">siz</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">register</span> <span class="n">u16</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">sp</span><span class="o">++</span> <span class="o">=</span> <span class="n">SWAP16BY8</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if TARGET_AU_BITS &lt; 32</span>
	<span class="cm">/* pass 2: fixup the 32-bit words */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">siz</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bitmap</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">register</span> <span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
			<span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">SWAP32BY16</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bitmap</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>				<span class="cm">/* swap_words */</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure copy_tgt_strings</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	dstp		Destination address.  Assumed to be 32-bit aligned</span>
<span class="cm"> *	srcp		Source address.  Assumed to be 32-bit aligned</span>
<span class="cm"> *	charcount	Number of characters to copy.</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Copies strings from the source (which is in usual .dof file order on</span>
<span class="cm"> * the loading processor) to the destination buffer (which should be in proper</span>
<span class="cm"> * target addressable unit order).  Makes sure the last string in the</span>
<span class="cm"> * buffer is NULL terminated (for safety).</span>
<span class="cm"> * Returns the first unused destination address.</span>
<span class="cm"> *********************************************************************** */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">copy_tgt_strings</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">charcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="n">tgt_au_t</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="n">tgt_au_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">srcp</span><span class="p">;</span>
	<span class="k">register</span> <span class="n">tgt_au_t</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">tgt_au_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">dstp</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">charcount</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
<span class="cp">#if TARGET_AU_BITS &lt;= BITS_PER_AU</span>
		<span class="cm">/* byte-swapping issues may exist for strings on target */</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">cnt</span> <span class="o">-=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">tgt_au_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">BITS_PER_AU</span> <span class="o">/</span> <span class="n">BITS_PER_BYTE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*apply force to make sure that the string table has null terminator */</span>
<span class="cp">#if (BITS_PER_AU == BITS_PER_BYTE) &amp;&amp; (TARGET_AU_BITS == BITS_PER_BYTE)</span>
	<span class="n">dst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/* little endian */</span>
	<span class="n">dst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">BITS_PER_AU</span> <span class="o">-</span> <span class="n">BITS_PER_BYTE</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* copy_tgt_strings */</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure init_module_handle</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	none</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Initializes the module handle we use to enable unloading, and installs</span>
<span class="cm"> * the debug information required by the target.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * The handle returned from dynamic_load_module needs to encapsulate all the</span>
<span class="cm"> * allocations done for the module, and enable them plus the modules symbols to</span>
<span class="cm"> * be deallocated.</span>
<span class="cm"> *</span>
<span class="cm"> *********************************************************************** */</span>
<span class="cp">#ifndef _BIG_ENDIAN</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="n">dllview_info_init</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;.dllview&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">(</span><span class="n">ldr_addr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">DBG_LIST_PAGE</span><span class="p">,</span> <span class="n">DLOAD_DATA</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="n">dllview_info_init</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;.dllview&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">(</span><span class="n">ldr_addr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">DLOAD_DATA</span><span class="p">,</span> <span class="n">DBG_LIST_PAGE</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_module_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">my_handle</span> <span class="o">*</span><span class="n">hndl</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">curr_sect</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="n">asecs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dll_module</span> <span class="o">*</span><span class="n">dbmod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dll_sect</span> <span class="o">*</span><span class="n">dbsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dbg_mirror_root</span> <span class="o">*</span><span class="n">mlist</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">modules_header</span> <span class="n">mhdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="n">dllview_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dynload_symbol</span> <span class="o">*</span><span class="n">debug_mirror_sym</span><span class="p">;</span>
	<span class="n">hndl</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myhandle</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hndl</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* must be errors detected, so forget it */</span>

	<span class="cm">/*  Store the section count */</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">secn_count</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">;</span>

	<span class="cm">/*  If a trampoline section was created, add it in */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sect_next_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">secn_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">secn_count</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">secn_count</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">secn_count</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifndef TARGET_ENDIANNESS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">big_e_target</span><span class="p">)</span>
		<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">secn_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* flag for big-endian */</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dload_errcount</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* abandon if errors detected */</span>
	<span class="cm">/* Locate the symbol that names the header for the CCS debug list</span>
<span class="cm">	   of modules. If not found, we just don&#39;t generate the debug record.</span>
<span class="cm">	   If found, we create our modules list.  We make sure to create the</span>
<span class="cm">	   loader_dllview_root even if there is no relocation info to record,</span>
<span class="cm">	   just to try to put both symbols in the same symbol table and</span>
<span class="cm">	   module. */</span>
	<span class="n">debug_mirror_sym</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">find_matching_symbol</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
							<span class="n">loader_dllview_root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_mirror_sym</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dynload_symbol</span> <span class="o">*</span><span class="n">dlmodsym</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dbg_mirror_root</span> <span class="o">*</span><span class="n">mlst</span><span class="p">;</span>

		<span class="cm">/* our root symbol is not yet present;</span>
<span class="cm">		   check if we have DLModules defined */</span>
		<span class="n">dlmodsym</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">find_matching_symbol</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
							<span class="n">LINKER_MODULES_HEADER</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlmodsym</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>	<span class="cm">/* no DLModules list so no debug info */</span>
		<span class="cm">/* if we have DLModules defined, construct our header */</span>
		<span class="n">mlst</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbg_mirror_root</span> <span class="o">*</span><span class="p">)</span>
		    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span>
						  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span>
							 <span class="n">dbg_mirror_root</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mlst</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DL_ERROR</span><span class="p">(</span><span class="n">err_alloc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dbg_mirror_root</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mlst</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mlst</span><span class="o">-&gt;</span><span class="n">changes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mlst</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mlst</span><span class="o">-&gt;</span><span class="n">dbthis</span> <span class="o">=</span> <span class="n">TDATA_TO_TADDR</span><span class="p">(</span><span class="n">dlmodsym</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
		<span class="cm">/* add our root symbol */</span>
		<span class="n">debug_mirror_sym</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">add_to_symbol_table</span>
		    <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">loader_dllview_root</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myhandle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_mirror_sym</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* failed, recover memory */</span>
			<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">mlst</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">debug_mirror_sym</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">mlst</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* First create the DLLview record and stuff it into the buffer.</span>
<span class="cm">	   Then write it to the DSP.  Record pertinent locations in our hndl,</span>
<span class="cm">	   and add it to the per-processor list of handles with debug info. */</span>
<span class="cp">#ifndef DEBUG_HEADER_IN_LOADER</span>
	<span class="n">mlist</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbg_mirror_root</span> <span class="o">*</span><span class="p">)</span><span class="n">debug_mirror_sym</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mlist</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">mlist</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbg_mirror_root</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">debug_list_header</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">mlist</span><span class="p">;</span>	<span class="cm">/* set pointer to root into our handle */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* no load addresses to be recorded */</span>
	<span class="cm">/* reuse temporary symbol storage */</span>
	<span class="n">dbmod</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dll_module</span> <span class="o">*</span><span class="p">)</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">local_symtab</span><span class="p">;</span>
	<span class="cm">/* Create the DLLview record in the memory we retain for our handle */</span>
	<span class="n">dbmod</span><span class="o">-&gt;</span><span class="n">num_sects</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">;</span>
	<span class="n">dbmod</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">verify</span><span class="p">.</span><span class="n">dv_timdat</span><span class="p">;</span>
	<span class="n">dbmod</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">INIT_VERSION</span><span class="p">;</span>
	<span class="n">dbmod</span><span class="o">-&gt;</span><span class="n">verification</span> <span class="o">=</span> <span class="n">VERIFICATION</span><span class="p">;</span>
	<span class="n">asecs</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">;</span>
	<span class="n">dbsec</span> <span class="o">=</span> <span class="n">dbmod</span><span class="o">-&gt;</span><span class="n">sects</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">curr_sect</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">allocated_secn_count</span><span class="p">;</span>
	     <span class="n">curr_sect</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">curr_sect</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbsec</span><span class="o">-&gt;</span><span class="n">sect_load_adr</span> <span class="o">=</span> <span class="n">asecs</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">;</span>
		<span class="n">dbsec</span><span class="o">-&gt;</span><span class="n">sect_run_adr</span> <span class="o">=</span> <span class="n">asecs</span><span class="o">-&gt;</span><span class="n">run_addr</span><span class="p">;</span>
		<span class="n">dbsec</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">asecs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  If a trampoline section was created go ahead and add its info */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sect_next_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbmod</span><span class="o">-&gt;</span><span class="n">num_sects</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dbsec</span><span class="o">-&gt;</span><span class="n">sect_load_adr</span> <span class="o">=</span> <span class="n">asecs</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">;</span>
		<span class="n">dbsec</span><span class="o">-&gt;</span><span class="n">sect_run_adr</span> <span class="o">=</span> <span class="n">asecs</span><span class="o">-&gt;</span><span class="n">run_addr</span><span class="p">;</span>
		<span class="n">dbsec</span><span class="o">++</span><span class="p">;</span>
		<span class="n">asecs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* now cram in the names */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">copy_tgt_strings</span><span class="p">(</span><span class="n">dbsec</span><span class="p">,</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_head</span><span class="p">,</span>
			      <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">debug_string_size</span><span class="p">);</span>

	<span class="cm">/* If a trampoline section was created, add its name so DLLView</span>
<span class="cm">	 * can show the user the section info. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">tramp_sect_next_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">copy_tgt_strings</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span>
				      <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">final_string_table</span><span class="p">,</span>
				      <span class="n">strlen</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">.</span><span class="n">final_string_table</span><span class="p">)</span> <span class="o">+</span>
				      <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* round off the size of the debug record, and remember same */</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbsiz</span> <span class="o">=</span> <span class="n">HOST_TO_TDATA_ROUND</span><span class="p">(</span><span class="n">cp</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dbmod</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* strictly to make our test harness happy */</span>
	<span class="n">dllview_info</span> <span class="o">=</span> <span class="n">dllview_info_init</span><span class="p">;</span>
	<span class="n">dllview_info</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">TDATA_TO_TADDR</span><span class="p">(</span><span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbsiz</span><span class="p">);</span>
	<span class="cm">/* Initialize memory context to default heap */</span>
	<span class="n">dllview_info</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* fill in next pointer and size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mlist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbmod</span><span class="o">-&gt;</span><span class="n">next_module</span> <span class="o">=</span> <span class="n">TADDR_TO_TDATA</span><span class="p">(</span><span class="n">mlist</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbthis</span><span class="p">);</span>
		<span class="n">dbmod</span><span class="o">-&gt;</span><span class="n">next_module_size</span> <span class="o">=</span> <span class="n">mlist</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbsiz</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dbmod</span><span class="o">-&gt;</span><span class="n">next_module_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dbmod</span><span class="o">-&gt;</span><span class="n">next_module</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* allocate memory for on-DSP DLLview debug record */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myalloc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myalloc</span><span class="o">-&gt;</span><span class="n">dload_allocate</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myalloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dllview_info</span><span class="p">,</span>
					     <span class="n">HOST_TO_TADDR</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Store load address of .dllview section */</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbthis</span> <span class="o">=</span> <span class="n">dllview_info</span><span class="p">.</span><span class="n">load_addr</span><span class="p">;</span>
	<span class="cm">/* Store memory context (segid) in which .dllview section</span>
<span class="cm">	 * was  allocated */</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">dllview_info</span><span class="p">.</span><span class="n">context</span><span class="p">;</span>
	<span class="n">mlist</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* swap bytes in the entire debug record, but not the string table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TARGET_ENDIANNESS_DIFFERS</span><span class="p">(</span><span class="n">TARGET_BIG_ENDIAN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">swap_words</span><span class="p">(</span><span class="n">dbmod</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dbsec</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dbmod</span><span class="p">,</span>
			   <span class="n">DLL_MODULE_BITMAP</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Update the DLLview list on the DSP write new record */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="o">-&gt;</span><span class="n">writemem</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="p">,</span> <span class="n">dbmod</span><span class="p">,</span>
				    <span class="n">dllview_info</span><span class="p">.</span><span class="n">load_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dllview_info</span><span class="p">,</span>
				    <span class="n">TADDR_TO_HOST</span><span class="p">(</span><span class="n">dllview_info</span><span class="p">.</span><span class="n">size</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* write new header */</span>
	<span class="n">mhdr</span><span class="p">.</span><span class="n">first_module_size</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbsiz</span><span class="p">;</span>
	<span class="n">mhdr</span><span class="p">.</span><span class="n">first_module</span> <span class="o">=</span> <span class="n">TADDR_TO_TDATA</span><span class="p">(</span><span class="n">dllview_info</span><span class="p">.</span><span class="n">load_addr</span><span class="p">);</span>
	<span class="cm">/* swap bytes in the module header, if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TARGET_ENDIANNESS_DIFFERS</span><span class="p">(</span><span class="n">TARGET_BIG_ENDIAN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">swap_words</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mhdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">modules_header</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">),</span>
			   <span class="n">MODULES_HEADER_BITMAP</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dllview_info</span> <span class="o">=</span> <span class="n">dllview_info_init</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="o">-&gt;</span><span class="n">writemem</span><span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">myio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mhdr</span><span class="p">,</span> <span class="n">mlist</span><span class="o">-&gt;</span><span class="n">dbthis</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">dllview_info</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">modules_header</span><span class="p">)</span> <span class="o">-</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Add the module handle to this processor&#39;s list</span>
<span class="cm">	   of handles with debug info */</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">mlist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>
		<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">hndl</span><span class="p">;</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_handle</span> <span class="o">*</span><span class="p">)</span><span class="n">mlist</span><span class="p">;</span>
	<span class="n">mlist</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">hndl</span><span class="p">;</span>	<span class="cm">/* insert after root */</span>
<span class="p">}</span>				<span class="cm">/* init_module_handle */</span>

<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure dynamic_unload_module</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	mhandle	A module handle from dynamic_load_module</span>
<span class="cm"> *	syms	Host-side symbol table and malloc/free functions</span>
<span class="cm"> *	alloc	Target-side memory allocation</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	The module specified by mhandle is unloaded.  Unloading causes all</span>
<span class="cm"> * target memory to be deallocated, all symbols defined by the module to</span>
<span class="cm"> * be purged, and any host-side storage used by the dynamic loader for</span>
<span class="cm"> * this module to be released.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	Zero for success. On error, the number of errors detected is returned.</span>
<span class="cm"> * Individual errors are reported using syms-&gt;error_report().</span>
<span class="cm"> *********************************************************************** */</span>
<span class="kt">int</span> <span class="nf">dynamic_unload_module</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mhandle</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dynamic_loader_sym</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dynamic_loader_allocate</span> <span class="o">*</span><span class="n">alloc</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dynamic_loader_initialize</span> <span class="o">*</span><span class="n">init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s16</span> <span class="n">curr_sect</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="o">*</span><span class="n">asecs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">my_handle</span> <span class="o">*</span><span class="n">hndl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dbg_mirror_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">errcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldr_section_info</span> <span class="n">dllview_info</span> <span class="o">=</span> <span class="n">dllview_info_init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">modules_header</span> <span class="n">mhdr</span><span class="p">;</span>

	<span class="n">hndl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_handle</span> <span class="o">*</span><span class="p">)</span><span class="n">mhandle</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hndl</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* if handle is null, nothing to do */</span>
	<span class="cm">/* Clear out the module symbols</span>
<span class="cm">	 * Note that if this is the module that defined MODULES_HEADER</span>
<span class="cm">	 (the head of the target debug list)</span>
<span class="cm">	 * then this operation will blow away that symbol.</span>
<span class="cm">	 It will therefore be impossible for subsequent</span>
<span class="cm">	 * operations to add entries to this un-referenceable list. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">syms</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">syms</span><span class="o">-&gt;</span><span class="n">purge_symbol_table</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">hndl</span><span class="p">);</span>
	<span class="cm">/* Deallocate target memory for sections</span>
<span class="cm">	 * NOTE: The trampoline section, if created, gets deleted here, too */</span>

	<span class="n">asecs</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">secns</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">curr_sect</span> <span class="o">=</span> <span class="p">(</span><span class="n">hndl</span><span class="o">-&gt;</span><span class="n">secn_count</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span> <span class="n">curr_sect</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">curr_sect</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asecs</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">alloc</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">alloc</span><span class="p">,</span> <span class="n">asecs</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">root</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* there is a debug list containing this module */</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbthis</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* target-side dllview record exists */</span>
		<span class="k">goto</span> <span class="n">loop_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Retrieve memory context in which .dllview was allocated */</span>
	<span class="n">dllview_info</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">context</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">prev</span> <span class="o">==</span> <span class="n">hndl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exitunltgt</span><span class="p">;</span>

	<span class="cm">/* target-side dllview record is in list */</span>
	<span class="cm">/* dequeue this record from our GPP-side mirror list */</span>
	<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>
		<span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
	<span class="cm">/* Update next_module of previous entry in target list</span>
<span class="cm">	 * We are using mhdr here as a surrogate for either a</span>
<span class="cm">	 struct modules_header or a dll_module */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mhdr</span><span class="p">.</span><span class="n">first_module</span> <span class="o">=</span> <span class="n">TADDR_TO_TDATA</span><span class="p">(</span><span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbthis</span><span class="p">);</span>
		<span class="n">mhdr</span><span class="p">.</span><span class="n">first_module_size</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbsiz</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mhdr</span><span class="p">.</span><span class="n">first_module</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mhdr</span><span class="p">.</span><span class="n">first_module_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exitunltgt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">connect</span><span class="p">(</span><span class="n">init</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dload_syms_error</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">iconnect</span><span class="p">);</span>
		<span class="n">errcount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exitunltgt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* swap bytes in the module header, if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TARGET_ENDIANNESS_DIFFERS</span><span class="p">(</span><span class="n">hndl</span><span class="o">-&gt;</span><span class="n">secn_count</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">swap_words</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mhdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">modules_header</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">),</span>
			   <span class="n">MODULES_HEADER_BITMAP</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">writemem</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mhdr</span><span class="p">,</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbthis</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">dllview_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">modules_header</span><span class="p">)</span> <span class="o">-</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">mhdr</span><span class="p">.</span><span class="n">update_flag</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dload_syms_error</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">dlvwrite</span><span class="p">);</span>
		<span class="n">errcount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* update change counter */</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">changes</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">writemem</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">changes</span><span class="p">),</span>
			    <span class="n">root</span><span class="o">-&gt;</span><span class="n">dbthis</span> <span class="o">+</span> <span class="n">HOST_TO_TADDR</span>
			    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mhdr</span><span class="p">.</span><span class="n">first_module</span><span class="p">)</span> <span class="o">+</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="n">mhdr</span><span class="p">.</span><span class="n">first_module_size</span><span class="p">)),</span>
			    <span class="o">&amp;</span><span class="n">dllview_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mhdr</span><span class="p">.</span><span class="n">update_flag</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dload_syms_error</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">dlvwrite</span><span class="p">);</span>
		<span class="n">errcount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">init</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">init</span><span class="p">);</span>
<span class="nl">exitunltgt:</span>
	<span class="cm">/* release target storage */</span>
	<span class="n">dllview_info</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">TDATA_TO_TADDR</span><span class="p">(</span><span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbsiz</span><span class="p">);</span>
	<span class="n">dllview_info</span><span class="p">.</span><span class="n">load_addr</span> <span class="o">=</span> <span class="n">hndl</span><span class="o">-&gt;</span><span class="n">dm</span><span class="p">.</span><span class="n">dbthis</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
		<span class="n">alloc</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">alloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dllview_info</span><span class="p">);</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* target-side dllview record exists */</span>
<span class="nl">loop_end:</span>
<span class="cp">#ifndef DEBUG_HEADER_IN_LOADER</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if all references gone, blow off the header */</span>
		<span class="cm">/* our root symbol may be gone due to the Purge above,</span>
<span class="cm">		   but if not, do not destroy the root */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">syms</span><span class="o">-&gt;</span><span class="n">find_matching_symbol</span>
		    <span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">loader_dllview_root</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">syms</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="nl">func_end:</span>
	<span class="cm">/* there is a debug list containing this module */</span>
	<span class="n">syms</span><span class="o">-&gt;</span><span class="n">dload_deallocate</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">mhandle</span><span class="p">);</span>	<span class="cm">/* release our storage */</span>
	<span class="k">return</span> <span class="n">errcount</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* dynamic_unload_module */</span>

<span class="cp">#if BITS_PER_AU &gt; BITS_PER_BYTE</span>
<span class="cm">/*************************************************************************</span>
<span class="cm"> * Procedure unpack_name</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	soffset	Byte offset into the string table</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Returns a pointer to the string specified by the offset supplied, or</span>
<span class="cm"> * NULL for error.</span>
<span class="cm"> *</span>
<span class="cm"> *********************************************************************** */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">unpack_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">u32</span> <span class="n">soffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">soffset</span> <span class="o">&gt;=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_strtab_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Bad string table offset &quot;</span> <span class="n">FMT_UI32</span><span class="p">,</span>
			    <span class="n">soffset</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint_least8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_head</span> <span class="o">+</span>
	    <span class="p">(</span><span class="n">soffset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">LOG_BITS_PER_AU</span> <span class="o">-</span> <span class="n">LOG_BITS_PER_BYTE</span><span class="p">));</span>
	<span class="n">dst</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_temp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">soffset</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* only 1 character in first word */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="n">BITS_PER_BYTE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="o">++</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BYTE_MASK</span><span class="p">));</span>
	<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">temp_len</span> <span class="o">=</span> <span class="n">dst</span> <span class="o">-</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_temp</span><span class="p">;</span>
	<span class="cm">/* squirrel away length including terminating null */</span>
	<span class="k">return</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">str_temp</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* unpack_name */</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
