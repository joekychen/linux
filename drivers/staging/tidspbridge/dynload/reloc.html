<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › dynload › reloc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>reloc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * reloc.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;header.h&quot;</span>

<span class="cp">#if TMS32060</span>
<span class="cm">/* the magic symbol for the start of BSS */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">bsssymbol</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;.bss&quot;</span> <span class="p">};</span>
<span class="cp">#endif</span>

<span class="cp">#if TMS32060</span>
<span class="cp">#include &quot;reloc_table_c6000.c&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if TMS32060</span>
<span class="cm">/* From coff.h - ignore these relocation operations */</span>
<span class="cp">#define R_C60ALIGN     0x76	</span><span class="cm">/* C60: Alignment info for compressor */</span><span class="cp"></span>
<span class="cp">#define R_C60FPHEAD    0x77	</span><span class="cm">/* C60: Explicit assembly directive */</span><span class="cp"></span>
<span class="cp">#define R_C60NOCMP    0x100	</span><span class="cm">/* C60: Don&#39;t compress this code scn */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> * Procedure dload_unpack</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	data	pointer to storage unit containing lowest host address of</span>
<span class="cm"> *		image data</span>
<span class="cm"> *	fieldsz	Size of bit field, 0 &lt; fieldsz &lt;= sizeof(rvalue)*BITS_PER_AU</span>
<span class="cm"> *	offset	Offset from LSB, 0 &lt;= offset &lt; BITS_PER_AU</span>
<span class="cm"> *	sgn	Signedness of the field (ROP_SGN, ROP_UNS, ROP_MAX, ROP_ANY)</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Extracts the specified field and returns it.</span>
<span class="cm"> ************************************************************************* */</span>
<span class="n">rvalue</span> <span class="nf">dload_unpack</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">tgt_au_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fieldsz</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">sgn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="n">rvalue</span> <span class="n">objval</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">,</span> <span class="n">direction</span><span class="p">;</span>
	<span class="k">register</span> <span class="n">tgt_au_t</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">fieldsz</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* avoid nastiness with 32-bit shift of 32-bit value */</span>
	<span class="cm">/* * collect up enough bits to contain the desired field */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TARGET_BIG_ENDIAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dp</span> <span class="o">+=</span> <span class="p">(</span><span class="n">fieldsz</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">LOG_TGTAU_BITS</span><span class="p">;</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">objval</span> <span class="o">=</span> <span class="o">*</span><span class="n">dp</span> <span class="o">&gt;&gt;</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="n">TGTAU_BITS</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;=</span> <span class="n">fieldsz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dp</span> <span class="o">+=</span> <span class="n">direction</span><span class="p">;</span>
		<span class="n">objval</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rvalue</span><span class="p">)</span> <span class="o">*</span><span class="n">dp</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="n">shift</span> <span class="o">+=</span> <span class="n">TGTAU_BITS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* * sign or zero extend the value appropriately */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sgn</span> <span class="o">==</span> <span class="n">ROP_UNS</span><span class="p">)</span>
		<span class="n">objval</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">fieldsz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rvalue</span><span class="p">)</span> <span class="o">*</span> <span class="n">BITS_PER_AU</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fieldsz</span><span class="p">;</span>
		<span class="n">objval</span> <span class="o">=</span> <span class="p">(</span><span class="n">objval</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">objval</span><span class="p">;</span>

<span class="p">}</span>				<span class="cm">/* dload_unpack */</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> * Procedure dload_repack</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	val		Value to insert</span>
<span class="cm"> *	data	Pointer to storage unit containing lowest host address of</span>
<span class="cm"> * 		image data</span>
<span class="cm"> *	fieldsz	Size of bit field, 0 &lt; fieldsz &lt;= sizeof(rvalue)*BITS_PER_AU</span>
<span class="cm"> *	offset	Offset from LSB, 0 &lt;= offset &lt; BITS_PER_AU</span>
<span class="cm"> *	sgn	Signedness of the field (ROP_SGN, ROP_UNS, ROP_MAX, ROP_ANY)</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Stuffs the specified value in the specified field.  Returns 0 for</span>
<span class="cm"> *	success</span>
<span class="cm"> * or 1 if the value will not fit in the specified field according to the</span>
<span class="cm"> * specified signedness rule.</span>
<span class="cm"> ************************************************************************* */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ovf_limit</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">dload_repack</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">rvalue</span> <span class="n">val</span><span class="p">,</span> <span class="n">tgt_au_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">fieldsz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">sgn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="n">urvalue</span> <span class="n">objval</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">,</span> <span class="n">direction</span><span class="p">;</span>
	<span class="k">register</span> <span class="n">tgt_au_t</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">fieldsz</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* avoid nastiness with 32-bit shift of 32-bit value */</span>
	<span class="cm">/* clip the bits */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2UL</span> <span class="o">&lt;&lt;</span> <span class="n">fieldsz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">objval</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
	<span class="cm">/* * store the bits through the specified mask */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TARGET_BIG_ENDIAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dp</span> <span class="o">+=</span> <span class="p">(</span><span class="n">fieldsz</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">LOG_TGTAU_BITS</span><span class="p">;</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* insert LSBs */</span>
	<span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">objval</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="n">TGTAU_BITS</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="cm">/* align mask and objval with AU boundary */</span>
	<span class="n">objval</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dp</span> <span class="o">+=</span> <span class="n">direction</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">+</span> <span class="n">objval</span><span class="p">;</span>
		<span class="n">objval</span> <span class="o">&gt;&gt;=</span> <span class="n">TGTAU_BITS</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="n">TGTAU_BITS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check for overflow</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sgn</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">fieldsz</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">sgn</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">ovf_limit</span><span class="p">[</span><span class="n">sgn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>				<span class="cm">/* dload_repack */</span>

<span class="cm">/* lookup table for the scaling amount in a C6x instruction */</span>
<span class="cp">#if TMS32060</span>
<span class="cp">#define SCALE_BITS 4		</span><span class="cm">/* there are 4 bits in the scale field */</span><span class="cp"></span>
<span class="cp">#define SCALE_MASK 0x7		</span><span class="cm">/* we really only use the bottom 3 bits */</span><span class="cp"></span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">c60_scale</span><span class="p">[</span><span class="n">SCALE_MASK</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> * Procedure dload_relocate</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	data	Pointer to base of image data</span>
<span class="cm"> *	rp		Pointer to relocation operation</span>
<span class="cm"> *</span>
<span class="cm"> * Effect:</span>
<span class="cm"> *	Performs the specified relocation operation</span>
<span class="cm"> ************************************************************************* */</span>
<span class="kt">void</span> <span class="nf">dload_relocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dload_state</span> <span class="o">*</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">tgt_au_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">reloc_record_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">tramps_generated</span><span class="p">,</span>
		    <span class="n">bool</span> <span class="n">second_pass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rvalue</span> <span class="n">val</span><span class="p">,</span> <span class="n">reloc_amt</span><span class="p">,</span> <span class="n">orig_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fieldsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reloc_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reloc_action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rvalue</span> <span class="o">*</span><span class="n">stackp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">top</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">local_symbol</span> <span class="o">*</span><span class="n">svp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef RFV_SCALE</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">image_packet_t</span> <span class="o">*</span><span class="n">img_pkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* The image packet data struct is only used during first pass</span>
<span class="cm">	 * relocation in the event that a trampoline is needed.  2nd pass</span>
<span class="cm">	 * relocation doesn&#39;t guarantee that data is coming from an</span>
<span class="cm">	 * image_packet_t structure. See cload.c, dload_data for how img_data is</span>
<span class="cm">	 * set. If that changes this needs to be updated!!! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">second_pass</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
		<span class="n">img_pkt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">image_packet_t</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span> <span class="o">-</span>
						    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span>
							   <span class="n">image_packet_t</span><span class="p">));</span>

	<span class="n">rx</span> <span class="o">=</span> <span class="n">HASH_FUNC</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">TYPE</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rop_map1</span><span class="p">[</span><span class="n">rx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">TYPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx</span> <span class="o">=</span> <span class="n">HASH_L</span><span class="p">(</span><span class="n">rop_map2</span><span class="p">[</span><span class="n">rx</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if TMS32060</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">TYPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">R_C60ALIGN</span>:
			<span class="k">case</span> <span class="n">R_C60NOCMP</span>:
			<span class="k">case</span> <span class="n">R_C60FPHEAD</span>:
				<span class="cm">/* Ignore these reloc types and return */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="cm">/* Unknown reloc type, print error and return */</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Bad coff operator 0x%x&quot;</span><span class="p">,</span>
					    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">TYPE</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#else</span>
			<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Bad coff operator 0x%x&quot;</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">TYPE</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rx</span> <span class="o">=</span> <span class="n">HASH_I</span><span class="p">(</span><span class="n">rop_map2</span><span class="p">[</span><span class="n">rx</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rx</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rop_action</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)))</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rx</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rop_info</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reloc_action</span> <span class="o">=</span> <span class="n">rop_action</span><span class="p">[</span><span class="n">rx</span><span class="p">];</span>
		<span class="n">reloc_info</span> <span class="o">=</span> <span class="n">rop_info</span><span class="p">[</span><span class="n">rx</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Buffer Overflow - Array Index Out &quot;</span>
			    <span class="s">&quot;of Bounds&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Compute the relocation amount for the referenced symbol, if any */</span>
	<span class="n">reloc_amt</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">UVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RFV_SYM</span><span class="p">(</span><span class="n">reloc_info</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* relocation uses a symbol reference */</span>
		<span class="cm">/* If this is first pass, use the module local symbol table,</span>
<span class="cm">		 * else use the trampoline symbol table. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">second_pass</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">SYMNDX</span> <span class="o">&lt;</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">dfile_hdr</span><span class="p">.</span><span class="n">df_no_syms</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* real symbol reference */</span>
				<span class="n">svp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">local_symtab</span><span class="p">[</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SYMNDX</span><span class="p">];</span>
				<span class="n">reloc_amt</span> <span class="o">=</span> <span class="p">(</span><span class="n">RFV_SYM</span><span class="p">(</span><span class="n">reloc_info</span><span class="p">)</span> <span class="o">==</span> <span class="n">ROP_SYMD</span><span class="p">)</span> <span class="o">?</span>
				    <span class="n">svp</span><span class="o">-&gt;</span><span class="n">delta</span> <span class="o">:</span> <span class="n">svp</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* reloc references current section */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SYMNDX</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reloc_amt</span> <span class="o">=</span> <span class="p">(</span><span class="n">RFV_SYM</span><span class="p">(</span><span class="n">reloc_info</span><span class="p">)</span> <span class="o">==</span> <span class="n">ROP_SYMD</span><span class="p">)</span> <span class="o">?</span>
				    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">delta_runaddr</span> <span class="o">:</span>
				    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="o">-&gt;</span><span class="n">run_addr</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* relocation uses a symbol reference */</span>
	<span class="cm">/* Handle stack adjustment */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">top</span> <span class="o">=</span> <span class="n">RFV_STK</span><span class="p">(</span><span class="n">reloc_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">top</span> <span class="o">+=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">relstkidx</span> <span class="o">-</span> <span class="n">RSTK_UOP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">top</span> <span class="o">&gt;=</span> <span class="n">STATIC_EXPR_STK_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
				    <span class="s">&quot;Expression stack overflow in %s at offset &quot;</span>
				    <span class="n">FMT_UI32</span><span class="p">,</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">relstk</span><span class="p">[</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">relstkidx</span><span class="p">];</span>
		<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">relstkidx</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
		<span class="n">stackp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">relstk</span><span class="p">[</span><span class="n">top</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="cm">/* Derive field position and size, if we need them */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reloc_info</span> <span class="o">&amp;</span> <span class="n">ROP_RW</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* read or write action in our future */</span>
		<span class="n">fieldsz</span> <span class="o">=</span> <span class="n">RFV_WIDTH</span><span class="p">(</span><span class="n">reloc_action</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fieldsz</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* field info from table */</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">RFV_POSN</span><span class="p">(</span><span class="n">reloc_action</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TARGET_BIG_ENDIAN</span><span class="p">)</span>
				<span class="cm">/* make sure vaddr is the lowest target</span>
<span class="cm">				 * address containing bits */</span>
				<span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+=</span> <span class="n">RFV_BIGOFF</span><span class="p">(</span><span class="n">reloc_info</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* field info from relocation op */</span>
			<span class="n">fieldsz</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">FIELDSZ</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">OFFSET</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TARGET_BIG_ENDIAN</span><span class="p">)</span>
				<span class="cm">/* make sure vaddr is the lowest target</span>
<span class="cm">				   address containing bits */</span>
				<span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">WORDSZ</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">fieldsz</span><span class="p">)</span>
				    <span class="o">&gt;&gt;</span> <span class="n">LOG_TARGET_AU_BITS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">tgt_au_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span> <span class="o">+</span> <span class="n">TADDR_TO_HOST</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">));</span>
		<span class="cm">/* compute lowest host location of referenced data */</span>
<span class="cp">#if BITS_PER_AU &gt; TARGET_AU_BITS</span>
		<span class="cm">/* conversion from target address to host address may lose</span>
<span class="cm">		   address bits; add loss to offset */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TARGET_BIG_ENDIAN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="o">-</span><span class="p">((</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">&lt;&lt;</span> <span class="n">LOG_TARGET_AU_BITS</span><span class="p">)</span> <span class="o">+</span>
				    <span class="n">offset</span> <span class="o">+</span> <span class="n">fieldsz</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="p">(</span><span class="n">BITS_PER_AU</span> <span class="o">-</span> <span class="n">TARGET_AU_BITS</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">&lt;&lt;</span> <span class="n">LOG_TARGET_AU_BITS</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="p">(</span><span class="n">BITS_PER_AU</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef RFV_SCALE</span>
		<span class="n">scale</span> <span class="o">=</span> <span class="n">RFV_SCALE</span><span class="p">(</span><span class="n">reloc_info</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="cm">/* read the object value from the current image, if so ordered */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reloc_info</span> <span class="o">&amp;</span> <span class="n">ROP_R</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* relocation reads current image value */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">dload_unpack</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fieldsz</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				   <span class="n">RFV_SIGN</span><span class="p">(</span><span class="n">reloc_info</span><span class="p">));</span>
		<span class="cm">/* Save off the original value in case the relo overflows and</span>
<span class="cm">		 * we can trampoline it. */</span>
		<span class="n">orig_val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

<span class="cp">#ifdef RFV_SCALE</span>
		<span class="n">val</span> <span class="o">&lt;&lt;=</span> <span class="n">scale</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="cm">/* perform the necessary arithmetic */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">RFV_ACTION</span><span class="p">(</span><span class="n">reloc_action</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* relocation actions */</span>
	<span class="k">case</span> <span class="n">RACT_VAL</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_ASGN</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">reloc_amt</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_ADD</span>:
		<span class="n">val</span> <span class="o">+=</span> <span class="n">reloc_amt</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_PCR</span>:
		<span class="cm">/*-----------------------------------------------------------</span>
<span class="cm">		 * Handle special cases of jumping from absolute sections</span>
<span class="cm">		 * (special reloc type) or to absolute destination</span>
<span class="cm">		 * (symndx == -1).  In either case, set the appropriate</span>
<span class="cm">		 * relocation amount to 0.</span>
<span class="cm">		 *----------------------------------------------------------- */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SYMNDX</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">reloc_amt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">reloc_amt</span> <span class="o">-</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">delta_runaddr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_ADDISP</span>:
		<span class="n">val</span> <span class="o">+=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">R_DISP</span> <span class="o">+</span> <span class="n">reloc_amt</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_ASGPC</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="o">-&gt;</span><span class="n">run_addr</span> <span class="o">+</span> <span class="n">reloc_amt</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_PLUS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">+=</span> <span class="o">*</span><span class="n">stackp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_SUB</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">stackp</span> <span class="o">-</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_NEG</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_MPY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">*=</span> <span class="o">*</span><span class="n">stackp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_DIV</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">stackp</span> <span class="o">/</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_MOD</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">stackp</span> <span class="o">%</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_SR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rvalue</span><span class="p">)</span> <span class="o">*</span> <span class="n">BITS_PER_AU</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">urvalue</span><span class="p">)</span> <span class="o">*</span><span class="n">stackp</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_ASR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rvalue</span><span class="p">)</span> <span class="o">*</span> <span class="n">BITS_PER_AU</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rvalue</span><span class="p">)</span> <span class="o">*</span> <span class="n">BITS_PER_AU</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">stackp</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_SL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rvalue</span><span class="p">)</span> <span class="o">*</span> <span class="n">BITS_PER_AU</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">stackp</span> <span class="o">&lt;&lt;</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_AND</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">*</span><span class="n">stackp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_OR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="o">*</span><span class="n">stackp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_XOR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">^=</span> <span class="o">*</span><span class="n">stackp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RACT_NOT</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="o">~</span><span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if TMS32060</span>
	<span class="k">case</span> <span class="n">RACT_C6SECT</span>:
		<span class="cm">/* actually needed address of secn containing symbol */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">svp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">SYMNDX</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">svp</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">reloc_amt</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span>
					    <span class="p">[</span><span class="n">svp</span><span class="o">-&gt;</span><span class="n">secnn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">run_addr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* !!! FALL THRU !!! */</span>
	<span class="k">case</span> <span class="n">RACT_C6BASE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">bss_run_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dynload_symbol</span> <span class="o">*</span><span class="n">symp</span><span class="p">;</span>
			<span class="n">symp</span> <span class="o">=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="o">-&gt;</span><span class="n">find_matching_symbol</span>
			    <span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">mysym</span><span class="p">,</span> <span class="n">bsssymbol</span><span class="p">);</span>
			<span class="cm">/* lookup value of global BSS base */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">symp</span><span class="p">)</span>
				<span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">bss_run_base</span> <span class="o">=</span> <span class="n">symp</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
					    <span class="s">&quot;Global BSS base referenced in %s &quot;</span>
					    <span class="s">&quot;offset&quot;</span> <span class="n">FMT_UI32</span> <span class="s">&quot; but not &quot;</span>
					    <span class="s">&quot;defined&quot;</span><span class="p">,</span>
					    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">reloc_amt</span> <span class="o">-=</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">bss_run_base</span><span class="p">;</span>
		<span class="cm">/* !!! FALL THRU !!! */</span>
	<span class="k">case</span> <span class="n">RACT_C6DSPL</span>:
		<span class="cm">/* scale factor determined by 3 LSBs of field */</span>
		<span class="n">scale</span> <span class="o">=</span> <span class="n">c60_scale</span><span class="p">[</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SCALE_MASK</span><span class="p">];</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">SCALE_BITS</span><span class="p">;</span>
		<span class="n">fieldsz</span> <span class="o">-=</span> <span class="n">SCALE_BITS</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">&gt;&gt;=</span> <span class="n">SCALE_BITS</span><span class="p">;</span>	<span class="cm">/* ignore the scale field hereafter */</span>
		<span class="n">val</span> <span class="o">&lt;&lt;=</span> <span class="n">scale</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">reloc_amt</span><span class="p">;</span>	<span class="cm">/* do the usual relocation */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">scale</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
			<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
				    <span class="s">&quot;Unaligned reference in %s offset &quot;</span>
				    <span class="n">FMT_UI32</span><span class="p">,</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>			<span class="cm">/* relocation actions */</span>
	<span class="cm">/* * Put back result as required */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reloc_info</span> <span class="o">&amp;</span> <span class="n">ROP_W</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* relocation writes image value */</span>
<span class="cp">#ifdef RFV_SCALE</span>
		<span class="n">val</span> <span class="o">&gt;&gt;=</span> <span class="n">scale</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dload_repack</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fieldsz</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				 <span class="n">RFV_SIGN</span><span class="p">(</span><span class="n">reloc_info</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Check to see if this relo can be trampolined,</span>
<span class="cm">			 * but only in first phase relocation.  2nd phase</span>
<span class="cm">			 * relocation cannot trampoline. */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">second_pass</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">dload_tramp_avail</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">rp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">true</span><span class="p">))</span> <span class="p">{</span>

				<span class="cm">/* Before generating the trampoline, restore</span>
<span class="cm">				 * the value to its original so the 2nd pass</span>
<span class="cm">				 *  relo will work. */</span>
				<span class="n">dload_repack</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="n">orig_val</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fieldsz</span><span class="p">,</span>
					     <span class="n">offset</span><span class="p">,</span> <span class="n">RFV_SIGN</span><span class="p">(</span><span class="n">reloc_info</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dload_tramp_generate</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
							<span class="p">(</span><span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span> <span class="o">-</span>
							 <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">ldr_sections</span><span class="p">),</span>
							 <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span><span class="p">,</span>
							 <span class="n">img_pkt</span><span class="p">,</span> <span class="n">rp</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
						    <span class="s">&quot;Failed to &quot;</span>
						    <span class="s">&quot;generate trampoline for &quot;</span>
						    <span class="s">&quot;bit overflow&quot;</span><span class="p">);</span>
					<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span>
						    <span class="s">&quot;Relocation val &quot;</span> <span class="n">FMT_UI32</span>
						    <span class="s">&quot; overflows %d bits in %s &quot;</span>
						    <span class="s">&quot;offset &quot;</span> <span class="n">FMT_UI32</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
						    <span class="n">fieldsz</span><span class="p">,</span>
						    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span> <span class="o">+</span>
						    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="o">*</span><span class="n">tramps_generated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dload_error</span><span class="p">(</span><span class="n">dlthis</span><span class="p">,</span> <span class="s">&quot;Relocation value &quot;</span>
					    <span class="n">FMT_UI32</span> <span class="s">&quot; overflows %d bits in %s&quot;</span>
					    <span class="s">&quot; offset &quot;</span> <span class="n">FMT_UI32</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">fieldsz</span><span class="p">,</span>
					    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_secn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					    <span class="n">dlthis</span><span class="o">-&gt;</span><span class="n">image_offset</span> <span class="o">+</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">top</span><span class="p">)</span>
		<span class="o">*</span><span class="n">stackp</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* reloc_value */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
