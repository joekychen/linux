<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › hw › hw_mmu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>hw_mmu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * hw_mmu.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * API definitions to setup MMU TLB and PTE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &quot;MMURegAcM.h&quot;</span>
<span class="cp">#include &lt;hw_defs.h&gt;</span>
<span class="cp">#include &lt;hw_mmu.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>

<span class="cp">#define MMU_BASE_VAL_MASK	0xFC00</span>
<span class="cp">#define MMU_PAGE_MAX	     3</span>
<span class="cp">#define MMU_ELEMENTSIZE_MAX      3</span>
<span class="cp">#define MMU_ADDR_MASK	    0xFFFFF000</span>
<span class="cp">#define MMU_TTB_MASK	     0xFFFFC000</span>
<span class="cp">#define MMU_SECTION_ADDR_MASK    0xFFF00000</span>
<span class="cp">#define MMU_SSECTION_ADDR_MASK   0xFF000000</span>
<span class="cp">#define MMU_PAGE_TABLE_MASK      0xFFFFFC00</span>
<span class="cp">#define MMU_LARGE_PAGE_MASK      0xFFFF0000</span>
<span class="cp">#define MMU_SMALL_PAGE_MASK      0xFFFFF000</span>

<span class="cp">#define MMU_LOAD_TLB	0x00000001</span>
<span class="cp">#define MMU_GFLUSH	0x60</span>

<span class="cm">/*</span>
<span class="cm"> * hw_mmu_page_size_t: Enumerated Type used to specify the MMU Page Size(SLSS)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">hw_mmu_page_size_t</span> <span class="p">{</span>
	<span class="n">HW_MMU_SECTION</span><span class="p">,</span>
	<span class="n">HW_MMU_LARGE_PAGE</span><span class="p">,</span>
	<span class="n">HW_MMU_SMALL_PAGE</span><span class="p">,</span>
	<span class="n">HW_MMU_SUPERSECTION</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * FUNCTION	      : mmu_flush_entry</span>
<span class="cm"> *</span>
<span class="cm"> * INPUTS:</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : base_address</span>
<span class="cm"> *       Type		: const u32</span>
<span class="cm"> *       Description     : Base Address of instance of MMU module</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> *</span>
<span class="cm"> *       Type		: hw_status</span>
<span class="cm"> *       Description     : 0		 -- No errors occurred</span>
<span class="cm"> *			 RET_BAD_NULL_PARAM     -- A Pointer</span>
<span class="cm"> *						Paramater was set to NULL</span>
<span class="cm"> *</span>
<span class="cm"> * PURPOSE:	      : Flush the TLB entry pointed by the</span>
<span class="cm"> *			lock counter register</span>
<span class="cm"> *			even if this entry is set protected</span>
<span class="cm"> *</span>
<span class="cm"> * METHOD:	       : Check the Input parameter and Flush a</span>
<span class="cm"> *			 single entry in the TLB.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">hw_status</span> <span class="n">mmu_flush_entry</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * FUNCTION	      : mmu_set_cam_entry</span>
<span class="cm"> *</span>
<span class="cm"> * INPUTS:</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : base_address</span>
<span class="cm"> *       TypE		: const u32</span>
<span class="cm"> *       Description     : Base Address of instance of MMU module</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : page_sz</span>
<span class="cm"> *       TypE		: const u32</span>
<span class="cm"> *       Description     : It indicates the page size</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : preserved_bit</span>
<span class="cm"> *       Type		: const u32</span>
<span class="cm"> *       Description     : It indicates the TLB entry is preserved entry</span>
<span class="cm"> *							or not</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : valid_bit</span>
<span class="cm"> *       Type		: const u32</span>
<span class="cm"> *       Description     : It indicates the TLB entry is valid entry or not</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : virtual_addr_tag</span>
<span class="cm"> *       Type	    	: const u32</span>
<span class="cm"> *       Description     : virtual Address</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> *</span>
<span class="cm"> *       Type	    	: hw_status</span>
<span class="cm"> *       Description     : 0		 -- No errors occurred</span>
<span class="cm"> *			 RET_BAD_NULL_PARAM     -- A Pointer Paramater</span>
<span class="cm"> *						   was set to NULL</span>
<span class="cm"> *			 RET_PARAM_OUT_OF_RANGE -- Input Parameter out</span>
<span class="cm"> *						   of Range</span>
<span class="cm"> *</span>
<span class="cm"> * PURPOSE:	      	: Set MMU_CAM reg</span>
<span class="cm"> *</span>
<span class="cm"> * METHOD:	       	: Check the Input parameters and set the CAM entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">hw_status</span> <span class="n">mmu_set_cam_entry</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u32</span> <span class="n">page_sz</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u32</span> <span class="n">preserved_bit</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u32</span> <span class="n">valid_bit</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u32</span> <span class="n">virtual_addr_tag</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * FUNCTION	      : mmu_set_ram_entry</span>
<span class="cm"> *</span>
<span class="cm"> * INPUTS:</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : base_address</span>
<span class="cm"> *       Type	    	: const u32</span>
<span class="cm"> *       Description     : Base Address of instance of MMU module</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : physical_addr</span>
<span class="cm"> *       Type	    	: const u32</span>
<span class="cm"> *       Description     : Physical Address to which the corresponding</span>
<span class="cm"> *			 virtual   Address shouldpoint</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : endianism</span>
<span class="cm"> *       Type	    	: hw_endianism_t</span>
<span class="cm"> *       Description     : endianism for the given page</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : element_size</span>
<span class="cm"> *       Type	    	: hw_element_size_t</span>
<span class="cm"> *       Description     : The element size ( 8,16, 32 or 64 bit)</span>
<span class="cm"> *</span>
<span class="cm"> *       Identifier      : mixed_size</span>
<span class="cm"> *       Type	    	: hw_mmu_mixed_size_t</span>
<span class="cm"> *       Description     : Element Size to follow CPU or TLB</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> *</span>
<span class="cm"> *       Type	    	: hw_status</span>
<span class="cm"> *       Description     : 0		 -- No errors occurred</span>
<span class="cm"> *			 RET_BAD_NULL_PARAM     -- A Pointer Paramater</span>
<span class="cm"> *							was set to NULL</span>
<span class="cm"> *			 RET_PARAM_OUT_OF_RANGE -- Input Parameter</span>
<span class="cm"> *							out of Range</span>
<span class="cm"> *</span>
<span class="cm"> * PURPOSE:	      : Set MMU_CAM reg</span>
<span class="cm"> *</span>
<span class="cm"> * METHOD:	       : Check the Input parameters and set the RAM entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">hw_status</span> <span class="n">mmu_set_ram_entry</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u32</span> <span class="n">physical_addr</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">hw_endianism_t</span> <span class="n">endianism</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">hw_element_size_t</span> <span class="n">element_size</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">hw_mmu_mixed_size_t</span> <span class="n">mixed_size</span><span class="p">);</span>

<span class="cm">/* HW FUNCTIONS */</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_enable</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">MMUMMU_CNTLMMU_ENABLE_WRITE32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">HW_SET</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_disable</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">MMUMMU_CNTLMMU_ENABLE_WRITE32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">HW_CLEAR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_num_locked_set</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">num_locked_entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">MMUMMU_LOCK_BASE_VALUE_WRITE32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">num_locked_entries</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_victim_num_set</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">victim_entry_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">MMUMMU_LOCK_CURRENT_VICTIM_WRITE32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">victim_entry_num</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_event_ack</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">irq_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">MMUMMU_IRQSTATUS_WRITE_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">irq_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_event_disable</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">irq_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_reg</span><span class="p">;</span>

	<span class="n">irq_reg</span> <span class="o">=</span> <span class="n">MMUMMU_IRQENABLE_READ_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">);</span>

	<span class="n">MMUMMU_IRQENABLE_WRITE_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">irq_reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">irq_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_event_enable</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">irq_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_reg</span><span class="p">;</span>

	<span class="n">irq_reg</span> <span class="o">=</span> <span class="n">MMUMMU_IRQENABLE_READ_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">);</span>

	<span class="n">MMUMMU_IRQENABLE_WRITE_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">irq_reg</span> <span class="o">|</span> <span class="n">irq_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_event_status</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">irq_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">irq_mask</span> <span class="o">=</span> <span class="n">MMUMMU_IRQSTATUS_READ_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_fault_addr_read</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* read values from register */</span>
	<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">MMUMMU_FAULT_AD_READ_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_ttb_set</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ttb_phys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">load_ttb</span><span class="p">;</span>

	<span class="n">load_ttb</span> <span class="o">=</span> <span class="n">ttb_phys_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x7FUL</span><span class="p">;</span>
	<span class="cm">/* write values to register */</span>
	<span class="n">MMUMMU_TTB_WRITE_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">load_ttb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_twl_enable</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">MMUMMU_CNTLTWL_ENABLE_WRITE32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">HW_SET</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_twl_disable</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">MMUMMU_CNTLTWL_ENABLE_WRITE32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">HW_CLEAR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_tlb_flush</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">virtual_addr</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">page_sz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">virtual_addr_tag</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">hw_mmu_page_size_t</span> <span class="n">pg_size_bits</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">page_sz</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HW_PAGE_SIZE4KB</span>:
		<span class="n">pg_size_bits</span> <span class="o">=</span> <span class="n">HW_MMU_SMALL_PAGE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE64KB</span>:
		<span class="n">pg_size_bits</span> <span class="o">=</span> <span class="n">HW_MMU_LARGE_PAGE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE1MB</span>:
		<span class="n">pg_size_bits</span> <span class="o">=</span> <span class="n">HW_MMU_SECTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE16MB</span>:
		<span class="n">pg_size_bits</span> <span class="o">=</span> <span class="n">HW_MMU_SUPERSECTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Generate the 20-bit tag from virtual address */</span>
	<span class="n">virtual_addr_tag</span> <span class="o">=</span> <span class="p">((</span><span class="n">virtual_addr</span> <span class="o">&amp;</span> <span class="n">MMU_ADDR_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>

	<span class="n">mmu_set_cam_entry</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">pg_size_bits</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">virtual_addr_tag</span><span class="p">);</span>

	<span class="n">mmu_flush_entry</span><span class="p">(</span><span class="n">base_address</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_tlb_add</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">physical_addr</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">virtual_addr</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">page_sz</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">entry_num</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">hw_mmu_map_attrs_t</span> <span class="o">*</span><span class="n">map_attrs</span><span class="p">,</span>
			 <span class="n">s8</span> <span class="n">preserved_bit</span><span class="p">,</span> <span class="n">s8</span> <span class="n">valid_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lock_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">virtual_addr_tag</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">hw_mmu_page_size_t</span> <span class="n">mmu_pg_size</span><span class="p">;</span>

	<span class="cm">/*Check the input Parameters */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">page_sz</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HW_PAGE_SIZE4KB</span>:
		<span class="n">mmu_pg_size</span> <span class="o">=</span> <span class="n">HW_MMU_SMALL_PAGE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE64KB</span>:
		<span class="n">mmu_pg_size</span> <span class="o">=</span> <span class="n">HW_MMU_LARGE_PAGE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE1MB</span>:
		<span class="n">mmu_pg_size</span> <span class="o">=</span> <span class="n">HW_MMU_SECTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE16MB</span>:
		<span class="n">mmu_pg_size</span> <span class="o">=</span> <span class="n">HW_MMU_SUPERSECTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_reg</span> <span class="o">=</span> <span class="n">MMUMMU_LOCK_READ_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">);</span>

	<span class="cm">/* Generate the 20-bit tag from virtual address */</span>
	<span class="n">virtual_addr_tag</span> <span class="o">=</span> <span class="p">((</span><span class="n">virtual_addr</span> <span class="o">&amp;</span> <span class="n">MMU_ADDR_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>

	<span class="cm">/* Write the fields in the CAM Entry Register */</span>
	<span class="n">mmu_set_cam_entry</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">mmu_pg_size</span><span class="p">,</span> <span class="n">preserved_bit</span><span class="p">,</span> <span class="n">valid_bit</span><span class="p">,</span>
			  <span class="n">virtual_addr_tag</span><span class="p">);</span>

	<span class="cm">/* Write the different fields of the RAM Entry Register */</span>
	<span class="cm">/* endianism of the page,Element Size of the page (8, 16, 32, 64 bit) */</span>
	<span class="n">mmu_set_ram_entry</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">physical_addr</span><span class="p">,</span> <span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">endianism</span><span class="p">,</span>
			  <span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">element_size</span><span class="p">,</span> <span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">mixed_size</span><span class="p">);</span>

	<span class="cm">/* Update the MMU Lock Register */</span>
	<span class="cm">/* currentVictim between lockedBaseValue and (MMU_Entries_Number - 1) */</span>
	<span class="n">MMUMMU_LOCK_CURRENT_VICTIM_WRITE32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">entry_num</span><span class="p">);</span>

	<span class="cm">/* Enable loading of an entry in TLB by writing 1</span>
<span class="cm">	   into LD_TLB_REG register */</span>
	<span class="n">MMUMMU_LD_TLB_WRITE_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">MMU_LOAD_TLB</span><span class="p">);</span>

	<span class="n">MMUMMU_LOCK_WRITE_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">lock_reg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_pte_set</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">pg_tbl_va</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">physical_addr</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">virtual_addr</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">page_sz</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hw_mmu_map_attrs_t</span> <span class="o">*</span><span class="n">map_attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pte_addr</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">num_entries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">page_sz</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HW_PAGE_SIZE4KB</span>:
		<span class="n">pte_addr</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l2</span><span class="p">(</span><span class="n">pg_tbl_va</span><span class="p">,</span>
					      <span class="n">virtual_addr</span> <span class="o">&amp;</span>
					      <span class="n">MMU_SMALL_PAGE_MASK</span><span class="p">);</span>
		<span class="n">pte_val</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">physical_addr</span> <span class="o">&amp;</span> <span class="n">MMU_SMALL_PAGE_MASK</span><span class="p">)</span> <span class="o">|</span>
		     <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">endianism</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span>
						    <span class="n">element_size</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
		     <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">mixed_size</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">|</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE64KB</span>:
		<span class="n">num_entries</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">pte_addr</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l2</span><span class="p">(</span><span class="n">pg_tbl_va</span><span class="p">,</span>
					      <span class="n">virtual_addr</span> <span class="o">&amp;</span>
					      <span class="n">MMU_LARGE_PAGE_MASK</span><span class="p">);</span>
		<span class="n">pte_val</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">physical_addr</span> <span class="o">&amp;</span> <span class="n">MMU_LARGE_PAGE_MASK</span><span class="p">)</span> <span class="o">|</span>
		     <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">endianism</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span>
						    <span class="n">element_size</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
		     <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">mixed_size</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE1MB</span>:
		<span class="n">pte_addr</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l1</span><span class="p">(</span><span class="n">pg_tbl_va</span><span class="p">,</span>
					      <span class="n">virtual_addr</span> <span class="o">&amp;</span>
					      <span class="n">MMU_SECTION_ADDR_MASK</span><span class="p">);</span>
		<span class="n">pte_val</span> <span class="o">=</span>
		    <span class="p">((((</span><span class="n">physical_addr</span> <span class="o">&amp;</span> <span class="n">MMU_SECTION_ADDR_MASK</span><span class="p">)</span> <span class="o">|</span>
		       <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">endianism</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span>
						       <span class="n">element_size</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span>
		       <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">mixed_size</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x40000</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE16MB</span>:
		<span class="n">num_entries</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">pte_addr</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l1</span><span class="p">(</span><span class="n">pg_tbl_va</span><span class="p">,</span>
					      <span class="n">virtual_addr</span> <span class="o">&amp;</span>
					      <span class="n">MMU_SSECTION_ADDR_MASK</span><span class="p">);</span>
		<span class="n">pte_val</span> <span class="o">=</span>
		    <span class="p">(((</span><span class="n">physical_addr</span> <span class="o">&amp;</span> <span class="n">MMU_SSECTION_ADDR_MASK</span><span class="p">)</span> <span class="o">|</span>
		      <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">endianism</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span>
						      <span class="n">element_size</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span>
		      <span class="p">(</span><span class="n">map_attrs</span><span class="o">-&gt;</span><span class="n">mixed_size</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">)</span>
		     <span class="p">)</span> <span class="o">|</span> <span class="mh">0x40000</span> <span class="o">|</span> <span class="mh">0x2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_MMU_COARSE_PAGE_SIZE</span>:
		<span class="n">pte_addr</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l1</span><span class="p">(</span><span class="n">pg_tbl_va</span><span class="p">,</span>
					      <span class="n">virtual_addr</span> <span class="o">&amp;</span>
					      <span class="n">MMU_SECTION_ADDR_MASK</span><span class="p">);</span>
		<span class="n">pte_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">physical_addr</span> <span class="o">&amp;</span> <span class="n">MMU_PAGE_TABLE_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">num_entries</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pte_addr</span><span class="p">)[</span><span class="n">num_entries</span><span class="p">]</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">hw_status</span> <span class="nf">hw_mmu_pte_clear</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">pg_tbl_va</span><span class="p">,</span> <span class="n">u32</span> <span class="n">virtual_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">page_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pte_addr</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">num_entries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">page_size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HW_PAGE_SIZE4KB</span>:
		<span class="n">pte_addr</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l2</span><span class="p">(</span><span class="n">pg_tbl_va</span><span class="p">,</span>
					      <span class="n">virtual_addr</span> <span class="o">&amp;</span>
					      <span class="n">MMU_SMALL_PAGE_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE64KB</span>:
		<span class="n">num_entries</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">pte_addr</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l2</span><span class="p">(</span><span class="n">pg_tbl_va</span><span class="p">,</span>
					      <span class="n">virtual_addr</span> <span class="o">&amp;</span>
					      <span class="n">MMU_LARGE_PAGE_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE1MB</span>:
	<span class="k">case</span> <span class="n">HW_MMU_COARSE_PAGE_SIZE</span>:
		<span class="n">pte_addr</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l1</span><span class="p">(</span><span class="n">pg_tbl_va</span><span class="p">,</span>
					      <span class="n">virtual_addr</span> <span class="o">&amp;</span>
					      <span class="n">MMU_SECTION_ADDR_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HW_PAGE_SIZE16MB</span>:
		<span class="n">num_entries</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">pte_addr</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l1</span><span class="p">(</span><span class="n">pg_tbl_va</span><span class="p">,</span>
					      <span class="n">virtual_addr</span> <span class="o">&amp;</span>
					      <span class="n">MMU_SSECTION_ADDR_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">num_entries</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pte_addr</span><span class="p">)[</span><span class="n">num_entries</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mmu_flush_entry */</span>
<span class="k">static</span> <span class="n">hw_status</span> <span class="nf">mmu_flush_entry</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flush_entry_data</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>

	<span class="cm">/* write values to register */</span>
	<span class="n">MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">flush_entry_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mmu_set_cam_entry */</span>
<span class="k">static</span> <span class="n">hw_status</span> <span class="nf">mmu_set_cam_entry</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u32</span> <span class="n">page_sz</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u32</span> <span class="n">preserved_bit</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u32</span> <span class="n">valid_bit</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u32</span> <span class="n">virtual_addr_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mmu_cam_reg</span><span class="p">;</span>

	<span class="n">mmu_cam_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">virtual_addr_tag</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">mmu_cam_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">mmu_cam_reg</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">page_sz</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">valid_bit</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
	    <span class="p">(</span><span class="n">preserved_bit</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>

	<span class="cm">/* write values to register */</span>
	<span class="n">MMUMMU_CAM_WRITE_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">mmu_cam_reg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mmu_set_ram_entry */</span>
<span class="k">static</span> <span class="n">hw_status</span> <span class="nf">mmu_set_ram_entry</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u32</span> <span class="n">physical_addr</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">hw_endianism_t</span> <span class="n">endianism</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">hw_element_size_t</span> <span class="n">element_size</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">hw_mmu_mixed_size_t</span> <span class="n">mixed_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mmu_ram_reg</span><span class="p">;</span>

	<span class="n">mmu_ram_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">physical_addr</span> <span class="o">&amp;</span> <span class="n">MMU_ADDR_MASK</span><span class="p">);</span>
	<span class="n">mmu_ram_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">mmu_ram_reg</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">endianism</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">element_size</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">|</span>
				       <span class="p">(</span><span class="n">mixed_size</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">));</span>

	<span class="cm">/* write values to register */</span>
	<span class="n">MMUMMU_RAM_WRITE_REGISTER32</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">mmu_ram_reg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hw_mmu_tlb_flush_all</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">MMU_GFLUSH</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
