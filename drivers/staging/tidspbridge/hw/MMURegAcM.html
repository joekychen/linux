<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › hw › MMURegAcM.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>MMURegAcM.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * MMURegAcM.h</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _MMU_REG_ACM_H</span>
<span class="cp">#define _MMU_REG_ACM_H</span>

<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;EasiGlobal.h&gt;</span>

<span class="cp">#include &quot;MMUAccInt.h&quot;</span>

<span class="cp">#if defined(USE_LEVEL_1_MACROS)</span>

<span class="cp">#define MMUMMU_SYSCONFIG_READ_REGISTER32(base_address)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_SYSCONFIG_READ_REGISTER32),\</span>
<span class="cp">      __raw_readl((base_address)+MMU_MMU_SYSCONFIG_OFFSET))</span>

<span class="cp">#define MMUMMU_SYSCONFIG_IDLE_MODE_WRITE32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;\</span>
<span class="cp">    register u32 data = __raw_readl((base_address)+offset);\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_SYSCONFIG_IDLE_MODE_WRITE32);\</span>
<span class="cp">    data &amp;= ~(MMU_MMU_SYSCONFIG_IDLE_MODE_MASK);\</span>
<span class="cp">    new_value &lt;&lt;= MMU_MMU_SYSCONFIG_IDLE_MODE_OFFSET;\</span>
<span class="cp">    new_value &amp;= MMU_MMU_SYSCONFIG_IDLE_MODE_MASK;\</span>
<span class="cp">    new_value |= data;\</span>
<span class="cp">    __raw_writel(new_value, base_address+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_SYSCONFIG_AUTO_IDLE_WRITE32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;\</span>
<span class="cp">    register u32 data = __raw_readl((base_address)+offset);\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_SYSCONFIG_AUTO_IDLE_WRITE32);\</span>
<span class="cp">    data &amp;= ~(MMU_MMU_SYSCONFIG_AUTO_IDLE_MASK);\</span>
<span class="cp">    new_value &lt;&lt;= MMU_MMU_SYSCONFIG_AUTO_IDLE_OFFSET;\</span>
<span class="cp">    new_value &amp;= MMU_MMU_SYSCONFIG_AUTO_IDLE_MASK;\</span>
<span class="cp">    new_value |= data;\</span>
<span class="cp">    __raw_writel(new_value, base_address+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_IRQSTATUS_READ_REGISTER32(base_address)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(easil1_mmummu_irqstatus_read_register32),\</span>
<span class="cp">      __raw_readl((base_address)+MMU_MMU_IRQSTATUS_OFFSET))</span>

<span class="cp">#define MMUMMU_IRQSTATUS_WRITE_REGISTER32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_IRQSTATUS_OFFSET;\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQSTATUS_WRITE_REGISTER32);\</span>
<span class="cp">    __raw_writel(new_value, (base_address)+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_IRQENABLE_READ_REGISTER32(base_address)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQENABLE_READ_REGISTER32),\</span>
<span class="cp">      __raw_readl((base_address)+MMU_MMU_IRQENABLE_OFFSET))</span>

<span class="cp">#define MMUMMU_IRQENABLE_WRITE_REGISTER32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_IRQENABLE_OFFSET;\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQENABLE_WRITE_REGISTER32);\</span>
<span class="cp">    __raw_writel(new_value, (base_address)+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_WALKING_STTWL_RUNNING_READ32(base_address)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_WALKING_STTWL_RUNNING_READ32),\</span>
<span class="cp">      (((__raw_readl(((base_address)+(MMU_MMU_WALKING_ST_OFFSET))))\</span>
<span class="cp">      &amp; MMU_MMU_WALKING_ST_TWL_RUNNING_MASK) &gt;&gt;\</span>
<span class="cp">      MMU_MMU_WALKING_ST_TWL_RUNNING_OFFSET))</span>

<span class="cp">#define MMUMMU_CNTLTWL_ENABLE_READ32(base_address)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CNTLTWL_ENABLE_READ32),\</span>
<span class="cp">      (((__raw_readl(((base_address)+(MMU_MMU_CNTL_OFFSET)))) &amp;\</span>
<span class="cp">      MMU_MMU_CNTL_TWL_ENABLE_MASK) &gt;&gt;\</span>
<span class="cp">      MMU_MMU_CNTL_TWL_ENABLE_OFFSET))</span>

<span class="cp">#define MMUMMU_CNTLTWL_ENABLE_WRITE32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_CNTL_OFFSET;\</span>
<span class="cp">    register u32 data = __raw_readl((base_address)+offset);\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CNTLTWL_ENABLE_WRITE32);\</span>
<span class="cp">    data &amp;= ~(MMU_MMU_CNTL_TWL_ENABLE_MASK);\</span>
<span class="cp">    new_value &lt;&lt;= MMU_MMU_CNTL_TWL_ENABLE_OFFSET;\</span>
<span class="cp">    new_value &amp;= MMU_MMU_CNTL_TWL_ENABLE_MASK;\</span>
<span class="cp">    new_value |= data;\</span>
<span class="cp">    __raw_writel(new_value, base_address+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_CNTLMMU_ENABLE_WRITE32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_CNTL_OFFSET;\</span>
<span class="cp">    register u32 data = __raw_readl((base_address)+offset);\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CNTLMMU_ENABLE_WRITE32);\</span>
<span class="cp">    data &amp;= ~(MMU_MMU_CNTL_MMU_ENABLE_MASK);\</span>
<span class="cp">    new_value &lt;&lt;= MMU_MMU_CNTL_MMU_ENABLE_OFFSET;\</span>
<span class="cp">    new_value &amp;= MMU_MMU_CNTL_MMU_ENABLE_MASK;\</span>
<span class="cp">    new_value |= data;\</span>
<span class="cp">    __raw_writel(new_value, base_address+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_FAULT_AD_READ_REGISTER32(base_address)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_FAULT_AD_READ_REGISTER32),\</span>
<span class="cp">      __raw_readl((base_address)+MMU_MMU_FAULT_AD_OFFSET))</span>

<span class="cp">#define MMUMMU_TTB_WRITE_REGISTER32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_TTB_OFFSET;\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_TTB_WRITE_REGISTER32);\</span>
<span class="cp">    __raw_writel(new_value, (base_address)+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_LOCK_READ_REGISTER32(base_address)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_READ_REGISTER32),\</span>
<span class="cp">      __raw_readl((base_address)+MMU_MMU_LOCK_OFFSET))</span>

<span class="cp">#define MMUMMU_LOCK_WRITE_REGISTER32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_LOCK_OFFSET;\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_WRITE_REGISTER32);\</span>
<span class="cp">    __raw_writel(new_value, (base_address)+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_LOCK_BASE_VALUE_READ32(base_address)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_BASE_VALUE_READ32),\</span>
<span class="cp">      (((__raw_readl(((base_address)+(MMU_MMU_LOCK_OFFSET)))) &amp;\</span>
<span class="cp">      MMU_MMU_LOCK_BASE_VALUE_MASK) &gt;&gt;\</span>
<span class="cp">      MMU_MMU_LOCK_BASE_VALUE_OFFSET))</span>

<span class="cp">#define MMUMMU_LOCK_BASE_VALUE_WRITE32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_LOCK_OFFSET;\</span>
<span class="cp">    register u32 data = __raw_readl((base_address)+offset);\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(easil1_mmummu_lock_base_value_write32);\</span>
<span class="cp">    data &amp;= ~(MMU_MMU_LOCK_BASE_VALUE_MASK);\</span>
<span class="cp">    new_value &lt;&lt;= MMU_MMU_LOCK_BASE_VALUE_OFFSET;\</span>
<span class="cp">    new_value &amp;= MMU_MMU_LOCK_BASE_VALUE_MASK;\</span>
<span class="cp">    new_value |= data;\</span>
<span class="cp">    __raw_writel(new_value, base_address+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_LOCK_CURRENT_VICTIM_READ32(base_address)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_READ32),\</span>
<span class="cp">      (((__raw_readl(((base_address)+(MMU_MMU_LOCK_OFFSET)))) &amp;\</span>
<span class="cp">      MMU_MMU_LOCK_CURRENT_VICTIM_MASK) &gt;&gt;\</span>
<span class="cp">      MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET))</span>

<span class="cp">#define MMUMMU_LOCK_CURRENT_VICTIM_WRITE32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_LOCK_OFFSET;\</span>
<span class="cp">    register u32 data = __raw_readl((base_address)+offset);\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_WRITE32);\</span>
<span class="cp">    data &amp;= ~(MMU_MMU_LOCK_CURRENT_VICTIM_MASK);\</span>
<span class="cp">    new_value &lt;&lt;= MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET;\</span>
<span class="cp">    new_value &amp;= MMU_MMU_LOCK_CURRENT_VICTIM_MASK;\</span>
<span class="cp">    new_value |= data;\</span>
<span class="cp">    __raw_writel(new_value, base_address+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_LOCK_CURRENT_VICTIM_SET32(var, value)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_SET32),\</span>
<span class="cp">      (((var) &amp; ~(MMU_MMU_LOCK_CURRENT_VICTIM_MASK)) |\</span>
<span class="cp">      (((value) &lt;&lt; MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET) &amp;\</span>
<span class="cp">      MMU_MMU_LOCK_CURRENT_VICTIM_MASK)))</span>

<span class="cp">#define MMUMMU_LD_TLB_READ_REGISTER32(base_address)\</span>
<span class="cp">    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LD_TLB_READ_REGISTER32),\</span>
<span class="cp">      __raw_readl((base_address)+MMU_MMU_LD_TLB_OFFSET))</span>

<span class="cp">#define MMUMMU_LD_TLB_WRITE_REGISTER32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_LD_TLB_OFFSET;\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LD_TLB_WRITE_REGISTER32);\</span>
<span class="cp">    __raw_writel(new_value, (base_address)+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_CAM_WRITE_REGISTER32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_CAM_OFFSET;\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CAM_WRITE_REGISTER32);\</span>
<span class="cp">    __raw_writel(new_value, (base_address)+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_RAM_WRITE_REGISTER32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_RAM_OFFSET;\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_RAM_WRITE_REGISTER32);\</span>
<span class="cp">    __raw_writel(new_value, (base_address)+offset);\</span>
<span class="cp">}</span>

<span class="cp">#define MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32(base_address, value)\</span>
<span class="cp">{\</span>
<span class="cp">    const u32 offset = MMU_MMU_FLUSH_ENTRY_OFFSET;\</span>
<span class="cp">    register u32 new_value = (value);\</span>
<span class="cp">    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32);\</span>
<span class="cp">    __raw_writel(new_value, (base_address)+offset);\</span>
<span class="cp">}</span>

<span class="cp">#endif </span><span class="cm">/* USE_LEVEL_1_MACROS */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _MMU_REG_ACM_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
