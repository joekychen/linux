<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › pmgr › dev.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>dev.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * dev.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Implementation of Bridge Bridge driver device operations.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="cm">/*  ----------------------------------- Host OS */</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>

<span class="cm">/*  ----------------------------------- DSP/BIOS Bridge */</span>
<span class="cp">#include &lt;dspbridge/dbdefs.h&gt;</span>

<span class="cm">/*  ----------------------------------- Platform Manager */</span>
<span class="cp">#include &lt;dspbridge/cod.h&gt;</span>
<span class="cp">#include &lt;dspbridge/drv.h&gt;</span>
<span class="cp">#include &lt;dspbridge/proc.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dmm.h&gt;</span>

<span class="cm">/*  ----------------------------------- Resource Manager */</span>
<span class="cp">#include &lt;dspbridge/mgr.h&gt;</span>
<span class="cp">#include &lt;dspbridge/node.h&gt;</span>

<span class="cm">/*  ----------------------------------- Others */</span>
<span class="cp">#include &lt;dspbridge/dspapi.h&gt;	</span><span class="cm">/* DSP API version info. */</span><span class="cp"></span>

<span class="cp">#include &lt;dspbridge/chnl.h&gt;</span>
<span class="cp">#include &lt;dspbridge/io.h&gt;</span>
<span class="cp">#include &lt;dspbridge/msg.h&gt;</span>
<span class="cp">#include &lt;dspbridge/cmm.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspdeh.h&gt;</span>

<span class="cm">/*  ----------------------------------- This */</span>
<span class="cp">#include &lt;dspbridge/dev.h&gt;</span>

<span class="cm">/*  ----------------------------------- Defines, Data Structures, Typedefs */</span>

<span class="cp">#define MAKEVERSION(major, minor)   (major * 10 + minor)</span>
<span class="cp">#define BRD_API_VERSION		MAKEVERSION(BRD_API_MAJOR_VERSION,	\</span>
<span class="cp">				BRD_API_MINOR_VERSION)</span>

<span class="cm">/* The Bridge device object: */</span>
<span class="k">struct</span> <span class="n">dev_object</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>	<span class="cm">/* Link to next dev_object. */</span>
	<span class="n">u8</span> <span class="n">dev_type</span><span class="p">;</span>		<span class="cm">/* Device Type */</span>
	<span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">;</span>	<span class="cm">/* Platform specific dev id */</span>
	<span class="cm">/* Bridge Context Handle */</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">bridge_context</span><span class="p">;</span>
	<span class="cm">/* Function interface to Bridge driver. */</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="n">bridge_interface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">brd_object</span> <span class="o">*</span><span class="n">lock_owner</span><span class="p">;</span>	<span class="cm">/* Client with exclusive access. */</span>
	<span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">cod_mgr</span><span class="p">;</span>	<span class="cm">/* Code manager handle. */</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr</span><span class="p">;</span>	<span class="cm">/* Channel manager. */</span>
	<span class="k">struct</span> <span class="n">deh_mgr</span> <span class="o">*</span><span class="n">deh_mgr</span><span class="p">;</span>	<span class="cm">/* DEH manager. */</span>
	<span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">msg_mgr</span><span class="p">;</span>	<span class="cm">/* Message manager. */</span>
	<span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">iomgr</span><span class="p">;</span>	<span class="cm">/* IO manager (CHNL, msg_ctrl) */</span>
	<span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">*</span><span class="n">cmm_mgr</span><span class="p">;</span>	<span class="cm">/* SM memory manager. */</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">;</span>	<span class="cm">/* Dynamic memory manager. */</span>
	<span class="n">u32</span> <span class="n">word_size</span><span class="p">;</span>		<span class="cm">/* DSP word size: quick access. */</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">drv_obj</span><span class="p">;</span>	<span class="cm">/* Driver Object */</span>
	<span class="cm">/* List of Processors attached to this device */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">proc_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">node_mgr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drv_ext</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">sz_string</span><span class="p">[</span><span class="n">MAXREGPATHLENGTH</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*  ----------------------------------- Function Prototypes */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fxn_not_implemented</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">init_cod_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">store_interface_fxns</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">drv_fxns</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> *  ======== dev_brd_write_fxn ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Exported function to be used as the COD write function.  This function</span>
<span class="cm"> *      is passed a handle to a DEV_hObject, then calls the</span>
<span class="cm"> *      device&#39;s bridge_brd_write() function.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">dev_brd_write_fxn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_add</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">host_buf</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span><span class="n">arb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Require of BrdWrite() */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_interface</span><span class="p">.</span><span class="n">brd_write</span><span class="p">)</span> <span class="p">(</span>
					<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">host_buf</span><span class="p">,</span>
					<span class="n">dsp_add</span><span class="p">,</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">mem_space</span><span class="p">);</span>
		<span class="cm">/* Special case of getting the address only */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ul_num_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ul_num_bytes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
			<span class="n">ul_written</span> <span class="o">=</span> <span class="n">ul_num_bytes</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ul_written</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_create_device ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Called by the operating system to load the PM Bridge Driver for a</span>
<span class="cm"> *      PM board (device).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_create_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">**</span><span class="n">device_obj</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_file_name</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">host_res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">drv_fxns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgrattrs</span> <span class="n">mgr_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_attrs</span> <span class="n">io_mgr_attrs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_windows</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_object</span> <span class="o">*</span><span class="n">hdrv_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">drv_request_bridge_res_dsp</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">host_res</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Failed to reserve bridge resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  Get the Bridge driver interface functions */</span>
	<span class="n">bridge_drv_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_fxns</span><span class="p">,</span> <span class="n">driver_file_name</span><span class="p">);</span>

	<span class="cm">/* Retrieve the Object handle from the driver data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_datap</span> <span class="o">&amp;&amp;</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hdrv_obj</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">drv_object</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to retrieve the object handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Create the device object, and pass a handle to the Bridge driver for</span>
<span class="cm">	 * storage. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_obj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Fill out the rest of the Dev Object structure: */</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dev_node_obj</span> <span class="o">=</span> <span class="n">dev_node_obj</span><span class="p">;</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cod_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">deh_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">lock_owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="n">DSPWORDSIZE</span><span class="p">;</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">drv_obj</span> <span class="o">=</span> <span class="n">hdrv_obj</span><span class="p">;</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dev_type</span> <span class="o">=</span> <span class="n">DSP_UNIT</span><span class="p">;</span>
			<span class="cm">/* Store this Bridge&#39;s interface functions, based on its</span>
<span class="cm">			 * version. */</span>
			<span class="n">store_interface_fxns</span><span class="p">(</span><span class="n">drv_fxns</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_interface</span><span class="p">);</span>

			<span class="cm">/* Call fxn_dev_create() to get the Bridge&#39;s device</span>
<span class="cm">			 * context handle. */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_interface</span><span class="p">.</span><span class="n">dev_create</span><span class="p">)</span>
			    <span class="p">(</span><span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">dev_obj</span><span class="p">,</span>
			     <span class="n">host_res</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Attempt to create the COD manager for this device: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">init_cod_mgr</span><span class="p">(</span><span class="n">dev_obj</span><span class="p">);</span>

	<span class="cm">/* Attempt to create the channel manager for this device: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mgr_attrs</span><span class="p">.</span><span class="n">max_channels</span> <span class="o">=</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">;</span>
		<span class="n">io_mgr_attrs</span><span class="p">.</span><span class="n">birq</span> <span class="o">=</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">birq_registers</span><span class="p">;</span>
		<span class="n">io_mgr_attrs</span><span class="p">.</span><span class="n">irq_shared</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">birq_attrib</span> <span class="o">&amp;</span> <span class="n">CFG_IRQSHARED</span><span class="p">);</span>
		<span class="n">io_mgr_attrs</span><span class="p">.</span><span class="n">word_size</span> <span class="o">=</span> <span class="n">DSPWORDSIZE</span><span class="p">;</span>
		<span class="n">mgr_attrs</span><span class="p">.</span><span class="n">word_size</span> <span class="o">=</span> <span class="n">DSPWORDSIZE</span><span class="p">;</span>
		<span class="n">num_windows</span> <span class="o">=</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">num_mem_windows</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_windows</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Assume last memory window is for CHNL */</span>
			<span class="n">io_mgr_attrs</span><span class="p">.</span><span class="n">shm_base</span> <span class="o">=</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
			    <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">offset_for_monitor</span><span class="p">;</span>
			<span class="n">io_mgr_attrs</span><span class="p">.</span><span class="n">sm_length</span> <span class="o">=</span>
			    <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_length</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>
			    <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">offset_for_monitor</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">io_mgr_attrs</span><span class="p">.</span><span class="n">shm_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">io_mgr_attrs</span><span class="p">.</span><span class="n">sm_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: No memory reserved for shared structures</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">chnl_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span><span class="p">,</span> <span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mgr_attrs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* It&#39;s OK for a device not to have a channel</span>
<span class="cm">			 * manager: */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Create CMM mgr even if Msg Mgr not impl. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cmm_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cmm_mgr</span><span class="p">,</span>
				    <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_obj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* Only create IO manager if we have a channel manager */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">io_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">iomgr</span><span class="p">,</span> <span class="n">dev_obj</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">io_mgr_attrs</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Only create DEH manager if we have an IO manager */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Instantiate the DEH module */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">bridge_deh_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">deh_mgr</span><span class="p">,</span> <span class="n">dev_obj</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Create DMM mgr . */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dmm_mgr</span><span class="p">,</span>
				    <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_obj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Add the new DEV_Object to the global list: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">drv_insert_dev_object</span><span class="p">(</span><span class="n">hdrv_obj</span><span class="p">,</span> <span class="n">dev_obj</span><span class="p">);</span>

	<span class="cm">/* Create the Processor List */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">proc_list</span><span class="p">);</span>
<span class="nl">leave:</span>
	<span class="cm">/*  If all went well, return a handle to the dev object;</span>
<span class="cm">	 *  else, cleanup and return NULL in the OUT parameter. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">device_obj</span> <span class="o">=</span> <span class="n">dev_obj</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cod_mgr</span><span class="p">)</span>
				<span class="n">cod_delete</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cod_mgr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dmm_mgr</span><span class="p">)</span>
				<span class="n">dmm_destroy</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dmm_mgr</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dev_obj</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">device_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_create2 ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      After successful loading of the image from api_init_complete2</span>
<span class="cm"> *      (PROC Auto_Start) or proc_load this fxn is called. This creates</span>
<span class="cm"> *      the Node Manager and updates the DEV Object.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_create2</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="cm">/* There can be only one Node Manager per DEV object */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">node_create_mgr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">,</span> <span class="n">hdev_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">node_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_destroy2 ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Destroys the Node manager for this device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_destroy2</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_delete_mgr</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">node_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_destroy_device ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Destroys the channel manager for this device, if any, calls</span>
<span class="cm"> *      bridge_dev_destroy(), and then attempts to unload the Bridge module.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_destroy_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cod_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cod_delete</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cod_mgr</span><span class="p">);</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cod_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node_delete_mgr</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">);</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">node_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Free the io, channel, and message managers for this board: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">iomgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">io_destroy</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">iomgr</span><span class="p">);</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">iomgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chnl_destroy</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span><span class="p">);</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">msg_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg_delete</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">msg_mgr</span><span class="p">);</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">msg_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">deh_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Uninitialize DEH module. */</span>
			<span class="n">bridge_deh_destroy</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">deh_mgr</span><span class="p">);</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">deh_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cmm_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmm_destroy</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cmm_mgr</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cmm_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dmm_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dmm_destroy</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dmm_mgr</span><span class="p">);</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dmm_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Call the driver&#39;s bridge_dev_destroy() function: */</span>
		<span class="cm">/* Require of DevDestroy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_interface</span><span class="p">.</span><span class="n">dev_destroy</span><span class="p">)</span>
			    <span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">);</span>
			<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Remove this DEV_Object from the global list: */</span>
			<span class="n">drv_remove_dev_object</span><span class="p">(</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">drv_obj</span><span class="p">,</span> <span class="n">dev_obj</span><span class="p">);</span>
			<span class="cm">/* Free The library * LDR_FreeModule</span>
<span class="cm">			 * (dev_obj-&gt;module_obj); */</span>
			<span class="cm">/* Free this dev object: */</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dev_obj</span><span class="p">);</span>
			<span class="n">dev_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_chnl_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the handle to the channel manager handle created for this</span>
<span class="cm"> *      device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_chnl_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">**</span><span class="n">mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_cmm_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the handle to the shared memory manager created for this</span>
<span class="cm"> *      device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_cmm_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">**</span><span class="n">mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cmm_mgr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_dmm_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the handle to the dynamic memory manager created for this</span>
<span class="cm"> *      device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_dmm_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">**</span><span class="n">mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_cod_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the COD manager create for this device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_cod_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">**</span><span class="n">cod_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">cod_mgr</span> <span class="o">=</span> <span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cod_mgr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">cod_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ========= dev_get_deh_mgr ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_deh_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">deh_mgr</span> <span class="o">**</span><span class="n">deh_manager</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">deh_manager</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="o">-&gt;</span><span class="n">deh_mgr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">deh_manager</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_dev_node ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the platform specific device ID for this device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_dev_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">**</span><span class="n">dev_nde</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dev_nde</span> <span class="o">=</span> <span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dev_node_obj</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dev_nde</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_first ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the first Device Object handle from an internal linked list</span>
<span class="cm"> *      DEV_OBJECTs maintained by DEV.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="nf">dev_get_first</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span><span class="n">drv_get_first_dev_object</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">dev_obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_intf_fxns ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the Bridge interface function structure for the loaded driver.</span>
<span class="cm"> *      if_fxns != NULL.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_intf_fxns</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">**</span><span class="n">if_fxns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">if_fxns</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_interface</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">if_fxns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ========= dev_get_io_mgr ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_io_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">**</span><span class="n">io_man</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">io_man</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="o">-&gt;</span><span class="n">iomgr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">io_man</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_next ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the next Device Object handle from an internal linked list</span>
<span class="cm"> *      of DEV_OBJECTs maintained by DEV, after having previously called</span>
<span class="cm"> *      dev_get_first() and zero or more dev_get_next</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="nf">dev_get_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">next_dev_object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next_dev_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span>
		    <span class="n">drv_get_next_dev_object</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">hdev_obj</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">next_dev_object</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ========= dev_get_msg_mgr ========</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dev_get_msg_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">**</span><span class="n">msg_man</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">msg_man</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="o">-&gt;</span><span class="n">msg_mgr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_node_manager ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the Node Manager Handle</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_node_manager</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">**</span><span class="n">node_man</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">node_man</span> <span class="o">=</span> <span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">node_man</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_symbol ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_symbol</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str_sym</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">pul_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">cod_mgr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_cod_mgr</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cod_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cod_mgr</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">str_sym</span><span class="p">,</span>
						   <span class="n">pul_value</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_get_bridge_context ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve the Bridge Context handle, as returned by the</span>
<span class="cm"> *      bridge_dev_create fxn.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_get_bridge_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">**</span><span class="n">phbridge_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">phbridge_context</span> <span class="o">=</span> <span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">phbridge_context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_notify_clients ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Notify all clients of this device of a change in device status.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_notify_clients</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: this code needs struct proc_object to have a list_head</span>
<span class="cm">	 * at the beginning. If not, this can go horribly wrong.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">proc_list</span><span class="p">)</span>
		<span class="n">proc_notify_clients</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">curr</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_remove_device ========</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">;</span>	<span class="cm">/* handle to device object */</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_datap</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_node_obj</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Retrieve the device object handle originally stored with</span>
<span class="cm">	 * the dev_node: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check the device string and then store dev object */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)((</span><span class="k">struct</span> <span class="n">drv_ext</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_node_obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sz_string</span><span class="p">,</span>
								<span class="s">&quot;TIOMAP1510&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hdev_obj</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">dev_object</span><span class="p">;</span>
			<span class="cm">/* Destroy the device object. */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">dev_destroy_device</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed, status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_set_chnl_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Set the channel manager for this device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_set_chnl_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">hmgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev_obj</span><span class="p">)</span>
		<span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span> <span class="o">=</span> <span class="n">hmgr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_set_msg_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Set the message manager for this device.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dev_set_msg_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hdev_obj</span><span class="o">-&gt;</span><span class="n">msg_mgr</span> <span class="o">=</span> <span class="n">hmgr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_start_device ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Initializes the new device with the BRIDGE environment.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_start_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* handle to &#39;Bridge Device */</span>
	<span class="cm">/* Bridge driver filename */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bridge_file_name</span> <span class="o">=</span> <span class="s">&quot;UMA&quot;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mgr_object</span> <span class="o">*</span><span class="n">hmgr_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="cm">/* Given all resources, create a device object. */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_create_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="n">bridge_file_name</span><span class="p">,</span>
				   <span class="n">dev_node_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Store away the hdev_obj with the DEVNODE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_datap</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev_node_obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed, status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_node_obj</span><span class="p">,</span> <span class="s">&quot;TIOMAP1510&quot;</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">dev_object</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">hdev_obj</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Create the Manager Object */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">mgr_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmgr_obj</span><span class="p">,</span> <span class="n">dev_node_obj</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_node_obj</span><span class="p">,</span>
							<span class="s">&quot;TIOMAP1510&quot;</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/* Ensure the device extension is NULL */</span>
				<span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">dev_object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Clean up */</span>
			<span class="n">dev_destroy_device</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">);</span>
			<span class="n">hdev_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== fxn_not_implemented ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Takes the place of a Bridge Null Function.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      Multiple, optional.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      -ENOSYS:   Always.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fxn_not_implemented</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== init_cod_mgr ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create a COD manager for this device.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      dev_obj:             Pointer to device object created with</span>
<span class="cm"> *                              dev_create_device()</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:                Success.</span>
<span class="cm"> *      -EFAULT:            Invalid hdev_obj.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Should only be called once by dev_create_device() for a given DevObject.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_cod_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sz_dummy_file</span> <span class="o">=</span> <span class="s">&quot;dummy&quot;</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">cod_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="n">sz_dummy_file</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_insert_proc_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Insert a ProcObject into the list maintained by DEV.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      p_proc_object:        Ptr to ProcObject to insert.</span>
<span class="cm"> *      dev_obj:         Ptr to Dev Object where the list is.</span>
<span class="cm">  *     already_attached:  Ptr to return the bool</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:           If successful.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      List Exists</span>
<span class="cm"> *      hdev_obj is Valid handle</span>
<span class="cm"> *      DEV Initialized</span>
<span class="cm"> *      already_attached != NULL</span>
<span class="cm"> *      proc_obj != 0</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      0 and List is not Empty.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_insert_proc_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">proc_obj</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">already_attached</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">proc_list</span><span class="p">))</span>
		<span class="o">*</span><span class="n">already_attached</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Add DevObject to tail. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: this code needs struct proc_object to have a list_head</span>
<span class="cm">	 * at the beginning. If not, this can go horribly wrong.</span>
<span class="cm">	 */</span>
	<span class="n">list_add_tail</span><span class="p">((</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="n">proc_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">proc_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dev_remove_proc_object ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Search for and remove a Proc object from the given list maintained</span>
<span class="cm"> *      by the DEV</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      p_proc_object:        Ptr to ProcObject to insert.</span>
<span class="cm"> *      dev_obj          Ptr to Dev Object where the list is.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:            If successful.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      List exists and is not empty</span>
<span class="cm"> *      proc_obj != 0</span>
<span class="cm"> *      hdev_obj is a valid Dev handle.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *  Details:</span>
<span class="cm"> *      List will be deleted when the DEV is destroyed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_remove_proc_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="n">u32</span> <span class="n">proc_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">cur_elem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span><span class="n">hdev_obj</span><span class="p">;</span>

	<span class="cm">/* Search list for dev_obj: */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">cur_elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">proc_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">cur_elem</span> <span class="o">==</span> <span class="n">proc_obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="n">cur_elem</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dev_get_dev_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">dev_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">dev_type</span> <span class="o">=</span> <span class="n">dev_obj</span><span class="o">-&gt;</span><span class="n">dev_type</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== store_interface_fxns ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Copy the Bridge&#39;s interface functions into the device object,</span>
<span class="cm"> *      ensuring that fxn_not_implemented() is set for:</span>
<span class="cm"> *</span>
<span class="cm"> *      1. All Bridge function pointers which are NULL; and</span>
<span class="cm"> *      2. All function slots in the struct dev_object structure which have no</span>
<span class="cm"> *         corresponding slots in the the Bridge&#39;s interface, because the Bridge</span>
<span class="cm"> *         is of an *older* version.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      intf_fxns:      Interface fxn Structure of the Bridge&#39;s Dev Object.</span>
<span class="cm"> *      drv_fxns:      Interface Fxns offered by the Bridge during DEV_Create().</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      Input pointers are valid.</span>
<span class="cm"> *      Bridge driver is *not* written for a newer DSP API.</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> *      All function pointers in the dev object&#39;s fxn interface are not NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">store_interface_fxns</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">drv_fxns</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">bridge_version</span><span class="p">;</span>

	<span class="cm">/* Local helper macro: */</span>
<span class="cp">#define  STORE_FXN(cast, pfn) \</span>
<span class="cp">    (intf_fxns-&gt;pfn = ((drv_fxns-&gt;pfn != NULL) ? drv_fxns-&gt;pfn : \</span>
<span class="cp">    (cast)fxn_not_implemented))</span>

	<span class="n">bridge_version</span> <span class="o">=</span> <span class="n">MAKEVERSION</span><span class="p">(</span><span class="n">drv_fxns</span><span class="o">-&gt;</span><span class="n">brd_api_major_version</span><span class="p">,</span>
				     <span class="n">drv_fxns</span><span class="o">-&gt;</span><span class="n">brd_api_minor_version</span><span class="p">);</span>
	<span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_api_major_version</span> <span class="o">=</span> <span class="n">drv_fxns</span><span class="o">-&gt;</span><span class="n">brd_api_major_version</span><span class="p">;</span>
	<span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_api_minor_version</span> <span class="o">=</span> <span class="n">drv_fxns</span><span class="o">-&gt;</span><span class="n">brd_api_minor_version</span><span class="p">;</span>
	<span class="cm">/* Install functions up to DSP API version .80 (first alpha): */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bridge_version</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_dev_create</span><span class="p">,</span> <span class="n">dev_create</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_dev_destroy</span><span class="p">,</span> <span class="n">dev_destroy</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_dev_ctrl</span><span class="p">,</span> <span class="n">dev_cntrl</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_monitor</span><span class="p">,</span> <span class="n">brd_monitor</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_start</span><span class="p">,</span> <span class="n">brd_start</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_stop</span><span class="p">,</span> <span class="n">brd_stop</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_status</span><span class="p">,</span> <span class="n">brd_status</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_read</span><span class="p">,</span> <span class="n">brd_read</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_write</span><span class="p">,</span> <span class="n">brd_write</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_setstate</span><span class="p">,</span> <span class="n">brd_set_state</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_memcopy</span><span class="p">,</span> <span class="n">brd_mem_copy</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_memwrite</span><span class="p">,</span> <span class="n">brd_mem_write</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_memmap</span><span class="p">,</span> <span class="n">brd_mem_map</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_brd_memunmap</span><span class="p">,</span> <span class="n">brd_mem_un_map</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_create</span><span class="p">,</span> <span class="n">chnl_create</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_destroy</span><span class="p">,</span> <span class="n">chnl_destroy</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_open</span><span class="p">,</span> <span class="n">chnl_open</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_close</span><span class="p">,</span> <span class="n">chnl_close</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_addioreq</span><span class="p">,</span> <span class="n">chnl_add_io_req</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_getioc</span><span class="p">,</span> <span class="n">chnl_get_ioc</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_cancelio</span><span class="p">,</span> <span class="n">chnl_cancel_io</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_flushio</span><span class="p">,</span> <span class="n">chnl_flush_io</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_getinfo</span><span class="p">,</span> <span class="n">chnl_get_info</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_getmgrinfo</span><span class="p">,</span> <span class="n">chnl_get_mgr_info</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_idle</span><span class="p">,</span> <span class="n">chnl_idle</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_chnl_registernotify</span><span class="p">,</span> <span class="n">chnl_register_notify</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_io_create</span><span class="p">,</span> <span class="n">io_create</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_io_destroy</span><span class="p">,</span> <span class="n">io_destroy</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_io_onloaded</span><span class="p">,</span> <span class="n">io_on_loaded</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_io_getprocload</span><span class="p">,</span> <span class="n">io_get_proc_load</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_msg_create</span><span class="p">,</span> <span class="n">msg_create</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_msg_createqueue</span><span class="p">,</span> <span class="n">msg_create_queue</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_msg_delete</span><span class="p">,</span> <span class="n">msg_delete</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_msg_deletequeue</span><span class="p">,</span> <span class="n">msg_delete_queue</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_msg_get</span><span class="p">,</span> <span class="n">msg_get</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_msg_put</span><span class="p">,</span> <span class="n">msg_put</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_msg_registernotify</span><span class="p">,</span> <span class="n">msg_register_notify</span><span class="p">);</span>
		<span class="n">STORE_FXN</span><span class="p">(</span><span class="n">fxn_msg_setqueueid</span><span class="p">,</span> <span class="n">msg_set_queue_id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Add code for any additional functions in newerBridge versions here */</span>
<span class="cp">#undef  STORE_FXN</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
