<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › pmgr › dmm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>dmm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * dmm.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * The Dynamic Memory Manager (DMM) module manages the DSP Virtual address</span>
<span class="cm"> * space that can be directly mapped to any MPU buffer or memory region</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *   Region: Generic memory entitiy having a start address and a size</span>
<span class="cm"> *   Chunk:  Reserved region</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/*  ----------------------------------- Host OS */</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>

<span class="cm">/*  ----------------------------------- DSP/BIOS Bridge */</span>
<span class="cp">#include &lt;dspbridge/dbdefs.h&gt;</span>

<span class="cm">/*  ----------------------------------- OS Adaptation Layer */</span>
<span class="cp">#include &lt;dspbridge/sync.h&gt;</span>

<span class="cm">/*  ----------------------------------- Platform Manager */</span>
<span class="cp">#include &lt;dspbridge/dev.h&gt;</span>
<span class="cp">#include &lt;dspbridge/proc.h&gt;</span>

<span class="cm">/*  ----------------------------------- This */</span>
<span class="cp">#include &lt;dspbridge/dmm.h&gt;</span>

<span class="cm">/*  ----------------------------------- Defines, Data Structures, Typedefs */</span>
<span class="cp">#define DMM_ADDR_VIRTUAL(a) \</span>
<span class="cp">	(((struct map_page *)(a) - virtual_mapping_table) * PG_SIZE4K +\</span>
<span class="cp">	dyn_mem_map_beg)</span>
<span class="cp">#define DMM_ADDR_TO_INDEX(a) (((a) - dyn_mem_map_beg) / PG_SIZE4K)</span>

<span class="cm">/* DMM Mgr */</span>
<span class="k">struct</span> <span class="n">dmm_object</span> <span class="p">{</span>
	<span class="cm">/* Dmm Lock is used to serialize access mem manager for</span>
<span class="cm">	 * multi-threads. */</span>
	<span class="n">spinlock_t</span> <span class="n">dmm_lock</span><span class="p">;</span>	<span class="cm">/* Lock to access dmm mgr */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">map_page</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">region_size</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mapped_size</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mapped</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*  Create the free list */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">virtual_mapping_table</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">free_region</span><span class="p">;</span>		<span class="cm">/* The index of free region */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">free_size</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">dyn_mem_map_beg</span><span class="p">;</span>	<span class="cm">/* The Beginning of dynamic memory mapping */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">table_size</span><span class="p">;</span>		<span class="cm">/* The size of virt and phys pages tables */</span>

<span class="cm">/*  ----------------------------------- Function Prototypes */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">get_region</span><span class="p">(</span><span class="n">u32</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">get_free_region</span><span class="p">(</span><span class="n">u32</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">get_mapped_region</span><span class="p">(</span><span class="n">u32</span> <span class="n">addrs</span><span class="p">);</span>

<span class="cm">/*  ======== dmm_create_tables ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create table to hold the information of physical address</span>
<span class="cm"> *      the buffer pages that is passed by the user, and the table</span>
<span class="cm"> *      to hold the information of the virtual memory that is reserved</span>
<span class="cm"> *      for DSP.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dmm_create_tables</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="p">)</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_delete_tables</span><span class="p">(</span><span class="n">dmm_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dyn_mem_map_beg</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">table_size</span> <span class="o">=</span> <span class="n">PG_ALIGN_HIGH</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">PG_SIZE4K</span><span class="p">)</span> <span class="o">/</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>
		<span class="cm">/*  Create the free list */</span>
		<span class="n">virtual_mapping_table</span> <span class="o">=</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">table_size</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_page</span><span class="p">),</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span>
				<span class="n">__GFP_HIGHMEM</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">virtual_mapping_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* On successful allocation,</span>
<span class="cm">			 * all entries are zero (&#39;free&#39;) */</span>
			<span class="n">free_region</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">free_size</span> <span class="o">=</span> <span class="n">table_size</span> <span class="o">*</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>
			<span class="n">virtual_mapping_table</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">region_size</span> <span class="o">=</span> <span class="n">table_size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: failure, status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dmm_create ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Create a dynamic memory manager object.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dmm_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">**</span><span class="n">dmm_manager</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">dmm_mgrattrs</span> <span class="o">*</span><span class="n">mgr_attrts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dmm_manager</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* create, zero, and tag a cmm mgr object */</span>
	<span class="n">dmm_obj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmm_obj</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_obj</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dmm_manager</span> <span class="o">=</span> <span class="n">dmm_obj</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dmm_destroy ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Release the communication memory manager resources.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dmm_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="p">)</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmm_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_delete_tables</span><span class="p">(</span><span class="n">dmm_obj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dmm_obj</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dmm_delete_tables ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Delete DMM Tables.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dmm_delete_tables</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Delete all DMM tables */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmm_mgr</span><span class="p">)</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">virtual_mapping_table</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dmm_get_handle ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Return the dynamic memory manager object for this device.</span>
<span class="cm"> *      This is typically called from the client process.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dmm_get_handle</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hprocessor</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">**</span><span class="n">dmm_manager</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hprocessor</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">proc_get_dev_object</span><span class="p">(</span><span class="n">hprocessor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdev_obj</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hdev_obj</span> <span class="o">=</span> <span class="n">dev_get_first</span><span class="p">();</span>	<span class="cm">/* default */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_dmm_mgr</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="n">dmm_manager</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dmm_map_memory ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Add a mapping block to the reserved chunk. DMM assumes that this block</span>
<span class="cm"> *  will be mapped in the DSP/IVA&#39;s address space. DMM returns an error if a</span>
<span class="cm"> *  mapping overlaps another one. This function stores the info that will be</span>
<span class="cm"> *  required later while unmapping the block.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dmm_map_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="p">)</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_obj</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>
	<span class="cm">/* Find the Reserved memory chunk containing the DSP block to</span>
<span class="cm">	 * be mapped */</span>
	<span class="n">chunk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="p">)</span><span class="n">get_region</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Mark the region &#39;mapped&#39;, leave the &#39;reserved&#39; info as-is */</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">mapped_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="n">PG_SIZE4K</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_obj</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s dmm_mgr %p, addr %x, size %x</span><span class="se">\n\t</span><span class="s">status %x, &quot;</span>
		<span class="s">&quot;chunk %p&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dmm_reserve_memory ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Reserve a chunk of virtually contiguous DSP/IVA address space.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dmm_reserve_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="o">*</span><span class="n">prsv_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="p">)</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rsv_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rsv_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_obj</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>

	<span class="cm">/* Try to get a DSP chunk from the free list */</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">get_free_region</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  DSP chunk of given size is available. */</span>
		<span class="n">rsv_addr</span> <span class="o">=</span> <span class="n">DMM_ADDR_VIRTUAL</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="cm">/* Calculate the number entries to use */</span>
		<span class="n">rsv_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsv_size</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">region_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Mark remainder of free region */</span>
			<span class="n">node</span><span class="p">[</span><span class="n">rsv_size</span><span class="p">].</span><span class="n">mapped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">node</span><span class="p">[</span><span class="n">rsv_size</span><span class="p">].</span><span class="n">reserved</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">node</span><span class="p">[</span><span class="n">rsv_size</span><span class="p">].</span><span class="n">region_size</span> <span class="o">=</span>
			    <span class="n">node</span><span class="o">-&gt;</span><span class="n">region_size</span> <span class="o">-</span> <span class="n">rsv_size</span><span class="p">;</span>
			<span class="n">node</span><span class="p">[</span><span class="n">rsv_size</span><span class="p">].</span><span class="n">mapped_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*  get_region will return first fit chunk. But we only use what</span>
<span class="cm">		   is requested. */</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">region_size</span> <span class="o">=</span> <span class="n">rsv_size</span><span class="p">;</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">mapped_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Return the chunk&#39;s starting address */</span>
		<span class="o">*</span><span class="n">prsv_addr</span> <span class="o">=</span> <span class="n">rsv_addr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/*dSP chunk of given size is not available */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_obj</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s dmm_mgr %p, size %x, prsv_addr %p</span><span class="se">\n\t</span><span class="s">status %x, &quot;</span>
		<span class="s">&quot;rsv_addr %x, rsv_size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
		<span class="n">prsv_addr</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">rsv_addr</span><span class="p">,</span> <span class="n">rsv_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dmm_un_map_memory ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Remove the mapped block from the reserved chunk.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dmm_un_map_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">psize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="p">)</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_obj</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>
	<span class="n">chunk</span> <span class="o">=</span> <span class="n">get_mapped_region</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Unmap the region */</span>
		<span class="o">*</span><span class="n">psize</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">mapped_size</span> <span class="o">*</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">mapped_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_obj</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: dmm_mgr %p, addr %x, psize %p</span><span class="se">\n\t</span><span class="s">status %x, &quot;</span>
		<span class="s">&quot;chunk %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== dmm_un_reserve_memory ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Free a chunk of reserved DSP/IVA address space.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dmm_un_reserve_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rsv_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="p">)</span><span class="n">dmm_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chunk_size</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_obj</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>

	<span class="cm">/* Find the chunk containing the reserved address */</span>
	<span class="n">chunk</span> <span class="o">=</span> <span class="n">get_mapped_region</span><span class="p">(</span><span class="n">rsv_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Free all the mapped pages for this reserved region */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">region_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mapped</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Remove mapping from the page tables. */</span>
				<span class="n">chunk_size</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mapped_size</span><span class="p">;</span>
				<span class="cm">/* Clear the mapping flags */</span>
				<span class="n">chunk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mapped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">chunk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mapped_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">i</span> <span class="o">+=</span> <span class="n">chunk_size</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Clear the flags (mark the region &#39;free&#39;) */</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="cm">/* NOTE: We do NOT coalesce free regions here.</span>
<span class="cm">		 * Free regions are coalesced in get_region(), as it traverses</span>
<span class="cm">		 *the whole mapping table</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_obj</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: dmm_mgr %p, rsv_addr %x</span><span class="se">\n\t</span><span class="s">status %x chunk %p&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">dmm_mgr</span><span class="p">,</span> <span class="n">rsv_addr</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== get_region ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Returns a region containing the specified memory region</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="nf">get_region</span><span class="p">(</span><span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">curr_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virtual_mapping_table</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* find page mapped by this address */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">DMM_ADDR_TO_INDEX</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">table_size</span><span class="p">)</span>
			<span class="n">curr_region</span> <span class="o">=</span> <span class="n">virtual_mapping_table</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: curr_region %p, free_region %d, free_size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">curr_region</span><span class="p">,</span> <span class="n">free_region</span><span class="p">,</span> <span class="n">free_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">curr_region</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== get_free_region ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *  Returns the requested free region</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="nf">get_free_region</span><span class="p">(</span><span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">curr_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">region_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virtual_mapping_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">curr_region</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">free_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Find the largest free region</span>
<span class="cm">		 * (coalesce during the traversal) */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">table_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">region_size</span> <span class="o">=</span> <span class="n">virtual_mapping_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">region_size</span><span class="p">;</span>
			<span class="n">next_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">region_size</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">virtual_mapping_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reserved</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Coalesce, if possible */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">next_i</span> <span class="o">&lt;</span> <span class="n">table_size</span> <span class="o">&amp;&amp;</span>
				    <span class="n">virtual_mapping_table</span><span class="p">[</span><span class="n">next_i</span><span class="p">].</span><span class="n">reserved</span>
				    <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">virtual_mapping_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">region_size</span> <span class="o">+=</span>
					    <span class="n">virtual_mapping_table</span>
					    <span class="p">[</span><span class="n">next_i</span><span class="p">].</span><span class="n">region_size</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">region_size</span> <span class="o">*=</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">region_size</span> <span class="o">&gt;</span> <span class="n">free_size</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">free_region</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="n">free_size</span> <span class="o">=</span> <span class="n">region_size</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">next_i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">free_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_region</span> <span class="o">=</span> <span class="n">virtual_mapping_table</span> <span class="o">+</span> <span class="n">free_region</span><span class="p">;</span>
		<span class="n">free_region</span> <span class="o">+=</span> <span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="n">PG_SIZE4K</span><span class="p">);</span>
		<span class="n">free_size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">curr_region</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== get_mapped_region ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *  Returns the requestedmapped region</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="nf">get_mapped_region</span><span class="p">(</span><span class="n">u32</span> <span class="n">addrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">curr_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virtual_mapping_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">curr_region</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">DMM_ADDR_TO_INDEX</span><span class="p">(</span><span class="n">addrs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">table_size</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">virtual_mapping_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mapped</span> <span class="o">||</span>
			       <span class="n">virtual_mapping_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reserved</span><span class="p">))</span>
		<span class="n">curr_region</span> <span class="o">=</span> <span class="n">virtual_mapping_table</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">curr_region</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DSP_DMM_DEBUG</span>
<span class="n">u32</span> <span class="nf">dmm_mem_map_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm_object</span> <span class="o">*</span><span class="n">dmm_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_page</span> <span class="o">*</span><span class="n">curr_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">freemem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bigsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_mgr</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virtual_mapping_table</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span>
		     <span class="n">virtual_mapping_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">region_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curr_node</span> <span class="o">=</span> <span class="n">virtual_mapping_table</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_node</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*printk(&quot;RESERVED size = 0x%x, &quot;</span>
<span class="cm">				   &quot;Map size = 0x%x\n&quot;,</span>
<span class="cm">				   (curr_node-&gt;region_size * PG_SIZE4K),</span>
<span class="cm">				   (curr_node-&gt;mapped == false) ? 0 :</span>
<span class="cm">				   (curr_node-&gt;mapped_size * PG_SIZE4K));</span>
<span class="cm">				 */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cm">/*				printk(&quot;UNRESERVED size = 0x%x\n&quot;,</span>
<span class="cm">					(curr_node-&gt;region_size * PG_SIZE4K));</span>
<span class="cm"> */</span>
				<span class="n">freemem</span> <span class="o">+=</span> <span class="p">(</span><span class="n">curr_node</span><span class="o">-&gt;</span><span class="n">region_size</span> <span class="o">*</span> <span class="n">PG_SIZE4K</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">curr_node</span><span class="o">-&gt;</span><span class="n">region_size</span> <span class="o">&gt;</span> <span class="n">bigsize</span><span class="p">)</span>
					<span class="n">bigsize</span> <span class="o">=</span> <span class="n">curr_node</span><span class="o">-&gt;</span><span class="n">region_size</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmm_mgr</span><span class="o">-&gt;</span><span class="n">dmm_lock</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Total DSP VA FREE memory = %d Mbytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">freemem</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Total DSP VA USED memory= %d Mbytes </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(((</span><span class="n">table_size</span> <span class="o">*</span> <span class="n">PG_SIZE4K</span><span class="p">)</span> <span class="o">-</span> <span class="n">freemem</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DSP VA - Biggest FREE block = %d Mbytes </span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">bigsize</span> <span class="o">*</span> <span class="n">PG_SIZE4K</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
