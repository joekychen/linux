<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › core › chnl_sm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>chnl_sm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * chnl_sm.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Implements upper edge functions for Bridge driver channel module.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *      The lower edge functions must be implemented by the Bridge driver</span>
<span class="cm"> *      writer, and are declared in chnl_sm.h.</span>
<span class="cm"> *</span>
<span class="cm"> *      Care is taken in this code to prevent simulataneous access to channel</span>
<span class="cm"> *      queues from</span>
<span class="cm"> *      1. Threads.</span>
<span class="cm"> *      2. io_dpc(), scheduled from the io_isr() as an event.</span>
<span class="cm"> *</span>
<span class="cm"> *      This is done primarily by:</span>
<span class="cm"> *      - Semaphores.</span>
<span class="cm"> *      - state flags in the channel object; and</span>
<span class="cm"> *      - ensuring the IO_Dispatch() routine, which is called from both</span>
<span class="cm"> *        CHNL_AddIOReq() and the DPC(if implemented), is not re-entered.</span>
<span class="cm"> *</span>
<span class="cm"> *  Channel Invariant:</span>
<span class="cm"> *      There is an important invariant condition which must be maintained per</span>
<span class="cm"> *      channel outside of bridge_chnl_get_ioc() and IO_Dispatch(), violation of</span>
<span class="cm"> *      which may cause timeouts and/or failure offunction sync_wait_on_event.</span>
<span class="cm"> *      This invariant condition is:</span>
<span class="cm"> *</span>
<span class="cm"> *          list_empty(&amp;pchnl-&gt;io_completions) ==&gt; pchnl-&gt;sync_event is reset</span>
<span class="cm"> *      and</span>
<span class="cm"> *          !list_empty(&amp;pchnl-&gt;io_completions) ==&gt; pchnl-&gt;sync_event is set.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/*  ----------------------------------- OS */</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>

<span class="cm">/*  ----------------------------------- DSP/BIOS Bridge */</span>
<span class="cp">#include &lt;dspbridge/dbdefs.h&gt;</span>

<span class="cm">/*  ----------------------------------- OS Adaptation Layer */</span>
<span class="cp">#include &lt;dspbridge/sync.h&gt;</span>

<span class="cm">/*  ----------------------------------- Bridge Driver */</span>
<span class="cp">#include &lt;dspbridge/dspdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspchnl.h&gt;</span>
<span class="cp">#include &quot;_tiomap.h&quot;</span>

<span class="cm">/*  ----------------------------------- Platform Manager */</span>
<span class="cp">#include &lt;dspbridge/dev.h&gt;</span>

<span class="cm">/*  ----------------------------------- Others */</span>
<span class="cp">#include &lt;dspbridge/io_sm.h&gt;</span>

<span class="cm">/*  ----------------------------------- Define for This */</span>
<span class="cp">#define USERMODE_ADDR   PAGE_OFFSET</span>

<span class="cp">#define MAILBOX_IRQ INT_MAIL_MPU_IRQ</span>

<span class="cm">/*  ----------------------------------- Function Prototypes */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">create_chirp_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">u32</span> <span class="n">chirps</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">free_chirp_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">search_free_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="o">*</span><span class="n">chnl</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_add_io_req ========</span>
<span class="cm"> *      Enqueue an I/O request for data transfer on a channel to the DSP.</span>
<span class="cm"> *      The direction (mode) is specified in the channel object. Note the DSP</span>
<span class="cm"> *      address is specified for channels opened in direct I/O mode.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_add_io_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">host_buf</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">byte_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">buf_size</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">dw_dsp_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dw_arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="p">)</span><span class="n">chnl_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_irp</span> <span class="o">*</span><span class="n">chnl_packet_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dw_state</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_eos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">host_sys_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">sched_dpc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mb_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">is_eos</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Validate args */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_buf</span> <span class="o">||</span> <span class="o">!</span><span class="n">pchnl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_eos</span> <span class="o">&amp;&amp;</span> <span class="n">CHNL_IS_INPUT</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check the channel state: only queue chirp if channel state</span>
<span class="cm">	 * allows it.</span>
<span class="cm">	 */</span>
	<span class="n">dw_state</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dw_state</span> <span class="o">!=</span> <span class="n">CHNL_STATEREADY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dw_state</span> <span class="o">&amp;</span> <span class="n">CHNL_STATECANCEL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ECANCELED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dw_state</span> <span class="o">&amp;</span> <span class="n">CHNL_STATEEOS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">CHNL_IS_OUTPUT</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="cm">/* No other possible states left */</span>
	<span class="p">}</span>

	<span class="n">dev_obj</span> <span class="o">=</span> <span class="n">dev_get_first</span><span class="p">();</span>
	<span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_ctxt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_ctxt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_type</span> <span class="o">==</span> <span class="n">CHNL_PCPY</span> <span class="o">&amp;&amp;</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">host_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">host_buf</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">USERMODE_ADDR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">host_sys_buf</span> <span class="o">=</span> <span class="n">host_buf</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* if addr in user mode, then copy to kernel space */</span>
		<span class="n">host_sys_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">buf_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_sys_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">CHNL_IS_OUTPUT</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">host_sys_buf</span><span class="p">,</span> <span class="n">host_buf</span><span class="p">,</span>
					<span class="n">buf_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">host_sys_buf</span><span class="p">);</span>
				<span class="n">host_sys_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">func_cont:</span>
	<span class="cm">/* Mailbox IRQ is disabled to avoid race condition with DMA/ZCPY</span>
<span class="cm">	 * channels. DPCCS is held to avoid race conditions with PCPY channels.</span>
<span class="cm">	 * If DPC is scheduled in process context (iosm_schedule) and any</span>
<span class="cm">	 * non-mailbox interrupt occurs, that DPC will run and break CS. Hence</span>
<span class="cm">	 * we disable ALL DPCs. We will try to disable ONLY IO DPC later. */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>
	<span class="n">omap_mbox_disable_irq</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">,</span> <span class="n">IRQ_RX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_type</span> <span class="o">==</span> <span class="n">CHNL_PCPY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is a processor-copy channel. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CHNL_IS_OUTPUT</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Check buffer size on output channels for fit. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">byte_size</span> <span class="o">&gt;</span> <span class="n">io_buf_size</span><span class="p">(</span>
						<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">iomgr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Get a free chirp: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">free_packets_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chnl_packet_obj</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">free_packets_list</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">chnl_irp</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="cm">/* Enqueue the chirp on the chnl&#39;s IORequest queue: */</span>
	<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">host_user_buf</span> <span class="o">=</span> <span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">host_sys_buf</span> <span class="o">=</span>
		<span class="n">host_buf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_type</span> <span class="o">==</span> <span class="n">CHNL_PCPY</span> <span class="o">&amp;&amp;</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">host_sys_buf</span> <span class="o">=</span> <span class="n">host_sys_buf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: for dma chans dw_dsp_addr contains dsp address</span>
<span class="cm">	 * of SM buffer.</span>
<span class="cm">	 */</span>
	<span class="cm">/* DSP address */</span>
	<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">dsp_tx_addr</span> <span class="o">=</span> <span class="n">dw_dsp_addr</span> <span class="o">/</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
	<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">byte_size</span> <span class="o">=</span> <span class="n">byte_size</span><span class="p">;</span>
	<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="cm">/* Only valid for output channel */</span>
	<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">dw_arg</span><span class="p">;</span>
	<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_eos</span> <span class="o">?</span> <span class="n">CHNL_IOCSTATEOS</span> <span class="o">:</span>
			<span class="n">CHNL_IOCSTATCOMPLETE</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">);</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_reqs</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If end of stream, update the channel state to prevent</span>
<span class="cm">	 * more IOR&#39;s.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_eos</span><span class="p">)</span>
		<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">CHNL_STATEEOS</span><span class="p">;</span>

	<span class="cm">/* Request IO from the DSP */</span>
	<span class="n">io_request_chnl</span><span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">iomgr</span><span class="p">,</span> <span class="n">pchnl</span><span class="p">,</span>
			<span class="p">(</span><span class="n">CHNL_IS_INPUT</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">)</span> <span class="o">?</span> <span class="n">IO_INPUT</span> <span class="o">:</span>
			 <span class="n">IO_OUTPUT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mb_val</span><span class="p">);</span>
	<span class="n">sched_dpc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">omap_mbox_enable_irq</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">,</span> <span class="n">IRQ_RX</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mb_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sm_interrupt_dsp</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">mb_val</span><span class="p">);</span>

	<span class="cm">/* Schedule a DPC, to do the actual data transfer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sched_dpc</span><span class="p">)</span>
		<span class="n">iosm_schedule</span><span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">iomgr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_cancel_io ========</span>
<span class="cm"> *      Return all I/O requests to the client which have not yet been</span>
<span class="cm"> *      transferred.  The channel&#39;s I/O completion object is</span>
<span class="cm"> *      signalled, and all the I/O requests are queued as IOC&#39;s, with the</span>
<span class="cm"> *      status field set to CHNL_IOCSTATCANCEL.</span>
<span class="cm"> *      This call is typically used in abort situations, and is a prelude to</span>
<span class="cm"> *      chnl_close();</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_cancel_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="p">)</span><span class="n">chnl_obj</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chnl_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">chnl_mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_irp</span> <span class="o">*</span><span class="n">chirp</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Check args: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pchnl</span> <span class="o">||</span> <span class="o">!</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">chnl_id</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span><span class="p">;</span>
	<span class="n">chnl_mode</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">;</span>
	<span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>

	<span class="cm">/*  Mark this channel as cancelled, to prevent further IORequests or</span>
<span class="cm">	 *  IORequests or dispatching. */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>

	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">CHNL_STATECANCEL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_type</span> <span class="o">==</span> <span class="n">CHNL_PCPY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Indicate we have no more buffers available for transfer: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CHNL_IS_INPUT</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">io_cancel_chnl</span><span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">iomgr</span><span class="p">,</span> <span class="n">chnl_id</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Record that we no longer have output buffers</span>
<span class="cm">			 * available: */</span>
			<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">output_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chnl_id</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Move all IOR&#39;s to IOC queue: */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">chirp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chirp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">chirp</span><span class="o">-&gt;</span><span class="n">byte_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chirp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">CHNL_IOCSTATCANCEL</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chirp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">);</span>
		<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_cs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_reqs</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_close ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Ensures all pending I/O on this channel is cancelled, discards all</span>
<span class="cm"> *      queued I/O completion notifications, then frees the resources allocated</span>
<span class="cm"> *      for this channel, and makes the corresponding logical channel id</span>
<span class="cm"> *      available for subsequent use.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="p">)</span><span class="n">chnl_obj</span><span class="p">;</span>

	<span class="cm">/* Check args: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pchnl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="cm">/* Cancel IO: this ensures no further IO requests or notifications */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">bridge_chnl_cancel_io</span><span class="p">(</span><span class="n">chnl_obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="cm">/* Invalidate channel object: Protects from CHNL_GetIOCompletion() */</span>
	<span class="cm">/* Free the slot in the channel manager: */</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">open_channels</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfy_delete</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
		<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Reset channel event: (NOTE: user_event freed in user context) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sync_reset_event</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span><span class="p">);</span>
		<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Free I/O request and I/O completion queues: */</span>
	<span class="n">free_chirp_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">);</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_cs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">free_chirp_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">);</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_reqs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">free_chirp_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">free_packets_list</span><span class="p">);</span>

	<span class="cm">/* Release channel object. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pchnl</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_create ========</span>
<span class="cm"> *      Create a channel manager object, responsible for opening new channels</span>
<span class="cm"> *      and closing old ones for a given board.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">**</span><span class="n">channel_mgr</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">chnl_mgrattrs</span> <span class="o">*</span><span class="n">mgr_attrts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_channels</span><span class="p">;</span>

	<span class="cm">/* Allocate channel manager object */</span>
	<span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The max_channels attr must equal the # of supported chnls for</span>
<span class="cm">		 * each transport(# chnls for PCPY = DDMA = ZCPY): i.e.</span>
<span class="cm">		 *      mgr_attrts-&gt;max_channels = CHNL_MAXCHANNELS =</span>
<span class="cm">		 *                       DDMA_MAXDDMACHNLS = DDMA_MAXZCPYCHNLS.</span>
<span class="cm">		 */</span>
		<span class="n">max_channels</span> <span class="o">=</span> <span class="n">CHNL_MAXCHANNELS</span> <span class="o">+</span> <span class="n">CHNL_MAXCHANNELS</span> <span class="o">*</span> <span class="n">CHNL_PCPY</span><span class="p">;</span>
		<span class="cm">/* Create array of channels */</span>
		<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="p">)</span>
						<span class="o">*</span> <span class="n">max_channels</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Initialize chnl_mgr object */</span>
			<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">CHNL_TYPESM</span><span class="p">;</span>
			<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="n">mgr_attrts</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
			<span class="cm">/* Total # chnls supported */</span>
			<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">max_channels</span> <span class="o">=</span> <span class="n">max_channels</span><span class="p">;</span>
			<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">open_channels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">output_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">last_output</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>
			<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bridge_chnl_destroy</span><span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="p">);</span>
		<span class="o">*</span><span class="n">channel_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Return channel manager object to caller... */</span>
		<span class="o">*</span><span class="n">channel_mgr</span> <span class="o">=</span> <span class="n">chnl_mgr_obj</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_destroy ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Close all open channels, and destroy the channel manager.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">hchnl_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">hchnl_mgr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chnl_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hchnl_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Close all open channels: */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">chnl_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chnl_id</span> <span class="o">&lt;</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">max_channels</span><span class="p">;</span>
		     <span class="n">chnl_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">bridge_chnl_close</span><span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span>
					      <span class="p">[</span><span class="n">chnl_id</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Error status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Free channel manager object: */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">);</span>

		<span class="cm">/* Set hchnl_mgr to NULL in device object. */</span>
		<span class="n">dev_set_chnl_mgr</span><span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* Free this Chnl Mgr object: */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hchnl_mgr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_flush_io ========</span>
<span class="cm"> *  purpose:</span>
<span class="cm"> *      Flushes all the outstanding data requests on a channel.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_flush_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="p">)</span><span class="n">chnl_obj</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">chnl_mode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_ioc</span> <span class="n">chnl_ioc_obj</span><span class="p">;</span>
	<span class="cm">/* Check args: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">timeout</span> <span class="o">==</span> <span class="n">CHNL_IOCNOWAIT</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">CHNL_IS_OUTPUT</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">chnl_mode</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">;</span>
			<span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Note: Currently, if another thread continues to add IO</span>
<span class="cm">		 * requests to this channel, this function will continue to</span>
<span class="cm">		 * flush all such queued IO requests. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CHNL_IS_OUTPUT</span><span class="p">(</span><span class="n">chnl_mode</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_type</span> <span class="o">==</span> <span class="n">CHNL_PCPY</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Wait for IO completions, up to the specified</span>
<span class="cm">			 * timeout: */</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">bridge_chnl_get_ioc</span><span class="p">(</span><span class="n">chnl_obj</span><span class="p">,</span>
						<span class="n">timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chnl_ioc_obj</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">chnl_ioc_obj</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">CHNL_IOCSTATTIMEOUT</span><span class="p">)</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">bridge_chnl_cancel_io</span><span class="p">(</span><span class="n">chnl_obj</span><span class="p">);</span>
			<span class="cm">/* Now, leave the channel in the ready state: */</span>
			<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CHNL_STATECANCEL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_get_info ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Retrieve information related to a channel.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_get_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">chnl_info</span> <span class="o">*</span><span class="n">channel_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="p">)</span><span class="n">chnl_obj</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel_info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Return the requested information: */</span>
			<span class="n">channel_info</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>
			<span class="n">channel_info</span><span class="o">-&gt;</span><span class="n">event_obj</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">user_event</span><span class="p">;</span>
			<span class="n">channel_info</span><span class="o">-&gt;</span><span class="n">cnhl_id</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span><span class="p">;</span>
			<span class="n">channel_info</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">;</span>
			<span class="n">channel_info</span><span class="o">-&gt;</span><span class="n">bytes_tx</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">bytes_moved</span><span class="p">;</span>
			<span class="n">channel_info</span><span class="o">-&gt;</span><span class="n">process</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">;</span>
			<span class="n">channel_info</span><span class="o">-&gt;</span><span class="n">sync_event</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span><span class="p">;</span>
			<span class="n">channel_info</span><span class="o">-&gt;</span><span class="n">cio_cs</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_cs</span><span class="p">;</span>
			<span class="n">channel_info</span><span class="o">-&gt;</span><span class="n">cio_reqs</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_reqs</span><span class="p">;</span>
			<span class="n">channel_info</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_get_ioc ========</span>
<span class="cm"> *      Optionally wait for I/O completion on a channel.  Dequeue an I/O</span>
<span class="cm"> *      completion record, which contains information about the completed</span>
<span class="cm"> *      I/O request.</span>
<span class="cm"> *      Note: Ensures Channel Invariant (see notes above).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_get_ioc</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">chnl_ioc</span> <span class="o">*</span><span class="n">chan_ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="p">)</span><span class="n">chnl_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_irp</span> <span class="o">*</span><span class="n">chnl_packet_obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stat_sync</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dequeue_ioc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_ioc</span> <span class="n">ioc</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">host_sys_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">;</span>

	<span class="cm">/* Check args: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan_ioc</span> <span class="o">||</span> <span class="o">!</span><span class="n">pchnl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="n">CHNL_IOCNOWAIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="n">dev_obj</span> <span class="o">=</span> <span class="n">dev_get_first</span><span class="p">();</span>
	<span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_ctxt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_ctxt</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">ioc</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CHNL_IOCSTATCOMPLETE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">!=</span>
	    <span class="n">CHNL_IOCNOWAIT</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="n">CHNL_IOCINFINITE</span><span class="p">)</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">SYNC_INFINITE</span><span class="p">;</span>

		<span class="n">stat_sync</span> <span class="o">=</span> <span class="n">sync_wait_on_event</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat_sync</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* No response from DSP */</span>
			<span class="n">ioc</span><span class="p">.</span><span class="n">status</span> <span class="o">|=</span> <span class="n">CHNL_IOCSTATTIMEOUT</span><span class="p">;</span>
			<span class="n">dequeue_ioc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stat_sync</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This can occur when the user mode thread is</span>
<span class="cm">			 * aborted (^C), or when _VWIN32_WaitSingleObject()</span>
<span class="cm">			 * fails due to unknown causes. */</span>
			<span class="cm">/* Even though Wait failed, there may be something in</span>
<span class="cm">			 * the Q: */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ioc</span><span class="p">.</span><span class="n">status</span> <span class="o">|=</span> <span class="n">CHNL_IOCSTATCANCEL</span><span class="p">;</span>
				<span class="n">dequeue_ioc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* See comment in AddIOReq */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>
	<span class="n">omap_mbox_disable_irq</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">,</span> <span class="n">IRQ_RX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dequeue_ioc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Dequeue IOC and set chan_ioc; */</span>
		<span class="n">chnl_packet_obj</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">chnl_irp</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="cm">/* Update chan_ioc from channel state and chirp: */</span>
		<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_cs</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this is a zero-copy channel, then set IOC&#39;s pbuf</span>
<span class="cm">		 * to the DSP&#39;s address. This DSP address will get</span>
<span class="cm">		 * translated to user&#39;s virtual addr later.</span>
<span class="cm">		 */</span>
		<span class="n">host_sys_buf</span> <span class="o">=</span> <span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">host_sys_buf</span><span class="p">;</span>
		<span class="n">ioc</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">host_user_buf</span><span class="p">;</span>
		<span class="n">ioc</span><span class="p">.</span><span class="n">byte_size</span> <span class="o">=</span> <span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">byte_size</span><span class="p">;</span>
		<span class="n">ioc</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">;</span>
		<span class="n">ioc</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
		<span class="n">ioc</span><span class="p">.</span><span class="n">status</span> <span class="o">|=</span> <span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="cm">/* Place the used chirp on the free list: */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">free_packets_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ioc</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ioc</span><span class="p">.</span><span class="n">byte_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ioc</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ioc</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Ensure invariant: If any IOC&#39;s are queued for this channel... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*  Since DSPStream_Reclaim() does not take a timeout</span>
<span class="cm">		 *  parameter, we pass the stream&#39;s timeout value to</span>
<span class="cm">		 *  bridge_chnl_get_ioc. We cannot determine whether or not</span>
<span class="cm">		 *  we have waited in User mode. Since the stream&#39;s timeout</span>
<span class="cm">		 *  value may be non-zero, we still have to set the event.</span>
<span class="cm">		 *  Therefore, this optimization is taken out.</span>
<span class="cm">		 *</span>
<span class="cm">		 *  if (timeout == CHNL_IOCNOWAIT) {</span>
<span class="cm">		 *    ... ensure event is set..</span>
<span class="cm">		 *      sync_set_event(pchnl-&gt;sync_event);</span>
<span class="cm">		 *  } */</span>
		<span class="n">sync_set_event</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* else, if list is empty, ensure event is reset. */</span>
		<span class="n">sync_reset_event</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">omap_mbox_enable_irq</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">,</span> <span class="n">IRQ_RX</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dequeue_ioc</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_type</span> <span class="o">==</span> <span class="n">CHNL_PCPY</span> <span class="o">&amp;&amp;</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ioc</span><span class="p">.</span><span class="n">buf</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">USERMODE_ADDR</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>

		<span class="cm">/* If the addr is in user mode, then copy it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_sys_buf</span> <span class="o">||</span> <span class="o">!</span><span class="n">ioc</span><span class="p">.</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CHNL_IS_INPUT</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">func_cont1</span><span class="p">;</span>

		<span class="cm">/*host_user_buf */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ioc</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">host_sys_buf</span><span class="p">,</span> <span class="n">ioc</span><span class="p">.</span><span class="n">byte_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="nl">func_cont1:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">host_sys_buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_cont:</span>
	<span class="cm">/* Update User&#39;s IOC block: */</span>
	<span class="o">*</span><span class="n">chan_ioc</span> <span class="o">=</span> <span class="n">ioc</span><span class="p">;</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_get_mgr_info ========</span>
<span class="cm"> *      Retrieve information related to the channel manager.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_get_mgr_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">hchnl_mgr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ch_id</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">chnl_mgrinfo</span> <span class="o">*</span><span class="n">mgr_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="p">)</span><span class="n">hchnl_mgr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mgr_info</span> <span class="o">||</span> <span class="o">!</span><span class="n">hchnl_mgr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch_id</span> <span class="o">&gt;</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHRNG</span><span class="p">;</span>

	<span class="cm">/* Return the requested information: */</span>
	<span class="n">mgr_info</span><span class="o">-&gt;</span><span class="n">chnl_obj</span> <span class="o">=</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">ch_id</span><span class="p">];</span>
	<span class="n">mgr_info</span><span class="o">-&gt;</span><span class="n">open_channels</span> <span class="o">=</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">open_channels</span><span class="p">;</span>
	<span class="n">mgr_info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="cm">/* total # of chnls */</span>
	<span class="n">mgr_info</span><span class="o">-&gt;</span><span class="n">max_channels</span> <span class="o">=</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">max_channels</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_idle ========</span>
<span class="cm"> *      Idles a particular channel.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span>
			    <span class="n">bool</span> <span class="n">flush_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s8</span> <span class="n">chnl_mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">chnl_mode</span> <span class="o">=</span> <span class="n">chnl_obj</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">;</span>
	<span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">chnl_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CHNL_IS_OUTPUT</span><span class="p">(</span><span class="n">chnl_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">flush_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Wait for IO completions, up to the specified timeout: */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">bridge_chnl_flush_io</span><span class="p">(</span><span class="n">chnl_obj</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">bridge_chnl_cancel_io</span><span class="p">(</span><span class="n">chnl_obj</span><span class="p">);</span>

		<span class="cm">/* Reset the byte count and put channel back in ready state. */</span>
		<span class="n">chnl_obj</span><span class="o">-&gt;</span><span class="n">bytes_moved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chnl_obj</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CHNL_STATECANCEL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_open ========</span>
<span class="cm"> *      Open a new half-duplex channel to the DSP board.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">**</span><span class="n">chnl</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">hchnl_mgr</span><span class="p">,</span> <span class="n">s8</span> <span class="n">chnl_mode</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">ch_id</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">chnl_attr</span> <span class="o">*</span><span class="n">pattrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">hchnl_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sync_object</span> <span class="o">*</span><span class="n">sync_event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">chnl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Validate Args: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">uio_reqs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hchnl_mgr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch_id</span> <span class="o">!=</span> <span class="n">CHNL_PICKFREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch_id</span> <span class="o">&gt;=</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">max_channels</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ECHRNG</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">ch_id</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Check for free channel */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">search_free_channel</span><span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Create channel object: */</span>
	<span class="n">pchnl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pchnl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Protect queues from io_dpc: */</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CHNL_STATECANCEL</span><span class="p">;</span>

	<span class="cm">/* Allocate initial IOR and IOC queues: */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">create_chirp_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">free_packets_list</span><span class="p">,</span>
			<span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">uio_reqs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">);</span>

	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_packets</span> <span class="o">=</span> <span class="n">pattrs</span><span class="o">-&gt;</span><span class="n">uio_reqs</span><span class="p">;</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_cs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_reqs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sync_event</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sync_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync_event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sync_init_event</span><span class="p">(</span><span class="n">sync_event</span><span class="p">);</span>

	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ntfy_object</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ntfy_init</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>

	<span class="cm">/* Initialize CHNL object fields: */</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">chnl_mgr_obj</span><span class="p">;</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span> <span class="o">=</span> <span class="n">ch_id</span><span class="p">;</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span> <span class="o">=</span> <span class="n">chnl_mode</span><span class="p">;</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">user_event</span> <span class="o">=</span> <span class="n">sync_event</span><span class="p">;</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span> <span class="o">=</span> <span class="n">sync_event</span><span class="p">;</span>
	<span class="cm">/* Get the process handle */</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">process</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cb_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">bytes_moved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Default to proc-copy */</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_type</span> <span class="o">=</span> <span class="n">CHNL_PCPY</span><span class="p">;</span>

	<span class="cm">/* Insert channel object in channel manager: */</span>
	<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">pchnl</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>
	<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">open_channels</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">chnl_mgr_lock</span><span class="p">);</span>
	<span class="cm">/* Return result... */</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CHNL_STATEREADY</span><span class="p">;</span>
	<span class="o">*</span><span class="n">chnl</span> <span class="o">=</span> <span class="n">pchnl</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="cm">/* Free memory */</span>
	<span class="n">free_chirp_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">);</span>
	<span class="n">free_chirp_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">);</span>
	<span class="n">free_chirp_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">free_packets_list</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sync_event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfy_delete</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">);</span>
		<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pchnl</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_chnl_register_notify ========</span>
<span class="cm"> *      Registers for events on a particular channel.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_chnl_register_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">chnl_obj</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">event_mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">notify_type</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dsp_notification</span> <span class="o">*</span><span class="n">hnotification</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">event_mask</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ntfy_register</span><span class="p">(</span><span class="n">chnl_obj</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">hnotification</span><span class="p">,</span>
						<span class="n">event_mask</span><span class="p">,</span> <span class="n">notify_type</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ntfy_unregister</span><span class="p">(</span><span class="n">chnl_obj</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">hnotification</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== create_chirp_list ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Initialize a queue of channel I/O Request/Completion packets.</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *      list:       Pointer to a list_head</span>
<span class="cm"> *      chirps:     Number of Chirps to allocate.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0 if successful, error code otherwise.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *  Ensures:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_chirp_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">u32</span> <span class="n">chirps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chnl_irp</span> <span class="o">*</span><span class="n">chirp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>

	<span class="cm">/* Make N chirps and place on queue. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chirps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chirp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_irp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chirp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chirp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If we couldn&#39;t allocate all chirps, free those allocated: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">chirps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_chirp_list</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== free_chirp_list ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Free the queue of Chirps.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_chirp_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">chirp_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chnl_irp</span> <span class="o">*</span><span class="n">chirp</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">chirp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">chirp_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chirp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">chirp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== search_free_channel ========</span>
<span class="cm"> *      Search for a free channel slot in the array of channel pointers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">search_free_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="o">*</span><span class="n">chnl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSR</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">max_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">*</span><span class="n">chnl</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
