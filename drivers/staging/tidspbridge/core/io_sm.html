<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › core › io_sm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>io_sm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * io_sm.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * IO dispatcher for a shared memory channel driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Channel Invariant:</span>
<span class="cm"> * There is an important invariant condition which must be maintained per</span>
<span class="cm"> * channel outside of bridge_chnl_get_ioc() and IO_Dispatch(), violation of</span>
<span class="cm"> * which may cause timeouts and/or failure of the sync_wait_on_event</span>
<span class="cm"> * function.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="cm">/* Host OS */</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="cm">/*  ----------------------------------- DSP/BIOS Bridge */</span>
<span class="cp">#include &lt;dspbridge/dbdefs.h&gt;</span>

<span class="cm">/* Services Layer */</span>
<span class="cp">#include &lt;dspbridge/ntfy.h&gt;</span>
<span class="cp">#include &lt;dspbridge/sync.h&gt;</span>

<span class="cm">/* Hardware Abstraction Layer */</span>
<span class="cp">#include &lt;hw_defs.h&gt;</span>
<span class="cp">#include &lt;hw_mmu.h&gt;</span>

<span class="cm">/* Bridge Driver */</span>
<span class="cp">#include &lt;dspbridge/dspdeh.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspio.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspioctl.h&gt;</span>
<span class="cp">#include &lt;dspbridge/wdt.h&gt;</span>
<span class="cp">#include &lt;_tiomap.h&gt;</span>
<span class="cp">#include &lt;tiomap_io.h&gt;</span>
<span class="cp">#include &lt;_tiomap_pwr.h&gt;</span>

<span class="cm">/* Platform Manager */</span>
<span class="cp">#include &lt;dspbridge/cod.h&gt;</span>
<span class="cp">#include &lt;dspbridge/node.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dev.h&gt;</span>

<span class="cm">/* Others */</span>
<span class="cp">#include &lt;dspbridge/rms_sh.h&gt;</span>
<span class="cp">#include &lt;dspbridge/mgr.h&gt;</span>
<span class="cp">#include &lt;dspbridge/drv.h&gt;</span>
<span class="cp">#include &quot;_cmm.h&quot;</span>
<span class="cp">#include &quot;module_list.h&quot;</span>

<span class="cm">/* This */</span>
<span class="cp">#include &lt;dspbridge/io_sm.h&gt;</span>
<span class="cp">#include &quot;_msg_sm.h&quot;</span>

<span class="cm">/* Defines, Data Structures, Typedefs */</span>
<span class="cp">#define OUTPUTNOTREADY  0xffff</span>
<span class="cp">#define NOTENABLED      0xffff	</span><span class="cm">/* Channel(s) not enabled */</span><span class="cp"></span>

<span class="cp">#define EXTEND      &quot;_EXT_END&quot;</span>

<span class="cp">#define SWAP_WORD(x)     (x)</span>
<span class="cp">#define UL_PAGE_ALIGN_SIZE 0x10000	</span><span class="cm">/* Page Align Size */</span><span class="cp"></span>

<span class="cp">#define MAX_PM_REQS 32</span>

<span class="cp">#define MMU_FAULT_HEAD1 0xa5a5a5a5</span>
<span class="cp">#define MMU_FAULT_HEAD2 0x96969696</span>
<span class="cp">#define POLL_MAX 1000</span>
<span class="cp">#define MAX_MMU_DBGBUFF 10240</span>

<span class="cm">/* IO Manager: only one created per board */</span>
<span class="k">struct</span> <span class="n">io_mgr</span> <span class="p">{</span>
	<span class="cm">/* These four fields must be the first fields in a io_mgr_ struct */</span>
	<span class="cm">/* Bridge device context */</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">bridge_context</span><span class="p">;</span>
	<span class="cm">/* Function interface to Bridge driver */</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">;</span>	<span class="cm">/* Device this board represents */</span>

	<span class="cm">/* These fields initialized in bridge_io_create() */</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shm</span> <span class="o">*</span><span class="n">shared_mem</span><span class="p">;</span>	<span class="cm">/* Shared Memory control */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">input</span><span class="p">;</span>		<span class="cm">/* Address of input channel */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">output</span><span class="p">;</span>		<span class="cm">/* Address of output channel */</span>
	<span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">msg_mgr</span><span class="p">;</span>	<span class="cm">/* Message manager */</span>
	<span class="cm">/* Msg control for from DSP messages */</span>
	<span class="k">struct</span> <span class="n">msg_ctrl</span> <span class="o">*</span><span class="n">msg_input_ctrl</span><span class="p">;</span>
	<span class="cm">/* Msg control for to DSP messages */</span>
	<span class="k">struct</span> <span class="n">msg_ctrl</span> <span class="o">*</span><span class="n">msg_output_ctrl</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">msg_input</span><span class="p">;</span>		<span class="cm">/* Address of input messages */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">msg_output</span><span class="p">;</span>		<span class="cm">/* Address of output messages */</span>
	<span class="n">u32</span> <span class="n">sm_buf_size</span><span class="p">;</span>	<span class="cm">/* Size of a shared memory I/O channel */</span>
	<span class="n">bool</span> <span class="n">shared_irq</span><span class="p">;</span>	<span class="cm">/* Is this IRQ shared? */</span>
	<span class="n">u32</span> <span class="n">word_size</span><span class="p">;</span>		<span class="cm">/* Size in bytes of DSP word */</span>
	<span class="n">u16</span> <span class="n">intr_val</span><span class="p">;</span>		<span class="cm">/* Interrupt value */</span>
	<span class="cm">/* Private extnd proc info; mmu setup */</span>
	<span class="k">struct</span> <span class="n">mgr_processorextinfo</span> <span class="n">ext_proc_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmm_object</span> <span class="o">*</span><span class="n">cmm_mgr</span><span class="p">;</span>	<span class="cm">/* Shared Mem Mngr */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">io_workq</span><span class="p">;</span>	<span class="cm">/* workqueue */</span>
<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_BACKTRACE)</span>
	<span class="n">u32</span> <span class="n">trace_buffer_begin</span><span class="p">;</span>	<span class="cm">/* Trace message start address */</span>
	<span class="n">u32</span> <span class="n">trace_buffer_end</span><span class="p">;</span>	<span class="cm">/* Trace message end address */</span>
	<span class="n">u32</span> <span class="n">trace_buffer_current</span><span class="p">;</span>	<span class="cm">/* Trace message current address */</span>
	<span class="n">u32</span> <span class="n">gpp_read_pointer</span><span class="p">;</span>		<span class="cm">/* GPP Read pointer to Trace buffer */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpp_va</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dsp_va</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* IO Dpc */</span>
	<span class="n">u32</span> <span class="n">dpc_req</span><span class="p">;</span>		<span class="cm">/* Number of requested DPC&#39;s. */</span>
	<span class="n">u32</span> <span class="n">dpc_sched</span><span class="p">;</span>		<span class="cm">/* Number of executed DPC&#39;s. */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">dpc_tasklet</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">dpc_lock</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/* Function Prototypes */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">io_dispatch_pm</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">notify_chnl_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">chnl_irp</span> <span class="o">*</span><span class="n">chnl_packet_obj</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">input_chnl</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">io_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">output_chnl</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">io_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">input_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmsg_mgr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">output_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmsg_mgr</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">find_ready_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>

<span class="cm">/* Bus Addr (cached kernel) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">register_shm_segs</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">cod_man</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">dw_gpp_base_pa</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_chnl_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">shm</span> <span class="o">*</span><span class="n">sm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">chnl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">host_free_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chnl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_chnl_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">shm</span> <span class="o">*</span><span class="n">sm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">chnl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">host_free_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chnl</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_io_create ========</span>
<span class="cm"> *      Create an IO manager object.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_io_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">**</span><span class="n">io_man</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">io_attrs</span> <span class="o">*</span><span class="n">mgr_attrts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">hbridge_context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg_devnode</span> <span class="o">*</span><span class="n">dev_node_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">hchnl_mgr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dev_type</span><span class="p">;</span>

	<span class="cm">/* Check requirements */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_man</span> <span class="o">||</span> <span class="o">!</span><span class="n">mgr_attrts</span> <span class="o">||</span> <span class="n">mgr_attrts</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="o">*</span><span class="n">io_man</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_get_chnl_mgr</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hchnl_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hchnl_mgr</span> <span class="o">||</span> <span class="n">hchnl_mgr</span><span class="o">-&gt;</span><span class="n">iomgr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Message manager will be created when a file is loaded, since</span>
<span class="cm">	 * size of message buffer in shared memory is configurable in</span>
<span class="cm">	 * the base image.</span>
<span class="cm">	 */</span>
	<span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hbridge_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hbridge_context</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">dev_get_dev_type</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_type</span><span class="p">);</span>

	<span class="cm">/* Allocate IO manager object */</span>
	<span class="n">pio_mgr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio_mgr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Initialize chnl_mgr object */</span>
	<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span> <span class="o">=</span> <span class="n">hchnl_mgr</span><span class="p">;</span>
	<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="n">mgr_attrts</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_type</span> <span class="o">==</span> <span class="n">DSP_UNIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Create an IO DPC */</span>
		<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_tasklet</span><span class="p">,</span> <span class="n">io_dpc</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pio_mgr</span><span class="p">);</span>

		<span class="cm">/* Initialize DPC counters */</span>
		<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_sched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev_get_dev_node</span><span class="p">(</span><span class="n">hdev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_node_obj</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bridge_io_destroy</span><span class="p">(</span><span class="n">pio_mgr</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span> <span class="o">=</span> <span class="n">hbridge_context</span><span class="p">;</span>
	<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">shared_irq</span> <span class="o">=</span> <span class="n">mgr_attrts</span><span class="o">-&gt;</span><span class="n">irq_shared</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dsp_wdt_init</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">bridge_io_destroy</span><span class="p">(</span><span class="n">pio_mgr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Return IO manager object to caller... */</span>
	<span class="n">hchnl_mgr</span><span class="o">-&gt;</span><span class="n">iomgr</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">io_man</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_io_destroy ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Disable interrupts, destroy the IO manager.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_io_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hio_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Free IO DPC object */</span>
		<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_tasklet</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_BACKTRACE)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">dsp_wdt_exit</span><span class="p">();</span>
		<span class="cm">/* Free this IO manager object */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hio_mgr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_io_on_loaded ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Called when a new program is loaded to get shared memory buffer</span>
<span class="cm"> *      parameters from COFF file. ulSharedBufferBase and ulSharedBufferLimit</span>
<span class="cm"> *      are in DSP address units.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_io_on_loaded</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">cod_man</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">hchnl_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmsg_mgr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_shm_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_shm_base_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_shm_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_shm_length</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_mem_length</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_msg_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_msg_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_msg_length</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_ext_end</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_gpp_pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_gpp_va</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_dsp_va</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_seg_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_pad_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_procs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ndx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* DSP MMU setup table */</span>
	<span class="k">struct</span> <span class="n">bridge_ioctl_extproc</span> <span class="n">ae_proc</span><span class="p">[</span><span class="n">BRDIOCTL_NUMOFMMUTLB</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">host_res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">pbridge_context</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">map_attrs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">shm0_end</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_dyn_ext_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_seg1_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa_curr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">va_curr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpp_va_curr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">all_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page_size</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">HW_PAGE_SIZE16MB</span><span class="p">,</span> <span class="n">HW_PAGE_SIZE1MB</span><span class="p">,</span>
		<span class="n">HW_PAGE_SIZE64KB</span><span class="p">,</span> <span class="n">HW_PAGE_SIZE4KB</span>
	<span class="p">};</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_bridge_context</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbridge_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pbridge_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">host_res</span> <span class="o">=</span> <span class="n">pbridge_context</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_cod_mgr</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cod_man</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cod_man</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hchnl_mgr</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span><span class="p">;</span>
	<span class="cm">/* The message manager is destroyed when the board is stopped. */</span>
	<span class="n">dev_get_msg_mgr</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_mgr</span><span class="p">);</span>
	<span class="n">hmsg_mgr</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_mgr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hchnl_mgr</span> <span class="o">||</span> <span class="o">!</span><span class="n">hmsg_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="p">)</span>
		<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Get start and length of channel part of shared memory */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">CHNL_SHARED_BUFFER_BASE_SYM</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">ul_shm_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">CHNL_SHARED_BUFFER_LIMIT_SYM</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">ul_shm_limit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ul_shm_limit</span> <span class="o">&lt;=</span> <span class="n">ul_shm_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Get total length in bytes */</span>
	<span class="n">ul_shm_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">ul_shm_limit</span> <span class="o">-</span> <span class="n">ul_shm_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
	<span class="cm">/* Calculate size of a PROCCOPY shared memory region */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: (proc)proccopy shmmem size: 0x%x bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="n">ul_shm_length</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shm</span><span class="p">)));</span>

	<span class="cm">/* Get start and length of message part of shared memory */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">MSG_SHARED_BUFFER_BASE_SYM</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">ul_msg_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">MSG_SHARED_BUFFER_LIMIT_SYM</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">ul_msg_limit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ul_msg_limit</span> <span class="o">&lt;=</span> <span class="n">ul_msg_base</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Length (bytes) of messaging part of shared</span>
<span class="cm">				 * memory.</span>
<span class="cm">				 */</span>
				<span class="n">ul_msg_length</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">ul_msg_limit</span> <span class="o">-</span> <span class="n">ul_msg_base</span> <span class="o">+</span>
				     <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * Total length (bytes) of shared memory:</span>
<span class="cm">				 * chnl + msg.</span>
<span class="cm">				 */</span>
				<span class="n">ul_mem_length</span> <span class="o">=</span> <span class="n">ul_shm_length</span> <span class="o">+</span> <span class="n">ul_msg_length</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_BACKTRACE)</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">DSP_TRACESEC_END</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shm0_end</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">SHM0_SHARED_END_SYM</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">shm0_end</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">DYNEXTBASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_dyn_ext_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">EXTEND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_ext_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get memory reserved in host resources */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">mgr_enum_processor_info</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsp_processorinfo</span> <span class="o">*</span><span class="p">)</span>
					      <span class="o">&amp;</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">,</span>
					      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span>
						     <span class="n">mgr_processorextinfo</span><span class="p">),</span>
					      <span class="o">&amp;</span><span class="n">num_procs</span><span class="p">);</span>

		<span class="cm">/* The first MMU TLB entry(TLB_0) in DCD is ShmBase. */</span>
		<span class="n">ndx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ul_gpp_pa</span> <span class="o">=</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_phys</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">ul_gpp_va</span> <span class="o">=</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="cm">/* This is the virtual uncached ioremapped address!!! */</span>
		<span class="cm">/* Why can&#39;t we directly take the DSPVA from the symbols? */</span>
		<span class="n">ul_dsp_va</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dsp_virt</span><span class="p">;</span>
		<span class="n">ul_seg_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">shm0_end</span> <span class="o">-</span> <span class="n">ul_dsp_va</span><span class="p">)</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
		<span class="n">ul_seg1_size</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">ul_ext_end</span> <span class="o">-</span> <span class="n">ul_dyn_ext_base</span><span class="p">)</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
		<span class="cm">/* 4K align */</span>
		<span class="n">ul_seg1_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ul_seg1_size</span> <span class="o">+</span> <span class="mh">0xFFF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0xFFFUL</span><span class="p">);</span>
		<span class="cm">/* 64K align */</span>
		<span class="n">ul_seg_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ul_seg_size</span> <span class="o">+</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0xFFFFUL</span><span class="p">);</span>
		<span class="n">ul_pad_size</span> <span class="o">=</span> <span class="n">UL_PAGE_ALIGN_SIZE</span> <span class="o">-</span> <span class="p">((</span><span class="n">ul_gpp_pa</span> <span class="o">+</span> <span class="n">ul_seg1_size</span><span class="p">)</span> <span class="o">%</span>
						    <span class="n">UL_PAGE_ALIGN_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ul_pad_size</span> <span class="o">==</span> <span class="n">UL_PAGE_ALIGN_SIZE</span><span class="p">)</span>
			<span class="n">ul_pad_size</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: ul_gpp_pa %x, ul_gpp_va %x, ul_dsp_va %x, &quot;</span>
			<span class="s">&quot;shm0_end %x, ul_dyn_ext_base %x, ul_ext_end %x, &quot;</span>
			<span class="s">&quot;ul_seg_size %x ul_seg1_size %x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">ul_gpp_pa</span><span class="p">,</span> <span class="n">ul_gpp_va</span><span class="p">,</span> <span class="n">ul_dsp_va</span><span class="p">,</span> <span class="n">shm0_end</span><span class="p">,</span>
			<span class="n">ul_dyn_ext_base</span><span class="p">,</span> <span class="n">ul_ext_end</span><span class="p">,</span> <span class="n">ul_seg_size</span><span class="p">,</span> <span class="n">ul_seg1_size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ul_seg_size</span> <span class="o">+</span> <span class="n">ul_seg1_size</span> <span class="o">+</span> <span class="n">ul_pad_size</span><span class="p">)</span> <span class="o">&gt;</span>
		    <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_length</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: shm Error, reserved 0x%x required 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_length</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			       <span class="n">ul_seg_size</span> <span class="o">+</span> <span class="n">ul_seg1_size</span> <span class="o">+</span> <span class="n">ul_pad_size</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">pa_curr</span> <span class="o">=</span> <span class="n">ul_gpp_pa</span><span class="p">;</span>
	<span class="n">va_curr</span> <span class="o">=</span> <span class="n">ul_dyn_ext_base</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
	<span class="n">gpp_va_curr</span> <span class="o">=</span> <span class="n">ul_gpp_va</span><span class="p">;</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">ul_seg1_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to fit into TLB entries. If not possible, push them to page</span>
<span class="cm">	 * tables. It is quite possible that if sections are not on</span>
<span class="cm">	 * bigger page boundary, we may end up making several small pages.</span>
<span class="cm">	 * So, push them onto page tables, if that is the case.</span>
<span class="cm">	 */</span>
	<span class="n">map_attrs</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="n">map_attrs</span> <span class="o">=</span> <span class="n">DSP_MAPLITTLEENDIAN</span><span class="p">;</span>
	<span class="n">map_attrs</span> <span class="o">|=</span> <span class="n">DSP_MAPPHYSICALADDR</span><span class="p">;</span>
	<span class="n">map_attrs</span> <span class="o">|=</span> <span class="n">DSP_MAPELEMSIZE32</span><span class="p">;</span>
	<span class="n">map_attrs</span> <span class="o">|=</span> <span class="n">DSP_MAPDONOTLOCK</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">num_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * To find the max. page size with which both PA &amp; VA are</span>
<span class="cm">		 * aligned.</span>
<span class="cm">		 */</span>
		<span class="n">all_bits</span> <span class="o">=</span> <span class="n">pa_curr</span> <span class="o">|</span> <span class="n">va_curr</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;all_bits %x, pa_curr %x, va_curr %x, &quot;</span>
			<span class="s">&quot;num_bytes %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">all_bits</span><span class="p">,</span> <span class="n">pa_curr</span><span class="p">,</span> <span class="n">va_curr</span><span class="p">,</span>
			<span class="n">num_bytes</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">num_bytes</span> <span class="o">&gt;=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">all_bits</span> <span class="o">&amp;</span>
							     <span class="p">(</span><span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
							      <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span>
				    <span class="n">brd_mem_map</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span>
						    <span class="n">pa_curr</span><span class="p">,</span> <span class="n">va_curr</span><span class="p">,</span>
						    <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">map_attrs</span><span class="p">,</span>
						    <span class="nb">NULL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
				<span class="n">pa_curr</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">va_curr</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">gpp_va_curr</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">num_bytes</span> <span class="o">-=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="cm">/*</span>
<span class="cm">				 * Don&#39;t try smaller sizes. Hopefully we have</span>
<span class="cm">				 * reached an address aligned to a bigger page</span>
<span class="cm">				 * size.</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pa_curr</span> <span class="o">+=</span> <span class="n">ul_pad_size</span><span class="p">;</span>
	<span class="n">va_curr</span> <span class="o">+=</span> <span class="n">ul_pad_size</span><span class="p">;</span>
	<span class="n">gpp_va_curr</span> <span class="o">+=</span> <span class="n">ul_pad_size</span><span class="p">;</span>

	<span class="cm">/* Configure the TLB entries for the next cacheable segment */</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">ul_seg_size</span><span class="p">;</span>
	<span class="n">va_curr</span> <span class="o">=</span> <span class="n">ul_dsp_va</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * To find the max. page size with which both PA &amp; VA are</span>
<span class="cm">		 * aligned.</span>
<span class="cm">		 */</span>
		<span class="n">all_bits</span> <span class="o">=</span> <span class="n">pa_curr</span> <span class="o">|</span> <span class="n">va_curr</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;all_bits for Seg1 %x, pa_curr %x, &quot;</span>
			<span class="s">&quot;va_curr %x, num_bytes %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">all_bits</span><span class="p">,</span> <span class="n">pa_curr</span><span class="p">,</span>
			<span class="n">va_curr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">num_bytes</span> <span class="o">&gt;=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">||</span>
			    <span class="o">!</span><span class="p">((</span><span class="n">all_bits</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndx</span> <span class="o">&lt;</span> <span class="n">MAX_LOCK_TLB_ENTRIES</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * This is the physical address written to</span>
<span class="cm">				 * DSP MMU.</span>
<span class="cm">				 */</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">gpp_pa</span> <span class="o">=</span> <span class="n">pa_curr</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * This is the virtual uncached ioremapped</span>
<span class="cm">				 * address!!!</span>
<span class="cm">				 */</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">gpp_va</span> <span class="o">=</span> <span class="n">gpp_va_curr</span><span class="p">;</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">dsp_va</span> <span class="o">=</span>
				    <span class="n">va_curr</span> <span class="o">/</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">endianism</span> <span class="o">=</span> <span class="n">HW_LITTLE_ENDIAN</span><span class="p">;</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">elem_size</span> <span class="o">=</span> <span class="n">HW_ELEM_SIZE16BIT</span><span class="p">;</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">mixed_mode</span> <span class="o">=</span> <span class="n">HW_MMU_CPUES</span><span class="p">;</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;shm MMU TLB entry PA %x&quot;</span>
					<span class="s">&quot; VA %x DSP_VA %x Size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">gpp_pa</span><span class="p">,</span>
					<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">gpp_va</span><span class="p">,</span>
					<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">dsp_va</span> <span class="o">*</span>
					<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">,</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">ndx</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span>
				    <span class="n">brd_mem_map</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span>
						    <span class="n">pa_curr</span><span class="p">,</span> <span class="n">va_curr</span><span class="p">,</span>
						    <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">map_attrs</span><span class="p">,</span>
						    <span class="nb">NULL</span><span class="p">);</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
					<span class="s">&quot;shm MMU PTE entry PA %x&quot;</span>
					<span class="s">&quot; VA %x DSP_VA %x Size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">gpp_pa</span><span class="p">,</span>
					<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">gpp_va</span><span class="p">,</span>
					<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">dsp_va</span> <span class="o">*</span>
					<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">,</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pa_curr</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">va_curr</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">gpp_va_curr</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">num_bytes</span> <span class="o">-=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t try smaller sizes. Hopefully we have reached</span>
<span class="cm">			 * an address aligned to a bigger page size.</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy remaining entries from CDB. All entries are 1 MB and</span>
<span class="cm">	 * should not conflict with shm entries on MPU or DSP side.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span> <span class="o">&amp;&amp;</span> <span class="n">ndx</span> <span class="o">&lt;</span> <span class="n">BRDIOCTL_NUMOFMMUTLB</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gpp_phys</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gpp_phys</span> <span class="o">&gt;</span>
		     <span class="n">ul_gpp_pa</span> <span class="o">-</span> <span class="mh">0x100000</span>
		     <span class="o">&amp;&amp;</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gpp_phys</span> <span class="o">&lt;=</span>
		     <span class="n">ul_gpp_pa</span> <span class="o">+</span> <span class="n">ul_seg_size</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dsp_virt</span> <span class="o">&gt;</span>
			<span class="n">ul_dsp_va</span> <span class="o">-</span> <span class="mh">0x100000</span> <span class="o">/</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span>
			<span class="o">&amp;&amp;</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dsp_virt</span> <span class="o">&lt;=</span>
			<span class="n">ul_dsp_va</span> <span class="o">+</span> <span class="n">ul_seg_size</span> <span class="o">/</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
				<span class="s">&quot;CDB MMU entry %d conflicts with &quot;</span>
				<span class="s">&quot;shm.</span><span class="se">\n\t</span><span class="s">CDB: GppPa %x, DspVa %x.</span><span class="se">\n\t</span><span class="s">SHM: &quot;</span>
				<span class="s">&quot;GppPa %x, DspVa %x, Bytes %x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gpp_phys</span><span class="p">,</span>
				<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dsp_virt</span><span class="p">,</span>
				<span class="n">ul_gpp_pa</span><span class="p">,</span> <span class="n">ul_dsp_va</span><span class="p">,</span> <span class="n">ul_seg_size</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndx</span> <span class="o">&lt;</span> <span class="n">MAX_LOCK_TLB_ENTRIES</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">dsp_va</span> <span class="o">=</span>
				    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
				    <span class="n">dsp_virt</span><span class="p">;</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">gpp_pa</span> <span class="o">=</span>
				    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
				    <span class="n">gpp_phys</span><span class="p">;</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">gpp_va</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="cm">/* 1 MB */</span>
				<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x100000</span><span class="p">;</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;shm MMU entry PA %x &quot;</span>
					<span class="s">&quot;DSP_VA 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">gpp_pa</span><span class="p">,</span>
					<span class="n">ae_proc</span><span class="p">[</span><span class="n">ndx</span><span class="p">].</span><span class="n">dsp_va</span><span class="p">);</span>
				<span class="n">ndx</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_mem_map</span>
				    <span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span>
				     <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
				     <span class="n">gpp_phys</span><span class="p">,</span>
				     <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
				     <span class="n">dsp_virt</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="n">map_attrs</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">map_attrs</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="n">map_attrs</span> <span class="o">=</span> <span class="n">DSP_MAPLITTLEENDIAN</span><span class="p">;</span>
	<span class="n">map_attrs</span> <span class="o">|=</span> <span class="n">DSP_MAPPHYSICALADDR</span><span class="p">;</span>
	<span class="n">map_attrs</span> <span class="o">|=</span> <span class="n">DSP_MAPELEMSIZE32</span><span class="p">;</span>
	<span class="n">map_attrs</span> <span class="o">|=</span> <span class="n">DSP_MAPDONOTLOCK</span><span class="p">;</span>

	<span class="cm">/* Map the L4 peripherals */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">l4_peripheral_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_mem_map</span>
		    <span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">l4_peripheral_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span>
		     <span class="n">l4_peripheral_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dsp_virt_addr</span><span class="p">,</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">,</span>
		     <span class="n">map_attrs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ndx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BRDIOCTL_NUMOFMMUTLB</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ae_proc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dsp_va</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ae_proc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gpp_pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ae_proc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gpp_va</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ae_proc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set the shm physical address entry (grayed out in CDB file)</span>
<span class="cm">	 * to the virtual uncached ioremapped address of shm reserved</span>
<span class="cm">	 * on MPU.</span>
<span class="cm">	 */</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gpp_phys</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">ul_gpp_va</span> <span class="o">+</span> <span class="n">ul_seg1_size</span> <span class="o">+</span> <span class="n">ul_pad_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need shm Phys addr. IO supports only one DSP for now:</span>
<span class="cm">	 * num_procs = 1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gpp_phys</span> <span class="o">||</span> <span class="n">num_procs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ae_proc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dsp_va</span> <span class="o">&gt;</span> <span class="n">ul_shm_base</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* ul_shm_base may not be at ul_dsp_va address */</span>
		<span class="n">ul_shm_base_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ul_shm_base</span> <span class="o">-</span> <span class="n">ae_proc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dsp_va</span><span class="p">)</span> <span class="o">*</span>
		    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * bridge_dev_ctrl() will set dev context dsp-mmu info. In</span>
<span class="cm">		 * bridge_brd_start() the MMU will be re-programed with MMU</span>
<span class="cm">		 * DSPVa-GPPPa pair info while DSP is in a known</span>
<span class="cm">		 * (reset) state.</span>
<span class="cm">		 */</span>

		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">dev_cntrl</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span>
						      <span class="n">BRDIOCTL_SETMMUCONFIG</span><span class="p">,</span>
						      <span class="n">ae_proc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="n">ul_shm_base</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gpp_phys</span><span class="p">;</span>
		<span class="n">ul_shm_base</span> <span class="o">+=</span> <span class="n">ul_shm_base_offset</span><span class="p">;</span>
		<span class="n">ul_shm_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">MEM_LINEAR_ADDRESS</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ul_shm_base</span><span class="p">,</span>
						       <span class="n">ul_mem_length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ul_shm_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Register SM */</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">register_shm_segs</span><span class="p">(</span><span class="n">hio_mgr</span><span class="p">,</span> <span class="n">cod_man</span><span class="p">,</span> <span class="n">ae_proc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gpp_pa</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">shm</span> <span class="o">*</span><span class="p">)</span><span class="n">ul_shm_base</span><span class="p">;</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">input</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shm</span><span class="p">);</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">input</span> <span class="o">+</span> <span class="p">(</span><span class="n">ul_shm_length</span> <span class="o">-</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shm</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">sm_buf_size</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">-</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">;</span>

	<span class="cm">/*  Set up Shared memory addresses for messaging. */</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_input_ctrl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_ctrl</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span>
						      <span class="o">+</span> <span class="n">ul_shm_length</span><span class="p">);</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_input</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_input_ctrl</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_ctrl</span><span class="p">);</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_output_ctrl</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">msg_ctrl</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_input_ctrl</span> <span class="o">+</span>
				<span class="n">ul_msg_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_output</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_output_ctrl</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_ctrl</span><span class="p">);</span>
	<span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">max_msgs</span> <span class="o">=</span>
	    <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_output_ctrl</span> <span class="o">-</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_input</span><span class="p">)</span>
	    <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_dspmsg</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;IO MGR shm details: shared_mem %p, input %p, &quot;</span>
		<span class="s">&quot;output %p, msg_input_ctrl %p, msg_input %p, &quot;</span>
		<span class="s">&quot;msg_output_ctrl %p, msg_output %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="p">,</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">,</span>
		<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_input_ctrl</span><span class="p">,</span>
		<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_input</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_output_ctrl</span><span class="p">,</span>
		<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg_output</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;(proc) Mas msgs in shared memory: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">max_msgs</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shm</span><span class="p">));</span>

<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_BACKTRACE)</span>
	<span class="cm">/* Get the start address of trace buffer */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">SYS_PUTCBEG</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_begin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_begin</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">ul_gpp_va</span> <span class="o">+</span> <span class="n">ul_seg1_size</span> <span class="o">+</span> <span class="n">ul_pad_size</span><span class="p">)</span> <span class="o">+</span>
	    <span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_begin</span> <span class="o">-</span> <span class="n">ul_dsp_va</span><span class="p">);</span>
	<span class="cm">/* Get the end address of trace buffer */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">SYS_PUTCEND</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_end</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">ul_gpp_va</span> <span class="o">+</span> <span class="n">ul_seg1_size</span> <span class="o">+</span> <span class="n">ul_pad_size</span><span class="p">)</span> <span class="o">+</span>
	    <span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_end</span> <span class="o">-</span> <span class="n">ul_dsp_va</span><span class="p">);</span>
	<span class="cm">/* Get the current address of DSP write pointer */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">BRIDGE_SYS_PUTC_CURRENT</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_current</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_current</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">ul_gpp_va</span> <span class="o">+</span> <span class="n">ul_seg1_size</span> <span class="o">+</span> <span class="n">ul_pad_size</span><span class="p">)</span> <span class="o">+</span>
	    <span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_current</span> <span class="o">-</span> <span class="n">ul_dsp_va</span><span class="p">);</span>
	<span class="cm">/* Calculate the size of trace buffer */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(((</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_end</span> <span class="o">-</span>
				<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_begin</span><span class="p">)</span> <span class="o">*</span>
				<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">dsp_va</span> <span class="o">=</span> <span class="n">ul_dsp_va</span><span class="p">;</span>
	<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_va</span> <span class="o">=</span> <span class="p">(</span><span class="n">ul_gpp_va</span> <span class="o">+</span> <span class="n">ul_seg1_size</span> <span class="o">+</span> <span class="n">ul_pad_size</span><span class="p">);</span>

<span class="cp">#endif</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== io_buf_size ========</span>
<span class="cm"> *      Size of shared memory I/O channel.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">io_buf_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hio_mgr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">sm_buf_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== io_cancel_chnl ========</span>
<span class="cm"> *      Cancel IO on a given PCPY channel.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">io_cancel_chnl</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">chnl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="p">)</span><span class="n">hio_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shm</span> <span class="o">*</span><span class="n">sm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hio_mgr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="n">sm</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="p">;</span>

	<span class="cm">/* Inform DSP that we have no more buffers on this channel */</span>
	<span class="n">set_chnl_free</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">chnl</span><span class="p">);</span>

	<span class="n">sm_interrupt_dsp</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">MBX_PCPY_CLASS</span><span class="p">);</span>
<span class="nl">func_end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  ======== io_dispatch_pm ========</span>
<span class="cm"> *      Performs I/O dispatch on PM related messages from DSP</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">io_dispatch_pm</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">parg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/* Perform Power message processing here */</span>
	<span class="n">parg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intr_val</span><span class="p">;</span>

	<span class="cm">/* Send the command to the Bridge clk/pwr manager to handle */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MBX_PM_HIBERNATE_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;PM: Hibernate command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span>
				<span class="n">dev_cntrl</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span>
					      <span class="n">BRDIOCTL_PWR_HIBERNATE</span><span class="p">,</span> <span class="n">parg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: hibernate cmd failed 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">parg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MBX_PM_OPP_REQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">opp_request</span><span class="p">.</span><span class="n">rqst_opp_pt</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;PM: Requested OPP = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">parg</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span>
				<span class="n">dev_cntrl</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span>
					<span class="n">BRDIOCTL_CONSTRAINT_REQUEST</span><span class="p">,</span> <span class="n">parg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;PM: Failed to set constraint &quot;</span>
				<span class="s">&quot;= 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">parg</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;PM: clk control value of msg = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">parg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intf_fxns</span><span class="o">-&gt;</span>
				<span class="n">dev_cntrl</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span>
					      <span class="n">BRDIOCTL_CLK_CTRL</span><span class="p">,</span> <span class="n">parg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;PM: Failed to ctrl the DSP clk&quot;</span>
				<span class="s">&quot;= 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">parg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== io_dpc ========</span>
<span class="cm"> *      Deferred procedure call for shared memory channel driver ISR.  Carries</span>
<span class="cm"> *      out the dispatch of I/O as a non-preemptible event.It can only be</span>
<span class="cm"> *      pre-empted      by an ISR.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">io_dpc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ref_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="p">)</span><span class="n">ref_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">msg_mgr_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">deh_mgr</span> <span class="o">*</span><span class="n">hdeh_mgr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">requested</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">serviced</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio_mgr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span><span class="p">;</span>
	<span class="n">dev_get_msg_mgr</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_mgr_obj</span><span class="p">);</span>
	<span class="n">dev_get_deh_mgr</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdeh_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chnl_mgr_obj</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">requested</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_req</span><span class="p">;</span>
	<span class="n">serviced</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_sched</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serviced</span> <span class="o">==</span> <span class="n">requested</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* Process pending DPC&#39;s */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Check value of interrupt reg to ensure it&#39;s a valid error */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intr_val</span> <span class="o">&gt;</span> <span class="n">DEH_BASE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intr_val</span> <span class="o">&lt;</span> <span class="n">DEH_LIMIT</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Notify DSP/BIOS exception */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hdeh_mgr</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE</span>
				<span class="n">print_dsp_debug_trace</span><span class="p">(</span><span class="n">pio_mgr</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="n">bridge_deh_notify</span><span class="p">(</span><span class="n">hdeh_mgr</span><span class="p">,</span> <span class="n">DSP_SYSERROR</span><span class="p">,</span>
						  <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intr_val</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Proc-copy chanel dispatch */</span>
		<span class="n">input_chnl</span><span class="p">(</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">IO_SERVICE</span><span class="p">);</span>
		<span class="n">output_chnl</span><span class="p">(</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">IO_SERVICE</span><span class="p">);</span>

<span class="cp">#ifdef CHNL_MESSAGES</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_mgr_obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Perform I/O dispatch on message queues */</span>
			<span class="n">input_msg</span><span class="p">(</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="n">msg_mgr_obj</span><span class="p">);</span>
			<span class="n">output_msg</span><span class="p">(</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="n">msg_mgr_obj</span><span class="p">);</span>
		<span class="p">}</span>

<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intr_val</span> <span class="o">&amp;</span> <span class="n">MBX_DBG_SYSPRINTF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Notify DSP Trace message */</span>
			<span class="n">print_dsp_debug_trace</span><span class="p">(</span><span class="n">pio_mgr</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">serviced</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">serviced</span> <span class="o">!=</span> <span class="n">requested</span><span class="p">);</span>
	<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_sched</span> <span class="o">=</span> <span class="n">requested</span><span class="p">;</span>
<span class="nl">func_end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== io_mbox_msg ========</span>
<span class="cm"> *      Main interrupt handler for the shared memory IO manager.</span>
<span class="cm"> *      Calls the Bridge&#39;s CHNL_ISR to determine if this interrupt is ours, then</span>
<span class="cm"> *      schedules a DPC to dispatch I/O.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">io_mbox_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_obj</span> <span class="o">=</span> <span class="n">dev_get_first</span><span class="p">();</span>
	<span class="n">dev_get_io_mgr</span><span class="p">(</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pio_mgr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio_mgr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_BAD</span><span class="p">;</span>

	<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intr_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">msg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intr_val</span> <span class="o">&amp;</span> <span class="n">MBX_PM_CLASS</span><span class="p">)</span>
		<span class="n">io_dispatch_pm</span><span class="p">(</span><span class="n">pio_mgr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intr_val</span> <span class="o">==</span> <span class="n">MBX_DEH_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">intr_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_req</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">dpc_tasklet</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== io_request_chnl ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Request chanenel I/O from the DSP. Sets flags in shared memory, then</span>
<span class="cm"> *      interrupts the DSP.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">io_request_chnl</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">io_manager</span><span class="p">,</span> <span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">io_mode</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">mbx_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shm</span> <span class="o">*</span><span class="n">sm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pchnl</span> <span class="o">||</span> <span class="o">!</span><span class="n">mbx_val</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">io_manager</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span><span class="p">;</span>
	<span class="n">sm</span> <span class="o">=</span> <span class="n">io_manager</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io_mode</span> <span class="o">==</span> <span class="n">IO_INPUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Indicate to the DSP we have a buffer available for input */</span>
		<span class="n">set_chnl_busy</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span><span class="p">);</span>
		<span class="o">*</span><span class="n">mbx_val</span> <span class="o">=</span> <span class="n">MBX_PCPY_CLASS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">io_mode</span> <span class="o">==</span> <span class="n">IO_OUTPUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Record the fact that we have a buffer available for</span>
<span class="cm">		 * output.</span>
<span class="cm">		 */</span>
		<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">output_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== iosm_schedule ========</span>
<span class="cm"> *      Schedule DPC for IO.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iosm_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">io_manager</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_manager</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Increment count of DPC&#39;s pending. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_manager</span><span class="o">-&gt;</span><span class="n">dpc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">io_manager</span><span class="o">-&gt;</span><span class="n">dpc_req</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_manager</span><span class="o">-&gt;</span><span class="n">dpc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Schedule DPC */</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_manager</span><span class="o">-&gt;</span><span class="n">dpc_tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== find_ready_output ========</span>
<span class="cm"> *      Search for a host output channel which is ready to send.  If this is</span>
<span class="cm"> *      called as a result of servicing the DPC, then implement a round</span>
<span class="cm"> *      robin search; otherwise, this was called by a client thread (via</span>
<span class="cm"> *      IO_Dispatch()), so just start searching from the current channel id.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">find_ready_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">OUTPUTNOTREADY</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">,</span> <span class="n">start_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">shift</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">pchnl</span> <span class="o">!=</span>
	      <span class="nb">NULL</span> <span class="o">?</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span> <span class="o">:</span> <span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">last_output</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">id</span> <span class="o">=</span> <span class="p">((</span><span class="n">id</span> <span class="o">==</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">id</span><span class="p">);</span>
		<span class="n">start_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">shift</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">last_output</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">id</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">id</span> <span class="o">=</span> <span class="p">((</span><span class="n">id</span> <span class="o">==</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">id</span><span class="p">);</span>
			<span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">id</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">id</span> <span class="o">!=</span> <span class="n">start_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== input_chnl ========</span>
<span class="cm"> *      Dispatch a buffer on an input channel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">input_chnl</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">io_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shm</span> <span class="o">*</span><span class="n">sm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chnl_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_irp</span> <span class="o">*</span><span class="n">chnl_packet_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dw_arg</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">clear_chnl</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">notify_client</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">sm</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="p">;</span>
	<span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span><span class="p">;</span>

	<span class="cm">/* Attempt to perform input */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sm</span><span class="o">-&gt;</span><span class="n">input_full</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">input_size</span> <span class="o">*</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
	<span class="n">chnl_id</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">input_id</span><span class="p">;</span>
	<span class="n">dw_arg</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chnl_id</span> <span class="o">&gt;=</span> <span class="n">CHNL_MAXCHANNELS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Shouldn&#39;t be here: would indicate corrupted shm. */</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pchnl</span> <span class="o">=</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">chnl_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pchnl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">CHNL_IS_INPUT</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CHNL_STATEEOS</span><span class="p">)</span> <span class="o">==</span> <span class="n">CHNL_STATEREADY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Get the I/O request, and attempt a transfer */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_reqs</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

				<span class="n">chnl_packet_obj</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span>
						<span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">chnl_irp</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
				<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_reqs</span><span class="o">--</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * Ensure we don&#39;t overflow the client&#39;s</span>
<span class="cm">				 * buffer.</span>
<span class="cm">				 */</span>
				<span class="n">bytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">byte_size</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">host_sys_buf</span><span class="p">,</span>
						<span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
				<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">bytes_moved</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
				<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">byte_size</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
				<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">dw_arg</span><span class="p">;</span>
				<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">CHNL_IOCSTATCOMPLETE</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * This assertion fails if the DSP</span>
<span class="cm">					 * sends EOS more than once on this</span>
<span class="cm">					 * channel.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">CHNL_STATEEOS</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
					<span class="cm">/*</span>
<span class="cm">					 * Zero bytes indicates EOS. Update</span>
<span class="cm">					 * IOC status for this chirp, and also</span>
<span class="cm">					 * the channel state.</span>
<span class="cm">					 */</span>
					<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span>
						<span class="n">CHNL_IOCSTATEOS</span><span class="p">;</span>
					<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">CHNL_STATEEOS</span><span class="p">;</span>
					<span class="cm">/*</span>
<span class="cm">					 * Notify that end of stream has</span>
<span class="cm">					 * occurred.</span>
<span class="cm">					 */</span>
					<span class="n">ntfy_notify</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span>
							<span class="n">DSP_STREAMDONE</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/* Tell DSP if no more I/O buffers available */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">))</span>
					<span class="n">set_chnl_free</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_id</span><span class="p">);</span>
				<span class="n">clear_chnl</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">notify_client</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Input full for this channel, but we have no</span>
<span class="cm">				 * buffers available.  The channel must be</span>
<span class="cm">				 * &quot;idling&quot;. Clear out the physical input</span>
<span class="cm">				 * channel.</span>
<span class="cm">				 */</span>
				<span class="n">clear_chnl</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Input channel cancelled: clear input channel */</span>
			<span class="n">clear_chnl</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* DPC fired after host closed channel: clear input channel */</span>
		<span class="n">clear_chnl</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear_chnl</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Indicate to the DSP we have read the input */</span>
		<span class="n">sm</span><span class="o">-&gt;</span><span class="n">input_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sm_interrupt_dsp</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">MBX_PCPY_CLASS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">notify_client</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Notify client with IO completion record */</span>
		<span class="n">notify_chnl_complete</span><span class="p">(</span><span class="n">pchnl</span><span class="p">,</span> <span class="n">chnl_packet_obj</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== input_msg ========</span>
<span class="cm"> *      Copies messages from shared memory to the message queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">input_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmsg_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">num_msgs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">msg_input</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msg_queue_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_frame</span> <span class="o">*</span><span class="n">pmsg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_dspmsg</span> <span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_ctrl</span> <span class="o">*</span><span class="n">msg_ctr_obj</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">input_empty</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">msg_ctr_obj</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">msg_input_ctrl</span><span class="p">;</span>
	<span class="cm">/* Get the number of input messages to be read */</span>
	<span class="n">input_empty</span> <span class="o">=</span> <span class="n">msg_ctr_obj</span><span class="o">-&gt;</span><span class="n">buf_empty</span><span class="p">;</span>
	<span class="n">num_msgs</span> <span class="o">=</span> <span class="n">msg_ctr_obj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input_empty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">msg_input</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">msg_input</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_msgs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the next message */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">msg_dspmsg</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_input</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span>
			<span class="n">read_ext32_bit_dsp_data</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">msg_dspmsg</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_input</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">arg1</span><span class="p">);</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">arg1</span> <span class="o">=</span>
			<span class="n">read_ext32_bit_dsp_data</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">msg_dspmsg</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_input</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">arg2</span><span class="p">);</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">arg2</span> <span class="o">=</span>
			<span class="n">read_ext32_bit_dsp_data</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">msg_dspmsg</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_input</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">msgq_id</span><span class="p">);</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">msgq_id</span> <span class="o">=</span>
			<span class="n">read_ext32_bit_dsp_data</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">msg_input</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_dspmsg</span><span class="p">);</span>

		<span class="cm">/* Determine which queue to put the message in */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>	<span class="s">&quot;input msg: cmd=0x%x arg1=0x%x &quot;</span>
				<span class="s">&quot;arg2=0x%x msgq_id=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">cmd</span><span class="p">,</span>
				<span class="n">msg</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">arg1</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">arg2</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">msgq_id</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Interrupt may occur before shared memory and message</span>
<span class="cm">		 * input locations have been set up. If all nodes were</span>
<span class="cm">		 * cleaned up, hmsg_mgr-&gt;max_msgs should be 0.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">msg_queue_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">queue_list</span><span class="p">,</span>
				<span class="n">list_elem</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">msgq_id</span> <span class="o">!=</span> <span class="n">msg_queue_obj</span><span class="o">-&gt;</span><span class="n">msgq_id</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/* Found it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">RMS_EXITACK</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Call the node exit notification.</span>
<span class="cm">				 * The exit message does not get</span>
<span class="cm">				 * queued.</span>
<span class="cm">				 */</span>
				<span class="p">(</span><span class="o">*</span><span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">on_exit</span><span class="p">)(</span><span class="n">msg_queue_obj</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">,</span>
						<span class="n">msg</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">arg1</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Not an exit acknowledgement, queue</span>
<span class="cm">			 * the message.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg_queue_obj</span><span class="o">-&gt;</span><span class="n">msg_free_list</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * No free frame to copy the</span>
<span class="cm">				 * message into.</span>
<span class="cm">				 */</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: no free msg frames,&quot;</span>
						<span class="s">&quot; discarding msg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">pmsg</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg_queue_obj</span><span class="o">-&gt;</span><span class="n">msg_free_list</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">msg_frame</span><span class="p">,</span> <span class="n">list_elem</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">list_elem</span><span class="p">);</span>
			<span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">msg_data</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">list_elem</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">msg_queue_obj</span><span class="o">-&gt;</span><span class="n">msg_used_list</span><span class="p">);</span>
			<span class="n">ntfy_notify</span><span class="p">(</span><span class="n">msg_queue_obj</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span>
					<span class="n">DSP_NODEMESSAGEREADY</span><span class="p">);</span>
			<span class="n">sync_set_event</span><span class="p">(</span><span class="n">msg_queue_obj</span><span class="o">-&gt;</span><span class="n">sync_event</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Set the post SWI flag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_msgs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Tell the DSP we&#39;ve read the messages */</span>
		<span class="n">msg_ctr_obj</span><span class="o">-&gt;</span><span class="n">buf_empty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">msg_ctr_obj</span><span class="o">-&gt;</span><span class="n">post_swi</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">sm_interrupt_dsp</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">MBX_PCPY_CLASS</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== notify_chnl_complete ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Signal the channel event, notifying the client that I/O has completed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">notify_chnl_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">chnl_irp</span> <span class="o">*</span><span class="n">chnl_packet_obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">signal_event</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pchnl</span> <span class="o">||</span> <span class="o">!</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span> <span class="o">||</span> <span class="o">!</span><span class="n">chnl_packet_obj</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: we signal the channel event only if the queue of IO</span>
<span class="cm">	 * completions is empty.  If it is not empty, the event is sure to be</span>
<span class="cm">	 * signalled by the only IO completion list consumer:</span>
<span class="cm">	 * bridge_chnl_get_ioc().</span>
<span class="cm">	 */</span>
	<span class="n">signal_event</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">);</span>
	<span class="cm">/* Enqueue the IO completion info for the client */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_completions</span><span class="p">);</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_cs</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_cs</span> <span class="o">&gt;</span> <span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">chnl_packets</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="cm">/* Signal the channel event (if not already set) that IO is complete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_event</span><span class="p">)</span>
		<span class="n">sync_set_event</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">sync_event</span><span class="p">);</span>

	<span class="cm">/* Notify that IO is complete */</span>
	<span class="n">ntfy_notify</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">DSP_STREAMIOCOMPLETION</span><span class="p">);</span>
<span class="nl">func_end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== output_chnl ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      Dispatch a buffer on an output channel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">output_chnl</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">chnl_object</span> <span class="o">*</span><span class="n">pchnl</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">io_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chnl_mgr</span> <span class="o">*</span><span class="n">chnl_mgr_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shm</span> <span class="o">*</span><span class="n">sm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chnl_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chnl_irp</span> <span class="o">*</span><span class="n">chnl_packet_obj</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dw_dsp_f_mask</span><span class="p">;</span>

	<span class="n">chnl_mgr_obj</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">chnl_mgr</span><span class="p">;</span>
	<span class="n">sm</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="p">;</span>
	<span class="cm">/* Attempt to perform output */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sm</span><span class="o">-&gt;</span><span class="n">output_full</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pchnl</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">((</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CHNL_STATEEOS</span><span class="p">)</span> <span class="o">==</span> <span class="n">CHNL_STATEREADY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* Look to see if both a PC and DSP output channel are ready */</span>
	<span class="n">dw_dsp_f_mask</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">dsp_free_mask</span><span class="p">;</span>
	<span class="n">chnl_id</span> <span class="o">=</span>
	    <span class="n">find_ready_output</span><span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="p">,</span> <span class="n">pchnl</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">output_mask</span> <span class="o">&amp;</span> <span class="n">dw_dsp_f_mask</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chnl_id</span> <span class="o">==</span> <span class="n">OUTPUTNOTREADY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">pchnl</span> <span class="o">=</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">chnl_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pchnl</span> <span class="o">||</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Shouldn&#39;t get here */</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_reqs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="cm">/* Get the I/O request, and attempt a transfer */</span>
	<span class="n">chnl_packet_obj</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">chnl_irp</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">cio_reqs</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Record fact that no more I/O buffers available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">io_requests</span><span class="p">))</span>
		<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">output_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chnl_id</span><span class="p">);</span>

	<span class="cm">/* Transfer buffer to DSP side */</span>
	<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">byte_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">sm_buf_size</span><span class="p">,</span>
					<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">byte_size</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">,</span>	<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">host_sys_buf</span><span class="p">,</span>
					<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">byte_size</span><span class="p">);</span>
	<span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">bytes_moved</span> <span class="o">+=</span> <span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">byte_size</span><span class="p">;</span>
	<span class="cm">/* Write all 32 bits of arg */</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
<span class="cp">#if _CHNL_WORDSIZE == 2</span>
	<span class="cm">/* Access can be different SM access word size (e.g. 16/32 bit words) */</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">output_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">chnl_id</span><span class="p">;</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">output_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">byte_size</span> <span class="o">+</span>
				<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
				<span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">output_id</span> <span class="o">=</span> <span class="n">chnl_id</span><span class="p">;</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">output_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">byte_size</span> <span class="o">+</span>
			<span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">chnl_mgr_obj</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">output_full</span> <span class="o">=</span>  <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Indicate to the DSP we have written the output */</span>
	<span class="n">sm_interrupt_dsp</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">MBX_PCPY_CLASS</span><span class="p">);</span>
	<span class="cm">/* Notify client with IO completion record (keep EOS) */</span>
	<span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="n">CHNL_IOCSTATEOS</span><span class="p">;</span>
	<span class="n">notify_chnl_complete</span><span class="p">(</span><span class="n">pchnl</span><span class="p">,</span> <span class="n">chnl_packet_obj</span><span class="p">);</span>
	<span class="cm">/* Notify if stream is done. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chnl_packet_obj</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">CHNL_IOCSTATEOS</span><span class="p">)</span>
		<span class="n">ntfy_notify</span><span class="p">(</span><span class="n">pchnl</span><span class="o">-&gt;</span><span class="n">ntfy_obj</span><span class="p">,</span> <span class="n">DSP_STREAMDONE</span><span class="p">);</span>

<span class="nl">func_end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== output_msg ========</span>
<span class="cm"> *      Copies messages from the message queues to the shared memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">output_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">pio_mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_mgr</span> <span class="o">*</span><span class="n">hmsg_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">num_msgs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_dspmsg</span> <span class="o">*</span><span class="n">msg_output</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_frame</span> <span class="o">*</span><span class="n">pmsg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_ctrl</span> <span class="o">*</span><span class="n">msg_ctr_obj</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">msg_ctr_obj</span> <span class="o">=</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">msg_output_ctrl</span><span class="p">;</span>

	<span class="cm">/* Check if output has been cleared */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg_ctr_obj</span><span class="o">-&gt;</span><span class="n">buf_empty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">num_msgs</span> <span class="o">=</span> <span class="p">(</span><span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">msgs_pending</span> <span class="o">&gt;</span> <span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">max_msgs</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">max_msgs</span> <span class="o">:</span> <span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">msgs_pending</span><span class="p">;</span>
	<span class="n">msg_output</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_dspmsg</span> <span class="o">*</span><span class="p">)</span> <span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">msg_output</span><span class="p">;</span>

	<span class="cm">/* Copy num_msgs messages into shared memory */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_msgs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">msg_used_list</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pmsg</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">msg_used_list</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">msg_frame</span><span class="p">,</span> <span class="n">list_elem</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">list_elem</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">msg_data</span><span class="p">).</span><span class="n">msgq_id</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">msg_output</span><span class="o">-&gt;</span><span class="n">msgq_id</span><span class="p">;</span>
		<span class="n">write_ext32_bit_dsp_data</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">msg_data</span><span class="p">).</span><span class="n">msg</span><span class="p">.</span><span class="n">cmd</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">msg_output</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">cmd</span><span class="p">;</span>
		<span class="n">write_ext32_bit_dsp_data</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">msg_data</span><span class="p">).</span><span class="n">msg</span><span class="p">.</span><span class="n">arg1</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">msg_output</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">arg1</span><span class="p">;</span>
		<span class="n">write_ext32_bit_dsp_data</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">msg_data</span><span class="p">).</span><span class="n">msg</span><span class="p">.</span><span class="n">arg2</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">msg_output</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">arg2</span><span class="p">;</span>
		<span class="n">write_ext32_bit_dsp_data</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">msg_output</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">list_elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">msg_free_list</span><span class="p">);</span>
		<span class="n">sync_set_event</span><span class="p">(</span><span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">sync_event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_msgs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hmsg_mgr</span><span class="o">-&gt;</span><span class="n">msgs_pending</span> <span class="o">-=</span> <span class="n">num_msgs</span><span class="p">;</span>
<span class="cp">#if _CHNL_WORDSIZE == 2</span>
		<span class="cm">/*</span>
<span class="cm">		 * Access can be different SM access word size</span>
<span class="cm">		 * (e.g. 16/32 bit words)</span>
<span class="cm">		 */</span>
		<span class="n">msg_ctr_obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">num_msgs</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="n">msg_ctr_obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">num_msgs</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">msg_ctr_obj</span><span class="o">-&gt;</span><span class="n">buf_empty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="cm">/* Set the post SWI flag */</span>
		<span class="n">msg_ctr_obj</span><span class="o">-&gt;</span><span class="n">post_swi</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/* Tell the DSP we have written the output. */</span>
		<span class="n">sm_interrupt_dsp</span><span class="p">(</span><span class="n">pio_mgr</span><span class="o">-&gt;</span><span class="n">bridge_context</span><span class="p">,</span> <span class="n">MBX_PCPY_CLASS</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== register_shm_segs ========</span>
<span class="cm"> *  purpose:</span>
<span class="cm"> *      Registers GPP SM segment with CMM.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">register_shm_segs</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">cod_man</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">dw_gpp_base_pa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_shm0_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">shm0_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_shm0_rsrvd_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_rsrvd_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_gpp_phys</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_dsp_virt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_shm_seg_id0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dw_offset</span><span class="p">,</span> <span class="n">dw_gpp_base_va</span><span class="p">,</span> <span class="n">ul_dsp_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read address and size info for first SM region.</span>
<span class="cm">	 * Get start of 1st SM Heap region.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span>
	    <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">SHM0_SHARED_BASE_SYM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_shm0_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ul_shm0_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Get end of 1st SM Heap region */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get start and length of message part of shared memory */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">SHM0_SHARED_END_SYM</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">shm0_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shm0_end</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Start of Gpp reserved region */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get start and length of message part of shared memory */</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_man</span><span class="p">,</span> <span class="n">SHM0_SHARED_RESERVED_BASE_SYM</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">ul_shm0_rsrvd_start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ul_shm0_rsrvd_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Register with CMM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_cmm_mgr</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">cmm_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">cmm_un_register_gppsm_seg</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">cmm_mgr</span><span class="p">,</span>
							   <span class="n">CMM_ALLSEGMENTS</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Register new SM region(s) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">shm0_end</span> <span class="o">-</span> <span class="n">ul_shm0_base</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Calc size (bytes) of SM the GPP can alloc from */</span>
		<span class="n">ul_rsrvd_size</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">shm0_end</span> <span class="o">-</span> <span class="n">ul_shm0_rsrvd_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ul_rsrvd_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Calc size of SM DSP can alloc from */</span>
		<span class="n">ul_dsp_size</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">ul_shm0_rsrvd_start</span> <span class="o">-</span> <span class="n">ul_shm0_base</span><span class="p">)</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ul_dsp_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* First TLB entry reserved for Bridge SM use. */</span>
		<span class="n">ul_gpp_phys</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gpp_phys</span><span class="p">;</span>
		<span class="cm">/* Get size in bytes */</span>
		<span class="n">ul_dsp_virt</span> <span class="o">=</span>
		    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">ext_proc_info</span><span class="p">.</span><span class="n">ty_tlb</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dsp_virt</span> <span class="o">*</span>
		    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calc byte offset used to convert GPP phys &lt;-&gt; DSP byte</span>
<span class="cm">		 * address.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dw_gpp_base_pa</span> <span class="o">&gt;</span> <span class="n">ul_dsp_virt</span><span class="p">)</span>
			<span class="n">dw_offset</span> <span class="o">=</span> <span class="n">dw_gpp_base_pa</span> <span class="o">-</span> <span class="n">ul_dsp_virt</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dw_offset</span> <span class="o">=</span> <span class="n">ul_dsp_virt</span> <span class="o">-</span> <span class="n">dw_gpp_base_pa</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ul_shm0_rsrvd_start</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">&lt;</span> <span class="n">ul_dsp_virt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calc Gpp phys base of SM region.</span>
<span class="cm">		 * This is actually uncached kernel virtual address.</span>
<span class="cm">		 */</span>
		<span class="n">dw_gpp_base_va</span> <span class="o">=</span>
		    <span class="n">ul_gpp_phys</span> <span class="o">+</span> <span class="n">ul_shm0_rsrvd_start</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">-</span>
		    <span class="n">ul_dsp_virt</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calc Gpp phys base of SM region.</span>
<span class="cm">		 * This is the physical address.</span>
<span class="cm">		 */</span>
		<span class="n">dw_gpp_base_pa</span> <span class="o">=</span>
		    <span class="n">dw_gpp_base_pa</span> <span class="o">+</span> <span class="n">ul_shm0_rsrvd_start</span> <span class="o">*</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">-</span>
		    <span class="n">ul_dsp_virt</span><span class="p">;</span>
		<span class="cm">/* Register SM Segment 0. */</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">cmm_register_gppsm_seg</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">cmm_mgr</span><span class="p">,</span> <span class="n">dw_gpp_base_pa</span><span class="p">,</span>
					   <span class="n">ul_rsrvd_size</span><span class="p">,</span> <span class="n">dw_offset</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">dw_gpp_base_pa</span> <span class="o">&gt;</span>
					    <span class="n">ul_dsp_virt</span><span class="p">)</span> <span class="o">?</span> <span class="n">CMM_ADDTODSPPA</span> <span class="o">:</span>
					   <span class="n">CMM_SUBFROMDSPPA</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">ul_shm0_base</span> <span class="o">*</span>
						  <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">),</span>
					   <span class="n">ul_dsp_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_shm_seg_id0</span><span class="p">,</span>
					   <span class="n">dw_gpp_base_va</span><span class="p">);</span>
		<span class="cm">/* First SM region is seg_id = 1 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ul_shm_seg_id0</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ZCPY IO routines. */</span>
<span class="cm">/*</span>
<span class="cm"> *  ======== IO_SHMcontrol ========</span>
<span class="cm"> *      Sets the requested shm setting.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">io_sh_msetting</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">desc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pargs</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_TIDSPBRIDGE_DVFS</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dspbridge_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span>
	    <span class="n">omap_dspbridge_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SHM_CURROPP</span>:
		<span class="cm">/* Update the shared memory with requested OPP information */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pargs</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">opp_table_struct</span><span class="p">.</span><span class="n">curr_opp_pt</span> <span class="o">=</span>
			    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pargs</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SHM_OPPINFO</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Update the shared memory with the voltage, frequency,</span>
<span class="cm">		 * min and max frequency values for an OPP.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">dsp_max_opps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">opp_table_struct</span><span class="p">.</span><span class="n">opp_point</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
			    <span class="n">voltage</span> <span class="o">=</span> <span class="n">vdd1_dsp_freq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;OPP-shm: voltage: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">vdd1_dsp_freq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">opp_table_struct</span><span class="p">.</span>
			    <span class="n">opp_point</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">vdd1_dsp_freq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;OPP-shm: frequency: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">vdd1_dsp_freq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">opp_table_struct</span><span class="p">.</span><span class="n">opp_point</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
			    <span class="n">min_freq</span> <span class="o">=</span> <span class="n">vdd1_dsp_freq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;OPP-shm: min freq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">vdd1_dsp_freq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
			<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">opp_table_struct</span><span class="p">.</span><span class="n">opp_point</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
			    <span class="n">max_freq</span> <span class="o">=</span> <span class="n">vdd1_dsp_freq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;OPP-shm: max freq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">vdd1_dsp_freq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">opp_table_struct</span><span class="p">.</span><span class="n">num_opp_pts</span> <span class="o">=</span>
		    <span class="n">dsp_max_opps</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;OPP-shm: max OPP number: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dsp_max_opps</span><span class="p">);</span>
		<span class="cm">/* Update the current OPP number */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_get_opp</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_get_opp</span><span class="p">)</span> <span class="p">();</span>
		<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">opp_table_struct</span><span class="p">.</span><span class="n">curr_opp_pt</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;OPP-shm: value programmed = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SHM_GETOPP</span>:
		<span class="cm">/* Get the OPP that DSP has requested */</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pargs</span> <span class="o">=</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">opp_request</span><span class="p">.</span><span class="n">rqst_opp_pt</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_io_get_proc_load ========</span>
<span class="cm"> *      Gets the Processor&#39;s Load information</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bridge_io_get_proc_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dsp_procloadstat</span> <span class="o">*</span><span class="n">proc_lstat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">proc_lstat</span><span class="o">-&gt;</span><span class="n">curr_load</span> <span class="o">=</span>
			<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">load_mon_info</span><span class="p">.</span><span class="n">curr_dsp_load</span><span class="p">;</span>
	<span class="n">proc_lstat</span><span class="o">-&gt;</span><span class="n">predicted_load</span> <span class="o">=</span>
	    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">load_mon_info</span><span class="p">.</span><span class="n">pred_dsp_load</span><span class="p">;</span>
	<span class="n">proc_lstat</span><span class="o">-&gt;</span><span class="n">curr_dsp_freq</span> <span class="o">=</span>
	    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">load_mon_info</span><span class="p">.</span><span class="n">curr_dsp_freq</span><span class="p">;</span>
	<span class="n">proc_lstat</span><span class="o">-&gt;</span><span class="n">predicted_freq</span> <span class="o">=</span>
	    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">shared_mem</span><span class="o">-&gt;</span><span class="n">load_mon_info</span><span class="p">.</span><span class="n">pred_dsp_freq</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;Curr Load = %d, Pred Load = %d, Curr Freq = %d, &quot;</span>
		<span class="s">&quot;Pred Freq = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">proc_lstat</span><span class="o">-&gt;</span><span class="n">curr_load</span><span class="p">,</span>
		<span class="n">proc_lstat</span><span class="o">-&gt;</span><span class="n">predicted_load</span><span class="p">,</span> <span class="n">proc_lstat</span><span class="o">-&gt;</span><span class="n">curr_dsp_freq</span><span class="p">,</span>
		<span class="n">proc_lstat</span><span class="o">-&gt;</span><span class="n">predicted_freq</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#if defined(CONFIG_TIDSPBRIDGE_BACKTRACE)</span>
<span class="kt">void</span> <span class="nf">print_dsp_debug_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ul_new_message_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ul_gpp_cur_pointer</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get the DSP current pointer */</span>
		<span class="n">ul_gpp_cur_pointer</span> <span class="o">=</span>
		    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_current</span><span class="p">);</span>
		<span class="n">ul_gpp_cur_pointer</span> <span class="o">=</span>
		    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_va</span> <span class="o">+</span> <span class="p">(</span><span class="n">ul_gpp_cur_pointer</span> <span class="o">-</span>
					  <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">dsp_va</span><span class="p">);</span>

		<span class="cm">/* No new debug messages available yet */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ul_gpp_cur_pointer</span> <span class="o">==</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ul_gpp_cur_pointer</span> <span class="o">&gt;</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Continuous data */</span>
			<span class="n">ul_new_message_length</span> <span class="o">=</span>
			    <span class="n">ul_gpp_cur_pointer</span> <span class="o">-</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span><span class="p">;</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span><span class="p">,</span>
			       <span class="n">ul_new_message_length</span><span class="p">);</span>
			<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">[</span><span class="n">ul_new_message_length</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Advance the GPP trace pointer to DSP current</span>
<span class="cm">			 * pointer.</span>
<span class="cm">			 */</span>
			<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span> <span class="o">+=</span> <span class="n">ul_new_message_length</span><span class="p">;</span>
			<span class="cm">/* Print the trace messages */</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DSPTrace: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ul_gpp_cur_pointer</span> <span class="o">&lt;</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Handle trace buffer wraparound */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span><span class="p">,</span>
			       <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_end</span> <span class="o">-</span>
			       <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span><span class="p">);</span>
			<span class="n">ul_new_message_length</span> <span class="o">=</span>
			    <span class="n">ul_gpp_cur_pointer</span> <span class="o">-</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_begin</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">[</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_end</span> <span class="o">-</span>
					      <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span><span class="p">],</span>
			       <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_begin</span><span class="p">,</span>
			       <span class="n">ul_new_message_length</span><span class="p">);</span>
			<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">[</span><span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_end</span> <span class="o">-</span>
				      <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span> <span class="o">+</span>
				      <span class="n">ul_new_message_length</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Advance the GPP trace pointer to DSP current</span>
<span class="cm">			 * pointer.</span>
<span class="cm">			 */</span>
			<span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">gpp_read_pointer</span> <span class="o">=</span>
			    <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">trace_buffer_begin</span> <span class="o">+</span>
			    <span class="n">ul_new_message_length</span><span class="p">;</span>
			<span class="cm">/* Print the trace messages */</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DSPTrace: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hio_mgr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE</span>
<span class="cm">/*</span>
<span class="cm"> *  ======== print_dsp_trace_buffer ========</span>
<span class="cm"> *      Prints the trace buffer returned from the DSP (if DBG_Trace is enabled).</span>
<span class="cm"> *  Parameters:</span>
<span class="cm"> *    hdeh_mgr:          Handle to DEH manager object</span>
<span class="cm"> *                      number of extra carriage returns to generate.</span>
<span class="cm"> *  Returns:</span>
<span class="cm"> *      0:        Success.</span>
<span class="cm"> *      -ENOMEM:    Unable to allocate memory.</span>
<span class="cm"> *  Requires:</span>
<span class="cm"> *      hdeh_mgr muse be valid. Checked in bridge_deh_notify.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">print_dsp_trace_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">hbridge_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">cod_mgr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_trace_end</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_trace_begin</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">trace_cur_pos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_num_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_num_words</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_word_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">psz_buf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str_beg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">trace_end</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf_end</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">new_line</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">pbridge_context</span> <span class="o">=</span> <span class="n">hbridge_context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">pbridge_context</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_cod_mgr</span><span class="p">(</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cod_mgr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cod_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Look for SYS_PUTCBEG/SYS_PUTCEND */</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="n">COD_TRACEBEG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_trace_begin</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="n">COD_TRACEEND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_trace_end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="cm">/* trace_cur_pos will hold the address of a DSP pointer */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">cod_mgr</span><span class="p">,</span> <span class="n">COD_TRACECURPOS</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">trace_cur_pos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">ul_num_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ul_trace_end</span> <span class="o">-</span> <span class="n">ul_trace_begin</span><span class="p">);</span>

	<span class="n">ul_num_words</span> <span class="o">=</span> <span class="n">ul_num_bytes</span> <span class="o">*</span> <span class="n">ul_word_size</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_intf_fxns</span><span class="p">(</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intf_fxns</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

	<span class="n">psz_buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ul_num_bytes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psz_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read trace buffer data */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_read</span><span class="p">)(</span><span class="n">pbridge_context</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">psz_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ul_trace_begin</span><span class="p">,</span>
			<span class="n">ul_num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>

		<span class="cm">/* Pack and do newline conversion */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PrintDspTraceBuffer: &quot;</span>
			<span class="s">&quot;before pack and unpack.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: DSP Trace Buffer Begin:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;=======================</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">psz_buf</span><span class="p">);</span>

		<span class="cm">/* Read the value at the DSP address in trace_cur_pos. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_read</span><span class="p">)(</span><span class="n">pbridge_context</span><span class="p">,</span>
				<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">trace_cur_pos</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">trace_cur_pos</span><span class="p">,</span>
				<span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="cm">/* Pack and do newline conversion */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DSP Trace Buffer Begin:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;=======================</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">psz_buf</span><span class="p">);</span>


		<span class="cm">/* convert to offset */</span>
		<span class="n">trace_cur_pos</span> <span class="o">=</span> <span class="n">trace_cur_pos</span> <span class="o">-</span> <span class="n">ul_trace_begin</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ul_num_bytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The buffer is not full, find the end of the</span>
<span class="cm">			 * data -- buf_end will be &gt;= pszBuf after</span>
<span class="cm">			 * while.</span>
<span class="cm">			 */</span>
			<span class="n">buf_end</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psz_buf</span><span class="p">[</span><span class="n">ul_num_bytes</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
			<span class="cm">/* DSP print position */</span>
			<span class="n">trace_end</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psz_buf</span><span class="p">[</span><span class="n">trace_cur_pos</span><span class="p">];</span>

			<span class="cm">/*</span>
<span class="cm">			 * Search buffer for a new_line and replace it</span>
<span class="cm">			 * with &#39;\0&#39;, then print as string.</span>
<span class="cm">			 * Continue until end of buffer is reached.</span>
<span class="cm">			 */</span>
			<span class="n">str_beg</span> <span class="o">=</span> <span class="n">trace_end</span><span class="p">;</span>
			<span class="n">ul_num_bytes</span> <span class="o">=</span> <span class="n">buf_end</span> <span class="o">-</span> <span class="n">str_beg</span><span class="p">;</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">str_beg</span> <span class="o">&lt;</span> <span class="n">buf_end</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_line</span> <span class="o">=</span> <span class="n">strnchr</span><span class="p">(</span><span class="n">str_beg</span><span class="p">,</span> <span class="n">ul_num_bytes</span><span class="p">,</span>
								<span class="sc">&#39;\n&#39;</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">new_line</span> <span class="o">&amp;&amp;</span> <span class="n">new_line</span> <span class="o">&lt;</span> <span class="n">buf_end</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">*</span><span class="n">new_line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str_beg</span><span class="p">);</span>
					<span class="n">str_beg</span> <span class="o">=</span> <span class="o">++</span><span class="n">new_line</span><span class="p">;</span>
					<span class="n">ul_num_bytes</span> <span class="o">=</span> <span class="n">buf_end</span> <span class="o">-</span> <span class="n">str_beg</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * Assume buffer empty if it contains</span>
<span class="cm">					 * a zero</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str_beg</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">str_beg</span><span class="p">[</span><span class="n">ul_num_bytes</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str_beg</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="n">str_beg</span> <span class="o">=</span> <span class="n">buf_end</span><span class="p">;</span>
					<span class="n">ul_num_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Search buffer for a nNewLine and replace it</span>
<span class="cm">			 * with &#39;\0&#39;, then print as string.</span>
<span class="cm">			 * Continue until buffer is exhausted.</span>
<span class="cm">			 */</span>
			<span class="n">str_beg</span> <span class="o">=</span> <span class="n">psz_buf</span><span class="p">;</span>
			<span class="n">ul_num_bytes</span> <span class="o">=</span> <span class="n">trace_end</span> <span class="o">-</span> <span class="n">str_beg</span><span class="p">;</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">str_beg</span> <span class="o">&lt;</span> <span class="n">trace_end</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_line</span> <span class="o">=</span> <span class="n">strnchr</span><span class="p">(</span><span class="n">str_beg</span><span class="p">,</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">new_line</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">new_line</span> <span class="o">&lt;</span> <span class="n">trace_end</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">*</span><span class="n">new_line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str_beg</span><span class="p">);</span>
					<span class="n">str_beg</span> <span class="o">=</span> <span class="o">++</span><span class="n">new_line</span><span class="p">;</span>
					<span class="n">ul_num_bytes</span> <span class="o">=</span> <span class="n">trace_end</span> <span class="o">-</span> <span class="n">str_beg</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * Assume buffer empty if it contains</span>
<span class="cm">					 * a zero</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str_beg</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">str_beg</span><span class="p">[</span><span class="n">ul_num_bytes</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str_beg</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="n">str_beg</span> <span class="o">=</span> <span class="n">trace_end</span><span class="p">;</span>
					<span class="n">ul_num_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">=======================</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;DSP Trace Buffer End:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">psz_buf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s Failed, status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dump_dsp_stack() - This function dumps the data on the DSP stack.</span>
<span class="cm"> * @bridge_context:	Bridge driver&#39;s device context pointer.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dump_dsp_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">bridge_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">code_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mgr</span> <span class="o">*</span><span class="n">node_mgr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">trace_begin</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">head</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">mmu_fault_dbg_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buffer_beg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buffer_end</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exc_type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dyn_ext_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset_output</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">poll_cnt</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dsp_regs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;EFR&quot;</span><span class="p">,</span> <span class="s">&quot;IERR&quot;</span><span class="p">,</span> <span class="s">&quot;ITSR&quot;</span><span class="p">,</span> <span class="s">&quot;NTSR&quot;</span><span class="p">,</span>
				<span class="s">&quot;IRP&quot;</span><span class="p">,</span> <span class="s">&quot;NRP&quot;</span><span class="p">,</span> <span class="s">&quot;AMR&quot;</span><span class="p">,</span> <span class="s">&quot;SSR&quot;</span><span class="p">,</span>
				<span class="s">&quot;ILC&quot;</span><span class="p">,</span> <span class="s">&quot;RILC&quot;</span><span class="p">,</span> <span class="s">&quot;IER&quot;</span><span class="p">,</span> <span class="s">&quot;CSR&quot;</span><span class="p">};</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">exec_ctxt</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Task&quot;</span><span class="p">,</span> <span class="s">&quot;SWI&quot;</span><span class="p">,</span> <span class="s">&quot;HWI&quot;</span><span class="p">,</span> <span class="s">&quot;Unknown&quot;</span><span class="p">};</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_object</span> <span class="o">=</span> <span class="n">bridge_context</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_cod_mgr</span><span class="p">(</span><span class="n">dev_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">code_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Failed on dev_get_cod_mgr.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_node_manager</span><span class="p">(</span><span class="n">dev_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Failed on dev_get_node_manager.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Look for SYS_PUTCBEG/SYS_PUTCEND: */</span>
		<span class="n">status</span> <span class="o">=</span>
			<span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">code_mgr</span><span class="p">,</span> <span class="n">COD_TRACEBEG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trace_begin</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: trace_begin Value 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">trace_begin</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Failed on cod_get_sym_value.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_intf_fxns</span><span class="p">(</span><span class="n">dev_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intf_fxns</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for the &quot;magic number&quot; in the trace buffer.  If it has</span>
<span class="cm">	 * yet to appear then poll the trace buffer to wait for it.  Its</span>
<span class="cm">	 * appearance signals that the DSP has finished dumping its state.</span>
<span class="cm">	 */</span>
	<span class="n">mmu_fault_dbg_info</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mmu_fault_dbg_info</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">poll_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">mmu_fault_dbg_info</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MMU_FAULT_HEAD1</span> <span class="o">||</span>
			<span class="n">mmu_fault_dbg_info</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MMU_FAULT_HEAD2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">poll_cnt</span> <span class="o">&lt;</span> <span class="n">POLL_MAX</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Read DSP dump size from the DSP trace buffer... */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_read</span><span class="p">)(</span><span class="n">bridge_context</span><span class="p">,</span>
				<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mmu_fault_dbg_info</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">trace_begin</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">mmu_fault_dbg_info</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">poll_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mmu_fault_dbg_info</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MMU_FAULT_HEAD1</span> <span class="o">&amp;&amp;</span>
			<span class="n">mmu_fault_dbg_info</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MMU_FAULT_HEAD2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s:No DSP MMU-Fault information available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">total_size</span> <span class="o">=</span> <span class="n">mmu_fault_dbg_info</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
		<span class="cm">/* Limit the size in case DSP went crazy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">&gt;</span> <span class="n">MAX_MMU_DBGBUFF</span><span class="p">)</span>
			<span class="n">total_size</span> <span class="o">=</span> <span class="n">MAX_MMU_DBGBUFF</span><span class="p">;</span>

		<span class="n">buffer</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Failed to &quot;</span>
				<span class="s">&quot;allocate stack dump buffer.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">buffer_beg</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
		<span class="n">buffer_end</span> <span class="o">=</span>  <span class="n">buffer</span> <span class="o">+</span> <span class="n">total_size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

		<span class="cm">/* Read bytes from the DSP trace buffer... */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_read</span><span class="p">)(</span><span class="n">bridge_context</span><span class="p">,</span>
				<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">trace_begin</span><span class="p">,</span>
				<span class="n">total_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Failed to Read Trace Buffer.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Aproximate Crash Position:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;--------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">exc_type</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exc_type</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">79</span><span class="p">];</span>         <span class="cm">/* IRP */</span>
		<span class="k">else</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>         <span class="cm">/* NRP */</span>

		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">code_mgr</span><span class="p">,</span> <span class="n">DYNEXTBASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dyn_ext_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">dyn_ext_base</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">node_find_addr</span><span class="p">(</span><span class="n">node_mgr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
			<span class="mh">0x1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset_output</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;0x%-8x [</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> + 0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
							<span class="n">i</span> <span class="o">-</span> <span class="n">offset_output</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;0x%-8x [Unable to match to a symbol.]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">buffer</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Execution Info:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;---------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">exec_ctxt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Execution context </span><span class="se">\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">exec_ctxt</span><span class="p">[</span><span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Execution context corrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">buffer_beg</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Task Handle</span><span class="se">\t\t</span><span class="s">0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Stack Pointer</span><span class="se">\t\t</span><span class="s">0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Stack Top</span><span class="se">\t\t</span><span class="s">0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Stack Bottom</span><span class="se">\t\t</span><span class="s">0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Stack Size</span><span class="se">\t\t</span><span class="s">0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Stack Size In Use</span><span class="se">\t</span><span class="s">0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>

		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">CPU Registers</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;---------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;A%d 0x%-8x [Function Argument %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;A15 0x%-8x [Frame Pointer]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;A%d 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">B0 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;B1 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;B2 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">buffer</span> <span class="o">&gt;</span> <span class="n">dyn_ext_base</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">node_find_addr</span><span class="p">(</span><span class="n">node_mgr</span><span class="p">,</span>
			<span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset_output</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>

			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;B3 0x%-8x [Function Return Pointer:&quot;</span>
				<span class="s">&quot; </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> + 0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
				<span class="o">*</span><span class="n">buffer</span> <span class="o">-</span> <span class="n">offset_output</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;B3 0x%-8x [Function Return Pointer:&quot;</span>
				<span class="s">&quot;Unable to match to a symbol.]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>

		<span class="n">buffer</span><span class="o">++</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;B%d 0x%-8x [Function Argument %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">14</span><span class="p">)</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;B14 0x%-8x [Data Page Pointer]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;B%d 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dsp_regs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dsp_regs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">);</span>

		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Stack:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">buffer_end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">buffer</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">buffer</span> <span class="o">&gt;</span> <span class="n">dyn_ext_base</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span>
				<span class="n">node_find_addr</span><span class="p">(</span><span class="n">node_mgr</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span> <span class="p">,</span> <span class="mh">0x600</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">offset_output</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;[%d] 0x%-8x [</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> + 0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
					<span class="o">*</span><span class="n">buffer</span> <span class="o">-</span> <span class="n">offset_output</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;[%d] 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buffer_beg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dump_dl_modules() - This functions dumps the _DLModules loaded in DSP side</span>
<span class="cm"> * @bridge_context:		Bridge driver&#39;s device context pointer.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dump_dl_modules</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">bridge_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cod_manager</span> <span class="o">*</span><span class="n">code_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">*</span><span class="n">intf_fxns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">bridge_ctxt</span> <span class="o">=</span> <span class="n">bridge_context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">dev_object</span> <span class="o">=</span> <span class="n">bridge_ctxt</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">modules_header</span> <span class="n">modules_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dll_module</span> <span class="o">*</span><span class="n">module_struct</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">module_dsp_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">module_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">module_struct_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sect_ndx</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sect_str</span> <span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_intf_fxns</span><span class="p">(</span><span class="n">dev_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intf_fxns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Failed on dev_get_intf_fxns.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_cod_mgr</span><span class="p">(</span><span class="n">dev_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code_mgr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">code_mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Failed on dev_get_cod_mgr.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Lookup  the address of the modules_header structure */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">cod_get_sym_value</span><span class="p">(</span><span class="n">code_mgr</span><span class="p">,</span> <span class="s">&quot;_DLModules&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module_dsp_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Failed on cod_get_sym_value for _DLModules.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: _DLModules at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">module_dsp_addr</span><span class="p">);</span>

	<span class="cm">/* Copy the modules_header structure from DSP memory. */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_read</span><span class="p">)(</span><span class="n">bridge_context</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">modules_hdr</span><span class="p">,</span>
				<span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">module_dsp_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">modules_hdr</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Failed failed to read modules header.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">module_dsp_addr</span> <span class="o">=</span> <span class="n">modules_hdr</span><span class="p">.</span><span class="n">first_module</span><span class="p">;</span>
	<span class="n">module_size</span> <span class="o">=</span> <span class="n">modules_hdr</span><span class="p">.</span><span class="n">first_module_size</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: dll_module_header 0x%x %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">module_dsp_addr</span><span class="p">,</span>
								<span class="n">module_size</span><span class="p">);</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Dynamically Loaded Modules:</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;---------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* For each dll_module structure in the list... */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">module_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocate/re-allocate memory to hold the dll_module</span>
<span class="cm">		 * structure. The memory is re-allocated only if the existing</span>
<span class="cm">		 * allocation is too small.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">module_size</span> <span class="o">&gt;</span> <span class="n">module_struct_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">module_struct</span><span class="p">);</span>
			<span class="n">module_struct</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">module_size</span><span class="o">+</span><span class="mi">128</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="n">module_struct_size</span> <span class="o">=</span> <span class="n">module_size</span><span class="o">+</span><span class="mi">128</span><span class="p">;</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: allocated module struct %p %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">module_struct</span><span class="p">,</span> <span class="n">module_struct_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">module_struct</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Copy the dll_module structure from DSP memory */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">intf_fxns</span><span class="o">-&gt;</span><span class="n">brd_read</span><span class="p">)(</span><span class="n">bridge_context</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">module_struct</span><span class="p">,</span> <span class="n">module_dsp_addr</span><span class="p">,</span> <span class="n">module_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span>
			<span class="s">&quot;%s: Failed to read dll_module struct for 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">module_dsp_addr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Update info regarding the _next_ module in the list. */</span>
		<span class="n">module_dsp_addr</span> <span class="o">=</span> <span class="n">module_struct</span><span class="o">-&gt;</span><span class="n">next_module</span><span class="p">;</span>
		<span class="n">module_size</span> <span class="o">=</span> <span class="n">module_struct</span><span class="o">-&gt;</span><span class="n">next_module_size</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: next module 0x%x %d, this module num sects %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">module_dsp_addr</span><span class="p">,</span> <span class="n">module_size</span><span class="p">,</span>
			<span class="n">module_struct</span><span class="o">-&gt;</span><span class="n">num_sects</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The section name strings start immedialty following</span>
<span class="cm">		 * the array of dll_sect structures.</span>
<span class="cm">		 */</span>
		<span class="n">sect_str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">module_struct</span><span class="o">-&gt;</span>
					<span class="n">sects</span><span class="p">[</span><span class="n">module_struct</span><span class="o">-&gt;</span><span class="n">num_sects</span><span class="p">];</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sect_str</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Advance to the first section name string.</span>
<span class="cm">		 * Each string follows the one before.</span>
<span class="cm">		 */</span>
		<span class="n">sect_str</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sect_str</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Access each dll_sect structure and its name string. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">sect_ndx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sect_ndx</span> <span class="o">&lt;</span> <span class="n">module_struct</span><span class="o">-&gt;</span><span class="n">num_sects</span><span class="p">;</span> <span class="n">sect_ndx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;    Section: 0x%x &quot;</span><span class="p">,</span>
				<span class="n">module_struct</span><span class="o">-&gt;</span><span class="n">sects</span><span class="p">[</span><span class="n">sect_ndx</span><span class="p">].</span><span class="n">sect_load_adr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span> <span class="n">sect_str</span> <span class="o">-</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">module_struct</span><span class="p">)</span> <span class="o">&lt;</span>
				<span class="n">module_struct_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sect_str</span><span class="p">);</span>
				<span class="cm">/* Each string follows the one before. */</span>
				<span class="n">sect_str</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sect_str</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;&lt;string error&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: section name sting address &quot;</span>
					<span class="s">&quot;is invalid %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">sect_str</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">module_struct</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
