<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › tidspbridge › core › tiomap3430.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tiomap3430.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * tiomap.c</span>
<span class="cm"> *</span>
<span class="cm"> * DSP-BIOS Bridge driver support functions for TI OMAP processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Processor Manager Driver for TI OMAP3430 EVM.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;plat/dsp.h&gt;</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cm">/*  ----------------------------------- Host OS */</span>
<span class="cp">#include &lt;dspbridge/host_os.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>

<span class="cm">/*  ----------------------------------- DSP/BIOS Bridge */</span>
<span class="cp">#include &lt;dspbridge/dbdefs.h&gt;</span>

<span class="cm">/*  ----------------------------------- OS Adaptation Layer */</span>
<span class="cp">#include &lt;dspbridge/drv.h&gt;</span>
<span class="cp">#include &lt;dspbridge/sync.h&gt;</span>

<span class="cm">/* ------------------------------------ Hardware Abstraction Layer */</span>
<span class="cp">#include &lt;hw_defs.h&gt;</span>
<span class="cp">#include &lt;hw_mmu.h&gt;</span>

<span class="cm">/*  ----------------------------------- Link Driver */</span>
<span class="cp">#include &lt;dspbridge/dspdefs.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspchnl.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspdeh.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspio.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspmsg.h&gt;</span>
<span class="cp">#include &lt;dspbridge/pwr.h&gt;</span>
<span class="cp">#include &lt;dspbridge/io_sm.h&gt;</span>

<span class="cm">/*  ----------------------------------- Platform Manager */</span>
<span class="cp">#include &lt;dspbridge/dev.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dspapi.h&gt;</span>
<span class="cp">#include &lt;dspbridge/dmm.h&gt;</span>
<span class="cp">#include &lt;dspbridge/wdt.h&gt;</span>

<span class="cm">/*  ----------------------------------- Local */</span>
<span class="cp">#include &quot;_tiomap.h&quot;</span>
<span class="cp">#include &quot;_tiomap_pwr.h&quot;</span>
<span class="cp">#include &quot;tiomap_io.h&quot;</span>

<span class="cm">/* Offset in shared mem to write to in order to synchronize start with DSP */</span>
<span class="cp">#define SHMSYNCOFFSET 4		</span><span class="cm">/* GPP byte offset */</span><span class="cp"></span>

<span class="cp">#define BUFFERSIZE 1024</span>

<span class="cp">#define TIHELEN_ACKTIMEOUT  10000</span>

<span class="cp">#define MMU_SECTION_ADDR_MASK    0xFFF00000</span>
<span class="cp">#define MMU_SSECTION_ADDR_MASK   0xFF000000</span>
<span class="cp">#define MMU_LARGE_PAGE_MASK      0xFFFF0000</span>
<span class="cp">#define MMU_SMALL_PAGE_MASK      0xFFFFF000</span>
<span class="cp">#define OMAP3_IVA2_BOOTADDR_MASK 0xFFFFFC00</span>
<span class="cp">#define PAGES_II_LVL_TABLE   512</span>
<span class="cp">#define PHYS_TO_PAGE(phys)      pfn_to_page((phys) &gt;&gt; PAGE_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * This is a totally ugly layer violation, but needed until</span>
<span class="cm"> * omap_ctrl_set_dsp_boot*() are provided.</span>
<span class="cm"> */</span>
<span class="cp">#define OMAP3_IVA2_BOOTMOD_IDLE 1</span>
<span class="cp">#define OMAP2_CONTROL_GENERAL 0x270</span>
<span class="cp">#define OMAP343X_CONTROL_IVA2_BOOTADDR (OMAP2_CONTROL_GENERAL + 0x0190)</span>
<span class="cp">#define OMAP343X_CONTROL_IVA2_BOOTMOD (OMAP2_CONTROL_GENERAL + 0x0194)</span>

<span class="cm">/* Forward Declarations: */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="o">*</span><span class="n">host_buff</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">mem_type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="o">*</span><span class="n">board_state</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="o">*</span><span class="n">host_buff</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">mem_type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">brd_state</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_mem_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">dsp_dest_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_src_addr</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_mem_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="o">*</span><span class="n">host_buff</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_mem_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">ul_mpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">virt_addr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_map_attr</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">mapped_pages</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_brd_mem_un_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">virt_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_dev_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span>
					<span class="o">**</span><span class="n">dev_cntxt</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">config_param</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_dev_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">dw_cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pargs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bridge_dev_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">user_va2_pa</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">address</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pte_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pa</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">va</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">hw_mmu_map_attrs_t</span> <span class="o">*</span><span class="n">map_attrs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pte_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">pg_table_attrs</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">va</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hw_mmu_map_attrs_t</span> <span class="o">*</span><span class="n">attrs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mem_map_vmalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">ul_mpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">virt_addr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hw_mmu_map_attrs_t</span> <span class="o">*</span><span class="n">hw_attrs</span><span class="p">);</span>

<span class="n">bool</span> <span class="n">wait_for_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dw_sync_addr</span><span class="p">);</span>

<span class="cm">/*  ----------------------------------- Globals */</span>

<span class="cm">/* Attributes of L2 page tables for DSP MMU */</span>
<span class="k">struct</span> <span class="n">page_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">num_entries</span><span class="p">;</span>	<span class="cm">/* Number of valid PTEs in the L2 PT */</span>
<span class="p">};</span>

<span class="cm">/* Attributes used to manage the DSP MMU page tables */</span>
<span class="k">struct</span> <span class="n">pg_table_attrs</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">pg_lock</span><span class="p">;</span>	<span class="cm">/* Critical section object handle */</span>

	<span class="n">u32</span> <span class="n">l1_base_pa</span><span class="p">;</span>		<span class="cm">/* Physical address of the L1 PT */</span>
	<span class="n">u32</span> <span class="n">l1_base_va</span><span class="p">;</span>		<span class="cm">/* Virtual  address of the L1 PT */</span>
	<span class="n">u32</span> <span class="n">l1_size</span><span class="p">;</span>		<span class="cm">/* Size of the L1 PT */</span>
	<span class="n">u32</span> <span class="n">l1_tbl_alloc_pa</span><span class="p">;</span>
	<span class="cm">/* Physical address of Allocated mem for L1 table. May not be aligned */</span>
	<span class="n">u32</span> <span class="n">l1_tbl_alloc_va</span><span class="p">;</span>
	<span class="cm">/* Virtual address of Allocated mem for L1 table. May not be aligned */</span>
	<span class="n">u32</span> <span class="n">l1_tbl_alloc_sz</span><span class="p">;</span>
	<span class="cm">/* Size of consistent memory allocated for L1 table.</span>
<span class="cm">	 * May not be aligned */</span>

	<span class="n">u32</span> <span class="n">l2_base_pa</span><span class="p">;</span>		<span class="cm">/* Physical address of the L2 PT */</span>
	<span class="n">u32</span> <span class="n">l2_base_va</span><span class="p">;</span>		<span class="cm">/* Virtual  address of the L2 PT */</span>
	<span class="n">u32</span> <span class="n">l2_size</span><span class="p">;</span>		<span class="cm">/* Size of the L2 PT */</span>
	<span class="n">u32</span> <span class="n">l2_tbl_alloc_pa</span><span class="p">;</span>
	<span class="cm">/* Physical address of Allocated mem for L2 table. May not be aligned */</span>
	<span class="n">u32</span> <span class="n">l2_tbl_alloc_va</span><span class="p">;</span>
	<span class="cm">/* Virtual address of Allocated mem for L2 table. May not be aligned */</span>
	<span class="n">u32</span> <span class="n">l2_tbl_alloc_sz</span><span class="p">;</span>
	<span class="cm">/* Size of consistent memory allocated for L2 table.</span>
<span class="cm">	 * May not be aligned */</span>

	<span class="n">u32</span> <span class="n">l2_num_pages</span><span class="p">;</span>	<span class="cm">/* Number of allocated L2 PT */</span>
	<span class="cm">/* Array [l2_num_pages] of L2 PT info structs */</span>
	<span class="k">struct</span> <span class="n">page_info</span> <span class="o">*</span><span class="n">pg_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  This Bridge driver&#39;s function interface table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="n">drv_interface_fxns</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* Bridge API ver. for which this bridge driver is built. */</span>
	<span class="n">BRD_API_MAJOR_VERSION</span><span class="p">,</span>
	<span class="n">BRD_API_MINOR_VERSION</span><span class="p">,</span>
	<span class="n">bridge_dev_create</span><span class="p">,</span>
	<span class="n">bridge_dev_destroy</span><span class="p">,</span>
	<span class="n">bridge_dev_ctrl</span><span class="p">,</span>
	<span class="n">bridge_brd_monitor</span><span class="p">,</span>
	<span class="n">bridge_brd_start</span><span class="p">,</span>
	<span class="n">bridge_brd_stop</span><span class="p">,</span>
	<span class="n">bridge_brd_status</span><span class="p">,</span>
	<span class="n">bridge_brd_read</span><span class="p">,</span>
	<span class="n">bridge_brd_write</span><span class="p">,</span>
	<span class="n">bridge_brd_set_state</span><span class="p">,</span>
	<span class="n">bridge_brd_mem_copy</span><span class="p">,</span>
	<span class="n">bridge_brd_mem_write</span><span class="p">,</span>
	<span class="n">bridge_brd_mem_map</span><span class="p">,</span>
	<span class="n">bridge_brd_mem_un_map</span><span class="p">,</span>
	<span class="cm">/* The following CHNL functions are provided by chnl_io.lib: */</span>
	<span class="n">bridge_chnl_create</span><span class="p">,</span>
	<span class="n">bridge_chnl_destroy</span><span class="p">,</span>
	<span class="n">bridge_chnl_open</span><span class="p">,</span>
	<span class="n">bridge_chnl_close</span><span class="p">,</span>
	<span class="n">bridge_chnl_add_io_req</span><span class="p">,</span>
	<span class="n">bridge_chnl_get_ioc</span><span class="p">,</span>
	<span class="n">bridge_chnl_cancel_io</span><span class="p">,</span>
	<span class="n">bridge_chnl_flush_io</span><span class="p">,</span>
	<span class="n">bridge_chnl_get_info</span><span class="p">,</span>
	<span class="n">bridge_chnl_get_mgr_info</span><span class="p">,</span>
	<span class="n">bridge_chnl_idle</span><span class="p">,</span>
	<span class="n">bridge_chnl_register_notify</span><span class="p">,</span>
	<span class="cm">/* The following IO functions are provided by chnl_io.lib: */</span>
	<span class="n">bridge_io_create</span><span class="p">,</span>
	<span class="n">bridge_io_destroy</span><span class="p">,</span>
	<span class="n">bridge_io_on_loaded</span><span class="p">,</span>
	<span class="n">bridge_io_get_proc_load</span><span class="p">,</span>
	<span class="cm">/* The following msg_ctrl functions are provided by chnl_io.lib: */</span>
	<span class="n">bridge_msg_create</span><span class="p">,</span>
	<span class="n">bridge_msg_create_queue</span><span class="p">,</span>
	<span class="n">bridge_msg_delete</span><span class="p">,</span>
	<span class="n">bridge_msg_delete_queue</span><span class="p">,</span>
	<span class="n">bridge_msg_get</span><span class="p">,</span>
	<span class="n">bridge_msg_put</span><span class="p">,</span>
	<span class="n">bridge_msg_register_notify</span><span class="p">,</span>
	<span class="n">bridge_msg_set_queue_id</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">dsp_mbox_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">io_mbox_msg</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">brd_state</span> <span class="o">==</span> <span class="n">BRD_DSP_HIBERNATION</span> <span class="o">||</span>
	    <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">brd_state</span> <span class="o">==</span> <span class="n">BRD_HIBERNATION</span><span class="p">)</span>
		<span class="n">wake_dsp</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">hw_mmu_tlb_flush_all</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_mmu_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bad_page_dump</span><span class="p">(</span><span class="n">u32</span> <span class="n">pa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;DSPBRIDGE: MAP function: COUNT 0 FOR PA 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pa</span><span class="p">);</span>
	<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Bad page state in process &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span>
		 <span class="s">&quot;page:%p flags:0x%0*lx mapping:%p mapcount:%d count:%d</span><span class="se">\n</span><span class="s">&quot;</span>
		 <span class="s">&quot;Backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">pg</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)),</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">,</span>
		 <span class="n">page_mapcount</span><span class="p">(</span><span class="n">pg</span><span class="p">),</span> <span class="n">page_count</span><span class="p">(</span><span class="n">pg</span><span class="p">));</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_drv_entry ========</span>
<span class="cm"> *  purpose:</span>
<span class="cm"> *      Bridge Driver entry point.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bridge_drv_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_drv_interface</span> <span class="o">**</span><span class="n">drv_intf</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_file_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">driver_file_name</span><span class="p">,</span> <span class="s">&quot;UMA&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">drv_intf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">drv_interface_fxns</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s Unknown Bridge file name&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_monitor ========</span>
<span class="cm"> *  purpose:</span>
<span class="cm"> *      This bridge_brd_monitor puts DSP into a Loadable state.</span>
<span class="cm"> *      i.e Application can load and start the device.</span>
<span class="cm"> *</span>
<span class="cm"> *  Preconditions:</span>
<span class="cm"> *      Device in &#39;OFF&#39; state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_dsp_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span>
		<span class="n">omap_dspbridge_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_read</span><span class="p">)(</span><span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_PM_PWSTST</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="n">OMAP_POWERSTATEST_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* IVA2 is not in ON state */</span>
		<span class="cm">/* Read and set PM_PWSTCTRL_IVA2  to ON */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_rmw_bits</span><span class="p">)(</span><span class="n">OMAP_POWERSTATEST_MASK</span><span class="p">,</span>
			<span class="n">PWRDM_POWER_ON</span><span class="p">,</span> <span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_PM_PWSTCTRL</span><span class="p">);</span>
		<span class="cm">/* Set the SW supervised state transition */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_cm_write</span><span class="p">)(</span><span class="n">OMAP34XX_CLKSTCTRL_FORCE_WAKEUP</span><span class="p">,</span>
					<span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_CM_CLKSTCTRL</span><span class="p">);</span>

		<span class="cm">/* Wait until the state has moved to ON */</span>
		<span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_read</span><span class="p">)(</span><span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_PM_PWSTST</span><span class="p">)</span> <span class="o">&amp;</span>
						<span class="n">OMAP_INTRANSITION_MASK</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="cm">/* Disable Automatic transition */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_cm_write</span><span class="p">)(</span><span class="n">OMAP34XX_CLKSTCTRL_DISABLE_AUTO</span><span class="p">,</span>
					<span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_CM_CLKSTCTRL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_rmw_bits</span><span class="p">)(</span><span class="n">OMAP3430_RST2_IVA2_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_RM_RSTCTRL</span><span class="p">);</span>
	<span class="n">dsp_clk_enable</span><span class="p">(</span><span class="n">DSP_CLK_IVA2</span><span class="p">);</span>

	<span class="cm">/* set the device state to IDLE */</span>
	<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">brd_state</span> <span class="o">=</span> <span class="n">BRD_IDLE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_read ========</span>
<span class="cm"> *  purpose:</span>
<span class="cm"> *      Reads buffers for DSP memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="o">*</span><span class="n">host_buff</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dsp_base_addr</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="o">-&gt;</span><span class="n">dsp_base_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dsp_addr</span> <span class="o">&lt;</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_start_add</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* change here to account for the 3 bands of the DSP internal memory */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dsp_addr</span> <span class="o">-</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_start_add</span><span class="p">)</span> <span class="o">&lt;</span>
	    <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">internal_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">dsp_addr</span> <span class="o">-</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_start_add</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">read_ext_dsp_data</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">host_buff</span><span class="p">,</span> <span class="n">dsp_addr</span><span class="p">,</span>
					   <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">mem_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* copy the data from  DSP memory, */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">host_buff</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">dsp_base_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="n">ul_num_bytes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_set_state ========</span>
<span class="cm"> *  purpose:</span>
<span class="cm"> *      This routine updates the Board status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">brd_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>

	<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">brd_state</span> <span class="o">=</span> <span class="n">brd_state</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_start ========</span>
<span class="cm"> *  purpose:</span>
<span class="cm"> *      Initializes DSP MMU and Starts DSP.</span>
<span class="cm"> *</span>
<span class="cm"> *  Preconditions:</span>
<span class="cm"> *  a) DSP domain is &#39;ACTIVE&#39;.</span>
<span class="cm"> *  b) DSP_RST1 is asserted.</span>
<span class="cm"> *  b) DSP_RST2 is released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dw_sync_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_shm_base</span><span class="p">;</span>	<span class="cm">/* Gpp Phys SM base addr(byte) */</span>
	<span class="n">u32</span> <span class="n">ul_shm_base_virt</span><span class="p">;</span>	<span class="cm">/* Dsp Virt SM base addr */</span>
	<span class="n">u32</span> <span class="n">ul_tlb_base_virt</span><span class="p">;</span>	<span class="cm">/* Base of MMU TLB entry */</span>
	<span class="cm">/* Offset of shm_base_virt from tlb_base_virt */</span>
	<span class="n">u32</span> <span class="n">ul_shm_offset_virt</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">entry_ndx</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">itmp_entry_ndx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* DSP-MMU TLB entry base address */</span>
	<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">resources</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_dsp_clk_rate</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_dsp_clk_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_bios_gp_timer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">clk_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_mgr</span> <span class="o">*</span><span class="n">hio_mgr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_load_monitor_timer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wdt_en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_dsp_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span>
		<span class="n">omap_dspbridge_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="cm">/* The device context contains all the mmu setup info from when the</span>
<span class="cm">	 * last dsp base image was loaded. The first entry is always</span>
<span class="cm">	 * SHMMEM base. */</span>
	<span class="cm">/* Get SHM_BEG - convert to byte address */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dev_get_symbol</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="n">SHMBASENAME</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">ul_shm_base_virt</span><span class="p">);</span>
	<span class="n">ul_shm_base_virt</span> <span class="o">*=</span> <span class="n">DSPWORDSIZE</span><span class="p">;</span>
	<span class="cm">/* DSP Virtual address */</span>
	<span class="n">ul_tlb_base_virt</span> <span class="o">=</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">atlb_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dsp_va</span><span class="p">;</span>
	<span class="n">ul_shm_offset_virt</span> <span class="o">=</span>
	    <span class="n">ul_shm_base_virt</span> <span class="o">-</span> <span class="p">(</span><span class="n">ul_tlb_base_virt</span> <span class="o">*</span> <span class="n">DSPWORDSIZE</span><span class="p">);</span>
	<span class="cm">/* Kernel logical address */</span>
	<span class="n">ul_shm_base</span> <span class="o">=</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">atlb_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gpp_va</span> <span class="o">+</span> <span class="n">ul_shm_offset_virt</span><span class="p">;</span>

	<span class="cm">/* 2nd wd is used as sync field */</span>
	<span class="n">dw_sync_addr</span> <span class="o">=</span> <span class="n">ul_shm_base</span> <span class="o">+</span> <span class="n">SHMSYNCOFFSET</span><span class="p">;</span>
	<span class="cm">/* Write a signature into the shm base + offset; this will</span>
<span class="cm">	 * get cleared when the DSP program starts. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ul_shm_base_virt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ul_shm_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Illegal SM base</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">dw_sync_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resources</span> <span class="o">=</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resources</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

		<span class="cm">/* Assert RST1 i.e only the RST only for DSP megacell */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * XXX: ioremapping  MUST be removed once ctrl</span>
<span class="cm">			 * function is made available.</span>
<span class="cm">			 */</span>
			<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ctrl</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">OMAP343X_CTRL_BASE</span><span class="p">,</span> <span class="n">SZ_4K</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctrl</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_rmw_bits</span><span class="p">)(</span><span class="n">OMAP3430_RST1_IVA2_MASK</span><span class="p">,</span>
					<span class="n">OMAP3430_RST1_IVA2_MASK</span><span class="p">,</span> <span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span>
					<span class="n">OMAP2_RM_RSTCTRL</span><span class="p">);</span>
			<span class="cm">/* Mask address with 1K for compatibility */</span>
			<span class="n">__raw_writel</span><span class="p">(</span><span class="n">dsp_addr</span> <span class="o">&amp;</span> <span class="n">OMAP3_IVA2_BOOTADDR_MASK</span><span class="p">,</span>
					<span class="n">ctrl</span> <span class="o">+</span> <span class="n">OMAP343X_CONTROL_IVA2_BOOTADDR</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Set bootmode to self loop if dsp_debug flag is true</span>
<span class="cm">			 */</span>
			<span class="n">__raw_writel</span><span class="p">((</span><span class="n">dsp_debug</span><span class="p">)</span> <span class="o">?</span> <span class="n">OMAP3_IVA2_BOOTMOD_IDLE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">ctrl</span> <span class="o">+</span> <span class="n">OMAP343X_CONTROL_IVA2_BOOTMOD</span><span class="p">);</span>

			<span class="n">iounmap</span><span class="p">(</span><span class="n">ctrl</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reset and Unreset the RST2, so that BOOTADDR is copied to</span>
<span class="cm">		 * IVA2 SYSC register */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_rmw_bits</span><span class="p">)(</span><span class="n">OMAP3430_RST2_IVA2_MASK</span><span class="p">,</span>
			<span class="n">OMAP3430_RST2_IVA2_MASK</span><span class="p">,</span> <span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_RM_RSTCTRL</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_rmw_bits</span><span class="p">)(</span><span class="n">OMAP3430_RST2_IVA2_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_RM_RSTCTRL</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

		<span class="cm">/* Disbale the DSP MMU */</span>
		<span class="n">hw_mmu_disable</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">);</span>
		<span class="cm">/* Disable TWL */</span>
		<span class="n">hw_mmu_twl_disable</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">);</span>

		<span class="cm">/* Only make TLB entry if both addresses are non-zero */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">entry_ndx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">entry_ndx</span> <span class="o">&lt;</span> <span class="n">BRDIOCTL_NUMOFMMUTLB</span><span class="p">;</span>
		     <span class="n">entry_ndx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">bridge_ioctl_extproc</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">atlb_entry</span><span class="p">[</span><span class="n">entry_ndx</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">hw_mmu_map_attrs_t</span> <span class="n">map_attrs</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">endianism</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">endianism</span><span class="p">,</span>
				<span class="p">.</span><span class="n">element_size</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">elem_size</span><span class="p">,</span>
				<span class="p">.</span><span class="n">mixed_size</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">mixed_mode</span><span class="p">,</span>
			<span class="p">};</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">gpp_pa</span> <span class="o">||</span> <span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">dsp_va</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
					<span class="s">&quot;MMU %d, pa: 0x%x, va: 0x%x, size: 0x%x&quot;</span><span class="p">,</span>
					<span class="n">itmp_entry_ndx</span><span class="p">,</span>
					<span class="n">e</span><span class="o">-&gt;</span><span class="n">gpp_pa</span><span class="p">,</span>
					<span class="n">e</span><span class="o">-&gt;</span><span class="n">dsp_va</span><span class="p">,</span>
					<span class="n">e</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

			<span class="n">hw_mmu_tlb_add</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_mmu_base</span><span class="p">,</span>
					<span class="n">e</span><span class="o">-&gt;</span><span class="n">gpp_pa</span><span class="p">,</span>
					<span class="n">e</span><span class="o">-&gt;</span><span class="n">dsp_va</span><span class="p">,</span>
					<span class="n">e</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					<span class="n">itmp_entry_ndx</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">map_attrs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">itmp_entry_ndx</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Lock the above TLB entries and get the BIOS and load monitor timer</span>
<span class="cm">	 * information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_mmu_num_locked_set</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">,</span> <span class="n">itmp_entry_ndx</span><span class="p">);</span>
		<span class="n">hw_mmu_victim_num_set</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">,</span> <span class="n">itmp_entry_ndx</span><span class="p">);</span>
		<span class="n">hw_mmu_ttb_set</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">,</span>
			       <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_pa</span><span class="p">);</span>
		<span class="n">hw_mmu_twl_enable</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">);</span>
		<span class="cm">/* Enable the SmartIdle and AutoIdle bit for MMU_SYSCONFIG */</span>

		<span class="n">temp</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">((</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFEF</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x11</span><span class="p">;</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>

		<span class="cm">/* Let the DSP MMU run */</span>
		<span class="n">hw_mmu_enable</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">);</span>

		<span class="cm">/* Enable the BIOS clock */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dev_get_symbol</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
				     <span class="n">BRIDGEINIT_BIOSGPTIMER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_bios_gp_timer</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dev_get_symbol</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
				     <span class="n">BRIDGEINIT_LOADMON_GPTIMER</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">ul_load_monitor_timer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ul_load_monitor_timer</span> <span class="o">!=</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clk_cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">BPWR_ENABLE_CLOCK</span> <span class="o">&lt;&lt;</span> <span class="n">MBX_PM_CLK_CMDSHIFT</span><span class="p">)</span> <span class="o">|</span>
			    <span class="n">ul_load_monitor_timer</span><span class="p">;</span>
			<span class="n">dsp_peripheral_clk_ctrl</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_cmd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;Not able to get the symbol for Load &quot;</span>
				<span class="s">&quot;Monitor Timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ul_bios_gp_timer</span> <span class="o">!=</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clk_cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">BPWR_ENABLE_CLOCK</span> <span class="o">&lt;&lt;</span> <span class="n">MBX_PM_CLK_CMDSHIFT</span><span class="p">)</span> <span class="o">|</span>
			    <span class="n">ul_bios_gp_timer</span><span class="p">;</span>
			<span class="n">dsp_peripheral_clk_ctrl</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clk_cmd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
				<span class="s">&quot;Not able to get the symbol for BIOS Timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the DSP clock rate */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dev_get_symbol</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span>
				     <span class="s">&quot;_BRIDGEINIT_DSP_FREQ&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ul_dsp_clk_addr</span><span class="p">);</span>
		<span class="cm">/*Set Autoidle Mode for IVA2 PLL */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_cm_write</span><span class="p">)(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">OMAP3430_AUTO_IVA2_DPLL_SHIFT</span><span class="p">,</span>
				<span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP3430_CM_AUTOIDLE_PLL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">ul_dsp_clk_addr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Get the clock rate */</span>
			<span class="n">ul_dsp_clk_rate</span> <span class="o">=</span> <span class="n">dsp_clk_get_iva2_rate</span><span class="p">();</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: DSP clock rate (KHZ): 0x%x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ul_dsp_clk_rate</span><span class="p">);</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">bridge_brd_write</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span>
					       <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ul_dsp_clk_rate</span><span class="p">,</span>
					       <span class="n">ul_dsp_clk_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Enable Mailbox events and also drain any pending</span>
<span class="cm">		 * stale messages.</span>
<span class="cm">		 */</span>
		<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">omap_mbox_get</span><span class="p">(</span><span class="s">&quot;dsp&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsp_mbox_notifier</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">mbox</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to get dsp mailbox handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
<span class="cm">/*PM_IVA2GRPSEL_PER = 0xC0;*/</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">per_pm_base</span> <span class="o">+</span> <span class="mh">0xA8</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF30</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xC0</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">resources</span><span class="o">-&gt;</span><span class="n">per_pm_base</span> <span class="o">+</span> <span class="mh">0xA8</span><span class="p">);</span>

<span class="cm">/*PM_MPUGRPSEL_PER &amp;= 0xFFFFFF3F; */</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">per_pm_base</span> <span class="o">+</span> <span class="mh">0xA4</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF3F</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">resources</span><span class="o">-&gt;</span><span class="n">per_pm_base</span> <span class="o">+</span> <span class="mh">0xA4</span><span class="p">);</span>
<span class="cm">/*CM_SLEEPDEP_PER |= 0x04; */</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">per_base</span> <span class="o">+</span> <span class="mh">0x44</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFB</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x04</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">resources</span><span class="o">-&gt;</span><span class="n">per_base</span> <span class="o">+</span> <span class="mh">0x44</span><span class="p">);</span>

<span class="cm">/*CM_CLKSTCTRL_IVA2 = 0x00000003 -To Allow automatic transitions */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_cm_write</span><span class="p">)(</span><span class="n">OMAP34XX_CLKSTCTRL_ENABLE_AUTO</span><span class="p">,</span>
					<span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_CM_CLKSTCTRL</span><span class="p">);</span>

		<span class="cm">/* Let DSP go */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s Unreset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* Enable DSP MMU Interrupts */</span>
		<span class="n">hw_mmu_event_enable</span><span class="p">(</span><span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">,</span>
				    <span class="n">HW_MMU_ALL_INTERRUPTS</span><span class="p">);</span>
		<span class="cm">/* release the RST1, DSP starts executing now .. */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_rmw_bits</span><span class="p">)(</span><span class="n">OMAP3430_RST1_IVA2_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_RM_RSTCTRL</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;Waiting for Sync @ 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dw_sync_addr</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;DSP c_int00 Address =  0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dsp_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dsp_debug</span><span class="p">)</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">__raw_readw</span><span class="p">(</span><span class="n">dw_sync_addr</span><span class="p">))</span>
				<span class="p">;</span>

		<span class="cm">/* Wait for DSP to clear word in shared memory */</span>
		<span class="cm">/* Read the Location */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_for_start</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">dw_sync_addr</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

		<span class="n">dev_get_symbol</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="s">&quot;_WDT_enable&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wdt_en</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wdt_en</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Start wdt */</span>
			<span class="n">dsp_wdt_sm_set</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ul_shm_base</span><span class="p">);</span>
			<span class="n">dsp_wdt_enable</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">dev_get_io_mgr</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dev_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hio_mgr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hio_mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">io_sh_msetting</span><span class="p">(</span><span class="n">hio_mgr</span><span class="p">,</span> <span class="n">SHM_OPPINFO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="cm">/* Write the synchronization bit to indicate the</span>
<span class="cm">			 * completion of OPP table update to DSP</span>
<span class="cm">			 */</span>
			<span class="n">__raw_writel</span><span class="p">(</span><span class="mi">0</span><span class="n">XCAFECAFE</span><span class="p">,</span> <span class="n">dw_sync_addr</span><span class="p">);</span>

			<span class="cm">/* update board state */</span>
			<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">brd_state</span> <span class="o">=</span> <span class="n">BRD_RUNNING</span><span class="p">;</span>
			<span class="cm">/* (void)chnlsm_enable_interrupt(dev_context); */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">brd_state</span> <span class="o">=</span> <span class="n">BRD_UNKNOWN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_stop ========</span>
<span class="cm"> *  purpose:</span>
<span class="cm"> *      Puts DSP in self loop.</span>
<span class="cm"> *</span>
<span class="cm"> *  Preconditions :</span>
<span class="cm"> *  a) None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pg_table_attrs</span> <span class="o">*</span><span class="n">pt_attrs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dsp_pwr_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_dsp_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span>
		<span class="n">omap_dspbridge_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">brd_state</span> <span class="o">==</span> <span class="n">BRD_STOPPED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* as per TRM, it is advised to first drive the IVA2 to &#39;Standby&#39; mode,</span>
<span class="cm">	 * before turning off the clocks.. This is to ensure that there are no</span>
<span class="cm">	 * pending L3 or other transactons from IVA2 */</span>
	<span class="n">dsp_pwr_state</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_read</span><span class="p">)(</span><span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_PM_PWSTST</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="n">OMAP_POWERSTATEST_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dsp_pwr_state</span> <span class="o">!=</span> <span class="n">PWRDM_POWER_OFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_rmw_bits</span><span class="p">)(</span><span class="n">OMAP3430_RST2_IVA2_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_RM_RSTCTRL</span><span class="p">);</span>
		<span class="n">sm_interrupt_dsp</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">MBX_PM_DSPIDLE</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="cm">/* IVA2 is not in OFF state */</span>
		<span class="cm">/* Set PM_PWSTCTRL_IVA2  to OFF */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_rmw_bits</span><span class="p">)(</span><span class="n">OMAP_POWERSTATEST_MASK</span><span class="p">,</span>
			<span class="n">PWRDM_POWER_OFF</span><span class="p">,</span> <span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_PM_PWSTCTRL</span><span class="p">);</span>
		<span class="cm">/* Set the SW supervised state transition for Sleep */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_cm_write</span><span class="p">)(</span><span class="n">OMAP34XX_CLKSTCTRL_FORCE_SLEEP</span><span class="p">,</span>
					<span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_CM_CLKSTCTRL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="cm">/* Release the Ext Base virtual Address as the next DSP Program</span>
<span class="cm">	 * may have a different load address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_ext_base_addr</span><span class="p">)</span>
		<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_ext_base_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">brd_state</span> <span class="o">=</span> <span class="n">BRD_STOPPED</span><span class="p">;</span>	<span class="cm">/* update board state */</span>

	<span class="n">dsp_wdt_enable</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

	<span class="cm">/* This is a good place to clear the MMU page tables as well */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">pt_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pt_attrs</span> <span class="o">=</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">pt_attrs</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_va</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_size</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_base_va</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_size</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">pg_info</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_num_pages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page_info</span><span class="p">)));</span>
	<span class="p">}</span>
	<span class="cm">/* Disable the mailbox interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap_mbox_disable_irq</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">,</span> <span class="n">IRQ_RX</span><span class="p">);</span>
		<span class="n">omap_mbox_put</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsp_mbox_notifier</span><span class="p">);</span>
		<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">mbox</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Reset IVA2 clocks*/</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">dsp_prm_write</span><span class="p">)(</span><span class="n">OMAP3430_RST1_IVA2_MASK</span> <span class="o">|</span> <span class="n">OMAP3430_RST2_IVA2_MASK</span> <span class="o">|</span>
			<span class="n">OMAP3430_RST3_IVA2_MASK</span><span class="p">,</span> <span class="n">OMAP3430_IVA2_MOD</span><span class="p">,</span> <span class="n">OMAP2_RM_RSTCTRL</span><span class="p">);</span>

	<span class="n">dsp_clock_disable_all</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_per_clks</span><span class="p">);</span>
	<span class="n">dsp_clk_disable</span><span class="p">(</span><span class="n">DSP_CLK_IVA2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_status ========</span>
<span class="cm"> *      Returns the board status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="o">*</span><span class="n">board_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="o">*</span><span class="n">board_state</span> <span class="o">=</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">brd_state</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_write ========</span>
<span class="cm"> *      Copies the buffers to DSP internal or external memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="o">*</span><span class="n">host_buff</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dsp_addr</span> <span class="o">&lt;</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_start_add</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dsp_addr</span> <span class="o">-</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_start_add</span><span class="p">)</span> <span class="o">&lt;</span>
	    <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">internal_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">write_dsp_data</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">host_buff</span><span class="p">,</span> <span class="n">dsp_addr</span><span class="p">,</span>
					<span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">mem_type</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">write_ext_dsp_data</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">host_buff</span><span class="p">,</span> <span class="n">dsp_addr</span><span class="p">,</span>
					    <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">mem_type</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_dev_create ========</span>
<span class="cm"> *      Creates a driver object. Puts DSP in self loop.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_dev_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span>
					<span class="o">**</span><span class="n">dev_cntxt</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dev_object</span> <span class="o">*</span><span class="n">hdev_obj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">config_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">entry_ndx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">resources</span> <span class="o">=</span> <span class="n">config_param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pg_table_attrs</span> <span class="o">*</span><span class="n">pt_attrs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pg_tbl_pa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pg_tbl_va</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">align_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="cm">/* Allocate and initialize a data structure to contain the bridge driver</span>
<span class="cm">	 *  state, which becomes the context for later calls into this driver */</span>
	<span class="n">dev_context</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">func_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_start_add</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">OMAP_GEM_BASE</span><span class="p">;</span>
	<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">self_loop</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_per_clks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">internal_size</span> <span class="o">=</span> <span class="n">OMAP_DSP_SIZE</span><span class="p">;</span>
	<span class="cm">/*  Clear dev context MMU table entries.</span>
<span class="cm">	 *  These get set on bridge_io_on_loaded() call after program loaded. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">entry_ndx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">entry_ndx</span> <span class="o">&lt;</span> <span class="n">BRDIOCTL_NUMOFMMUTLB</span><span class="p">;</span> <span class="n">entry_ndx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">atlb_entry</span><span class="p">[</span><span class="n">entry_ndx</span><span class="p">].</span><span class="n">gpp_pa</span> <span class="o">=</span>
		    <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">atlb_entry</span><span class="p">[</span><span class="n">entry_ndx</span><span class="p">].</span><span class="n">dsp_va</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_base_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">MEM_LINEAR_ADDRESS</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
								 <span class="p">(</span><span class="n">config_param</span><span class="o">-&gt;</span>
								  <span class="n">mem_base</span>
								  <span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
								 <span class="n">config_param</span><span class="o">-&gt;</span>
								 <span class="n">mem_length</span>
								 <span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_base_addr</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">pt_attrs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pg_table_attrs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pt_attrs</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_size</span> <span class="o">=</span> <span class="n">SZ_16K</span><span class="p">;</span> <span class="cm">/* 4096 entries of 32 bits */</span>
		<span class="n">align_size</span> <span class="o">=</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_size</span><span class="p">;</span>
		<span class="cm">/* Align sizes are expected to be power of 2 */</span>
		<span class="cm">/* we like to get aligned on L1 table size */</span>
		<span class="n">pg_tbl_va</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">mem_alloc_phys_mem</span><span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_size</span><span class="p">,</span>
						     <span class="n">align_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pg_tbl_pa</span><span class="p">);</span>

		<span class="cm">/* Check if the PA is aligned for us */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pg_tbl_pa</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">align_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* PA not aligned to page table size ,</span>
<span class="cm">			 * try with more allocation and align */</span>
			<span class="n">mem_free_phys_mem</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pg_tbl_va</span><span class="p">,</span> <span class="n">pg_tbl_pa</span><span class="p">,</span>
					  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_size</span><span class="p">);</span>
			<span class="cm">/* we like to get aligned on L1 table size */</span>
			<span class="n">pg_tbl_va</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">mem_alloc_phys_mem</span><span class="p">((</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
						     <span class="n">align_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pg_tbl_pa</span><span class="p">);</span>
			<span class="cm">/* We should be able to get aligned table now */</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_pa</span> <span class="o">=</span> <span class="n">pg_tbl_pa</span><span class="p">;</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_va</span> <span class="o">=</span> <span class="n">pg_tbl_va</span><span class="p">;</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_sz</span> <span class="o">=</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="cm">/* Align the PA to the next &#39;align&#39;  boundary */</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_pa</span> <span class="o">=</span>
			    <span class="p">((</span><span class="n">pg_tbl_pa</span><span class="p">)</span> <span class="o">+</span>
			     <span class="p">(</span><span class="n">align_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">align_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_va</span> <span class="o">=</span>
			    <span class="n">pg_tbl_va</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_pa</span> <span class="o">-</span> <span class="n">pg_tbl_pa</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* We got aligned PA, cool */</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_pa</span> <span class="o">=</span> <span class="n">pg_tbl_pa</span><span class="p">;</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_va</span> <span class="o">=</span> <span class="n">pg_tbl_va</span><span class="p">;</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_sz</span> <span class="o">=</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_size</span><span class="p">;</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_pa</span> <span class="o">=</span> <span class="n">pg_tbl_pa</span><span class="p">;</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_va</span> <span class="o">=</span> <span class="n">pg_tbl_va</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_va</span><span class="p">)</span>
			<span class="n">memset</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_va</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
			       <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_size</span><span class="p">);</span>

		<span class="cm">/* number of L2 page tables = DMM pool used + SHMMEM +EXTMEM +</span>
<span class="cm">		 * L4 pages */</span>
		<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_num_pages</span> <span class="o">=</span> <span class="p">((</span><span class="n">DMMPOOLSIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_size</span> <span class="o">=</span> <span class="n">HW_MMU_COARSE_PAGE_SIZE</span> <span class="o">*</span>
		    <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_num_pages</span><span class="p">;</span>
		<span class="n">align_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Make it u32 aligned */</span>
		<span class="cm">/* we like to get aligned on L1 table size */</span>
		<span class="n">pg_tbl_va</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">mem_alloc_phys_mem</span><span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_size</span><span class="p">,</span>
						     <span class="n">align_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pg_tbl_pa</span><span class="p">);</span>
		<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_pa</span> <span class="o">=</span> <span class="n">pg_tbl_pa</span><span class="p">;</span>
		<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_va</span> <span class="o">=</span> <span class="n">pg_tbl_va</span><span class="p">;</span>
		<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_sz</span> <span class="o">=</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_size</span><span class="p">;</span>
		<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_base_pa</span> <span class="o">=</span> <span class="n">pg_tbl_pa</span><span class="p">;</span>
		<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_base_va</span> <span class="o">=</span> <span class="n">pg_tbl_va</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_base_va</span><span class="p">)</span>
			<span class="n">memset</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_base_va</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
			       <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_size</span><span class="p">);</span>

		<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">pg_info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_num_pages</span> <span class="o">*</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
			<span class="s">&quot;L1 pa %x, va %x, size %x</span><span class="se">\n</span><span class="s"> L2 pa %x, va &quot;</span>
			<span class="s">&quot;%x, size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_pa</span><span class="p">,</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_va</span><span class="p">,</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_size</span><span class="p">,</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_base_pa</span><span class="p">,</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_base_va</span><span class="p">,</span>
			<span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_size</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;pt_attrs %p L2 NumPages %x pg_info %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pt_attrs</span><span class="p">,</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_num_pages</span><span class="p">,</span> <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">pg_info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pt_attrs</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_base_va</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_base_va</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">pg_info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">pt_attrs</span> <span class="o">=</span> <span class="n">pt_attrs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">pg_lock</span><span class="p">);</span>
		<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">tc_word_swap_on</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">tc_wordswapon</span><span class="p">;</span>

		<span class="cm">/* Set the Clock Divisor for the DSP module */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="cm">/* MMU address is obtained from the host</span>
<span class="cm">		 * resources struct */</span>
		<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_mmu_base</span> <span class="o">=</span> <span class="n">resources</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dev_obj</span> <span class="o">=</span> <span class="n">hdev_obj</span><span class="p">;</span>
		<span class="cm">/* Store current board state. */</span>
		<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">brd_state</span> <span class="o">=</span> <span class="n">BRD_UNKNOWN</span><span class="p">;</span>
		<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">resources</span> <span class="o">=</span> <span class="n">resources</span><span class="p">;</span>
		<span class="n">dsp_clk_enable</span><span class="p">(</span><span class="n">DSP_CLK_IVA2</span><span class="p">);</span>
		<span class="n">bridge_brd_stop</span><span class="p">(</span><span class="n">dev_context</span><span class="p">);</span>
		<span class="cm">/* Return ptr to our device state to the DSP API for storage */</span>
		<span class="o">*</span><span class="n">dev_cntxt</span> <span class="o">=</span> <span class="n">dev_context</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt_attrs</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">pg_info</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_va</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mem_free_phys_mem</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
						  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_va</span><span class="p">,</span>
						  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_pa</span><span class="p">,</span>
						  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_sz</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_va</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mem_free_phys_mem</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
						  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_va</span><span class="p">,</span>
						  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_pa</span><span class="p">,</span>
						  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_sz</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pt_attrs</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dev_context</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">func_end:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_dev_ctrl ========</span>
<span class="cm"> *      Receives device specific commands.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_dev_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">dw_cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pargs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_ioctl_extproc</span> <span class="o">*</span><span class="n">pa_ext_proc</span> <span class="o">=</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">bridge_ioctl_extproc</span> <span class="o">*</span><span class="p">)</span><span class="n">pargs</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ndx</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dw_cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BRDIOCTL_CHNLREAD</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRDIOCTL_CHNLWRITE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRDIOCTL_SETMMUCONFIG</span>:
		<span class="cm">/* store away dsp-mmu setup values for later use */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ndx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ndx</span> <span class="o">&lt;</span> <span class="n">BRDIOCTL_NUMOFMMUTLB</span><span class="p">;</span> <span class="n">ndx</span><span class="o">++</span><span class="p">,</span> <span class="n">pa_ext_proc</span><span class="o">++</span><span class="p">)</span>
			<span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">atlb_entry</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">pa_ext_proc</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRDIOCTL_DEEPSLEEP</span>:
	<span class="k">case</span> <span class="n">BRDIOCTL_EMERGENCYSLEEP</span>:
		<span class="cm">/* Currently only DSP Idle is supported Need to update for</span>
<span class="cm">		 * later releases */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sleep_dsp</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">PWR_DEEPSLEEP</span><span class="p">,</span> <span class="n">pargs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRDIOCTL_WAKEUP</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">wake_dsp</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">pargs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRDIOCTL_CLK_CTRL</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Looking For Baseport Fix for Clocks */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dsp_peripheral_clk_ctrl</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">pargs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRDIOCTL_PWR_HIBERNATE</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">handle_hibernation_from_dsp</span><span class="p">(</span><span class="n">dev_context</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRDIOCTL_PRESCALE_NOTIFY</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">pre_scale_dsp</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">pargs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRDIOCTL_POSTSCALE_NOTIFY</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">post_scale_dsp</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">pargs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRDIOCTL_CONSTRAINT_REQUEST</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">handle_constraints_set</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">pargs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_dev_destroy ========</span>
<span class="cm"> *      Destroys the driver object.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_dev_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pg_table_attrs</span> <span class="o">*</span><span class="n">pt_attrs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg_hostres</span> <span class="o">*</span><span class="n">host_res</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">shm_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_data</span> <span class="o">*</span><span class="n">drv_datap</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="cm">/* It should never happen */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_ctxt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* first put the device to stop state */</span>
	<span class="n">bridge_brd_stop</span><span class="p">(</span><span class="n">dev_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">pt_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pt_attrs</span> <span class="o">=</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">pt_attrs</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">pg_info</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_va</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mem_free_phys_mem</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_va</span><span class="p">,</span>
					  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_pa</span><span class="p">,</span>
					  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l2_tbl_alloc_sz</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_va</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mem_free_phys_mem</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_va</span><span class="p">,</span>
					  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_pa</span><span class="p">,</span>
					  <span class="n">pt_attrs</span><span class="o">-&gt;</span><span class="n">l1_tbl_alloc_sz</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pt_attrs</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">host_res</span> <span class="o">=</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
		<span class="n">shm_size</span> <span class="o">=</span> <span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">shm_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shm_size</span> <span class="o">&gt;=</span> <span class="mh">0x10000</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_phys</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">mem_free_phys_mem</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
						  <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span>
						  <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
						  <span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_phys</span>
						  <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shm_size</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s: Error getting shm size &quot;</span>
				<span class="s">&quot;from registry: %x. Not calling &quot;</span>
				<span class="s">&quot;mem_free_phys_mem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_phys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
			<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
			<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
			<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">dmmu_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">per_base</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">per_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">per_pm_base</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">per_pm_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">core_pm_base</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">host_res</span><span class="o">-&gt;</span><span class="n">core_pm_base</span><span class="p">);</span>

		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">host_res</span><span class="o">-&gt;</span><span class="n">dmmu_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">host_res</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Free the driver&#39;s device context: */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">drv_datap</span><span class="o">-&gt;</span><span class="n">base_img</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_ctxt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_mem_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">dsp_dest_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_src_addr</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">src_addr</span> <span class="o">=</span> <span class="n">dsp_src_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dest_addr</span> <span class="o">=</span> <span class="n">dsp_dest_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">copy_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_bytes</span> <span class="o">=</span> <span class="n">ul_num_bytes</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">host_buf</span><span class="p">[</span><span class="n">BUFFERSIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">total_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">copy_bytes</span> <span class="o">=</span>
		    <span class="n">total_bytes</span> <span class="o">&gt;</span> <span class="n">BUFFERSIZE</span> <span class="o">?</span> <span class="n">BUFFERSIZE</span> <span class="o">:</span> <span class="n">total_bytes</span><span class="p">;</span>
		<span class="cm">/* Read from External memory */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">read_ext_dsp_data</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">host_buf</span><span class="p">,</span> <span class="n">src_addr</span><span class="p">,</span>
					   <span class="n">copy_bytes</span><span class="p">,</span> <span class="n">mem_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dest_addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_start_add</span> <span class="o">+</span>
					 <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">internal_size</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Write to Internal memory */</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">write_dsp_data</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">host_buf</span><span class="p">,</span>
							<span class="n">dest_addr</span><span class="p">,</span> <span class="n">copy_bytes</span><span class="p">,</span>
							<span class="n">mem_type</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Write to External memory */</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">write_ext_dsp_data</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">host_buf</span><span class="p">,</span>
						       <span class="n">dest_addr</span><span class="p">,</span> <span class="n">copy_bytes</span><span class="p">,</span>
						       <span class="n">mem_type</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">total_bytes</span> <span class="o">-=</span> <span class="n">copy_bytes</span><span class="p">;</span>
		<span class="n">src_addr</span> <span class="o">+=</span> <span class="n">copy_bytes</span><span class="p">;</span>
		<span class="n">dest_addr</span> <span class="o">+=</span> <span class="n">copy_bytes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Mem Write does not halt the DSP to write unlike bridge_brd_write */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_mem_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="o">*</span><span class="n">host_buff</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_addr</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mem_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_remain_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ul_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ul_remain_bytes</span> <span class="o">=</span> <span class="n">ul_num_bytes</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ul_remain_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ul_bytes</span> <span class="o">=</span>
		    <span class="n">ul_remain_bytes</span> <span class="o">&gt;</span> <span class="n">BUFFERSIZE</span> <span class="o">?</span> <span class="n">BUFFERSIZE</span> <span class="o">:</span> <span class="n">ul_remain_bytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dsp_addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">dsp_start_add</span> <span class="o">+</span>
				 <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">internal_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">write_dsp_data</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">host_buff</span><span class="p">,</span> <span class="n">dsp_addr</span><span class="p">,</span>
					   <span class="n">ul_bytes</span><span class="p">,</span> <span class="n">mem_type</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">write_ext_dsp_data</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">host_buff</span><span class="p">,</span>
						    <span class="n">dsp_addr</span><span class="p">,</span> <span class="n">ul_bytes</span><span class="p">,</span>
						    <span class="n">mem_type</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ul_remain_bytes</span> <span class="o">-=</span> <span class="n">ul_bytes</span><span class="p">;</span>
		<span class="n">dsp_addr</span> <span class="o">+=</span> <span class="n">ul_bytes</span><span class="p">;</span>
		<span class="n">host_buff</span> <span class="o">=</span> <span class="n">host_buff</span> <span class="o">+</span> <span class="n">ul_bytes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_mem_map ========</span>
<span class="cm"> *      This function maps MPU buffer to the DSP address space. It performs</span>
<span class="cm"> *  linear to physical address translation if required. It translates each</span>
<span class="cm"> *  page since linear addresses can be physically non-contiguous</span>
<span class="cm"> *  All address &amp; size arguments are assumed to be page aligned (in proc.c)</span>
<span class="cm"> *</span>
<span class="cm"> *  TODO: Disable MMU while updating the page tables (but that&#39;ll stall DSP)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_mem_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">ul_mpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">virt_addr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_map_attr</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">mapped_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">attrs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_mmu_map_attrs_t</span> <span class="n">hw_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_usr_pgs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">mapped_page</span><span class="p">,</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">pg_num</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">va</span> <span class="o">=</span> <span class="n">virt_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr_task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pg_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mpu_addr</span><span class="p">,</span> <span class="n">pa</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
		<span class="s">&quot;%s hDevCtxt %p, pa %x, va %x, size %x, ul_map_attr %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">ul_mpu_addr</span><span class="p">,</span> <span class="n">virt_addr</span><span class="p">,</span> <span class="n">ul_num_bytes</span><span class="p">,</span>
		<span class="n">ul_map_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ul_num_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ul_map_attr</span> <span class="o">&amp;</span> <span class="n">DSP_MAP_DIR_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">attrs</span> <span class="o">=</span> <span class="n">ul_map_attr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Assign default attributes */</span>
		<span class="n">attrs</span> <span class="o">=</span> <span class="n">ul_map_attr</span> <span class="o">|</span> <span class="p">(</span><span class="n">DSP_MAPVIRTUALADDR</span> <span class="o">|</span> <span class="n">DSP_MAPELEMSIZE16</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Take mapping properties */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attrs</span> <span class="o">&amp;</span> <span class="n">DSP_MAPBIGENDIAN</span><span class="p">)</span>
		<span class="n">hw_attrs</span><span class="p">.</span><span class="n">endianism</span> <span class="o">=</span> <span class="n">HW_BIG_ENDIAN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hw_attrs</span><span class="p">.</span><span class="n">endianism</span> <span class="o">=</span> <span class="n">HW_LITTLE_ENDIAN</span><span class="p">;</span>

	<span class="n">hw_attrs</span><span class="p">.</span><span class="n">mixed_size</span> <span class="o">=</span> <span class="p">(</span><span class="k">enum</span> <span class="n">hw_mmu_mixed_size_t</span><span class="p">)</span>
	    <span class="p">((</span><span class="n">attrs</span> <span class="o">&amp;</span> <span class="n">DSP_MAPMIXEDELEMSIZE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="cm">/* Ignore element_size if mixed_size is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_attrs</span><span class="p">.</span><span class="n">mixed_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attrs</span> <span class="o">&amp;</span> <span class="n">DSP_MAPELEMSIZE8</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Size is 8 bit */</span>
			<span class="n">hw_attrs</span><span class="p">.</span><span class="n">element_size</span> <span class="o">=</span> <span class="n">HW_ELEM_SIZE8BIT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attrs</span> <span class="o">&amp;</span> <span class="n">DSP_MAPELEMSIZE16</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Size is 16 bit */</span>
			<span class="n">hw_attrs</span><span class="p">.</span><span class="n">element_size</span> <span class="o">=</span> <span class="n">HW_ELEM_SIZE16BIT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attrs</span> <span class="o">&amp;</span> <span class="n">DSP_MAPELEMSIZE32</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Size is 32 bit */</span>
			<span class="n">hw_attrs</span><span class="p">.</span><span class="n">element_size</span> <span class="o">=</span> <span class="n">HW_ELEM_SIZE32BIT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attrs</span> <span class="o">&amp;</span> <span class="n">DSP_MAPELEMSIZE64</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Size is 64 bit */</span>
			<span class="n">hw_attrs</span><span class="p">.</span><span class="n">element_size</span> <span class="o">=</span> <span class="n">HW_ELEM_SIZE64BIT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Mixedsize isn&#39;t enabled, so size can&#39;t be</span>
<span class="cm">			 * zero here</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attrs</span> <span class="o">&amp;</span> <span class="n">DSP_MAPDONOTLOCK</span><span class="p">)</span>
		<span class="n">hw_attrs</span><span class="p">.</span><span class="n">donotlockmpupage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hw_attrs</span><span class="p">.</span><span class="n">donotlockmpupage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attrs</span> <span class="o">&amp;</span> <span class="n">DSP_MAPVMALLOCADDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">mem_map_vmalloc</span><span class="p">(</span><span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">ul_mpu_addr</span><span class="p">,</span> <span class="n">virt_addr</span><span class="p">,</span>
				       <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw_attrs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do OS-specific user-va to pa translation.</span>
<span class="cm">	 * Combine physically contiguous regions to reduce TLBs.</span>
<span class="cm">	 * Pass the translated pa to pte_update.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">attrs</span> <span class="o">&amp;</span> <span class="n">DSP_MAPPHYSICALADDR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pte_update</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">ul_mpu_addr</span><span class="p">,</span> <span class="n">virt_addr</span><span class="p">,</span>
				    <span class="n">ul_num_bytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw_attrs</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Important Note: ul_mpu_addr is mapped from user application process</span>
<span class="cm">	 * to current process - it must lie completely within the current</span>
<span class="cm">	 * virtual memory address space in order to be of use to us here!</span>
<span class="cm">	 */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ul_mpu_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
			<span class="s">&quot;VMAfor UserBuf: ul_mpu_addr=%x, ul_num_bytes=%x, &quot;</span>
			<span class="s">&quot;vm_start=%lx, vm_end=%lx, vm_flags=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ul_mpu_addr</span><span class="p">,</span>
			<span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is observed that under some circumstances, the user buffer is</span>
<span class="cm">	 * spread across several VMAs. So loop through and check if the entire</span>
<span class="cm">	 * user buffer is covered</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">vma</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ul_mpu_addr</span> <span class="o">+</span> <span class="n">ul_num_bytes</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* jump to the next VMA region */</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
			<span class="s">&quot;VMA for UserBuf ul_mpu_addr=%x ul_num_bytes=%x, &quot;</span>
			<span class="s">&quot;vm_start=%lx, vm_end=%lx, vm_flags=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ul_mpu_addr</span><span class="p">,</span>
			<span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Failed to get VMA region for 0x%x (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">ul_mpu_addr</span><span class="p">,</span> <span class="n">ul_num_bytes</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">func_cont</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_usr_pgs</span> <span class="o">=</span> <span class="n">ul_num_bytes</span> <span class="o">/</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>
		<span class="n">mpu_addr</span> <span class="o">=</span> <span class="n">ul_mpu_addr</span><span class="p">;</span>

		<span class="cm">/* Get the physical addresses for user buffer */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pg_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pg_i</span> <span class="o">&lt;</span> <span class="n">num_usr_pgs</span><span class="p">;</span> <span class="n">pg_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pa</span> <span class="o">=</span> <span class="n">user_va2_pa</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mpu_addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pa</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;DSPBRIDGE: VM_IO mapping physical&quot;</span>
				       <span class="s">&quot;address is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">pa</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">pg</span> <span class="o">=</span> <span class="n">PHYS_TO_PAGE</span><span class="p">(</span><span class="n">pa</span><span class="p">);</span>
				<span class="n">get_page</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Bad page in VM_IO buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">bad_page_dump</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pg</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">pte_set</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">pt_attrs</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span>
					 <span class="n">va</span><span class="p">,</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw_attrs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">va</span> <span class="o">+=</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">;</span>
			<span class="n">mpu_addr</span> <span class="o">+=</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">;</span>
			<span class="n">pa</span> <span class="o">+=</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">num_usr_pgs</span> <span class="o">=</span> <span class="n">ul_num_bytes</span> <span class="o">/</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_WRITE</span> <span class="o">|</span> <span class="n">VM_MAYWRITE</span><span class="p">))</span>
			<span class="n">write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pg_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pg_i</span> <span class="o">&lt;</span> <span class="n">num_usr_pgs</span><span class="p">;</span> <span class="n">pg_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pg_num</span> <span class="o">=</span> <span class="n">get_user_pages</span><span class="p">(</span><span class="n">curr_task</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">ul_mpu_addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">write</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapped_page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pg_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">mapped_page</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Bad page count after doing&quot;</span>
					       <span class="s">&quot;get_user_pages on&quot;</span>
					       <span class="s">&quot;user buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">bad_page_dump</span><span class="p">(</span><span class="n">page_to_phys</span><span class="p">(</span><span class="n">mapped_page</span><span class="p">),</span>
						      <span class="n">mapped_page</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">pte_set</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">pt_attrs</span><span class="p">,</span>
						 <span class="n">page_to_phys</span><span class="p">(</span><span class="n">mapped_page</span><span class="p">),</span> <span class="n">va</span><span class="p">,</span>
						 <span class="n">HW_PAGE_SIZE4KB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw_attrs</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">mapped_pages</span><span class="p">)</span>
					<span class="n">mapped_pages</span><span class="p">[</span><span class="n">pg_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_page</span><span class="p">;</span>

				<span class="n">va</span> <span class="o">+=</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">;</span>
				<span class="n">ul_mpu_addr</span> <span class="o">+=</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;DSPBRIDGE: get_user_pages FAILED,&quot;</span>
				       <span class="s">&quot;MPU addr = 0x%x,&quot;</span>
				       <span class="s">&quot;vma-&gt;vm_flags = 0x%lx,&quot;</span>
				       <span class="s">&quot;get_user_pages Err&quot;</span>
				       <span class="s">&quot;Value = %d, Buffer&quot;</span>
				       <span class="s">&quot;size=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ul_mpu_addr</span><span class="p">,</span>
				       <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">,</span> <span class="n">pg_num</span><span class="p">,</span> <span class="n">ul_num_bytes</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
<span class="nl">func_cont:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Roll out the mapped pages incase it failed in middle of</span>
<span class="cm">		 * mapping</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pg_i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bridge_brd_mem_un_map</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">virt_addr</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">pg_i</span> <span class="o">*</span> <span class="n">PG_SIZE4K</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * In any case, flush the TLB</span>
<span class="cm">	 * This is called from here instead from pte_update to avoid unnecessary</span>
<span class="cm">	 * repetition while mapping non-contiguous physical regions of a virtual</span>
<span class="cm">	 * region</span>
<span class="cm">	 */</span>
	<span class="n">flush_all</span><span class="p">(</span><span class="n">dev_context</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s status %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== bridge_brd_mem_un_map ========</span>
<span class="cm"> *      Invalidate the PTEs for the DSP VA block to be unmapped.</span>
<span class="cm"> *</span>
<span class="cm"> *      PTEs of a mapped memory block are contiguous in any page table</span>
<span class="cm"> *      So, instead of looking up the PTE address for every 4K block,</span>
<span class="cm"> *      we clear consecutive PTEs until we unmap all the bytes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bridge_brd_mem_un_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">virt_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">l1_base_va</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">l2_base_va</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">l2_base_pa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">l2_page_num</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pte_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pte_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pte_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pte_addr_l1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pte_addr_l2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rem_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rem_bytes_l2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">va_curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pg_table_attrs</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">pt_attrs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">numof4k_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">va_curr</span> <span class="o">=</span> <span class="n">virt_addr</span><span class="p">;</span>
	<span class="n">rem_bytes</span> <span class="o">=</span> <span class="n">ul_num_bytes</span><span class="p">;</span>
	<span class="n">rem_bytes_l2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">l1_base_va</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l1_base_va</span><span class="p">;</span>
	<span class="n">pte_addr_l1</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l1</span><span class="p">(</span><span class="n">l1_base_va</span><span class="p">,</span> <span class="n">va_curr</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s dev_ctxt %p, va %x, NumBytes %x l1_base_va %x, &quot;</span>
		<span class="s">&quot;pte_addr_l1 %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">virt_addr</span><span class="p">,</span>
		<span class="n">ul_num_bytes</span><span class="p">,</span> <span class="n">l1_base_va</span><span class="p">,</span> <span class="n">pte_addr_l1</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rem_bytes</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">va_curr_orig</span> <span class="o">=</span> <span class="n">va_curr</span><span class="p">;</span>
		<span class="cm">/* Find whether the L1 PTE points to a valid L2 PT */</span>
		<span class="n">pte_addr_l1</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l1</span><span class="p">(</span><span class="n">l1_base_va</span><span class="p">,</span> <span class="n">va_curr</span><span class="p">);</span>
		<span class="n">pte_val</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pte_addr_l1</span><span class="p">;</span>
		<span class="n">pte_size</span> <span class="o">=</span> <span class="n">hw_mmu_pte_size_l1</span><span class="p">(</span><span class="n">pte_val</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">!=</span> <span class="n">HW_MMU_COARSE_PAGE_SIZE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip_coarse_page</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get the L2 PA from the L1 PTE, and find</span>
<span class="cm">		 * corresponding L2 VA</span>
<span class="cm">		 */</span>
		<span class="n">l2_base_pa</span> <span class="o">=</span> <span class="n">hw_mmu_pte_coarse_l1</span><span class="p">(</span><span class="n">pte_val</span><span class="p">);</span>
		<span class="n">l2_base_va</span> <span class="o">=</span> <span class="n">l2_base_pa</span> <span class="o">-</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l2_base_pa</span> <span class="o">+</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l2_base_va</span><span class="p">;</span>
		<span class="n">l2_page_num</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">l2_base_pa</span> <span class="o">-</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l2_base_pa</span><span class="p">)</span> <span class="o">/</span> <span class="n">HW_MMU_COARSE_PAGE_SIZE</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Find the L2 PTE address from which we will start</span>
<span class="cm">		 * clearing, the number of PTEs to be cleared on this</span>
<span class="cm">		 * page, and the size of VA space that needs to be</span>
<span class="cm">		 * cleared on this L2 page</span>
<span class="cm">		 */</span>
		<span class="n">pte_addr_l2</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l2</span><span class="p">(</span><span class="n">l2_base_va</span><span class="p">,</span> <span class="n">va_curr</span><span class="p">);</span>
		<span class="n">pte_count</span> <span class="o">=</span> <span class="n">pte_addr_l2</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HW_MMU_COARSE_PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">pte_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">HW_MMU_COARSE_PAGE_SIZE</span> <span class="o">-</span> <span class="n">pte_count</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rem_bytes</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">pte_count</span> <span class="o">*</span> <span class="n">PG_SIZE4K</span><span class="p">))</span>
			<span class="n">pte_count</span> <span class="o">=</span> <span class="n">rem_bytes</span> <span class="o">/</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>
		<span class="n">rem_bytes_l2</span> <span class="o">=</span> <span class="n">pte_count</span> <span class="o">*</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Unmap the VA space on this L2 PT. A quicker way</span>
<span class="cm">		 * would be to clear pte_count entries starting from</span>
<span class="cm">		 * pte_addr_l2. However, below code checks that we don&#39;t</span>
<span class="cm">		 * clear invalid entries or less than 64KB for a 64KB</span>
<span class="cm">		 * entry. Similar checking is done for L1 PTEs too</span>
<span class="cm">		 * below</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">rem_bytes_l2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pte_val</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pte_addr_l2</span><span class="p">;</span>
			<span class="n">pte_size</span> <span class="o">=</span> <span class="n">hw_mmu_pte_size_l2</span><span class="p">(</span><span class="n">pte_val</span><span class="p">);</span>
			<span class="cm">/* va_curr aligned to pte_size? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rem_bytes_l2</span> <span class="o">&lt;</span> <span class="n">pte_size</span> <span class="o">||</span>
			    <span class="n">va_curr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Collect Physical addresses from VA */</span>
			<span class="n">paddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">pte_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">==</span> <span class="n">HW_PAGE_SIZE64KB</span><span class="p">)</span>
				<span class="n">numof4k_pages</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">numof4k_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">temp</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">numof4k_pages</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">paddr</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">paddr</span> <span class="o">+=</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">pg</span> <span class="o">=</span> <span class="n">PHYS_TO_PAGE</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DSPBRIDGE: UNMAP function: &quot;</span>
						<span class="s">&quot;COUNT 0 FOR PA 0x%x, size = &quot;</span>
						<span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">ul_num_bytes</span><span class="p">);</span>
					<span class="n">bad_page_dump</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">pg</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">paddr</span> <span class="o">+=</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw_mmu_pte_clear</span><span class="p">(</span><span class="n">pte_addr_l2</span><span class="p">,</span> <span class="n">va_curr</span><span class="p">,</span> <span class="n">pte_size</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">EXIT_LOOP</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">rem_bytes_l2</span> <span class="o">-=</span> <span class="n">pte_size</span><span class="p">;</span>
			<span class="n">va_curr</span> <span class="o">+=</span> <span class="n">pte_size</span><span class="p">;</span>
			<span class="n">pte_addr_l2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rem_bytes_l2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_info</span><span class="p">[</span><span class="n">l2_page_num</span><span class="p">].</span><span class="n">num_entries</span> <span class="o">-=</span> <span class="n">pte_count</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_info</span><span class="p">[</span><span class="n">l2_page_num</span><span class="p">].</span><span class="n">num_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Clear the L1 PTE pointing to the L2 PT</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw_mmu_pte_clear</span><span class="p">(</span><span class="n">l1_base_va</span><span class="p">,</span> <span class="n">va_curr_orig</span><span class="p">,</span>
						     <span class="n">HW_MMU_COARSE_PAGE_SIZE</span><span class="p">))</span>
					<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
					<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_lock</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">EXIT_LOOP</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">rem_bytes</span> <span class="o">-=</span> <span class="n">pte_count</span> <span class="o">*</span> <span class="n">PG_SIZE4K</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_lock</span><span class="p">);</span>
		<span class="k">continue</span><span class="p">;</span>
<span class="nl">skip_coarse_page:</span>
		<span class="cm">/* va_curr aligned to pte_size? */</span>
		<span class="cm">/* pte_size = 1 MB or 16 MB */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rem_bytes</span> <span class="o">&lt;</span> <span class="n">pte_size</span> <span class="o">||</span>
		    <span class="n">va_curr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">==</span> <span class="n">HW_PAGE_SIZE1MB</span><span class="p">)</span>
			<span class="n">numof4k_pages</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">numof4k_pages</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Collect Physical addresses from VA */</span>
		<span class="n">paddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">pte_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">temp</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">numof4k_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">paddr</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">pg</span> <span class="o">=</span> <span class="n">PHYS_TO_PAGE</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DSPBRIDGE: UNMAP function: &quot;</span>
						<span class="s">&quot;COUNT 0 FOR PA 0x%x, size = &quot;</span>
						<span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">ul_num_bytes</span><span class="p">);</span>
					<span class="n">bad_page_dump</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">pg</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">paddr</span> <span class="o">+=</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw_mmu_pte_clear</span><span class="p">(</span><span class="n">l1_base_va</span><span class="p">,</span> <span class="n">va_curr</span><span class="p">,</span> <span class="n">pte_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">rem_bytes</span> <span class="o">-=</span> <span class="n">pte_size</span><span class="p">;</span>
			<span class="n">va_curr</span> <span class="o">+=</span> <span class="n">pte_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">EXIT_LOOP</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * It is better to flush the TLB here, so that any stale old entries</span>
<span class="cm">	 * get flushed</span>
<span class="cm">	 */</span>
<span class="nl">EXIT_LOOP:</span>
	<span class="n">flush_all</span><span class="p">(</span><span class="n">dev_context</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
		<span class="s">&quot;%s: va_curr %x, pte_addr_l1 %x pte_addr_l2 %x rem_bytes %x,&quot;</span>
		<span class="s">&quot; rem_bytes_l2 %x status %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">va_curr</span><span class="p">,</span> <span class="n">pte_addr_l1</span><span class="p">,</span>
		<span class="n">pte_addr_l2</span><span class="p">,</span> <span class="n">rem_bytes</span><span class="p">,</span> <span class="n">rem_bytes_l2</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== user_va2_pa ========</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      This function walks through the page tables to convert a userland</span>
<span class="cm"> *      virtual address to physical address</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">user_va2_pa</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span> <span class="o">||</span> <span class="n">pgd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">||</span> <span class="n">pmd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ptep</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== pte_update ========</span>
<span class="cm"> *      This function calculates the optimum page-aligned addresses and sizes</span>
<span class="cm"> *      Caller must pass page-aligned values</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pte_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_ctxt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pa</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">va</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">hw_mmu_map_attrs_t</span> <span class="o">*</span><span class="n">map_attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">all_bits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa_curr</span> <span class="o">=</span> <span class="n">pa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">va_curr</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span> <span class="o">=</span> <span class="n">dev_ctxt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page_size</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">HW_PAGE_SIZE16MB</span><span class="p">,</span> <span class="n">HW_PAGE_SIZE1MB</span><span class="p">,</span>
		<span class="n">HW_PAGE_SIZE64KB</span><span class="p">,</span> <span class="n">HW_PAGE_SIZE4KB</span>
	<span class="p">};</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* To find the max. page size with which both PA &amp; VA are</span>
<span class="cm">		 * aligned */</span>
		<span class="n">all_bits</span> <span class="o">=</span> <span class="n">pa_curr</span> <span class="o">|</span> <span class="n">va_curr</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">num_bytes</span> <span class="o">&gt;=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">all_bits</span> <span class="o">&amp;</span>
							     <span class="p">(</span><span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
							      <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">pte_set</span><span class="p">(</span><span class="n">dev_context</span><span class="o">-&gt;</span><span class="n">pt_attrs</span><span class="p">,</span> <span class="n">pa_curr</span><span class="p">,</span>
					    <span class="n">va_curr</span><span class="p">,</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">map_attrs</span><span class="p">);</span>
				<span class="n">pa_curr</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">va_curr</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">num_bytes</span> <span class="o">-=</span> <span class="n">page_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="cm">/* Don&#39;t try smaller sizes. Hopefully we have</span>
<span class="cm">				 * reached an address aligned to a bigger page</span>
<span class="cm">				 * size */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== pte_set ========</span>
<span class="cm"> *      This function calculates PTE address (MPU virtual) to be updated</span>
<span class="cm"> *      It also manages the L2 page tables</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pte_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">pg_table_attrs</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">va</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hw_mmu_map_attrs_t</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pte_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pte_addr_l1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pte_size</span><span class="p">;</span>
	<span class="cm">/* Base address of the PT that will be updated */</span>
	<span class="n">u32</span> <span class="n">pg_tbl_va</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">l1_base_va</span><span class="p">;</span>
	<span class="cm">/* Compiler warns that the next three variables might be used</span>
<span class="cm">	 * uninitialized in this function. Doesn&#39;t seem so. Working around,</span>
<span class="cm">	 * anyways. */</span>
	<span class="n">u32</span> <span class="n">l2_base_va</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">l2_base_pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">l2_page_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">l1_base_va</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l1_base_va</span><span class="p">;</span>
	<span class="n">pg_tbl_va</span> <span class="o">=</span> <span class="n">l1_base_va</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">==</span> <span class="n">HW_PAGE_SIZE64KB</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Find whether the L1 PTE points to a valid L2 PT */</span>
		<span class="n">pte_addr_l1</span> <span class="o">=</span> <span class="n">hw_mmu_pte_addr_l1</span><span class="p">(</span><span class="n">l1_base_va</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_addr_l1</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">l1_base_va</span> <span class="o">+</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l1_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pte_val</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pte_addr_l1</span><span class="p">;</span>
			<span class="n">pte_size</span> <span class="o">=</span> <span class="n">hw_mmu_pte_size_l1</span><span class="p">(</span><span class="n">pte_val</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">==</span> <span class="n">HW_MMU_COARSE_PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Get the L2 PA from the L1 PTE, and find</span>
<span class="cm">			 * corresponding L2 VA */</span>
			<span class="n">l2_base_pa</span> <span class="o">=</span> <span class="n">hw_mmu_pte_coarse_l1</span><span class="p">(</span><span class="n">pte_val</span><span class="p">);</span>
			<span class="n">l2_base_va</span> <span class="o">=</span>
			    <span class="n">l2_base_pa</span> <span class="o">-</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l2_base_pa</span> <span class="o">+</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l2_base_va</span><span class="p">;</span>
			<span class="n">l2_page_num</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">l2_base_pa</span> <span class="o">-</span>
			     <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l2_base_pa</span><span class="p">)</span> <span class="o">/</span> <span class="n">HW_MMU_COARSE_PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* L1 PTE is invalid. Allocate a L2 PT and</span>
<span class="cm">			 * point the L1 PTE to it */</span>
			<span class="cm">/* Find a free L2 PT. */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l2_num_pages</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num_entries</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l2_num_pages</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">l2_page_num</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">l2_base_pa</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l2_base_pa</span> <span class="o">+</span> <span class="p">(</span><span class="n">l2_page_num</span> <span class="o">*</span>
						<span class="n">HW_MMU_COARSE_PAGE_SIZE</span><span class="p">);</span>
				<span class="n">l2_base_va</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">l2_base_va</span> <span class="o">+</span> <span class="p">(</span><span class="n">l2_page_num</span> <span class="o">*</span>
						<span class="n">HW_MMU_COARSE_PAGE_SIZE</span><span class="p">);</span>
				<span class="cm">/* Endianness attributes are ignored for</span>
<span class="cm">				 * HW_MMU_COARSE_PAGE_SIZE */</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">hw_mmu_pte_set</span><span class="p">(</span><span class="n">l1_base_va</span><span class="p">,</span> <span class="n">l2_base_pa</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span>
						   <span class="n">HW_MMU_COARSE_PAGE_SIZE</span><span class="p">,</span>
						   <span class="n">attrs</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Found valid L1 PTE of another size.</span>
<span class="cm">			 * Should not overwrite it. */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pg_tbl_va</span> <span class="o">=</span> <span class="n">l2_base_va</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">HW_PAGE_SIZE64KB</span><span class="p">)</span>
				<span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_info</span><span class="p">[</span><span class="n">l2_page_num</span><span class="p">].</span><span class="n">num_entries</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_info</span><span class="p">[</span><span class="n">l2_page_num</span><span class="p">].</span><span class="n">num_entries</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;PTE: L2 BaseVa %x, BasePa %x, PageNum &quot;</span>
				<span class="s">&quot;%x, num_entries %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">l2_base_va</span><span class="p">,</span>
				<span class="n">l2_base_pa</span><span class="p">,</span> <span class="n">l2_page_num</span><span class="p">,</span>
				<span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_info</span><span class="p">[</span><span class="n">l2_page_num</span><span class="p">].</span><span class="n">num_entries</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pg_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;PTE: pg_tbl_va %x, pa %x, va %x, size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pg_tbl_va</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;PTE: endianism %x, element_size %x, &quot;</span>
			<span class="s">&quot;mixed_size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">-&gt;</span><span class="n">endianism</span><span class="p">,</span>
			<span class="n">attrs</span><span class="o">-&gt;</span><span class="n">element_size</span><span class="p">,</span> <span class="n">attrs</span><span class="o">-&gt;</span><span class="n">mixed_size</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hw_mmu_pte_set</span><span class="p">(</span><span class="n">pg_tbl_va</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Memory map kernel VA -- memory allocated with vmalloc */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_map_vmalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">ul_mpu_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">virt_addr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">ul_num_bytes</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hw_mmu_map_attrs_t</span> <span class="o">*</span><span class="n">hw_attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa_curr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa_next</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">va_curr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size_curr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_of4k_pages</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do Kernel va to pa translation.</span>
<span class="cm">	 * Combine physically contiguous regions to reduce TLBs.</span>
<span class="cm">	 * Pass the translated pa to pte_update.</span>
<span class="cm">	 */</span>
	<span class="n">num_pages</span> <span class="o">=</span> <span class="n">ul_num_bytes</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>	<span class="cm">/* PAGE_SIZE = OS page size */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">va_curr</span> <span class="o">=</span> <span class="n">ul_mpu_addr</span><span class="p">;</span>
	<span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmalloc_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">va_curr</span><span class="p">);</span>
	<span class="n">pa_next</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reuse pa_next from the previous iteraion to avoid</span>
<span class="cm">		 * an extra va2pa call</span>
<span class="cm">		 */</span>
		<span class="n">pa_curr</span> <span class="o">=</span> <span class="n">pa_next</span><span class="p">;</span>
		<span class="n">size_curr</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the next page is physically contiguous,</span>
<span class="cm">		 * map it with the current one by increasing</span>
<span class="cm">		 * the size of the region to be mapped</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">vmalloc_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">va_curr</span> <span class="o">+</span> <span class="n">size_curr</span><span class="p">));</span>
			<span class="n">pa_next</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pa_next</span> <span class="o">==</span> <span class="p">(</span><span class="n">pa_curr</span> <span class="o">+</span> <span class="n">size_curr</span><span class="p">))</span>
				<span class="n">size_curr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pa_next</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pa</span> <span class="o">=</span> <span class="n">pa_curr</span><span class="p">;</span>
		<span class="n">num_of4k_pages</span> <span class="o">=</span> <span class="n">size_curr</span> <span class="o">/</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">temp</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">num_of4k_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">get_page</span><span class="p">(</span><span class="n">PHYS_TO_PAGE</span><span class="p">(</span><span class="n">pa</span><span class="p">));</span>
			<span class="n">pa</span> <span class="o">+=</span> <span class="n">HW_PAGE_SIZE4KB</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pte_update</span><span class="p">(</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">pa_curr</span><span class="p">,</span> <span class="n">virt_addr</span> <span class="o">+</span>
				    <span class="p">(</span><span class="n">va_curr</span> <span class="o">-</span> <span class="n">ul_mpu_addr</span><span class="p">),</span> <span class="n">size_curr</span><span class="p">,</span>
				    <span class="n">hw_attrs</span><span class="p">);</span>
		<span class="n">va_curr</span> <span class="o">+=</span> <span class="n">size_curr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * In any case, flush the TLB</span>
<span class="cm">	 * This is called from here instead from pte_update to avoid unnecessary</span>
<span class="cm">	 * repetition while mapping non-contiguous physical regions of a virtual</span>
<span class="cm">	 * region</span>
<span class="cm">	 */</span>
	<span class="n">flush_all</span><span class="p">(</span><span class="n">dev_context</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="s">&quot;%s status %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ======== wait_for_start ========</span>
<span class="cm"> *      Wait for the singal from DSP that it has started, or time out.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">wait_for_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">bridge_dev_context</span> <span class="o">*</span><span class="n">dev_context</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dw_sync_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">TIHELEN_ACKTIMEOUT</span><span class="p">;</span>

	<span class="cm">/*  Wait for response from board */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__raw_readw</span><span class="p">(</span><span class="n">dw_sync_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">timeout</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/*  If timed out: return false */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Timed out waiting DSP to Start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
