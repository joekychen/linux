<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › keucr › scsiglue.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>scsiglue.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_devinfo.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>
<span class="cp">#include &quot;scsiglue.h&quot;</span>
<span class="cp">#include &quot;transport.h&quot;</span>

<span class="cm">/* Host functions */</span>
<span class="cm">/*</span>
<span class="cm"> * host_info()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">host_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* pr_info(&quot;scsiglue --- host_info\n&quot;); */</span>
	<span class="k">return</span> <span class="s">&quot;SCSI emulation for USB Mass Storage devices&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * slave_alloc()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- slave_alloc\n&quot;); */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>

	<span class="n">blk_queue_update_dma_alignment</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="p">(</span><span class="mi">512</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">==</span> <span class="n">USB_SC_UFI</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="o">-&gt;</span><span class="n">pdt_1f_for_no_lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * slave_configure()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- slave_configure\n&quot;); */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">US_FL_MAX_SECTORS_64</span> <span class="o">|</span> <span class="n">US_FL_MAX_SECTORS_MIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_sectors</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_MAX_SECTORS_MIN</span><span class="p">)</span>
			<span class="n">max_sectors</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">queue_max_sectors</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_sectors</span><span class="p">)</span>
			<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span>
					      <span class="n">max_sectors</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_DISK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">!=</span> <span class="n">USB_SC_SCSI</span> <span class="o">&amp;&amp;</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">!=</span> <span class="n">USB_SC_CYP_ATACB</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_ms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_192_bytes_for_3f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_NO_WP_DETECT</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">skip_ms_page_3f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">skip_ms_page_8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_FIX_CAPACITY</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">fix_capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_CAPACITY_HEURISTICS</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">guess_capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&gt;</span> <span class="n">SCSI_2</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">=</span> <span class="n">SCSI_2</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">retry_hwerror</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">allow_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">last_sector_bug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_ms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">USB_PR_CB</span> <span class="o">||</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">USB_PR_CBI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">==</span> <span class="n">SCSI_UNKNOWN</span><span class="p">)</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_NOT_LOCKABLE</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lockable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is always called with scsi_lock(host) held */</span>
<span class="cm">/*</span>
<span class="cm"> * queuecommand()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">queuecommand_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span>
				<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- queuecommand\n&quot;); */</span>

	<span class="cm">/* check for state-transition errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* pr_info(&quot;Error in %s: us-&gt;srb = %p\n&quot;</span>
<span class="cm">				 __FUNCTION__, us-&gt;srb); */</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* fail the command if we are disconnecting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Fail command during disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">done</span><span class="p">(</span><span class="n">srb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* enqueue the command and wake up the control thread */</span>
	<span class="n">srb</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span> <span class="o">=</span> <span class="n">srb</span><span class="p">;</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">cmnd_ready</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">queuecommand</span><span class="p">)</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Error handling functions</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/* Command timeout and abort */</span>
<span class="cm">/*</span>
<span class="cm"> * command_abort()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">command_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- command_abort\n&quot;); */</span>

	<span class="n">scsi_lock</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span> <span class="o">!=</span> <span class="n">srb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-- nothing to abort</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_TIMED_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_ABORTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
		<span class="n">usb_stor_stop_transport</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>

	<span class="cm">/* Wait for the aborted command to finish */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This invokes the transport reset mechanism to reset the state of the</span>
<span class="cm"> * device.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * device_reset()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- device_reset\n&quot;); */</span>

	<span class="cm">/* lock the device pointers and do the reset */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">));</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">FAILED</span> <span class="o">:</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bus_reset()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- bus_reset\n&quot;); */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_port_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">FAILED</span> <span class="o">:</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * usb_stor_report_device_reset()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_stor_report_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- usb_stor_report_device_reset\n&quot;); */</span>
	<span class="n">scsi_report_device_reset</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_SCM_MULT_TARG</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">scsi_report_device_reset</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * usb_stor_report_bus_reset()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_stor_report_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- usb_stor_report_bus_reset\n&quot;); */</span>
	<span class="n">scsi_lock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">scsi_report_bus_reset</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * /proc/scsi/ functions</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/* we use this macro to help us write into the buffer */</span>
<span class="cp">#undef SPRINTF</span>
<span class="cp">#define SPRINTF(args...) \</span>
<span class="cp">	do { if (pos &lt; buffer+length) pos += sprintf(pos, ## args); } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * proc_info()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span>
					<span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- proc_info\n&quot;); */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* print the controller name */</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;   Host scsi%d: usb-storage</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>

	<span class="cm">/* print product, vendor, and serial number strings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">vendorName</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">vendorName</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">string</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;       Vendor: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">product</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">product</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">productName</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">productName</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">string</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;      Product: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">string</span> <span class="o">=</span> <span class="s">&quot;None&quot;</span><span class="p">;</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;Serial Number: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>

	<span class="cm">/* show the protocol and transport */</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;     Protocol: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol_name</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;    Transport: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_name</span><span class="p">);</span>

	<span class="cm">/* show the device flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="s">&quot;       Quirks:&quot;</span><span class="p">);</span>

<span class="cp">#define US_FLAG(name, value) \</span>
<span class="cp">	if (us-&gt;fflags &amp; value)\</span>
<span class="cp">		pos += sprintf(pos, &quot; &quot; #name);</span>
<span class="n">US_DO_ALL_FLAGS</span>
<span class="cp">#undef US_FLAG</span>

		<span class="o">*</span><span class="p">(</span><span class="n">pos</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate start of next buffer, and return value. */</span>
	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Sysfs interface</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/* Output routine for the sysfs max_sectors file */</span>
<span class="cm">/*</span>
<span class="cm"> * show_max_sectors()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_max_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- ssize_t show_max_sectors\n&quot;); */</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queue_max_sectors</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Input routine for the sysfs max_sectors file */</span>
<span class="cm">/*</span>
<span class="cm"> * store_max_sectors()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_max_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ms</span><span class="p">;</span>

	<span class="cm">/* pr_info(&quot;scsiglue --- ssize_t store_max_sectors\n&quot;); */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%hu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ms</span> <span class="o">&lt;=</span> <span class="n">SCSI_DEFAULT_MAX_SECTORS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">max_sectors</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">show_max_sectors</span><span class="p">,</span> <span class="n">store_max_sectors</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">sysfs_device_attr_list</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">dev_attr_max_sectors</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">};</span>

<span class="cm">/* this defines our host template, with which we&#39;ll allocate hosts */</span>

<span class="cm">/*</span>
<span class="cm"> * usb_stor_host_template()</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">usb_stor_host_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* basic userland interface stuff */</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>				<span class="s">&quot;eucr-storage&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span> <span class="o">=</span>			<span class="s">&quot;eucr-storage&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_info</span> <span class="o">=</span>			<span class="n">proc_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>				<span class="n">host_info</span><span class="p">,</span>

	<span class="cm">/* command interface -- queued only */</span>
	<span class="p">.</span><span class="n">queuecommand</span> <span class="o">=</span>			<span class="n">queuecommand</span><span class="p">,</span>

	<span class="cm">/* error and abort handlers */</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span> <span class="o">=</span>		<span class="n">command_abort</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span>	<span class="n">device_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span> <span class="o">=</span>		<span class="n">bus_reset</span><span class="p">,</span>

	<span class="cm">/* queue commands only, only one command per LUN */</span>
	<span class="p">.</span><span class="n">can_queue</span> <span class="o">=</span>			<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span> <span class="o">=</span>			<span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* unknown initiator id */</span>
	<span class="p">.</span><span class="n">this_id</span> <span class="o">=</span>			<span class="o">-</span><span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">slave_alloc</span> <span class="o">=</span>			<span class="n">slave_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_configure</span> <span class="o">=</span>		<span class="n">slave_configure</span><span class="p">,</span>

	<span class="cm">/* lots of sg segments can be handled */</span>
	<span class="p">.</span><span class="n">sg_tablesize</span> <span class="o">=</span>			<span class="n">SG_ALL</span><span class="p">,</span>

	<span class="cm">/* limit the total size of a transfer to 120 KB */</span>
	<span class="p">.</span><span class="n">max_sectors</span> <span class="o">=</span>                  <span class="mi">240</span><span class="p">,</span>

	<span class="cm">/* merge commands... this seems to help performance, but</span>
<span class="cm">	 * periodically someone should test to see which setting is more</span>
<span class="cm">	 * optimal.</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">use_clustering</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* emulated HBA */</span>
	<span class="p">.</span><span class="n">emulated</span> <span class="o">=</span>			<span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* we do our own delay after a device or bus reset */</span>
	<span class="p">.</span><span class="n">skip_settle_delay</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* sysfs device attributes */</span>
	<span class="p">.</span><span class="n">sdev_attrs</span> <span class="o">=</span>			<span class="n">sysfs_device_attr_list</span><span class="p">,</span>

	<span class="cm">/* module management */</span>
	<span class="p">.</span><span class="n">module</span> <span class="o">=</span>			<span class="n">THIS_MODULE</span>
<span class="p">};</span>

<span class="cm">/* To Report &quot;Illegal Request: Invalid Field in CDB */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">usb_stor_sense_invalidCDB</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0x70</span><span class="p">,</span>			    <span class="cm">/* current error */</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">]</span>	<span class="o">=</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span>	    <span class="cm">/* Illegal Request = 0x05 */</span>
	<span class="p">[</span><span class="mi">7</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0x0a</span><span class="p">,</span>			    <span class="cm">/* additional length */</span>
	<span class="p">[</span><span class="mi">12</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0x24</span>			    <span class="cm">/* Invalid Field in CDB */</span>
<span class="p">};</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Scatter-gather transfer buffer access routines</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * usb_stor_access_xfer_buf()</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">usb_stor_access_xfer_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">**</span><span class="n">sgptr</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="k">enum</span> <span class="n">xfer_buf_dir</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="cm">/* pr_info(&quot;transport --- usb_stor_access_xfer_buf\n&quot;); */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="o">*</span><span class="n">sgptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">srb</span><span class="p">);</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">buflen</span> <span class="o">&amp;&amp;</span> <span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">+</span>
					<span class="p">((</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">poff</span> <span class="o">=</span> <span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sglen</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sglen</span> <span class="o">&gt;</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Transfer ends within this s-g entry */</span>
			<span class="n">sglen</span> <span class="o">=</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">cnt</span><span class="p">;</span>
			<span class="o">*</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">sglen</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Transfer continues to next s-g entry */</span>
			<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">sglen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sglen</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">poff</span><span class="p">);</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">TO_XFER_BUF</span><span class="p">)</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">poff</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">poff</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

			<span class="cm">/* Start at the beginning of the next page */</span>
			<span class="n">poff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">++</span><span class="n">page</span><span class="p">;</span>
			<span class="n">cnt</span> <span class="o">+=</span> <span class="n">plen</span><span class="p">;</span>
			<span class="n">sglen</span> <span class="o">-=</span> <span class="n">plen</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">sgptr</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>

	<span class="cm">/* Return the amount actually transferred */</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Store the contents of buffer into srb&#39;s transfer</span>
<span class="cm"> * buffer and set the SCSI residue.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * usb_stor_set_xfer_buf()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_stor_set_xfer_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* pr_info(&quot;transport --- usb_stor_set_xfer_buf\n&quot;); */</span>
	<span class="cm">/* TO_XFER_BUF = 0, FROM_XFER_BUF = 1 */</span>
	<span class="n">buflen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">buflen</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">));</span>
	<span class="n">buflen</span> <span class="o">=</span> <span class="n">usb_stor_access_xfer_buf</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="n">srb</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&lt;</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">))</span>
		<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">srb</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">-</span> <span class="n">buflen</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
